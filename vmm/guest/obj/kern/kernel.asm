
vmm/guest/obj/kern/kernel:     file format elf64-x86-64


Disassembly of section .bootstrap:

0000000000100000 <_head64>:
_head64:

# Save multiboot_info addr passed by bootloader
#ifdef VMM_GUEST
// VMCALL to the VMM to get a multiboot map.
    movl $VMX_VMCALL_MBMAP, %eax
  100000:	b8 01 00 00 00       	mov    $0x1,%eax
    vmcall
  100005:	0f 01 c1             	vmcall 
#endif
	
    movl $multiboot_info, %eax
  100008:	b8 00 70 10 00       	mov    $0x107000,%eax
    movl %ebx, (%eax)
  10000d:	89 18                	mov    %ebx,(%rax)
#ifndef VMM_GUEST
    movw $0x1234,0x472			# warm boot
#endif
	
# Reset the stack pointer in case we didn't come from the loader
    movl $0x7c00,%esp
  10000f:	bc 00 7c 00 00       	mov    $0x7c00,%esp

    call verify_cpu   #check if CPU supports long mode
  100014:	e8 cc 00 00 00       	callq  1000e5 <verify_cpu>
#ifndef VMM_GUEST
    movl $CR4_PAE,%eax
#else
    movl $(CR4_PAE|CR4_VMXE),%eax
  100019:	b8 20 20 00 00       	mov    $0x2020,%eax
#endif
    movl %eax,%cr4
  10001e:	0f 22 e0             	mov    %rax,%cr4

# build an early boot pml4 at physical address pml4phys 

    #initializing the page tables
    movl $pml4,%edi
  100021:	bf 00 20 10 00       	mov    $0x102000,%edi
    xorl %eax,%eax
  100026:	31 c0                	xor    %eax,%eax
    movl $((4096/4)*5),%ecx  # moving these many words to the 6 pages with 4 second level pages + 1 3rd level + 1 4th level pages 
  100028:	b9 00 14 00 00       	mov    $0x1400,%ecx
    rep stosl
  10002d:	f3 ab                	rep stos %eax,%es:(%rdi)
    # creating a 4G boot page table
    # setting the 4th level page table only the second entry needed (PML4)
    movl $pml4,%eax
  10002f:	b8 00 20 10 00       	mov    $0x102000,%eax
    movl $pdpt1, %ebx
  100034:	bb 00 30 10 00       	mov    $0x103000,%ebx
    orl $PTE_P,%ebx
  100039:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10003c:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%eax)
  10003f:	89 18                	mov    %ebx,(%rax)

    movl $pdpt2, %ebx
  100041:	bb 00 40 10 00       	mov    $0x104000,%ebx
    orl $PTE_P,%ebx
  100046:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  100049:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,0x8(%eax)
  10004c:	89 58 08             	mov    %ebx,0x8(%rax)

    # setting the 3rd level page table (PDPE)
    # 4 entries (counter in ecx), point to the next four physical pages (pgdirs)
    # pgdirs in 0xa0000--0xd000
    movl $pdpt1,%edi
  10004f:	bf 00 30 10 00       	mov    $0x103000,%edi
    movl $pde1,%ebx
  100054:	bb 00 50 10 00       	mov    $0x105000,%ebx
    orl $PTE_P,%ebx
  100059:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10005c:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%edi)
  10005f:	89 1f                	mov    %ebx,(%rdi)

    movl $pdpt2,%edi
  100061:	bf 00 40 10 00       	mov    $0x104000,%edi
    movl $pde2,%ebx
  100066:	bb 00 60 10 00       	mov    $0x106000,%ebx
    orl $PTE_P,%ebx
  10006b:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10006e:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%edi)
  100071:	89 1f                	mov    %ebx,(%rdi)
    
    # setting the pgdir so that the LA=PA
    # mapping first 1G of mem at KERNBASE
    movl $128,%ecx
  100073:	b9 80 00 00 00       	mov    $0x80,%ecx
    # Start at the end and work backwards
    #leal (pml4 + 5*0x1000 - 0x8),%edi
    movl $pde1,%edi
  100078:	bf 00 50 10 00       	mov    $0x105000,%edi
    movl $pde2,%ebx
  10007d:	bb 00 60 10 00       	mov    $0x106000,%ebx
    #64th entry - 0x8004000000
    addl $256,%ebx 
  100082:	81 c3 00 01 00 00    	add    $0x100,%ebx
    # PTE_P|PTE_W|PTE_MBZ
    movl $0x00000183,%eax
  100088:	b8 83 01 00 00       	mov    $0x183,%eax
  1:
     movl %eax,(%edi)
  10008d:	89 07                	mov    %eax,(%rdi)
     movl %eax,(%ebx)
  10008f:	89 03                	mov    %eax,(%rbx)
     addl $0x8,%edi
  100091:	83 c7 08             	add    $0x8,%edi
     addl $0x8,%ebx
  100094:	83 c3 08             	add    $0x8,%ebx
     addl $0x00200000,%eax
  100097:	05 00 00 20 00       	add    $0x200000,%eax
     subl $1,%ecx
  10009c:	83 e9 01             	sub    $0x1,%ecx
     cmp $0x0,%ecx
  10009f:	83 f9 00             	cmp    $0x0,%ecx
     jne 1b
  1000a2:	75 e9                	jne    10008d <_head64+0x8d>
 /*    subl $1,%ecx */
 /*    cmp $0x0,%ecx */
 /*    jne 1b */

    # set the cr3 register
    movl $pml4,%eax
  1000a4:	b8 00 20 10 00       	mov    $0x102000,%eax
    movl %eax, %cr3
  1000a9:	0f 22 d8             	mov    %rax,%cr3

	
    # enable the long mode in MSR
    movl $EFER_MSR,%ecx
  1000ac:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
    rdmsr
  1000b1:	0f 32                	rdmsr  
    btsl $EFER_LME,%eax
  1000b3:	0f ba e8 08          	bts    $0x8,%eax
    wrmsr
  1000b7:	0f 30                	wrmsr  
    
    # enable paging 
    movl %cr0,%eax
  1000b9:	0f 20 c0             	mov    %cr0,%rax
    orl $CR0_PE,%eax
  1000bc:	83 c8 01             	or     $0x1,%eax
    orl $CR0_PG,%eax
  1000bf:	0d 00 00 00 80       	or     $0x80000000,%eax
    orl $CR0_AM,%eax
  1000c4:	0d 00 00 04 00       	or     $0x40000,%eax
    orl $CR0_WP,%eax
  1000c9:	0d 00 00 01 00       	or     $0x10000,%eax
    orl $CR0_MP,%eax
  1000ce:	83 c8 02             	or     $0x2,%eax
    movl %eax,%cr0
  1000d1:	0f 22 c0             	mov    %rax,%cr0
    #jump to long mode with CS=0 and

    movl $gdtdesc_64,%eax
  1000d4:	b8 18 10 10 00       	mov    $0x101018,%eax
    lgdt (%eax)
  1000d9:	0f 01 10             	lgdt   (%rax)
    pushl $0x8
  1000dc:	6a 08                	pushq  $0x8
    movl $_start,%eax
  1000de:	b8 0c 00 20 00       	mov    $0x20000c,%eax
    pushl %eax
  1000e3:	50                   	push   %rax

00000000001000e4 <jumpto_longmode>:
    
    .globl jumpto_longmode
    .type jumpto_longmode,@function
jumpto_longmode:
    lret
  1000e4:	cb                   	lret   

00000000001000e5 <verify_cpu>:
/*     movabs $_back_from_head64, %rax */
/*     pushq %rax */
/*     lretq */

verify_cpu:
    pushfl                   # get eflags in eax -- standardard way to check for cpuid
  1000e5:	9c                   	pushfq 
    popl %eax
  1000e6:	58                   	pop    %rax
    movl %eax,%ecx
  1000e7:	89 c1                	mov    %eax,%ecx
    xorl $0x200000, %eax
  1000e9:	35 00 00 20 00       	xor    $0x200000,%eax
    pushl %eax
  1000ee:	50                   	push   %rax
    popfl
  1000ef:	9d                   	popfq  
    pushfl
  1000f0:	9c                   	pushfq 
    popl %eax
  1000f1:	58                   	pop    %rax
    cmpl %eax,%ebx
  1000f2:	39 c3                	cmp    %eax,%ebx
    jz verify_cpu_no_longmode   # no cpuid -- no long mode
  1000f4:	74 1c                	je     100112 <verify_cpu_no_longmode>

    movl $0x0,%eax              # see if cpuid 1 is implemented
  1000f6:	b8 00 00 00 00       	mov    $0x0,%eax
    cpuid
  1000fb:	0f a2                	cpuid  
    cmpl $0x1,%eax
  1000fd:	83 f8 01             	cmp    $0x1,%eax
    jb verify_cpu_no_longmode    # cpuid 1 is not implemented
  100100:	72 10                	jb     100112 <verify_cpu_no_longmode>


    mov $0x80000001, %eax
  100102:	b8 01 00 00 80       	mov    $0x80000001,%eax
    cpuid                 
  100107:	0f a2                	cpuid  
    test $(1 << 29),%edx                 #Test if the LM-bit, is set or not.
  100109:	f7 c2 00 00 00 20    	test   $0x20000000,%edx
    jz verify_cpu_no_longmode
  10010f:	74 01                	je     100112 <verify_cpu_no_longmode>

    ret
  100111:	c3                   	retq   

0000000000100112 <verify_cpu_no_longmode>:

verify_cpu_no_longmode:
    jmp verify_cpu_no_longmode
  100112:	eb fe                	jmp    100112 <verify_cpu_no_longmode>
  100114:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10011b:	00 00 00 
  10011e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100125:	00 00 00 
  100128:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10012f:	00 00 00 
  100132:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100139:	00 00 00 
  10013c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100143:	00 00 00 
  100146:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10014d:	00 00 00 
  100150:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100157:	00 00 00 
  10015a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100161:	00 00 00 
  100164:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10016b:	00 00 00 
  10016e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100175:	00 00 00 
  100178:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10017f:	00 00 00 
  100182:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100189:	00 00 00 
  10018c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100193:	00 00 00 
  100196:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10019d:	00 00 00 
  1001a0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001a7:	00 00 00 
  1001aa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001b1:	00 00 00 
  1001b4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001bb:	00 00 00 
  1001be:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001c5:	00 00 00 
  1001c8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001cf:	00 00 00 
  1001d2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001d9:	00 00 00 
  1001dc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001e3:	00 00 00 
  1001e6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001ed:	00 00 00 
  1001f0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001f7:	00 00 00 
  1001fa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100201:	00 00 00 
  100204:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10020b:	00 00 00 
  10020e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100215:	00 00 00 
  100218:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10021f:	00 00 00 
  100222:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100229:	00 00 00 
  10022c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100233:	00 00 00 
  100236:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10023d:	00 00 00 
  100240:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100247:	00 00 00 
  10024a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100251:	00 00 00 
  100254:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10025b:	00 00 00 
  10025e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100265:	00 00 00 
  100268:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10026f:	00 00 00 
  100272:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100279:	00 00 00 
  10027c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100283:	00 00 00 
  100286:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10028d:	00 00 00 
  100290:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100297:	00 00 00 
  10029a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002a1:	00 00 00 
  1002a4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002ab:	00 00 00 
  1002ae:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002b5:	00 00 00 
  1002b8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002bf:	00 00 00 
  1002c2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002c9:	00 00 00 
  1002cc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002d3:	00 00 00 
  1002d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002dd:	00 00 00 
  1002e0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002e7:	00 00 00 
  1002ea:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002f1:	00 00 00 
  1002f4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002fb:	00 00 00 
  1002fe:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100305:	00 00 00 
  100308:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10030f:	00 00 00 
  100312:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100319:	00 00 00 
  10031c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100323:	00 00 00 
  100326:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10032d:	00 00 00 
  100330:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100337:	00 00 00 
  10033a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100341:	00 00 00 
  100344:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10034b:	00 00 00 
  10034e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100355:	00 00 00 
  100358:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10035f:	00 00 00 
  100362:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100369:	00 00 00 
  10036c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100373:	00 00 00 
  100376:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10037d:	00 00 00 
  100380:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100387:	00 00 00 
  10038a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100391:	00 00 00 
  100394:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10039b:	00 00 00 
  10039e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003a5:	00 00 00 
  1003a8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003af:	00 00 00 
  1003b2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003b9:	00 00 00 
  1003bc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003c3:	00 00 00 
  1003c6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003cd:	00 00 00 
  1003d0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003d7:	00 00 00 
  1003da:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003e1:	00 00 00 
  1003e4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003eb:	00 00 00 
  1003ee:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003f5:	00 00 00 
  1003f8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003ff:	00 00 00 
  100402:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100409:	00 00 00 
  10040c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100413:	00 00 00 
  100416:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10041d:	00 00 00 
  100420:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100427:	00 00 00 
  10042a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100431:	00 00 00 
  100434:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10043b:	00 00 00 
  10043e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100445:	00 00 00 
  100448:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10044f:	00 00 00 
  100452:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100459:	00 00 00 
  10045c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100463:	00 00 00 
  100466:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10046d:	00 00 00 
  100470:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100477:	00 00 00 
  10047a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100481:	00 00 00 
  100484:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10048b:	00 00 00 
  10048e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100495:	00 00 00 
  100498:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10049f:	00 00 00 
  1004a2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004a9:	00 00 00 
  1004ac:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004b3:	00 00 00 
  1004b6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004bd:	00 00 00 
  1004c0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004c7:	00 00 00 
  1004ca:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004d1:	00 00 00 
  1004d4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004db:	00 00 00 
  1004de:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004e5:	00 00 00 
  1004e8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004ef:	00 00 00 
  1004f2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004f9:	00 00 00 
  1004fc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100503:	00 00 00 
  100506:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10050d:	00 00 00 
  100510:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100517:	00 00 00 
  10051a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100521:	00 00 00 
  100524:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10052b:	00 00 00 
  10052e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100535:	00 00 00 
  100538:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10053f:	00 00 00 
  100542:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100549:	00 00 00 
  10054c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100553:	00 00 00 
  100556:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10055d:	00 00 00 
  100560:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100567:	00 00 00 
  10056a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100571:	00 00 00 
  100574:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10057b:	00 00 00 
  10057e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100585:	00 00 00 
  100588:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10058f:	00 00 00 
  100592:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100599:	00 00 00 
  10059c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005a3:	00 00 00 
  1005a6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005ad:	00 00 00 
  1005b0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005b7:	00 00 00 
  1005ba:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005c1:	00 00 00 
  1005c4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005cb:	00 00 00 
  1005ce:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005d5:	00 00 00 
  1005d8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005df:	00 00 00 
  1005e2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005e9:	00 00 00 
  1005ec:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005f3:	00 00 00 
  1005f6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005fd:	00 00 00 
  100600:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100607:	00 00 00 
  10060a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100611:	00 00 00 
  100614:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10061b:	00 00 00 
  10061e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100625:	00 00 00 
  100628:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10062f:	00 00 00 
  100632:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100639:	00 00 00 
  10063c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100643:	00 00 00 
  100646:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10064d:	00 00 00 
  100650:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100657:	00 00 00 
  10065a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100661:	00 00 00 
  100664:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10066b:	00 00 00 
  10066e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100675:	00 00 00 
  100678:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10067f:	00 00 00 
  100682:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100689:	00 00 00 
  10068c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100693:	00 00 00 
  100696:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10069d:	00 00 00 
  1006a0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006a7:	00 00 00 
  1006aa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006b1:	00 00 00 
  1006b4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006bb:	00 00 00 
  1006be:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006c5:	00 00 00 
  1006c8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006cf:	00 00 00 
  1006d2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006d9:	00 00 00 
  1006dc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006e3:	00 00 00 
  1006e6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006ed:	00 00 00 
  1006f0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006f7:	00 00 00 
  1006fa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100701:	00 00 00 
  100704:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10070b:	00 00 00 
  10070e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100715:	00 00 00 
  100718:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10071f:	00 00 00 
  100722:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100729:	00 00 00 
  10072c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100733:	00 00 00 
  100736:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10073d:	00 00 00 
  100740:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100747:	00 00 00 
  10074a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100751:	00 00 00 
  100754:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10075b:	00 00 00 
  10075e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100765:	00 00 00 
  100768:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10076f:	00 00 00 
  100772:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100779:	00 00 00 
  10077c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100783:	00 00 00 
  100786:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10078d:	00 00 00 
  100790:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100797:	00 00 00 
  10079a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007a1:	00 00 00 
  1007a4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007ab:	00 00 00 
  1007ae:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007b5:	00 00 00 
  1007b8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007bf:	00 00 00 
  1007c2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007c9:	00 00 00 
  1007cc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007d3:	00 00 00 
  1007d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007dd:	00 00 00 
  1007e0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007e7:	00 00 00 
  1007ea:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007f1:	00 00 00 
  1007f4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007fb:	00 00 00 
  1007fe:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100805:	00 00 00 
  100808:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10080f:	00 00 00 
  100812:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100819:	00 00 00 
  10081c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100823:	00 00 00 
  100826:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10082d:	00 00 00 
  100830:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100837:	00 00 00 
  10083a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100841:	00 00 00 
  100844:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10084b:	00 00 00 
  10084e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100855:	00 00 00 
  100858:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10085f:	00 00 00 
  100862:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100869:	00 00 00 
  10086c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100873:	00 00 00 
  100876:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10087d:	00 00 00 
  100880:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100887:	00 00 00 
  10088a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100891:	00 00 00 
  100894:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10089b:	00 00 00 
  10089e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008a5:	00 00 00 
  1008a8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008af:	00 00 00 
  1008b2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008b9:	00 00 00 
  1008bc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008c3:	00 00 00 
  1008c6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008cd:	00 00 00 
  1008d0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008d7:	00 00 00 
  1008da:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008e1:	00 00 00 
  1008e4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008eb:	00 00 00 
  1008ee:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008f5:	00 00 00 
  1008f8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008ff:	00 00 00 
  100902:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100909:	00 00 00 
  10090c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100913:	00 00 00 
  100916:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10091d:	00 00 00 
  100920:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100927:	00 00 00 
  10092a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100931:	00 00 00 
  100934:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10093b:	00 00 00 
  10093e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100945:	00 00 00 
  100948:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10094f:	00 00 00 
  100952:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100959:	00 00 00 
  10095c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100963:	00 00 00 
  100966:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10096d:	00 00 00 
  100970:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100977:	00 00 00 
  10097a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100981:	00 00 00 
  100984:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10098b:	00 00 00 
  10098e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100995:	00 00 00 
  100998:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10099f:	00 00 00 
  1009a2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009a9:	00 00 00 
  1009ac:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009b3:	00 00 00 
  1009b6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009bd:	00 00 00 
  1009c0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009c7:	00 00 00 
  1009ca:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009d1:	00 00 00 
  1009d4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009db:	00 00 00 
  1009de:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009e5:	00 00 00 
  1009e8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009ef:	00 00 00 
  1009f2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009f9:	00 00 00 
  1009fc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a03:	00 00 00 
  100a06:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a0d:	00 00 00 
  100a10:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a17:	00 00 00 
  100a1a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a21:	00 00 00 
  100a24:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a2b:	00 00 00 
  100a2e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a35:	00 00 00 
  100a38:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a3f:	00 00 00 
  100a42:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a49:	00 00 00 
  100a4c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a53:	00 00 00 
  100a56:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a5d:	00 00 00 
  100a60:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a67:	00 00 00 
  100a6a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a71:	00 00 00 
  100a74:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a7b:	00 00 00 
  100a7e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a85:	00 00 00 
  100a88:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a8f:	00 00 00 
  100a92:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a99:	00 00 00 
  100a9c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aa3:	00 00 00 
  100aa6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aad:	00 00 00 
  100ab0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ab7:	00 00 00 
  100aba:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ac1:	00 00 00 
  100ac4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100acb:	00 00 00 
  100ace:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ad5:	00 00 00 
  100ad8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100adf:	00 00 00 
  100ae2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ae9:	00 00 00 
  100aec:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100af3:	00 00 00 
  100af6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100afd:	00 00 00 
  100b00:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b07:	00 00 00 
  100b0a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b11:	00 00 00 
  100b14:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b1b:	00 00 00 
  100b1e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b25:	00 00 00 
  100b28:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b2f:	00 00 00 
  100b32:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b39:	00 00 00 
  100b3c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b43:	00 00 00 
  100b46:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b4d:	00 00 00 
  100b50:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b57:	00 00 00 
  100b5a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b61:	00 00 00 
  100b64:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b6b:	00 00 00 
  100b6e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b75:	00 00 00 
  100b78:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b7f:	00 00 00 
  100b82:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b89:	00 00 00 
  100b8c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b93:	00 00 00 
  100b96:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b9d:	00 00 00 
  100ba0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ba7:	00 00 00 
  100baa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bb1:	00 00 00 
  100bb4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bbb:	00 00 00 
  100bbe:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bc5:	00 00 00 
  100bc8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bcf:	00 00 00 
  100bd2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bd9:	00 00 00 
  100bdc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100be3:	00 00 00 
  100be6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bed:	00 00 00 
  100bf0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bf7:	00 00 00 
  100bfa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c01:	00 00 00 
  100c04:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c0b:	00 00 00 
  100c0e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c15:	00 00 00 
  100c18:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c1f:	00 00 00 
  100c22:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c29:	00 00 00 
  100c2c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c33:	00 00 00 
  100c36:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c3d:	00 00 00 
  100c40:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c47:	00 00 00 
  100c4a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c51:	00 00 00 
  100c54:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c5b:	00 00 00 
  100c5e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c65:	00 00 00 
  100c68:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c6f:	00 00 00 
  100c72:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c79:	00 00 00 
  100c7c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c83:	00 00 00 
  100c86:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c8d:	00 00 00 
  100c90:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c97:	00 00 00 
  100c9a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ca1:	00 00 00 
  100ca4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cab:	00 00 00 
  100cae:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cb5:	00 00 00 
  100cb8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cbf:	00 00 00 
  100cc2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cc9:	00 00 00 
  100ccc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cd3:	00 00 00 
  100cd6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cdd:	00 00 00 
  100ce0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ce7:	00 00 00 
  100cea:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cf1:	00 00 00 
  100cf4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cfb:	00 00 00 
  100cfe:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d05:	00 00 00 
  100d08:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d0f:	00 00 00 
  100d12:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d19:	00 00 00 
  100d1c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d23:	00 00 00 
  100d26:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d2d:	00 00 00 
  100d30:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d37:	00 00 00 
  100d3a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d41:	00 00 00 
  100d44:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d4b:	00 00 00 
  100d4e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d55:	00 00 00 
  100d58:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d5f:	00 00 00 
  100d62:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d69:	00 00 00 
  100d6c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d73:	00 00 00 
  100d76:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d7d:	00 00 00 
  100d80:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d87:	00 00 00 
  100d8a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d91:	00 00 00 
  100d94:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d9b:	00 00 00 
  100d9e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100da5:	00 00 00 
  100da8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100daf:	00 00 00 
  100db2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100db9:	00 00 00 
  100dbc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dc3:	00 00 00 
  100dc6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dcd:	00 00 00 
  100dd0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dd7:	00 00 00 
  100dda:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100de1:	00 00 00 
  100de4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100deb:	00 00 00 
  100dee:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100df5:	00 00 00 
  100df8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dff:	00 00 00 
  100e02:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e09:	00 00 00 
  100e0c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e13:	00 00 00 
  100e16:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e1d:	00 00 00 
  100e20:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e27:	00 00 00 
  100e2a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e31:	00 00 00 
  100e34:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e3b:	00 00 00 
  100e3e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e45:	00 00 00 
  100e48:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e4f:	00 00 00 
  100e52:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e59:	00 00 00 
  100e5c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e63:	00 00 00 
  100e66:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e6d:	00 00 00 
  100e70:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e77:	00 00 00 
  100e7a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e81:	00 00 00 
  100e84:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e8b:	00 00 00 
  100e8e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e95:	00 00 00 
  100e98:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e9f:	00 00 00 
  100ea2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ea9:	00 00 00 
  100eac:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100eb3:	00 00 00 
  100eb6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ebd:	00 00 00 
  100ec0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ec7:	00 00 00 
  100eca:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ed1:	00 00 00 
  100ed4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100edb:	00 00 00 
  100ede:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ee5:	00 00 00 
  100ee8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100eef:	00 00 00 
  100ef2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ef9:	00 00 00 
  100efc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f03:	00 00 00 
  100f06:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f0d:	00 00 00 
  100f10:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f17:	00 00 00 
  100f1a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f21:	00 00 00 
  100f24:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f2b:	00 00 00 
  100f2e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f35:	00 00 00 
  100f38:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f3f:	00 00 00 
  100f42:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f49:	00 00 00 
  100f4c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f53:	00 00 00 
  100f56:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f5d:	00 00 00 
  100f60:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f67:	00 00 00 
  100f6a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f71:	00 00 00 
  100f74:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f7b:	00 00 00 
  100f7e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f85:	00 00 00 
  100f88:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f8f:	00 00 00 
  100f92:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f99:	00 00 00 
  100f9c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fa3:	00 00 00 
  100fa6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fad:	00 00 00 
  100fb0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fb7:	00 00 00 
  100fba:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fc1:	00 00 00 
  100fc4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fcb:	00 00 00 
  100fce:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fd5:	00 00 00 
  100fd8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fdf:	00 00 00 
  100fe2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fe9:	00 00 00 
  100fec:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ff3:	00 00 00 
  100ff6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ffd:	00 00 00 

0000000000101000 <gdt_64>:
	...
  101008:	ff                   	(bad)  
  101009:	ff 00                	incl   (%rax)
  10100b:	00 00                	add    %al,(%rax)
  10100d:	9a                   	(bad)  
  10100e:	af                   	scas   %es:(%rdi),%eax
  10100f:	00 ff                	add    %bh,%bh
  101011:	ff 00                	incl   (%rax)
  101013:	00 00                	add    %al,(%rax)
  101015:	92                   	xchg   %eax,%edx
  101016:	cf                   	iret   
	...

0000000000101018 <gdtdesc_64>:
  101018:	17                   	(bad)  
  101019:	00 00                	add    %al,(%rax)
  10101b:	10 10                	adc    %dl,(%rax)
	...

0000000000102000 <pml4phys>:
	...

0000000000103000 <pdpt1>:
	...

0000000000104000 <pdpt2>:
	...

0000000000105000 <pde1>:
	...

0000000000106000 <pde2>:
	...

0000000000107000 <multiboot_info>:
  107000:	00 00                	add    %al,(%rax)
	...

Disassembly of section .text:

0000008004200000 <_start+0x8003fffff4>:
  8004200000:	02 b0 ad 1b 00 00    	add    0x1bad(%rax),%dh
  8004200006:	00 00                	add    %al,(%rax)
  8004200008:	fe 4f 52             	decb   0x52(%rdi)
  800420000b:	e4 48                	in     $0x48,%al

000000800420000c <entry>:
entry:

/* .globl _back_from_head64 */
/* _back_from_head64: */

    movabs   $gdtdesc_64,%rax
  800420000c:	48 b8 38 c0 22 04 80 	movabs $0x800422c038,%rax
  8004200013:	00 00 00 
    lgdt     (%rax)
  8004200016:	0f 01 10             	lgdt   (%rax)
    movw    $DATA_SEL,%ax
  8004200019:	66 b8 10 00          	mov    $0x10,%ax
    movw    %ax,%ds
  800420001d:	8e d8                	mov    %eax,%ds
    movw    %ax,%ss
  800420001f:	8e d0                	mov    %eax,%ss
    movw    %ax,%fs
  8004200021:	8e e0                	mov    %eax,%fs
    movw    %ax,%gs
  8004200023:	8e e8                	mov    %eax,%gs
    movw    %ax,%es
  8004200025:	8e c0                	mov    %eax,%es
    pushq   $CODE_SEL
  8004200027:	6a 08                	pushq  $0x8
    movabs  $relocated,%rax
  8004200029:	48 b8 36 00 20 04 80 	movabs $0x8004200036,%rax
  8004200030:	00 00 00 
    pushq   %rax
  8004200033:	50                   	push   %rax
    lretq
  8004200034:	48 cb                	lretq  

0000008004200036 <relocated>:
relocated:

	# Clear the frame pointer register (RBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movq	$0x0,%rbp			# nuke frame pointer
  8004200036:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp

	# Set the stack pointer
	movabs	$(bootstacktop),%rax
  800420003d:	48 b8 00 c0 22 04 80 	movabs $0x800422c000,%rax
  8004200044:	00 00 00 
	movq  %rax,%rsp
  8004200047:	48 89 c4             	mov    %rax,%rsp

	# now to C code
    movabs $i386_init, %rax
  800420004a:	48 b8 9e 01 20 04 80 	movabs $0x800420019e,%rax
  8004200051:	00 00 00 
	call *%rax
  8004200054:	ff d0                	callq  *%rax

0000008004200056 <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
  8004200056:	eb fe                	jmp    8004200056 <spin>

0000008004200058 <cpuid>:

#define read_rip(var) __asm __volatile("leaq (%%rip), %0" : "=r" (var)::"cc","memory")

static __inline void
cpuid(uint32_t info, uint32_t *eaxp, uint32_t *ebxp, uint32_t *ecxp, uint32_t *edxp)
{
  8004200058:	55                   	push   %rbp
  8004200059:	48 89 e5             	mov    %rsp,%rbp
  800420005c:	53                   	push   %rbx
  800420005d:	48 83 ec 38          	sub    $0x38,%rsp
  8004200061:	89 7d e4             	mov    %edi,-0x1c(%rbp)
  8004200064:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
  8004200068:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  800420006c:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  8004200070:	4c 89 45 c0          	mov    %r8,-0x40(%rbp)
	uint32_t eax, ebx, ecx, edx;
	asm volatile("cpuid" 
  8004200074:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004200077:	0f a2                	cpuid  
  8004200079:	89 de                	mov    %ebx,%esi
  800420007b:	89 45 f4             	mov    %eax,-0xc(%rbp)
  800420007e:	89 75 f0             	mov    %esi,-0x10(%rbp)
  8004200081:	89 4d ec             	mov    %ecx,-0x14(%rbp)
  8004200084:	89 55 e8             	mov    %edx,-0x18(%rbp)
			 : "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx)
			 : "a" (info));
	if (eaxp)
  8004200087:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420008c:	74 09                	je     8004200097 <cpuid+0x3f>
		*eaxp = eax;
  800420008e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004200092:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004200095:	89 10                	mov    %edx,(%rax)
	if (ebxp)
  8004200097:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420009c:	74 09                	je     80042000a7 <cpuid+0x4f>
		*ebxp = ebx;
  800420009e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042000a2:	8b 55 f0             	mov    -0x10(%rbp),%edx
  80042000a5:	89 10                	mov    %edx,(%rax)
	if (ecxp)
  80042000a7:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  80042000ac:	74 09                	je     80042000b7 <cpuid+0x5f>
		*ecxp = ecx;
  80042000ae:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042000b2:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042000b5:	89 10                	mov    %edx,(%rax)
	if (edxp)
  80042000b7:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  80042000bc:	74 09                	je     80042000c7 <cpuid+0x6f>
		*edxp = edx;
  80042000be:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042000c2:	8b 55 e8             	mov    -0x18(%rbp),%edx
  80042000c5:	89 10                	mov    %edx,(%rax)
}
  80042000c7:	48 83 c4 38          	add    $0x38,%rsp
  80042000cb:	5b                   	pop    %rbx
  80042000cc:	5d                   	pop    %rbp
  80042000cd:	c3                   	retq   

00000080042000ce <xchg>:

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  80042000ce:	55                   	push   %rbp
  80042000cf:	48 89 e5             	mov    %rsp,%rbp
  80042000d2:	48 83 ec 1c          	sub    $0x1c,%rsp
  80042000d6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042000da:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  80042000dd:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042000e1:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042000e4:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042000e8:	f0 87 02             	lock xchg %eax,(%rdx)
  80042000eb:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  80042000ee:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80042000f1:	c9                   	leaveq 
  80042000f2:	c3                   	retq   

00000080042000f3 <lock_kernel>:

extern struct spinlock kernel_lock;

static inline void
lock_kernel(void)
{
  80042000f3:	55                   	push   %rbp
  80042000f4:	48 89 e5             	mov    %rsp,%rbp
	spin_lock(&kernel_lock);
  80042000f7:	48 bf 60 c7 22 04 80 	movabs $0x800422c760,%rdi
  80042000fe:	00 00 00 
  8004200101:	48 b8 5d 77 21 04 80 	movabs $0x800421775d,%rax
  8004200108:	00 00 00 
  800420010b:	ff d0                	callq  *%rax
}
  800420010d:	5d                   	pop    %rbp
  800420010e:	c3                   	retq   

000000800420010f <vmcall>:
#ifdef VMM_GUEST

static void boot_virtual_aps(void);

int64_t vmcall(int num, int check, uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  800420010f:	55                   	push   %rbp
  8004200110:	48 89 e5             	mov    %rsp,%rbp
  8004200113:	53                   	push   %rbx
  8004200114:	48 83 ec 48          	sub    $0x48,%rsp
  8004200118:	89 7d dc             	mov    %edi,-0x24(%rbp)
  800420011b:	89 75 d8             	mov    %esi,-0x28(%rbp)
  800420011e:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  8004200122:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  8004200126:	4c 89 45 c0          	mov    %r8,-0x40(%rbp)
  800420012a:	4c 89 4d b8          	mov    %r9,-0x48(%rbp)
    int64_t ret;
    asm volatile("vmcall\n" : "=a" (ret) : "a" (num), "d" (a1), "c" (a2), "b" (a3), "D" (a4), "S" (a5) : "cc", "memory");
  800420012e:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004200131:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004200135:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8004200139:	4c 8b 45 c0          	mov    -0x40(%rbp),%r8
  800420013d:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004200141:	48 8b 75 10          	mov    0x10(%rbp),%rsi
  8004200145:	4c 89 c3             	mov    %r8,%rbx
  8004200148:	0f 01 c1             	vmcall 
  800420014b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if(check && ret > 0) panic("vmcall %d returned %d (> 0)", num, ret);
  800420014f:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  8004200153:	74 3e                	je     8004200193 <vmcall+0x84>
  8004200155:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420015a:	7e 37                	jle    8004200193 <vmcall+0x84>
  800420015c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004200160:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004200163:	49 89 d0             	mov    %rdx,%r8
  8004200166:	89 c1                	mov    %eax,%ecx
  8004200168:	48 ba a0 8c 21 04 80 	movabs $0x8004218ca0,%rdx
  800420016f:	00 00 00 
  8004200172:	be 30 00 00 00       	mov    $0x30,%esi
  8004200177:	48 bf bc 8c 21 04 80 	movabs $0x8004218cbc,%rdi
  800420017e:	00 00 00 
  8004200181:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200186:	49 b9 e4 05 20 04 80 	movabs $0x80042005e4,%r9
  800420018d:	00 00 00 
  8004200190:	41 ff d1             	callq  *%r9
    return ret;
  8004200193:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  8004200197:	48 83 c4 48          	add    $0x48,%rsp
  800420019b:	5b                   	pop    %rbx
  800420019c:	5d                   	pop    %rbp
  800420019d:	c3                   	retq   

000000800420019e <i386_init>:



void
i386_init(void)
{
  800420019e:	55                   	push   %rbp
  800420019f:	48 89 e5             	mov    %rsp,%rbp
  80042001a2:	48 83 ec 10          	sub    $0x10,%rsp
	extern char edata[], end[];

	// Before doing anything else, complete the ELF loading process.
	// Clear the uninitialized global data (BSS) section of our program.
	// This ensures that all static/global variables start out zero.
	memset(edata, 0, end - edata);
  80042001a6:	48 ba 10 f0 6d 04 80 	movabs $0x80046df010,%rdx
  80042001ad:	00 00 00 
  80042001b0:	48 b8 d4 ce 49 04 80 	movabs $0x800449ced4,%rax
  80042001b7:	00 00 00 
  80042001ba:	48 29 c2             	sub    %rax,%rdx
  80042001bd:	48 89 d0             	mov    %rdx,%rax
  80042001c0:	48 89 c2             	mov    %rax,%rdx
  80042001c3:	be 00 00 00 00       	mov    $0x0,%esi
  80042001c8:	48 bf d4 ce 49 04 80 	movabs $0x800449ced4,%rdi
  80042001cf:	00 00 00 
  80042001d2:	48 b8 d4 03 21 04 80 	movabs $0x80042103d4,%rax
  80042001d9:	00 00 00 
  80042001dc:	ff d0                	callq  *%rax

	// Initialize the console.
	// Can't call cprintf until after we do this!
	cons_init();
  80042001de:	48 b8 e1 12 20 04 80 	movabs $0x80042012e1,%rax
  80042001e5:	00 00 00 
  80042001e8:	ff d0                	callq  *%rax


	cprintf("6828 decimal is %o octal!\n", 6828);
  80042001ea:	be ac 1a 00 00       	mov    $0x1aac,%esi
  80042001ef:	48 bf c8 8c 21 04 80 	movabs $0x8004218cc8,%rdi
  80042001f6:	00 00 00 
  80042001f9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042001fe:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  8004200205:	00 00 00 
  8004200208:	ff d2                	callq  *%rdx


#ifdef VMM_GUEST
	/* Guest VMX extension exposure check */
	{
		uint32_t ecx = 0;
  800420020a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
		cpuid(0x1, NULL, NULL, &ecx, NULL);
  8004200211:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  8004200215:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800420021b:	48 89 c1             	mov    %rax,%rcx
  800420021e:	ba 00 00 00 00       	mov    $0x0,%edx
  8004200223:	be 00 00 00 00       	mov    $0x0,%esi
  8004200228:	bf 01 00 00 00       	mov    $0x1,%edi
  800420022d:	48 b8 58 00 20 04 80 	movabs $0x8004200058,%rax
  8004200234:	00 00 00 
  8004200237:	ff d0                	callq  *%rax
		if (ecx & 0x20)
  8004200239:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420023c:	83 e0 20             	and    $0x20,%eax
  800420023f:	85 c0                	test   %eax,%eax
  8004200241:	74 2a                	je     800420026d <i386_init+0xcf>
			panic("[ERR] VMX extension exposed to guest.\n");
  8004200243:	48 ba e8 8c 21 04 80 	movabs $0x8004218ce8,%rdx
  800420024a:	00 00 00 
  800420024d:	be 53 00 00 00       	mov    $0x53,%esi
  8004200252:	48 bf bc 8c 21 04 80 	movabs $0x8004218cbc,%rdi
  8004200259:	00 00 00 
  800420025c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200261:	48 b9 e4 05 20 04 80 	movabs $0x80042005e4,%rcx
  8004200268:	00 00 00 
  800420026b:	ff d1                	callq  *%rcx
		else
			cprintf("VMX extension hidden from guest.\n");
  800420026d:	48 bf 10 8d 21 04 80 	movabs $0x8004218d10,%rdi
  8004200274:	00 00 00 
  8004200277:	b8 00 00 00 00       	mov    $0x0,%eax
  800420027c:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  8004200283:	00 00 00 
  8004200286:	ff d2                	callq  *%rdx
#endif



	// Lab 2 memory management initialization functions
	x64_vm_init();
  8004200288:	b8 00 00 00 00       	mov    $0x0,%eax
  800420028d:	48 ba 76 27 20 04 80 	movabs $0x8004202776,%rdx
  8004200294:	00 00 00 
  8004200297:	ff d2                	callq  *%rdx


	// Lab 3 user environment initialization functions
	env_init();
  8004200299:	48 b8 a6 80 20 04 80 	movabs $0x80042080a6,%rax
  80042002a0:	00 00 00 
  80042002a3:	ff d0                	callq  *%rax
	trap_init();
  80042002a5:	48 b8 08 97 20 04 80 	movabs $0x8004209708,%rax
  80042002ac:	00 00 00 
  80042002af:	ff d0                	callq  *%rax
	lapic_init();
#endif


	// Lab 4 multitasking initialization functions
	pic_init();
  80042002b1:	48 b8 90 92 20 04 80 	movabs $0x8004209290,%rax
  80042002b8:	00 00 00 
  80042002bb:	ff d0                	callq  *%rax


	// Acquire the big kernel lock before waking up APs
	// Your code here:

	lock_kernel();
  80042002bd:	48 b8 f3 00 20 04 80 	movabs $0x80042000f3,%rax
  80042002c4:	00 00 00 
  80042002c7:	ff d0                	callq  *%rax




	// Start fs.
	ENV_CREATE(fs_fs, ENV_TYPE_FS);
  80042002c9:	be 01 00 00 00       	mov    $0x1,%esi
  80042002ce:	48 bf 9d 59 2b 04 80 	movabs $0x80042b599d,%rdi
  80042002d5:	00 00 00 
  80042002d8:	48 b8 44 89 20 04 80 	movabs $0x8004208944,%rax
  80042002df:	00 00 00 
  80042002e2:	ff d0                	callq  *%rax
	test_ept_map();
#endif



	ENV_CREATE(user_icode, ENV_TYPE_USER);
  80042002e4:	be 00 00 00 00       	mov    $0x0,%esi
  80042002e9:	48 bf b1 d8 29 04 80 	movabs $0x800429d8b1,%rdi
  80042002f0:	00 00 00 
  80042002f3:	48 b8 44 89 20 04 80 	movabs $0x8004208944,%rax
  80042002fa:	00 00 00 
  80042002fd:	ff d0                	callq  *%rax

#endif // TEST*


	// Should not be necessary - drains keyboard because interrupt has given up.
	kbd_intr();
  80042002ff:	48 b8 13 11 20 04 80 	movabs $0x8004201113,%rax
  8004200306:	00 00 00 
  8004200309:	ff d0                	callq  *%rax



	// Schedule and run the first user environment!
	sched_yield();
  800420030b:	48 b8 d5 d2 20 04 80 	movabs $0x800420d2d5,%rax
  8004200312:	00 00 00 
  8004200315:	ff d0                	callq  *%rax

0000008004200317 <boot_aps>:
void *mpentry_kstack;

// Start the non-boot (AP) processors.
static void
boot_aps(void)
{
  8004200317:	55                   	push   %rbp
  8004200318:	48 89 e5             	mov    %rsp,%rbp
  800420031b:	48 83 ec 30          	sub    $0x30,%rsp
	extern unsigned char mpentry_start[], mpentry_end[];
	void *code;
	struct CpuInfo *c;

	// Write entry code to unused memory at MPENTRY_PADDR
	code = KADDR(MPENTRY_PADDR);
  800420031f:	48 c7 45 f0 00 70 00 	movq   $0x7000,-0x10(%rbp)
  8004200326:	00 
  8004200327:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420032b:	48 c1 e8 0c          	shr    $0xc,%rax
  800420032f:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004200332:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004200335:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  800420033c:	00 00 00 
  800420033f:	48 8b 00             	mov    (%rax),%rax
  8004200342:	48 39 c2             	cmp    %rax,%rdx
  8004200345:	72 32                	jb     8004200379 <boot_aps+0x62>
  8004200347:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420034b:	48 89 c1             	mov    %rax,%rcx
  800420034e:	48 ba 38 8d 21 04 80 	movabs $0x8004218d38,%rdx
  8004200355:	00 00 00 
  8004200358:	be bb 00 00 00       	mov    $0xbb,%esi
  800420035d:	48 bf bc 8c 21 04 80 	movabs $0x8004218cbc,%rdi
  8004200364:	00 00 00 
  8004200367:	b8 00 00 00 00       	mov    $0x0,%eax
  800420036c:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004200373:	00 00 00 
  8004200376:	41 ff d0             	callq  *%r8
  8004200379:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004200380:	00 00 00 
  8004200383:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004200387:	48 01 d0             	add    %rdx,%rax
  800420038a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	memmove(code, mpentry_start, mpentry_end - mpentry_start);
  800420038e:	48 ba a6 68 21 04 80 	movabs $0x80042168a6,%rdx
  8004200395:	00 00 00 
  8004200398:	48 b8 c0 67 21 04 80 	movabs $0x80042167c0,%rax
  800420039f:	00 00 00 
  80042003a2:	48 29 c2             	sub    %rax,%rdx
  80042003a5:	48 89 d0             	mov    %rdx,%rax
  80042003a8:	48 89 c2             	mov    %rax,%rdx
  80042003ab:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042003af:	48 be c0 67 21 04 80 	movabs $0x80042167c0,%rsi
  80042003b6:	00 00 00 
  80042003b9:	48 89 c7             	mov    %rax,%rdi
  80042003bc:	48 b8 5f 04 21 04 80 	movabs $0x800421045f,%rax
  80042003c3:	00 00 00 
  80042003c6:	ff d0                	callq  *%rax
	// Boot each AP one at a time
	for (c = cpus; c < cpus + ncpu; c++) {
  80042003c8:	48 b8 20 e0 69 04 80 	movabs $0x800469e020,%rax
  80042003cf:	00 00 00 
  80042003d2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042003d6:	e9 0e 01 00 00       	jmpq   80042004e9 <boot_aps+0x1d2>
		if (c == cpus + cpunum())  // We've started already.
  80042003db:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  80042003e2:	00 00 00 
  80042003e5:	ff d0                	callq  *%rax
  80042003e7:	48 98                	cltq   
  80042003e9:	48 c1 e0 03          	shl    $0x3,%rax
  80042003ed:	48 89 c2             	mov    %rax,%rdx
  80042003f0:	48 c1 e2 04          	shl    $0x4,%rdx
  80042003f4:	48 01 c2             	add    %rax,%rdx
  80042003f7:	48 b8 20 e0 69 04 80 	movabs $0x800469e020,%rax
  80042003fe:	00 00 00 
  8004200401:	48 01 d0             	add    %rdx,%rax
  8004200404:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004200408:	75 05                	jne    800420040f <boot_aps+0xf8>
			continue;
  800420040a:	e9 d2 00 00 00       	jmpq   80042004e1 <boot_aps+0x1ca>

		// Tell mpentry.S what stack to use 
		mpentry_kstack = percpu_kstacks[c - cpus] + KSTKSIZE;
  800420040f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004200413:	48 b8 20 e0 69 04 80 	movabs $0x800469e020,%rax
  800420041a:	00 00 00 
  800420041d:	48 29 c2             	sub    %rax,%rdx
  8004200420:	48 89 d0             	mov    %rdx,%rax
  8004200423:	48 c1 f8 03          	sar    $0x3,%rax
  8004200427:	48 89 c2             	mov    %rax,%rdx
  800420042a:	48 b8 f1 f0 f0 f0 f0 	movabs $0xf0f0f0f0f0f0f0f1,%rax
  8004200431:	f0 f0 f0 
  8004200434:	48 0f af c2          	imul   %rdx,%rax
  8004200438:	48 83 c0 01          	add    $0x1,%rax
  800420043c:	48 c1 e0 10          	shl    $0x10,%rax
  8004200440:	48 89 c2             	mov    %rax,%rdx
  8004200443:	48 b8 00 f0 69 04 80 	movabs $0x800469f000,%rax
  800420044a:	00 00 00 
  800420044d:	48 01 c2             	add    %rax,%rdx
  8004200450:	48 b8 d8 c5 69 04 80 	movabs $0x800469c5d8,%rax
  8004200457:	00 00 00 
  800420045a:	48 89 10             	mov    %rdx,(%rax)
		// Start the CPU at mpentry_start
		lapic_startap(c->cpu_id, PADDR(code));
  800420045d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004200461:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004200465:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420046c:	00 00 00 
  800420046f:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  8004200473:	77 32                	ja     80042004a7 <boot_aps+0x190>
  8004200475:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004200479:	48 89 c1             	mov    %rax,%rcx
  800420047c:	48 ba 60 8d 21 04 80 	movabs $0x8004218d60,%rdx
  8004200483:	00 00 00 
  8004200486:	be c5 00 00 00       	mov    $0xc5,%esi
  800420048b:	48 bf bc 8c 21 04 80 	movabs $0x8004218cbc,%rdi
  8004200492:	00 00 00 
  8004200495:	b8 00 00 00 00       	mov    $0x0,%eax
  800420049a:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042004a1:	00 00 00 
  80042004a4:	41 ff d0             	callq  *%r8
  80042004a7:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  80042004ae:	ff ff ff 
  80042004b1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042004b5:	48 01 d0             	add    %rdx,%rax
  80042004b8:	89 c2                	mov    %eax,%edx
  80042004ba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042004be:	0f b6 00             	movzbl (%rax),%eax
  80042004c1:	0f b6 c0             	movzbl %al,%eax
  80042004c4:	89 d6                	mov    %edx,%esi
  80042004c6:	89 c7                	mov    %eax,%edi
  80042004c8:	48 b8 42 74 21 04 80 	movabs $0x8004217442,%rax
  80042004cf:	00 00 00 
  80042004d2:	ff d0                	callq  *%rax
		// Wait for the CPU to finish some basic setup in mp_main()
		while(c->cpu_status != CPU_STARTED)
  80042004d4:	90                   	nop
  80042004d5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042004d9:	8b 40 04             	mov    0x4(%rax),%eax
  80042004dc:	83 f8 01             	cmp    $0x1,%eax
  80042004df:	75 f4                	jne    80042004d5 <boot_aps+0x1be>

	// Write entry code to unused memory at MPENTRY_PADDR
	code = KADDR(MPENTRY_PADDR);
	memmove(code, mpentry_start, mpentry_end - mpentry_start);
	// Boot each AP one at a time
	for (c = cpus; c < cpus + ncpu; c++) {
  80042004e1:	48 81 45 f8 88 00 00 	addq   $0x88,-0x8(%rbp)
  80042004e8:	00 
  80042004e9:	48 b8 48 e2 69 04 80 	movabs $0x800469e248,%rax
  80042004f0:	00 00 00 
  80042004f3:	8b 00                	mov    (%rax),%eax
  80042004f5:	48 98                	cltq   
  80042004f7:	48 c1 e0 03          	shl    $0x3,%rax
  80042004fb:	48 89 c2             	mov    %rax,%rdx
  80042004fe:	48 c1 e2 04          	shl    $0x4,%rdx
  8004200502:	48 01 c2             	add    %rax,%rdx
  8004200505:	48 b8 20 e0 69 04 80 	movabs $0x800469e020,%rax
  800420050c:	00 00 00 
  800420050f:	48 01 d0             	add    %rdx,%rax
  8004200512:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004200516:	0f 87 bf fe ff ff    	ja     80042003db <boot_aps+0xc4>
		lapic_startap(c->cpu_id, PADDR(code));
		// Wait for the CPU to finish some basic setup in mp_main()
		while(c->cpu_status != CPU_STARTED)
			;
	}
}
  800420051c:	c9                   	leaveq 
  800420051d:	c3                   	retq   

000000800420051e <mp_main>:

// Setup code for APs
void
mp_main(void)
{
  800420051e:	55                   	push   %rbp
  800420051f:	48 89 e5             	mov    %rsp,%rbp
  8004200522:	48 83 ec 10          	sub    $0x10,%rsp
	// We are in high EIP now, safe to switch to kern_pgdir 
	lcr3(boot_cr3);
  8004200526:	48 b8 e0 c5 69 04 80 	movabs $0x800469c5e0,%rax
  800420052d:	00 00 00 
  8004200530:	48 8b 00             	mov    (%rax),%rax
  8004200533:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  8004200537:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420053b:	0f 22 d8             	mov    %rax,%cr3
	cprintf("SMP: CPU %d starting\n", cpunum());
  800420053e:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  8004200545:	00 00 00 
  8004200548:	ff d0                	callq  *%rax
  800420054a:	89 c6                	mov    %eax,%esi
  800420054c:	48 bf 84 8d 21 04 80 	movabs $0x8004218d84,%rdi
  8004200553:	00 00 00 
  8004200556:	b8 00 00 00 00       	mov    $0x0,%eax
  800420055b:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  8004200562:	00 00 00 
  8004200565:	ff d2                	callq  *%rdx

	lapic_init();
  8004200567:	48 b8 db 71 21 04 80 	movabs $0x80042171db,%rax
  800420056e:	00 00 00 
  8004200571:	ff d0                	callq  *%rax
	env_init_percpu();
  8004200573:	48 b8 73 81 20 04 80 	movabs $0x8004208173,%rax
  800420057a:	00 00 00 
  800420057d:	ff d0                	callq  *%rax
	trap_init_percpu();
  800420057f:	48 b8 0b be 20 04 80 	movabs $0x800420be0b,%rax
  8004200586:	00 00 00 
  8004200589:	ff d0                	callq  *%rax
	xchg(&thiscpu->cpu_status, CPU_STARTED); // tell boot_aps() we're up
  800420058b:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  8004200592:	00 00 00 
  8004200595:	ff d0                	callq  *%rax
  8004200597:	48 98                	cltq   
  8004200599:	48 c1 e0 03          	shl    $0x3,%rax
  800420059d:	48 89 c2             	mov    %rax,%rdx
  80042005a0:	48 c1 e2 04          	shl    $0x4,%rdx
  80042005a4:	48 01 d0             	add    %rdx,%rax
  80042005a7:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  80042005ae:	00 00 00 
  80042005b1:	48 01 d0             	add    %rdx,%rax
  80042005b4:	48 83 c0 04          	add    $0x4,%rax
  80042005b8:	be 01 00 00 00       	mov    $0x1,%esi
  80042005bd:	48 89 c7             	mov    %rax,%rdi
  80042005c0:	48 b8 ce 00 20 04 80 	movabs $0x80042000ce,%rax
  80042005c7:	00 00 00 
  80042005ca:	ff d0                	callq  *%rax
	// to start running processes on this CPU.  But make sure that
	// only one CPU can enter the scheduler at a time!
	//
	// Your code here:

	lock_kernel();
  80042005cc:	48 b8 f3 00 20 04 80 	movabs $0x80042000f3,%rax
  80042005d3:	00 00 00 
  80042005d6:	ff d0                	callq  *%rax
	sched_yield();     // start running processes
  80042005d8:	48 b8 d5 d2 20 04 80 	movabs $0x800420d2d5,%rax
  80042005df:	00 00 00 
  80042005e2:	ff d0                	callq  *%rax

00000080042005e4 <_panic>:
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", and then enters the kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt,...)
{
  80042005e4:	55                   	push   %rbp
  80042005e5:	48 89 e5             	mov    %rsp,%rbp
  80042005e8:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  80042005ef:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  80042005f6:	89 b5 24 ff ff ff    	mov    %esi,-0xdc(%rbp)
  80042005fc:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  8004200603:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420060a:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  8004200611:	84 c0                	test   %al,%al
  8004200613:	74 20                	je     8004200635 <_panic+0x51>
  8004200615:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  8004200619:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420061d:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  8004200621:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  8004200625:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  8004200629:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420062d:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  8004200631:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  8004200635:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	if (panicstr)
  800420063c:	48 b8 d0 c5 69 04 80 	movabs $0x800469c5d0,%rax
  8004200643:	00 00 00 
  8004200646:	48 8b 00             	mov    (%rax),%rax
  8004200649:	48 85 c0             	test   %rax,%rax
  800420064c:	74 05                	je     8004200653 <_panic+0x6f>
		goto dead;
  800420064e:	e9 b5 00 00 00       	jmpq   8004200708 <_panic+0x124>
	panicstr = fmt;
  8004200653:	48 b8 d0 c5 69 04 80 	movabs $0x800469c5d0,%rax
  800420065a:	00 00 00 
  800420065d:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  8004200664:	48 89 10             	mov    %rdx,(%rax)

	// Be extra sure that the machine is in as reasonable state
	__asm __volatile("cli; cld");
  8004200667:	fa                   	cli    
  8004200668:	fc                   	cld    

	va_start(ap, fmt);
  8004200669:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  8004200670:	00 00 00 
  8004200673:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  800420067a:	00 00 00 
  800420067d:	48 8d 45 10          	lea    0x10(%rbp),%rax
  8004200681:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  8004200688:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420068f:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)

	cprintf("kernel panic on CPU %d at %s:%d: ", cpunum(), file, line);
  8004200696:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420069d:	00 00 00 
  80042006a0:	ff d0                	callq  *%rax
  80042006a2:	8b 8d 24 ff ff ff    	mov    -0xdc(%rbp),%ecx
  80042006a8:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  80042006af:	89 c6                	mov    %eax,%esi
  80042006b1:	48 bf a0 8d 21 04 80 	movabs $0x8004218da0,%rdi
  80042006b8:	00 00 00 
  80042006bb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042006c0:	49 b8 90 95 20 04 80 	movabs $0x8004209590,%r8
  80042006c7:	00 00 00 
  80042006ca:	41 ff d0             	callq  *%r8

	vcprintf(fmt, ap);
  80042006cd:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
  80042006d4:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80042006db:	48 89 d6             	mov    %rdx,%rsi
  80042006de:	48 89 c7             	mov    %rax,%rdi
  80042006e1:	48 b8 31 95 20 04 80 	movabs $0x8004209531,%rax
  80042006e8:	00 00 00 
  80042006eb:	ff d0                	callq  *%rax
	cprintf("\n");
  80042006ed:	48 bf c2 8d 21 04 80 	movabs $0x8004218dc2,%rdi
  80042006f4:	00 00 00 
  80042006f7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042006fc:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  8004200703:	00 00 00 
  8004200706:	ff d2                	callq  *%rdx
	va_end(ap);

dead:
	/* break into the kernel monitor */
	while (1)
		monitor(NULL);
  8004200708:	bf 00 00 00 00       	mov    $0x0,%edi
  800420070d:	48 b8 99 1b 20 04 80 	movabs $0x8004201b99,%rax
  8004200714:	00 00 00 
  8004200717:	ff d0                	callq  *%rax
  8004200719:	eb ed                	jmp    8004200708 <_panic+0x124>

000000800420071b <_warn>:
}

/* like panic, but don't */
void
_warn(const char *file, int line, const char *fmt,...)
{
  800420071b:	55                   	push   %rbp
  800420071c:	48 89 e5             	mov    %rsp,%rbp
  800420071f:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  8004200726:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  800420072d:	89 b5 24 ff ff ff    	mov    %esi,-0xdc(%rbp)
  8004200733:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420073a:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  8004200741:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  8004200748:	84 c0                	test   %al,%al
  800420074a:	74 20                	je     800420076c <_warn+0x51>
  800420074c:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  8004200750:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  8004200754:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  8004200758:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420075c:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  8004200760:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  8004200764:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  8004200768:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  800420076c:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  8004200773:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  800420077a:	00 00 00 
  800420077d:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  8004200784:	00 00 00 
  8004200787:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420078b:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  8004200792:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004200799:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	cprintf("kernel warning at %s:%d: ", file, line);
  80042007a0:	8b 95 24 ff ff ff    	mov    -0xdc(%rbp),%edx
  80042007a6:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042007ad:	48 89 c6             	mov    %rax,%rsi
  80042007b0:	48 bf c4 8d 21 04 80 	movabs $0x8004218dc4,%rdi
  80042007b7:	00 00 00 
  80042007ba:	b8 00 00 00 00       	mov    $0x0,%eax
  80042007bf:	48 b9 90 95 20 04 80 	movabs $0x8004209590,%rcx
  80042007c6:	00 00 00 
  80042007c9:	ff d1                	callq  *%rcx
	vcprintf(fmt, ap);
  80042007cb:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
  80042007d2:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80042007d9:	48 89 d6             	mov    %rdx,%rsi
  80042007dc:	48 89 c7             	mov    %rax,%rdi
  80042007df:	48 b8 31 95 20 04 80 	movabs $0x8004209531,%rax
  80042007e6:	00 00 00 
  80042007e9:	ff d0                	callq  *%rax
	cprintf("\n");
  80042007eb:	48 bf c2 8d 21 04 80 	movabs $0x8004218dc2,%rdi
  80042007f2:	00 00 00 
  80042007f5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042007fa:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  8004200801:	00 00 00 
  8004200804:	ff d2                	callq  *%rdx
	va_end(ap);
}
  8004200806:	c9                   	leaveq 
  8004200807:	c3                   	retq   

0000008004200808 <delay>:
static void cons_putc(int c);

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
  8004200808:	55                   	push   %rbp
  8004200809:	48 89 e5             	mov    %rsp,%rbp
  800420080c:	48 83 ec 20          	sub    $0x20,%rsp
  8004200810:	c7 45 fc 84 00 00 00 	movl   $0x84,-0x4(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200817:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420081a:	89 c2                	mov    %eax,%edx
  800420081c:	ec                   	in     (%dx),%al
  800420081d:	88 45 fb             	mov    %al,-0x5(%rbp)
  8004200820:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%rbp)
  8004200827:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420082a:	89 c2                	mov    %eax,%edx
  800420082c:	ec                   	in     (%dx),%al
  800420082d:	88 45 f3             	mov    %al,-0xd(%rbp)
  8004200830:	c7 45 ec 84 00 00 00 	movl   $0x84,-0x14(%rbp)
  8004200837:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420083a:	89 c2                	mov    %eax,%edx
  800420083c:	ec                   	in     (%dx),%al
  800420083d:	88 45 eb             	mov    %al,-0x15(%rbp)
  8004200840:	c7 45 e4 84 00 00 00 	movl   $0x84,-0x1c(%rbp)
  8004200847:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420084a:	89 c2                	mov    %eax,%edx
  800420084c:	ec                   	in     (%dx),%al
  800420084d:	88 45 e3             	mov    %al,-0x1d(%rbp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
  8004200850:	c9                   	leaveq 
  8004200851:	c3                   	retq   

0000008004200852 <serial_proc_data>:

static bool serial_exists;

static int
serial_proc_data(void)
{
  8004200852:	55                   	push   %rbp
  8004200853:	48 89 e5             	mov    %rsp,%rbp
  8004200856:	48 83 ec 10          	sub    $0x10,%rsp
  800420085a:	c7 45 fc fd 03 00 00 	movl   $0x3fd,-0x4(%rbp)
  8004200861:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004200864:	89 c2                	mov    %eax,%edx
  8004200866:	ec                   	in     (%dx),%al
  8004200867:	88 45 fb             	mov    %al,-0x5(%rbp)
	return data;
  800420086a:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
  800420086e:	0f b6 c0             	movzbl %al,%eax
  8004200871:	83 e0 01             	and    $0x1,%eax
  8004200874:	85 c0                	test   %eax,%eax
  8004200876:	75 07                	jne    800420087f <serial_proc_data+0x2d>
		return -1;
  8004200878:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420087d:	eb 17                	jmp    8004200896 <serial_proc_data+0x44>
  800420087f:	c7 45 f4 f8 03 00 00 	movl   $0x3f8,-0xc(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200886:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004200889:	89 c2                	mov    %eax,%edx
  800420088b:	ec                   	in     (%dx),%al
  800420088c:	88 45 f3             	mov    %al,-0xd(%rbp)
	return data;
  800420088f:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
	return inb(COM1+COM_RX);
  8004200893:	0f b6 c0             	movzbl %al,%eax
}
  8004200896:	c9                   	leaveq 
  8004200897:	c3                   	retq   

0000008004200898 <serial_intr>:

void
serial_intr(void)
{
  8004200898:	55                   	push   %rbp
  8004200899:	48 89 e5             	mov    %rsp,%rbp
	if (serial_exists)
  800420089c:	48 b8 00 d0 49 04 80 	movabs $0x800449d000,%rax
  80042008a3:	00 00 00 
  80042008a6:	0f b6 00             	movzbl (%rax),%eax
  80042008a9:	84 c0                	test   %al,%al
  80042008ab:	74 16                	je     80042008c3 <serial_intr+0x2b>
		cons_intr(serial_proc_data);
  80042008ad:	48 bf 52 08 20 04 80 	movabs $0x8004200852,%rdi
  80042008b4:	00 00 00 
  80042008b7:	48 b8 64 11 20 04 80 	movabs $0x8004201164,%rax
  80042008be:	00 00 00 
  80042008c1:	ff d0                	callq  *%rax
}
  80042008c3:	5d                   	pop    %rbp
  80042008c4:	c3                   	retq   

00000080042008c5 <serial_putc>:

static void
serial_putc(int c)
{
  80042008c5:	55                   	push   %rbp
  80042008c6:	48 89 e5             	mov    %rsp,%rbp
  80042008c9:	48 83 ec 28          	sub    $0x28,%rsp
  80042008cd:	89 7d dc             	mov    %edi,-0x24(%rbp)
	int i;

	for (i = 0;
  80042008d0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042008d7:	eb 10                	jmp    80042008e9 <serial_putc+0x24>
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
	     i++)
		delay();
  80042008d9:	48 b8 08 08 20 04 80 	movabs $0x8004200808,%rax
  80042008e0:	00 00 00 
  80042008e3:	ff d0                	callq  *%rax
{
	int i;

	for (i = 0;
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
	     i++)
  80042008e5:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042008e9:	c7 45 f8 fd 03 00 00 	movl   $0x3fd,-0x8(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042008f0:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042008f3:	89 c2                	mov    %eax,%edx
  80042008f5:	ec                   	in     (%dx),%al
  80042008f6:	88 45 f7             	mov    %al,-0x9(%rbp)
	return data;
  80042008f9:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
serial_putc(int c)
{
	int i;

	for (i = 0;
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
  80042008fd:	0f b6 c0             	movzbl %al,%eax
  8004200900:	83 e0 20             	and    $0x20,%eax
static void
serial_putc(int c)
{
	int i;

	for (i = 0;
  8004200903:	85 c0                	test   %eax,%eax
  8004200905:	75 09                	jne    8004200910 <serial_putc+0x4b>
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
  8004200907:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%rbp)
  800420090e:	7e c9                	jle    80042008d9 <serial_putc+0x14>
	     i++)
		delay();

	outb(COM1 + COM_TX, c);
  8004200910:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004200913:	0f b6 c0             	movzbl %al,%eax
  8004200916:	c7 45 f0 f8 03 00 00 	movl   $0x3f8,-0x10(%rbp)
  800420091d:	88 45 ef             	mov    %al,-0x11(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200920:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8004200924:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200927:	ee                   	out    %al,(%dx)
}
  8004200928:	c9                   	leaveq 
  8004200929:	c3                   	retq   

000000800420092a <serial_init>:

static void
serial_init(void)
{
  800420092a:	55                   	push   %rbp
  800420092b:	48 89 e5             	mov    %rsp,%rbp
  800420092e:	48 83 ec 50          	sub    $0x50,%rsp
  8004200932:	c7 45 fc fa 03 00 00 	movl   $0x3fa,-0x4(%rbp)
  8004200939:	c6 45 fb 00          	movb   $0x0,-0x5(%rbp)
  800420093d:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200941:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004200944:	ee                   	out    %al,(%dx)
  8004200945:	c7 45 f4 fb 03 00 00 	movl   $0x3fb,-0xc(%rbp)
  800420094c:	c6 45 f3 80          	movb   $0x80,-0xd(%rbp)
  8004200950:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004200954:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004200957:	ee                   	out    %al,(%dx)
  8004200958:	c7 45 ec f8 03 00 00 	movl   $0x3f8,-0x14(%rbp)
  800420095f:	c6 45 eb 0c          	movb   $0xc,-0x15(%rbp)
  8004200963:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004200967:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800420096a:	ee                   	out    %al,(%dx)
  800420096b:	c7 45 e4 f9 03 00 00 	movl   $0x3f9,-0x1c(%rbp)
  8004200972:	c6 45 e3 00          	movb   $0x0,-0x1d(%rbp)
  8004200976:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  800420097a:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  800420097d:	ee                   	out    %al,(%dx)
  800420097e:	c7 45 dc fb 03 00 00 	movl   $0x3fb,-0x24(%rbp)
  8004200985:	c6 45 db 03          	movb   $0x3,-0x25(%rbp)
  8004200989:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  800420098d:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004200990:	ee                   	out    %al,(%dx)
  8004200991:	c7 45 d4 fc 03 00 00 	movl   $0x3fc,-0x2c(%rbp)
  8004200998:	c6 45 d3 00          	movb   $0x0,-0x2d(%rbp)
  800420099c:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  80042009a0:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  80042009a3:	ee                   	out    %al,(%dx)
  80042009a4:	c7 45 cc f9 03 00 00 	movl   $0x3f9,-0x34(%rbp)
  80042009ab:	c6 45 cb 01          	movb   $0x1,-0x35(%rbp)
  80042009af:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  80042009b3:	8b 55 cc             	mov    -0x34(%rbp),%edx
  80042009b6:	ee                   	out    %al,(%dx)
  80042009b7:	c7 45 c4 fd 03 00 00 	movl   $0x3fd,-0x3c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042009be:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  80042009c1:	89 c2                	mov    %eax,%edx
  80042009c3:	ec                   	in     (%dx),%al
  80042009c4:	88 45 c3             	mov    %al,-0x3d(%rbp)
	return data;
  80042009c7:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
  80042009cb:	3c ff                	cmp    $0xff,%al
  80042009cd:	0f 95 c2             	setne  %dl
  80042009d0:	48 b8 00 d0 49 04 80 	movabs $0x800449d000,%rax
  80042009d7:	00 00 00 
  80042009da:	88 10                	mov    %dl,(%rax)
  80042009dc:	c7 45 bc fa 03 00 00 	movl   $0x3fa,-0x44(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042009e3:	8b 45 bc             	mov    -0x44(%rbp),%eax
  80042009e6:	89 c2                	mov    %eax,%edx
  80042009e8:	ec                   	in     (%dx),%al
  80042009e9:	88 45 bb             	mov    %al,-0x45(%rbp)
  80042009ec:	c7 45 b4 f8 03 00 00 	movl   $0x3f8,-0x4c(%rbp)
  80042009f3:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  80042009f6:	89 c2                	mov    %eax,%edx
  80042009f8:	ec                   	in     (%dx),%al
  80042009f9:	88 45 b3             	mov    %al,-0x4d(%rbp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);


	// Enable serial interrupts
	if (serial_exists)
  80042009fc:	48 b8 00 d0 49 04 80 	movabs $0x800449d000,%rax
  8004200a03:	00 00 00 
  8004200a06:	0f b6 00             	movzbl (%rax),%eax
  8004200a09:	84 c0                	test   %al,%al
  8004200a0b:	74 23                	je     8004200a30 <serial_init+0x106>
		irq_setmask_8259A(irq_mask_8259A & ~(1<<4));
  8004200a0d:	48 b8 72 c6 22 04 80 	movabs $0x800422c672,%rax
  8004200a14:	00 00 00 
  8004200a17:	0f b7 00             	movzwl (%rax),%eax
  8004200a1a:	0f b7 c0             	movzwl %ax,%eax
  8004200a1d:	25 ef ff 00 00       	and    $0xffef,%eax
  8004200a22:	89 c7                	mov    %eax,%edi
  8004200a24:	48 b8 e2 93 20 04 80 	movabs $0x80042093e2,%rax
  8004200a2b:	00 00 00 
  8004200a2e:	ff d0                	callq  *%rax

}
  8004200a30:	c9                   	leaveq 
  8004200a31:	c3                   	retq   

0000008004200a32 <lpt_putc>:
// For information on PC parallel port programming, see the class References
// page.

static void
lpt_putc(int c)
{
  8004200a32:	55                   	push   %rbp
  8004200a33:	48 89 e5             	mov    %rsp,%rbp
  8004200a36:	48 83 ec 38          	sub    $0x38,%rsp
  8004200a3a:	89 7d cc             	mov    %edi,-0x34(%rbp)
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 12800; i++)
  8004200a3d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004200a44:	eb 10                	jmp    8004200a56 <lpt_putc+0x24>
		delay();
  8004200a46:	48 b8 08 08 20 04 80 	movabs $0x8004200808,%rax
  8004200a4d:	00 00 00 
  8004200a50:	ff d0                	callq  *%rax
static void
lpt_putc(int c)
{
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 12800; i++)
  8004200a52:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004200a56:	c7 45 f8 79 03 00 00 	movl   $0x379,-0x8(%rbp)
  8004200a5d:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004200a60:	89 c2                	mov    %eax,%edx
  8004200a62:	ec                   	in     (%dx),%al
  8004200a63:	88 45 f7             	mov    %al,-0x9(%rbp)
	return data;
  8004200a66:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  8004200a6a:	84 c0                	test   %al,%al
  8004200a6c:	78 09                	js     8004200a77 <lpt_putc+0x45>
  8004200a6e:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%rbp)
  8004200a75:	7e cf                	jle    8004200a46 <lpt_putc+0x14>
		delay();
	outb(0x378+0, c);
  8004200a77:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200a7a:	0f b6 c0             	movzbl %al,%eax
  8004200a7d:	c7 45 f0 78 03 00 00 	movl   $0x378,-0x10(%rbp)
  8004200a84:	88 45 ef             	mov    %al,-0x11(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200a87:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8004200a8b:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200a8e:	ee                   	out    %al,(%dx)
  8004200a8f:	c7 45 e8 7a 03 00 00 	movl   $0x37a,-0x18(%rbp)
  8004200a96:	c6 45 e7 0d          	movb   $0xd,-0x19(%rbp)
  8004200a9a:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004200a9e:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004200aa1:	ee                   	out    %al,(%dx)
  8004200aa2:	c7 45 e0 7a 03 00 00 	movl   $0x37a,-0x20(%rbp)
  8004200aa9:	c6 45 df 08          	movb   $0x8,-0x21(%rbp)
  8004200aad:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004200ab1:	8b 55 e0             	mov    -0x20(%rbp),%edx
  8004200ab4:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
  8004200ab5:	c9                   	leaveq 
  8004200ab6:	c3                   	retq   

0000008004200ab7 <cga_init>:
static uint16_t crt_pos;


static void
cga_init(void)
{
  8004200ab7:	55                   	push   %rbp
  8004200ab8:	48 89 e5             	mov    %rsp,%rbp
  8004200abb:	48 83 ec 30          	sub    $0x30,%rsp
	volatile uint16_t *cp;
	uint16_t was;
	unsigned pos;

	cp = (uint16_t*) (KERNBASE + CGA_BUF);
  8004200abf:	48 b8 00 80 0b 04 80 	movabs $0x80040b8000,%rax
  8004200ac6:	00 00 00 
  8004200ac9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	was = *cp;
  8004200acd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200ad1:	0f b7 00             	movzwl (%rax),%eax
  8004200ad4:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
	*cp = (uint16_t) 0xA55A;
  8004200ad8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200adc:	66 c7 00 5a a5       	movw   $0xa55a,(%rax)
	if (*cp != 0xA55A) {
  8004200ae1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200ae5:	0f b7 00             	movzwl (%rax),%eax
  8004200ae8:	66 3d 5a a5          	cmp    $0xa55a,%ax
  8004200aec:	74 20                	je     8004200b0e <cga_init+0x57>
		cp = (uint16_t*) (KERNBASE + MONO_BUF);
  8004200aee:	48 b8 00 00 0b 04 80 	movabs $0x80040b0000,%rax
  8004200af5:	00 00 00 
  8004200af8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		addr_6845 = MONO_BASE;
  8004200afc:	48 b8 04 d0 49 04 80 	movabs $0x800449d004,%rax
  8004200b03:	00 00 00 
  8004200b06:	c7 00 b4 03 00 00    	movl   $0x3b4,(%rax)
  8004200b0c:	eb 1b                	jmp    8004200b29 <cga_init+0x72>
	} else {
		*cp = was;
  8004200b0e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200b12:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  8004200b16:	66 89 10             	mov    %dx,(%rax)
		addr_6845 = CGA_BASE;
  8004200b19:	48 b8 04 d0 49 04 80 	movabs $0x800449d004,%rax
  8004200b20:	00 00 00 
  8004200b23:	c7 00 d4 03 00 00    	movl   $0x3d4,(%rax)
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
  8004200b29:	48 b8 04 d0 49 04 80 	movabs $0x800449d004,%rax
  8004200b30:	00 00 00 
  8004200b33:	8b 00                	mov    (%rax),%eax
  8004200b35:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004200b38:	c6 45 eb 0e          	movb   $0xe,-0x15(%rbp)
  8004200b3c:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004200b40:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004200b43:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
  8004200b44:	48 b8 04 d0 49 04 80 	movabs $0x800449d004,%rax
  8004200b4b:	00 00 00 
  8004200b4e:	8b 00                	mov    (%rax),%eax
  8004200b50:	83 c0 01             	add    $0x1,%eax
  8004200b53:	89 45 e4             	mov    %eax,-0x1c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200b56:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004200b59:	89 c2                	mov    %eax,%edx
  8004200b5b:	ec                   	in     (%dx),%al
  8004200b5c:	88 45 e3             	mov    %al,-0x1d(%rbp)
	return data;
  8004200b5f:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004200b63:	0f b6 c0             	movzbl %al,%eax
  8004200b66:	c1 e0 08             	shl    $0x8,%eax
  8004200b69:	89 45 f0             	mov    %eax,-0x10(%rbp)
	outb(addr_6845, 15);
  8004200b6c:	48 b8 04 d0 49 04 80 	movabs $0x800449d004,%rax
  8004200b73:	00 00 00 
  8004200b76:	8b 00                	mov    (%rax),%eax
  8004200b78:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004200b7b:	c6 45 db 0f          	movb   $0xf,-0x25(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200b7f:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004200b83:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004200b86:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
  8004200b87:	48 b8 04 d0 49 04 80 	movabs $0x800449d004,%rax
  8004200b8e:	00 00 00 
  8004200b91:	8b 00                	mov    (%rax),%eax
  8004200b93:	83 c0 01             	add    $0x1,%eax
  8004200b96:	89 45 d4             	mov    %eax,-0x2c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200b99:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8004200b9c:	89 c2                	mov    %eax,%edx
  8004200b9e:	ec                   	in     (%dx),%al
  8004200b9f:	88 45 d3             	mov    %al,-0x2d(%rbp)
	return data;
  8004200ba2:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004200ba6:	0f b6 c0             	movzbl %al,%eax
  8004200ba9:	09 45 f0             	or     %eax,-0x10(%rbp)

	crt_buf = (uint16_t*) cp;
  8004200bac:	48 b8 08 d0 49 04 80 	movabs $0x800449d008,%rax
  8004200bb3:	00 00 00 
  8004200bb6:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004200bba:	48 89 10             	mov    %rdx,(%rax)
	crt_pos = pos;
  8004200bbd:	8b 45 f0             	mov    -0x10(%rbp),%eax
  8004200bc0:	89 c2                	mov    %eax,%edx
  8004200bc2:	48 b8 10 d0 49 04 80 	movabs $0x800449d010,%rax
  8004200bc9:	00 00 00 
  8004200bcc:	66 89 10             	mov    %dx,(%rax)
}
  8004200bcf:	c9                   	leaveq 
  8004200bd0:	c3                   	retq   

0000008004200bd1 <cga_putc>:



static void
cga_putc(int c)
{
  8004200bd1:	55                   	push   %rbp
  8004200bd2:	48 89 e5             	mov    %rsp,%rbp
  8004200bd5:	48 83 ec 40          	sub    $0x40,%rsp
  8004200bd9:	89 7d cc             	mov    %edi,-0x34(%rbp)

	// if no attribute given, then use black on white
	if (!(c & ~0xFF))
  8004200bdc:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200bdf:	b0 00                	mov    $0x0,%al
  8004200be1:	85 c0                	test   %eax,%eax
  8004200be3:	75 07                	jne    8004200bec <cga_putc+0x1b>
		c |= 0x0700;
  8004200be5:	81 4d cc 00 07 00 00 	orl    $0x700,-0x34(%rbp)

	switch (c & 0xff) {
  8004200bec:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200bef:	0f b6 c0             	movzbl %al,%eax
  8004200bf2:	83 f8 09             	cmp    $0x9,%eax
  8004200bf5:	0f 84 f6 00 00 00    	je     8004200cf1 <cga_putc+0x120>
  8004200bfb:	83 f8 09             	cmp    $0x9,%eax
  8004200bfe:	7f 0a                	jg     8004200c0a <cga_putc+0x39>
  8004200c00:	83 f8 08             	cmp    $0x8,%eax
  8004200c03:	74 18                	je     8004200c1d <cga_putc+0x4c>
  8004200c05:	e9 3e 01 00 00       	jmpq   8004200d48 <cga_putc+0x177>
  8004200c0a:	83 f8 0a             	cmp    $0xa,%eax
  8004200c0d:	74 75                	je     8004200c84 <cga_putc+0xb3>
  8004200c0f:	83 f8 0d             	cmp    $0xd,%eax
  8004200c12:	0f 84 89 00 00 00    	je     8004200ca1 <cga_putc+0xd0>
  8004200c18:	e9 2b 01 00 00       	jmpq   8004200d48 <cga_putc+0x177>
	case '\b':
		if (crt_pos > 0) {
  8004200c1d:	48 b8 10 d0 49 04 80 	movabs $0x800449d010,%rax
  8004200c24:	00 00 00 
  8004200c27:	0f b7 00             	movzwl (%rax),%eax
  8004200c2a:	66 85 c0             	test   %ax,%ax
  8004200c2d:	74 50                	je     8004200c7f <cga_putc+0xae>
			crt_pos--;
  8004200c2f:	48 b8 10 d0 49 04 80 	movabs $0x800449d010,%rax
  8004200c36:	00 00 00 
  8004200c39:	0f b7 00             	movzwl (%rax),%eax
  8004200c3c:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004200c3f:	48 b8 10 d0 49 04 80 	movabs $0x800449d010,%rax
  8004200c46:	00 00 00 
  8004200c49:	66 89 10             	mov    %dx,(%rax)
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
  8004200c4c:	48 b8 08 d0 49 04 80 	movabs $0x800449d008,%rax
  8004200c53:	00 00 00 
  8004200c56:	48 8b 10             	mov    (%rax),%rdx
  8004200c59:	48 b8 10 d0 49 04 80 	movabs $0x800449d010,%rax
  8004200c60:	00 00 00 
  8004200c63:	0f b7 00             	movzwl (%rax),%eax
  8004200c66:	0f b7 c0             	movzwl %ax,%eax
  8004200c69:	48 01 c0             	add    %rax,%rax
  8004200c6c:	48 01 c2             	add    %rax,%rdx
  8004200c6f:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200c72:	b0 00                	mov    $0x0,%al
  8004200c74:	83 c8 20             	or     $0x20,%eax
  8004200c77:	66 89 02             	mov    %ax,(%rdx)
		}
		break;
  8004200c7a:	e9 04 01 00 00       	jmpq   8004200d83 <cga_putc+0x1b2>
  8004200c7f:	e9 ff 00 00 00       	jmpq   8004200d83 <cga_putc+0x1b2>
	case '\n':
		crt_pos += CRT_COLS;
  8004200c84:	48 b8 10 d0 49 04 80 	movabs $0x800449d010,%rax
  8004200c8b:	00 00 00 
  8004200c8e:	0f b7 00             	movzwl (%rax),%eax
  8004200c91:	8d 50 50             	lea    0x50(%rax),%edx
  8004200c94:	48 b8 10 d0 49 04 80 	movabs $0x800449d010,%rax
  8004200c9b:	00 00 00 
  8004200c9e:	66 89 10             	mov    %dx,(%rax)
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
  8004200ca1:	48 b8 10 d0 49 04 80 	movabs $0x800449d010,%rax
  8004200ca8:	00 00 00 
  8004200cab:	0f b7 30             	movzwl (%rax),%esi
  8004200cae:	48 b8 10 d0 49 04 80 	movabs $0x800449d010,%rax
  8004200cb5:	00 00 00 
  8004200cb8:	0f b7 08             	movzwl (%rax),%ecx
  8004200cbb:	0f b7 c1             	movzwl %cx,%eax
  8004200cbe:	69 c0 cd cc 00 00    	imul   $0xcccd,%eax,%eax
  8004200cc4:	c1 e8 10             	shr    $0x10,%eax
  8004200cc7:	89 c2                	mov    %eax,%edx
  8004200cc9:	66 c1 ea 06          	shr    $0x6,%dx
  8004200ccd:	89 d0                	mov    %edx,%eax
  8004200ccf:	c1 e0 02             	shl    $0x2,%eax
  8004200cd2:	01 d0                	add    %edx,%eax
  8004200cd4:	c1 e0 04             	shl    $0x4,%eax
  8004200cd7:	29 c1                	sub    %eax,%ecx
  8004200cd9:	89 ca                	mov    %ecx,%edx
  8004200cdb:	29 d6                	sub    %edx,%esi
  8004200cdd:	89 f2                	mov    %esi,%edx
  8004200cdf:	48 b8 10 d0 49 04 80 	movabs $0x800449d010,%rax
  8004200ce6:	00 00 00 
  8004200ce9:	66 89 10             	mov    %dx,(%rax)
		break;
  8004200cec:	e9 92 00 00 00       	jmpq   8004200d83 <cga_putc+0x1b2>
	case '\t':
		cons_putc(' ');
  8004200cf1:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200cf6:	48 b8 a1 12 20 04 80 	movabs $0x80042012a1,%rax
  8004200cfd:	00 00 00 
  8004200d00:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200d02:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200d07:	48 b8 a1 12 20 04 80 	movabs $0x80042012a1,%rax
  8004200d0e:	00 00 00 
  8004200d11:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200d13:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200d18:	48 b8 a1 12 20 04 80 	movabs $0x80042012a1,%rax
  8004200d1f:	00 00 00 
  8004200d22:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200d24:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200d29:	48 b8 a1 12 20 04 80 	movabs $0x80042012a1,%rax
  8004200d30:	00 00 00 
  8004200d33:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200d35:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200d3a:	48 b8 a1 12 20 04 80 	movabs $0x80042012a1,%rax
  8004200d41:	00 00 00 
  8004200d44:	ff d0                	callq  *%rax
		break;
  8004200d46:	eb 3b                	jmp    8004200d83 <cga_putc+0x1b2>
	default:
		crt_buf[crt_pos++] = c;		/* write the character */
  8004200d48:	48 b8 08 d0 49 04 80 	movabs $0x800449d008,%rax
  8004200d4f:	00 00 00 
  8004200d52:	48 8b 30             	mov    (%rax),%rsi
  8004200d55:	48 b8 10 d0 49 04 80 	movabs $0x800449d010,%rax
  8004200d5c:	00 00 00 
  8004200d5f:	0f b7 00             	movzwl (%rax),%eax
  8004200d62:	8d 48 01             	lea    0x1(%rax),%ecx
  8004200d65:	48 ba 10 d0 49 04 80 	movabs $0x800449d010,%rdx
  8004200d6c:	00 00 00 
  8004200d6f:	66 89 0a             	mov    %cx,(%rdx)
  8004200d72:	0f b7 c0             	movzwl %ax,%eax
  8004200d75:	48 01 c0             	add    %rax,%rax
  8004200d78:	48 8d 14 06          	lea    (%rsi,%rax,1),%rdx
  8004200d7c:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200d7f:	66 89 02             	mov    %ax,(%rdx)
		break;
  8004200d82:	90                   	nop
	}


	/* scroll if necessary */

	if (crt_pos >= CRT_SIZE) {
  8004200d83:	48 b8 10 d0 49 04 80 	movabs $0x800449d010,%rax
  8004200d8a:	00 00 00 
  8004200d8d:	0f b7 00             	movzwl (%rax),%eax
  8004200d90:	66 3d cf 07          	cmp    $0x7cf,%ax
  8004200d94:	0f 86 89 00 00 00    	jbe    8004200e23 <cga_putc+0x252>
		int i;


		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
  8004200d9a:	48 b8 08 d0 49 04 80 	movabs $0x800449d008,%rax
  8004200da1:	00 00 00 
  8004200da4:	48 8b 00             	mov    (%rax),%rax
  8004200da7:	48 8d 88 a0 00 00 00 	lea    0xa0(%rax),%rcx
  8004200dae:	48 b8 08 d0 49 04 80 	movabs $0x800449d008,%rax
  8004200db5:	00 00 00 
  8004200db8:	48 8b 00             	mov    (%rax),%rax
  8004200dbb:	ba 00 0f 00 00       	mov    $0xf00,%edx
  8004200dc0:	48 89 ce             	mov    %rcx,%rsi
  8004200dc3:	48 89 c7             	mov    %rax,%rdi
  8004200dc6:	48 b8 5f 04 21 04 80 	movabs $0x800421045f,%rax
  8004200dcd:	00 00 00 
  8004200dd0:	ff d0                	callq  *%rax
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
  8004200dd2:	c7 45 fc 80 07 00 00 	movl   $0x780,-0x4(%rbp)
  8004200dd9:	eb 22                	jmp    8004200dfd <cga_putc+0x22c>
			crt_buf[i] = 0x0700 | ' ';
  8004200ddb:	48 b8 08 d0 49 04 80 	movabs $0x800449d008,%rax
  8004200de2:	00 00 00 
  8004200de5:	48 8b 00             	mov    (%rax),%rax
  8004200de8:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004200deb:	48 63 d2             	movslq %edx,%rdx
  8004200dee:	48 01 d2             	add    %rdx,%rdx
  8004200df1:	48 01 d0             	add    %rdx,%rax
  8004200df4:	66 c7 00 20 07       	movw   $0x720,(%rax)
	if (crt_pos >= CRT_SIZE) {
		int i;


		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
  8004200df9:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004200dfd:	81 7d fc cf 07 00 00 	cmpl   $0x7cf,-0x4(%rbp)
  8004200e04:	7e d5                	jle    8004200ddb <cga_putc+0x20a>
			crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
  8004200e06:	48 b8 10 d0 49 04 80 	movabs $0x800449d010,%rax
  8004200e0d:	00 00 00 
  8004200e10:	0f b7 00             	movzwl (%rax),%eax
  8004200e13:	8d 50 b0             	lea    -0x50(%rax),%edx
  8004200e16:	48 b8 10 d0 49 04 80 	movabs $0x800449d010,%rax
  8004200e1d:	00 00 00 
  8004200e20:	66 89 10             	mov    %dx,(%rax)
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
  8004200e23:	48 b8 04 d0 49 04 80 	movabs $0x800449d004,%rax
  8004200e2a:	00 00 00 
  8004200e2d:	8b 00                	mov    (%rax),%eax
  8004200e2f:	89 45 f8             	mov    %eax,-0x8(%rbp)
  8004200e32:	c6 45 f7 0e          	movb   $0xe,-0x9(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200e36:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  8004200e3a:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004200e3d:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
  8004200e3e:	48 b8 10 d0 49 04 80 	movabs $0x800449d010,%rax
  8004200e45:	00 00 00 
  8004200e48:	0f b7 00             	movzwl (%rax),%eax
  8004200e4b:	66 c1 e8 08          	shr    $0x8,%ax
  8004200e4f:	0f b6 c0             	movzbl %al,%eax
  8004200e52:	48 ba 04 d0 49 04 80 	movabs $0x800449d004,%rdx
  8004200e59:	00 00 00 
  8004200e5c:	8b 12                	mov    (%rdx),%edx
  8004200e5e:	83 c2 01             	add    $0x1,%edx
  8004200e61:	89 55 f0             	mov    %edx,-0x10(%rbp)
  8004200e64:	88 45 ef             	mov    %al,-0x11(%rbp)
  8004200e67:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8004200e6b:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200e6e:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
  8004200e6f:	48 b8 04 d0 49 04 80 	movabs $0x800449d004,%rax
  8004200e76:	00 00 00 
  8004200e79:	8b 00                	mov    (%rax),%eax
  8004200e7b:	89 45 e8             	mov    %eax,-0x18(%rbp)
  8004200e7e:	c6 45 e7 0f          	movb   $0xf,-0x19(%rbp)
  8004200e82:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004200e86:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004200e89:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
  8004200e8a:	48 b8 10 d0 49 04 80 	movabs $0x800449d010,%rax
  8004200e91:	00 00 00 
  8004200e94:	0f b7 00             	movzwl (%rax),%eax
  8004200e97:	0f b6 c0             	movzbl %al,%eax
  8004200e9a:	48 ba 04 d0 49 04 80 	movabs $0x800449d004,%rdx
  8004200ea1:	00 00 00 
  8004200ea4:	8b 12                	mov    (%rdx),%edx
  8004200ea6:	83 c2 01             	add    $0x1,%edx
  8004200ea9:	89 55 e0             	mov    %edx,-0x20(%rbp)
  8004200eac:	88 45 df             	mov    %al,-0x21(%rbp)
  8004200eaf:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004200eb3:	8b 55 e0             	mov    -0x20(%rbp),%edx
  8004200eb6:	ee                   	out    %al,(%dx)
}
  8004200eb7:	c9                   	leaveq 
  8004200eb8:	c3                   	retq   

0000008004200eb9 <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
  8004200eb9:	55                   	push   %rbp
  8004200eba:	48 89 e5             	mov    %rsp,%rbp
  8004200ebd:	48 83 ec 30          	sub    $0x30,%rsp
  8004200ec1:	c7 45 f0 64 00 00 00 	movl   $0x64,-0x10(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200ec8:	8b 45 f0             	mov    -0x10(%rbp),%eax
  8004200ecb:	89 c2                	mov    %eax,%edx
  8004200ecd:	ec                   	in     (%dx),%al
  8004200ece:	88 45 ef             	mov    %al,-0x11(%rbp)
	return data;
  8004200ed1:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
	int c;
	uint8_t data;
	static uint32_t shift;
	int r;
	if ((inb(KBSTATP) & KBS_DIB) == 0)
  8004200ed5:	0f b6 c0             	movzbl %al,%eax
  8004200ed8:	83 e0 01             	and    $0x1,%eax
  8004200edb:	85 c0                	test   %eax,%eax
  8004200edd:	75 0a                	jne    8004200ee9 <kbd_proc_data+0x30>
		return -1;
  8004200edf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004200ee4:	e9 28 02 00 00       	jmpq   8004201111 <kbd_proc_data+0x258>
  8004200ee9:	c7 45 e8 60 00 00 00 	movl   $0x60,-0x18(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200ef0:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004200ef3:	89 c2                	mov    %eax,%edx
  8004200ef5:	ec                   	in     (%dx),%al
  8004200ef6:	88 45 e7             	mov    %al,-0x19(%rbp)
	return data;
  8004200ef9:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax

	data = inb(KBDATAP);
  8004200efd:	88 45 fb             	mov    %al,-0x5(%rbp)

	if (data == 0xE0) {
  8004200f00:	80 7d fb e0          	cmpb   $0xe0,-0x5(%rbp)
  8004200f04:	75 27                	jne    8004200f2d <kbd_proc_data+0x74>
		// E0 escape character
		shift |= E0ESC;
  8004200f06:	48 b8 28 d2 49 04 80 	movabs $0x800449d228,%rax
  8004200f0d:	00 00 00 
  8004200f10:	8b 00                	mov    (%rax),%eax
  8004200f12:	83 c8 40             	or     $0x40,%eax
  8004200f15:	89 c2                	mov    %eax,%edx
  8004200f17:	48 b8 28 d2 49 04 80 	movabs $0x800449d228,%rax
  8004200f1e:	00 00 00 
  8004200f21:	89 10                	mov    %edx,(%rax)
		return 0;
  8004200f23:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200f28:	e9 e4 01 00 00       	jmpq   8004201111 <kbd_proc_data+0x258>
	} else if (data & 0x80) {
  8004200f2d:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200f31:	84 c0                	test   %al,%al
  8004200f33:	79 65                	jns    8004200f9a <kbd_proc_data+0xe1>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
  8004200f35:	48 b8 28 d2 49 04 80 	movabs $0x800449d228,%rax
  8004200f3c:	00 00 00 
  8004200f3f:	8b 00                	mov    (%rax),%eax
  8004200f41:	83 e0 40             	and    $0x40,%eax
  8004200f44:	85 c0                	test   %eax,%eax
  8004200f46:	75 09                	jne    8004200f51 <kbd_proc_data+0x98>
  8004200f48:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200f4c:	83 e0 7f             	and    $0x7f,%eax
  8004200f4f:	eb 04                	jmp    8004200f55 <kbd_proc_data+0x9c>
  8004200f51:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200f55:	88 45 fb             	mov    %al,-0x5(%rbp)
		shift &= ~(shiftcode[data] | E0ESC);
  8004200f58:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200f5c:	48 ba 60 c0 22 04 80 	movabs $0x800422c060,%rdx
  8004200f63:	00 00 00 
  8004200f66:	48 98                	cltq   
  8004200f68:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200f6c:	83 c8 40             	or     $0x40,%eax
  8004200f6f:	0f b6 c0             	movzbl %al,%eax
  8004200f72:	f7 d0                	not    %eax
  8004200f74:	89 c2                	mov    %eax,%edx
  8004200f76:	48 b8 28 d2 49 04 80 	movabs $0x800449d228,%rax
  8004200f7d:	00 00 00 
  8004200f80:	8b 00                	mov    (%rax),%eax
  8004200f82:	21 c2                	and    %eax,%edx
  8004200f84:	48 b8 28 d2 49 04 80 	movabs $0x800449d228,%rax
  8004200f8b:	00 00 00 
  8004200f8e:	89 10                	mov    %edx,(%rax)
		return 0;
  8004200f90:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200f95:	e9 77 01 00 00       	jmpq   8004201111 <kbd_proc_data+0x258>
	} else if (shift & E0ESC) {
  8004200f9a:	48 b8 28 d2 49 04 80 	movabs $0x800449d228,%rax
  8004200fa1:	00 00 00 
  8004200fa4:	8b 00                	mov    (%rax),%eax
  8004200fa6:	83 e0 40             	and    $0x40,%eax
  8004200fa9:	85 c0                	test   %eax,%eax
  8004200fab:	74 21                	je     8004200fce <kbd_proc_data+0x115>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
  8004200fad:	80 4d fb 80          	orb    $0x80,-0x5(%rbp)
		shift &= ~E0ESC;
  8004200fb1:	48 b8 28 d2 49 04 80 	movabs $0x800449d228,%rax
  8004200fb8:	00 00 00 
  8004200fbb:	8b 00                	mov    (%rax),%eax
  8004200fbd:	83 e0 bf             	and    $0xffffffbf,%eax
  8004200fc0:	89 c2                	mov    %eax,%edx
  8004200fc2:	48 b8 28 d2 49 04 80 	movabs $0x800449d228,%rax
  8004200fc9:	00 00 00 
  8004200fcc:	89 10                	mov    %edx,(%rax)
	}

	shift |= shiftcode[data];
  8004200fce:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200fd2:	48 ba 60 c0 22 04 80 	movabs $0x800422c060,%rdx
  8004200fd9:	00 00 00 
  8004200fdc:	48 98                	cltq   
  8004200fde:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200fe2:	0f b6 d0             	movzbl %al,%edx
  8004200fe5:	48 b8 28 d2 49 04 80 	movabs $0x800449d228,%rax
  8004200fec:	00 00 00 
  8004200fef:	8b 00                	mov    (%rax),%eax
  8004200ff1:	09 c2                	or     %eax,%edx
  8004200ff3:	48 b8 28 d2 49 04 80 	movabs $0x800449d228,%rax
  8004200ffa:	00 00 00 
  8004200ffd:	89 10                	mov    %edx,(%rax)
	shift ^= togglecode[data];
  8004200fff:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004201003:	48 ba 60 c1 22 04 80 	movabs $0x800422c160,%rdx
  800420100a:	00 00 00 
  800420100d:	48 98                	cltq   
  800420100f:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004201013:	0f b6 d0             	movzbl %al,%edx
  8004201016:	48 b8 28 d2 49 04 80 	movabs $0x800449d228,%rax
  800420101d:	00 00 00 
  8004201020:	8b 00                	mov    (%rax),%eax
  8004201022:	31 c2                	xor    %eax,%edx
  8004201024:	48 b8 28 d2 49 04 80 	movabs $0x800449d228,%rax
  800420102b:	00 00 00 
  800420102e:	89 10                	mov    %edx,(%rax)

	c = charcode[shift & (CTL | SHIFT)][data];
  8004201030:	48 b8 28 d2 49 04 80 	movabs $0x800449d228,%rax
  8004201037:	00 00 00 
  800420103a:	8b 00                	mov    (%rax),%eax
  800420103c:	83 e0 03             	and    $0x3,%eax
  800420103f:	89 c2                	mov    %eax,%edx
  8004201041:	48 b8 60 c5 22 04 80 	movabs $0x800422c560,%rax
  8004201048:	00 00 00 
  800420104b:	89 d2                	mov    %edx,%edx
  800420104d:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  8004201051:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004201055:	48 01 d0             	add    %rdx,%rax
  8004201058:	0f b6 00             	movzbl (%rax),%eax
  800420105b:	0f b6 c0             	movzbl %al,%eax
  800420105e:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (shift & CAPSLOCK) {
  8004201061:	48 b8 28 d2 49 04 80 	movabs $0x800449d228,%rax
  8004201068:	00 00 00 
  800420106b:	8b 00                	mov    (%rax),%eax
  800420106d:	83 e0 08             	and    $0x8,%eax
  8004201070:	85 c0                	test   %eax,%eax
  8004201072:	74 22                	je     8004201096 <kbd_proc_data+0x1dd>
		if ('a' <= c && c <= 'z')
  8004201074:	83 7d fc 60          	cmpl   $0x60,-0x4(%rbp)
  8004201078:	7e 0c                	jle    8004201086 <kbd_proc_data+0x1cd>
  800420107a:	83 7d fc 7a          	cmpl   $0x7a,-0x4(%rbp)
  800420107e:	7f 06                	jg     8004201086 <kbd_proc_data+0x1cd>
			c += 'A' - 'a';
  8004201080:	83 6d fc 20          	subl   $0x20,-0x4(%rbp)
  8004201084:	eb 10                	jmp    8004201096 <kbd_proc_data+0x1dd>
		else if ('A' <= c && c <= 'Z')
  8004201086:	83 7d fc 40          	cmpl   $0x40,-0x4(%rbp)
  800420108a:	7e 0a                	jle    8004201096 <kbd_proc_data+0x1dd>
  800420108c:	83 7d fc 5a          	cmpl   $0x5a,-0x4(%rbp)
  8004201090:	7f 04                	jg     8004201096 <kbd_proc_data+0x1dd>
			c += 'a' - 'A';
  8004201092:	83 45 fc 20          	addl   $0x20,-0x4(%rbp)
	}

	// Process special keys

	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
  8004201096:	48 b8 28 d2 49 04 80 	movabs $0x800449d228,%rax
  800420109d:	00 00 00 
  80042010a0:	8b 00                	mov    (%rax),%eax
  80042010a2:	f7 d0                	not    %eax
  80042010a4:	83 e0 06             	and    $0x6,%eax
  80042010a7:	85 c0                	test   %eax,%eax
  80042010a9:	75 37                	jne    80042010e2 <kbd_proc_data+0x229>
  80042010ab:	81 7d fc e9 00 00 00 	cmpl   $0xe9,-0x4(%rbp)
  80042010b2:	75 2e                	jne    80042010e2 <kbd_proc_data+0x229>
		cprintf("Rebooting!\n");
  80042010b4:	48 bf de 8d 21 04 80 	movabs $0x8004218dde,%rdi
  80042010bb:	00 00 00 
  80042010be:	b8 00 00 00 00       	mov    $0x0,%eax
  80042010c3:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  80042010ca:	00 00 00 
  80042010cd:	ff d2                	callq  *%rdx
  80042010cf:	c7 45 e0 92 00 00 00 	movl   $0x92,-0x20(%rbp)
  80042010d6:	c6 45 df 03          	movb   $0x3,-0x21(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042010da:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  80042010de:	8b 55 e0             	mov    -0x20(%rbp),%edx
  80042010e1:	ee                   	out    %al,(%dx)
		outb(0x92, 0x3); // courtesy of Chris Frost
	}

#ifdef VMM_GUEST
	if (c == 0x1b) {
  80042010e2:	83 7d fc 1b          	cmpl   $0x1b,-0x4(%rbp)
  80042010e6:	75 26                	jne    800420110e <kbd_proc_data+0x255>
		cprintf("ESC pressed\n");
  80042010e8:	48 bf ea 8d 21 04 80 	movabs $0x8004218dea,%rdi
  80042010ef:	00 00 00 
  80042010f2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042010f7:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  80042010fe:	00 00 00 
  8004201101:	ff d2                	callq  *%rdx
		asm("vmcall":"=a"(r): "0"(VMX_VMCALL_BACKTOHOST));
  8004201103:	b8 05 00 00 00       	mov    $0x5,%eax
  8004201108:	0f 01 c1             	vmcall 
  800420110b:	89 45 f4             	mov    %eax,-0xc(%rbp)
	}
#endif

	return c;
  800420110e:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004201111:	c9                   	leaveq 
  8004201112:	c3                   	retq   

0000008004201113 <kbd_intr>:

void
kbd_intr(void)
{
  8004201113:	55                   	push   %rbp
  8004201114:	48 89 e5             	mov    %rsp,%rbp
	cons_intr(kbd_proc_data);
  8004201117:	48 bf b9 0e 20 04 80 	movabs $0x8004200eb9,%rdi
  800420111e:	00 00 00 
  8004201121:	48 b8 64 11 20 04 80 	movabs $0x8004201164,%rax
  8004201128:	00 00 00 
  800420112b:	ff d0                	callq  *%rax
}
  800420112d:	5d                   	pop    %rbp
  800420112e:	c3                   	retq   

000000800420112f <kbd_init>:

static void
kbd_init(void)
{
  800420112f:	55                   	push   %rbp
  8004201130:	48 89 e5             	mov    %rsp,%rbp

	// Drain the kbd buffer so that Bochs generates interrupts.
	kbd_intr();
  8004201133:	48 b8 13 11 20 04 80 	movabs $0x8004201113,%rax
  800420113a:	00 00 00 
  800420113d:	ff d0                	callq  *%rax
	irq_setmask_8259A(irq_mask_8259A & ~(1<<1));
  800420113f:	48 b8 72 c6 22 04 80 	movabs $0x800422c672,%rax
  8004201146:	00 00 00 
  8004201149:	0f b7 00             	movzwl (%rax),%eax
  800420114c:	0f b7 c0             	movzwl %ax,%eax
  800420114f:	25 fd ff 00 00       	and    $0xfffd,%eax
  8004201154:	89 c7                	mov    %eax,%edi
  8004201156:	48 b8 e2 93 20 04 80 	movabs $0x80042093e2,%rax
  800420115d:	00 00 00 
  8004201160:	ff d0                	callq  *%rax

}
  8004201162:	5d                   	pop    %rbp
  8004201163:	c3                   	retq   

0000008004201164 <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
static void
cons_intr(int (*proc)(void))
{
  8004201164:	55                   	push   %rbp
  8004201165:	48 89 e5             	mov    %rsp,%rbp
  8004201168:	48 83 ec 20          	sub    $0x20,%rsp
  800420116c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int c;

	while ((c = (*proc)()) != -1) {
  8004201170:	eb 6a                	jmp    80042011dc <cons_intr+0x78>
		if (c == 0)
  8004201172:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004201176:	75 02                	jne    800420117a <cons_intr+0x16>
			continue;
  8004201178:	eb 62                	jmp    80042011dc <cons_intr+0x78>
		cons.buf[cons.wpos++] = c;
  800420117a:	48 b8 20 d0 49 04 80 	movabs $0x800449d020,%rax
  8004201181:	00 00 00 
  8004201184:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  800420118a:	8d 48 01             	lea    0x1(%rax),%ecx
  800420118d:	48 ba 20 d0 49 04 80 	movabs $0x800449d020,%rdx
  8004201194:	00 00 00 
  8004201197:	89 8a 04 02 00 00    	mov    %ecx,0x204(%rdx)
  800420119d:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042011a0:	89 d1                	mov    %edx,%ecx
  80042011a2:	48 ba 20 d0 49 04 80 	movabs $0x800449d020,%rdx
  80042011a9:	00 00 00 
  80042011ac:	89 c0                	mov    %eax,%eax
  80042011ae:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
		if (cons.wpos == CONSBUFSIZE)
  80042011b1:	48 b8 20 d0 49 04 80 	movabs $0x800449d020,%rax
  80042011b8:	00 00 00 
  80042011bb:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  80042011c1:	3d 00 02 00 00       	cmp    $0x200,%eax
  80042011c6:	75 14                	jne    80042011dc <cons_intr+0x78>
			cons.wpos = 0;
  80042011c8:	48 b8 20 d0 49 04 80 	movabs $0x800449d020,%rax
  80042011cf:	00 00 00 
  80042011d2:	c7 80 04 02 00 00 00 	movl   $0x0,0x204(%rax)
  80042011d9:	00 00 00 
static void
cons_intr(int (*proc)(void))
{
	int c;

	while ((c = (*proc)()) != -1) {
  80042011dc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042011e0:	ff d0                	callq  *%rax
  80042011e2:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80042011e5:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  80042011e9:	75 87                	jne    8004201172 <cons_intr+0xe>
			continue;
		cons.buf[cons.wpos++] = c;
		if (cons.wpos == CONSBUFSIZE)
			cons.wpos = 0;
	}
}
  80042011eb:	c9                   	leaveq 
  80042011ec:	c3                   	retq   

00000080042011ed <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
  80042011ed:	55                   	push   %rbp
  80042011ee:	48 89 e5             	mov    %rsp,%rbp
  80042011f1:	48 83 ec 10          	sub    $0x10,%rsp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
  80042011f5:	48 b8 98 08 20 04 80 	movabs $0x8004200898,%rax
  80042011fc:	00 00 00 
  80042011ff:	ff d0                	callq  *%rax
	kbd_intr();
  8004201201:	48 b8 13 11 20 04 80 	movabs $0x8004201113,%rax
  8004201208:	00 00 00 
  800420120b:	ff d0                	callq  *%rax

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
  800420120d:	48 b8 20 d0 49 04 80 	movabs $0x800449d020,%rax
  8004201214:	00 00 00 
  8004201217:	8b 90 00 02 00 00    	mov    0x200(%rax),%edx
  800420121d:	48 b8 20 d0 49 04 80 	movabs $0x800449d020,%rax
  8004201224:	00 00 00 
  8004201227:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  800420122d:	39 c2                	cmp    %eax,%edx
  800420122f:	74 69                	je     800420129a <cons_getc+0xad>
		c = cons.buf[cons.rpos++];
  8004201231:	48 b8 20 d0 49 04 80 	movabs $0x800449d020,%rax
  8004201238:	00 00 00 
  800420123b:	8b 80 00 02 00 00    	mov    0x200(%rax),%eax
  8004201241:	8d 48 01             	lea    0x1(%rax),%ecx
  8004201244:	48 ba 20 d0 49 04 80 	movabs $0x800449d020,%rdx
  800420124b:	00 00 00 
  800420124e:	89 8a 00 02 00 00    	mov    %ecx,0x200(%rdx)
  8004201254:	48 ba 20 d0 49 04 80 	movabs $0x800449d020,%rdx
  800420125b:	00 00 00 
  800420125e:	89 c0                	mov    %eax,%eax
  8004201260:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004201264:	0f b6 c0             	movzbl %al,%eax
  8004201267:	89 45 fc             	mov    %eax,-0x4(%rbp)
		if (cons.rpos == CONSBUFSIZE)
  800420126a:	48 b8 20 d0 49 04 80 	movabs $0x800449d020,%rax
  8004201271:	00 00 00 
  8004201274:	8b 80 00 02 00 00    	mov    0x200(%rax),%eax
  800420127a:	3d 00 02 00 00       	cmp    $0x200,%eax
  800420127f:	75 14                	jne    8004201295 <cons_getc+0xa8>
			cons.rpos = 0;
  8004201281:	48 b8 20 d0 49 04 80 	movabs $0x800449d020,%rax
  8004201288:	00 00 00 
  800420128b:	c7 80 00 02 00 00 00 	movl   $0x0,0x200(%rax)
  8004201292:	00 00 00 
		return c;
  8004201295:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201298:	eb 05                	jmp    800420129f <cons_getc+0xb2>
	}
	return 0;
  800420129a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420129f:	c9                   	leaveq 
  80042012a0:	c3                   	retq   

00000080042012a1 <cons_putc>:

// output a character to the console
static void
cons_putc(int c)
{
  80042012a1:	55                   	push   %rbp
  80042012a2:	48 89 e5             	mov    %rsp,%rbp
  80042012a5:	48 83 ec 10          	sub    $0x10,%rsp
  80042012a9:	89 7d fc             	mov    %edi,-0x4(%rbp)
	serial_putc(c);
  80042012ac:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042012af:	89 c7                	mov    %eax,%edi
  80042012b1:	48 b8 c5 08 20 04 80 	movabs $0x80042008c5,%rax
  80042012b8:	00 00 00 
  80042012bb:	ff d0                	callq  *%rax
	lpt_putc(c);
  80042012bd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042012c0:	89 c7                	mov    %eax,%edi
  80042012c2:	48 b8 32 0a 20 04 80 	movabs $0x8004200a32,%rax
  80042012c9:	00 00 00 
  80042012cc:	ff d0                	callq  *%rax
	cga_putc(c);
  80042012ce:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042012d1:	89 c7                	mov    %eax,%edi
  80042012d3:	48 b8 d1 0b 20 04 80 	movabs $0x8004200bd1,%rax
  80042012da:	00 00 00 
  80042012dd:	ff d0                	callq  *%rax
}
  80042012df:	c9                   	leaveq 
  80042012e0:	c3                   	retq   

00000080042012e1 <cons_init>:

// initialize the console devices
void
cons_init(void)
{
  80042012e1:	55                   	push   %rbp
  80042012e2:	48 89 e5             	mov    %rsp,%rbp
	cga_init();
  80042012e5:	48 b8 b7 0a 20 04 80 	movabs $0x8004200ab7,%rax
  80042012ec:	00 00 00 
  80042012ef:	ff d0                	callq  *%rax
	kbd_init();
  80042012f1:	48 b8 2f 11 20 04 80 	movabs $0x800420112f,%rax
  80042012f8:	00 00 00 
  80042012fb:	ff d0                	callq  *%rax
	serial_init();
  80042012fd:	48 b8 2a 09 20 04 80 	movabs $0x800420092a,%rax
  8004201304:	00 00 00 
  8004201307:	ff d0                	callq  *%rax

	if (!serial_exists)
  8004201309:	48 b8 00 d0 49 04 80 	movabs $0x800449d000,%rax
  8004201310:	00 00 00 
  8004201313:	0f b6 00             	movzbl (%rax),%eax
  8004201316:	83 f0 01             	xor    $0x1,%eax
  8004201319:	84 c0                	test   %al,%al
  800420131b:	74 1b                	je     8004201338 <cons_init+0x57>
		cprintf("Serial port does not exist!\n");
  800420131d:	48 bf f7 8d 21 04 80 	movabs $0x8004218df7,%rdi
  8004201324:	00 00 00 
  8004201327:	b8 00 00 00 00       	mov    $0x0,%eax
  800420132c:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  8004201333:	00 00 00 
  8004201336:	ff d2                	callq  *%rdx
}
  8004201338:	5d                   	pop    %rbp
  8004201339:	c3                   	retq   

000000800420133a <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf.

void
cputchar(int c)
{
  800420133a:	55                   	push   %rbp
  800420133b:	48 89 e5             	mov    %rsp,%rbp
  800420133e:	48 83 ec 10          	sub    $0x10,%rsp
  8004201342:	89 7d fc             	mov    %edi,-0x4(%rbp)
	cons_putc(c);
  8004201345:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201348:	89 c7                	mov    %eax,%edi
  800420134a:	48 b8 a1 12 20 04 80 	movabs $0x80042012a1,%rax
  8004201351:	00 00 00 
  8004201354:	ff d0                	callq  *%rax
}
  8004201356:	c9                   	leaveq 
  8004201357:	c3                   	retq   

0000008004201358 <getchar>:

int
getchar(void)
{
  8004201358:	55                   	push   %rbp
  8004201359:	48 89 e5             	mov    %rsp,%rbp
  800420135c:	48 83 ec 10          	sub    $0x10,%rsp
	int c;

	while ((c = cons_getc()) == 0)
  8004201360:	48 b8 ed 11 20 04 80 	movabs $0x80042011ed,%rax
  8004201367:	00 00 00 
  800420136a:	ff d0                	callq  *%rax
  800420136c:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420136f:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004201373:	74 eb                	je     8004201360 <getchar+0x8>
		/* do nothing */;
	return c;
  8004201375:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004201378:	c9                   	leaveq 
  8004201379:	c3                   	retq   

000000800420137a <iscons>:

int
iscons(int fdnum)
{
  800420137a:	55                   	push   %rbp
  800420137b:	48 89 e5             	mov    %rsp,%rbp
  800420137e:	48 83 ec 04          	sub    $0x4,%rsp
  8004201382:	89 7d fc             	mov    %edi,-0x4(%rbp)
	// used by readline
	return 1;
  8004201385:	b8 01 00 00 00       	mov    $0x1,%eax
}
  800420138a:	c9                   	leaveq 
  800420138b:	c3                   	retq   

000000800420138c <mon_help>:

/***** Implementations of basic kernel monitor commands *****/

int
mon_help(int argc, char **argv, struct Trapframe *tf)
{
  800420138c:	55                   	push   %rbp
  800420138d:	48 89 e5             	mov    %rsp,%rbp
  8004201390:	48 83 ec 30          	sub    $0x30,%rsp
  8004201394:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004201397:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420139b:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int i;

	for (i = 0; i < NCOMMANDS; i++)
  800420139f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042013a6:	eb 6c                	jmp    8004201414 <mon_help+0x88>
		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
  80042013a8:	48 b9 80 c5 22 04 80 	movabs $0x800422c580,%rcx
  80042013af:	00 00 00 
  80042013b2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042013b5:	48 63 d0             	movslq %eax,%rdx
  80042013b8:	48 89 d0             	mov    %rdx,%rax
  80042013bb:	48 01 c0             	add    %rax,%rax
  80042013be:	48 01 d0             	add    %rdx,%rax
  80042013c1:	48 c1 e0 03          	shl    $0x3,%rax
  80042013c5:	48 01 c8             	add    %rcx,%rax
  80042013c8:	48 8b 48 08          	mov    0x8(%rax),%rcx
  80042013cc:	48 be 80 c5 22 04 80 	movabs $0x800422c580,%rsi
  80042013d3:	00 00 00 
  80042013d6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042013d9:	48 63 d0             	movslq %eax,%rdx
  80042013dc:	48 89 d0             	mov    %rdx,%rax
  80042013df:	48 01 c0             	add    %rax,%rax
  80042013e2:	48 01 d0             	add    %rdx,%rax
  80042013e5:	48 c1 e0 03          	shl    $0x3,%rax
  80042013e9:	48 01 f0             	add    %rsi,%rax
  80042013ec:	48 8b 00             	mov    (%rax),%rax
  80042013ef:	48 89 ca             	mov    %rcx,%rdx
  80042013f2:	48 89 c6             	mov    %rax,%rsi
  80042013f5:	48 bf a5 8e 21 04 80 	movabs $0x8004218ea5,%rdi
  80042013fc:	00 00 00 
  80042013ff:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201404:	48 b9 90 95 20 04 80 	movabs $0x8004209590,%rcx
  800420140b:	00 00 00 
  800420140e:	ff d1                	callq  *%rcx
int
mon_help(int argc, char **argv, struct Trapframe *tf)
{
	int i;

	for (i = 0; i < NCOMMANDS; i++)
  8004201410:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004201414:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201417:	83 f8 03             	cmp    $0x3,%eax
  800420141a:	76 8c                	jbe    80042013a8 <mon_help+0x1c>
		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
	return 0;
  800420141c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201421:	c9                   	leaveq 
  8004201422:	c3                   	retq   

0000008004201423 <mon_kerninfo>:

int
mon_kerninfo(int argc, char **argv, struct Trapframe *tf)
{
  8004201423:	55                   	push   %rbp
  8004201424:	48 89 e5             	mov    %rsp,%rbp
  8004201427:	48 83 ec 30          	sub    $0x30,%rsp
  800420142b:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420142e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004201432:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	extern char _start[], entry[], etext[], edata[], end[];

	cprintf("Special kernel symbols:\n");
  8004201436:	48 bf ae 8e 21 04 80 	movabs $0x8004218eae,%rdi
  800420143d:	00 00 00 
  8004201440:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201445:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  800420144c:	00 00 00 
  800420144f:	ff d2                	callq  *%rdx
	cprintf("  _start                  %08x (phys)\n", _start);
  8004201451:	48 be 0c 00 20 00 00 	movabs $0x20000c,%rsi
  8004201458:	00 00 00 
  800420145b:	48 bf c8 8e 21 04 80 	movabs $0x8004218ec8,%rdi
  8004201462:	00 00 00 
  8004201465:	b8 00 00 00 00       	mov    $0x0,%eax
  800420146a:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  8004201471:	00 00 00 
  8004201474:	ff d2                	callq  *%rdx
	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
  8004201476:	48 ba 0c 00 20 00 00 	movabs $0x20000c,%rdx
  800420147d:	00 00 00 
  8004201480:	48 be 0c 00 20 04 80 	movabs $0x800420000c,%rsi
  8004201487:	00 00 00 
  800420148a:	48 bf f0 8e 21 04 80 	movabs $0x8004218ef0,%rdi
  8004201491:	00 00 00 
  8004201494:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201499:	48 b9 90 95 20 04 80 	movabs $0x8004209590,%rcx
  80042014a0:	00 00 00 
  80042014a3:	ff d1                	callq  *%rcx
	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
  80042014a5:	48 ba 9b 8c 21 00 00 	movabs $0x218c9b,%rdx
  80042014ac:	00 00 00 
  80042014af:	48 be 9b 8c 21 04 80 	movabs $0x8004218c9b,%rsi
  80042014b6:	00 00 00 
  80042014b9:	48 bf 18 8f 21 04 80 	movabs $0x8004218f18,%rdi
  80042014c0:	00 00 00 
  80042014c3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042014c8:	48 b9 90 95 20 04 80 	movabs $0x8004209590,%rcx
  80042014cf:	00 00 00 
  80042014d2:	ff d1                	callq  *%rcx
	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
  80042014d4:	48 ba d4 ce 49 00 00 	movabs $0x49ced4,%rdx
  80042014db:	00 00 00 
  80042014de:	48 be d4 ce 49 04 80 	movabs $0x800449ced4,%rsi
  80042014e5:	00 00 00 
  80042014e8:	48 bf 40 8f 21 04 80 	movabs $0x8004218f40,%rdi
  80042014ef:	00 00 00 
  80042014f2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042014f7:	48 b9 90 95 20 04 80 	movabs $0x8004209590,%rcx
  80042014fe:	00 00 00 
  8004201501:	ff d1                	callq  *%rcx
	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
  8004201503:	48 ba 10 f0 6d 00 00 	movabs $0x6df010,%rdx
  800420150a:	00 00 00 
  800420150d:	48 be 10 f0 6d 04 80 	movabs $0x80046df010,%rsi
  8004201514:	00 00 00 
  8004201517:	48 bf 68 8f 21 04 80 	movabs $0x8004218f68,%rdi
  800420151e:	00 00 00 
  8004201521:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201526:	48 b9 90 95 20 04 80 	movabs $0x8004209590,%rcx
  800420152d:	00 00 00 
  8004201530:	ff d1                	callq  *%rcx
	cprintf("Kernel executable memory footprint: %dKB\n",
		ROUNDUP(end - entry, 1024) / 1024);
  8004201532:	48 c7 45 f8 00 04 00 	movq   $0x400,-0x8(%rbp)
  8004201539:	00 
  800420153a:	48 b8 0c 00 20 04 80 	movabs $0x800420000c,%rax
  8004201541:	00 00 00 
  8004201544:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004201548:	48 29 c2             	sub    %rax,%rdx
  800420154b:	48 b8 10 f0 6d 04 80 	movabs $0x80046df010,%rax
  8004201552:	00 00 00 
  8004201555:	48 83 e8 01          	sub    $0x1,%rax
  8004201559:	48 01 d0             	add    %rdx,%rax
  800420155c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004201560:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004201564:	ba 00 00 00 00       	mov    $0x0,%edx
  8004201569:	48 f7 75 f8          	divq   -0x8(%rbp)
  800420156d:	48 89 d0             	mov    %rdx,%rax
  8004201570:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004201574:	48 29 c2             	sub    %rax,%rdx
  8004201577:	48 89 d0             	mov    %rdx,%rax
	cprintf("  _start                  %08x (phys)\n", _start);
	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
	cprintf("Kernel executable memory footprint: %dKB\n",
  800420157a:	48 8d 90 ff 03 00 00 	lea    0x3ff(%rax),%rdx
  8004201581:	48 85 c0             	test   %rax,%rax
  8004201584:	48 0f 48 c2          	cmovs  %rdx,%rax
  8004201588:	48 c1 f8 0a          	sar    $0xa,%rax
  800420158c:	48 89 c6             	mov    %rax,%rsi
  800420158f:	48 bf 90 8f 21 04 80 	movabs $0x8004218f90,%rdi
  8004201596:	00 00 00 
  8004201599:	b8 00 00 00 00       	mov    $0x0,%eax
  800420159e:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  80042015a5:	00 00 00 
  80042015a8:	ff d2                	callq  *%rdx
		ROUNDUP(end - entry, 1024) / 1024);
	return 0;
  80042015aa:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042015af:	c9                   	leaveq 
  80042015b0:	c3                   	retq   

00000080042015b1 <mon_backtrace>:

int
mon_backtrace(int argc, char **argv, struct Trapframe *tf)
{
  80042015b1:	55                   	push   %rbp
  80042015b2:	48 89 e5             	mov    %rsp,%rbp
  80042015b5:	48 81 ec 50 05 00 00 	sub    $0x550,%rsp
  80042015bc:	89 bd cc fa ff ff    	mov    %edi,-0x534(%rbp)
  80042015c2:	48 89 b5 c0 fa ff ff 	mov    %rsi,-0x540(%rbp)
  80042015c9:	48 89 95 b8 fa ff ff 	mov    %rdx,-0x548(%rbp)

static __inline uint64_t
read_rbp(void)
{
	uint64_t rbp;
	__asm __volatile("movq %%rbp,%0" : "=r" (rbp)::"cc","memory");
  80042015d0:	48 89 e8             	mov    %rbp,%rax
  80042015d3:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	return rbp;
  80042015d7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
	uint64_t rip;
	uint64_t rsp;
	uint64_t offset;
	struct Ripdebuginfo info;

	rbp = (const uint64_t*)read_rbp();
  80042015db:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

static __inline uint64_t
read_rsp(void)
{
	uint64_t esp;
	__asm __volatile("movq %%rsp,%0" : "=r" (esp));
  80042015df:	48 89 e0             	mov    %rsp,%rax
  80042015e2:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	return esp;
  80042015e6:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
	rsp = read_rsp();
  80042015ea:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	if (tf) {
  80042015ee:	48 83 bd b8 fa ff ff 	cmpq   $0x0,-0x548(%rbp)
  80042015f5:	00 
  80042015f6:	74 21                	je     8004201619 <mon_backtrace+0x68>
		rbp = (const uint64_t*)tf->tf_regs.reg_rbp;
  80042015f8:	48 8b 85 b8 fa ff ff 	mov    -0x548(%rbp),%rax
  80042015ff:	48 8b 40 50          	mov    0x50(%rax),%rax
  8004201603:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		rsp = tf->tf_rsp;
  8004201607:	48 8b 85 b8 fa ff ff 	mov    -0x548(%rbp),%rax
  800420160e:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  8004201615:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	}

	read_rip(rip);
  8004201619:	48 8d 05 00 00 00 00 	lea    0x0(%rip),%rax        # 8004201620 <mon_backtrace+0x6f>
  8004201620:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	cprintf("Stack backtrace:\n");
  8004201624:	48 bf ba 8f 21 04 80 	movabs $0x8004218fba,%rdi
  800420162b:	00 00 00 
  800420162e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201633:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  800420163a:	00 00 00 
  800420163d:	ff d2                	callq  *%rdx
	while (rbp) {
  800420163f:	e9 17 03 00 00       	jmpq   800420195b <mon_backtrace+0x3aa>
		// print this stack frame
		cprintf("  rbp %016llx  rip %016llx\n", rbp, rip);
  8004201644:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004201648:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420164c:	48 89 c6             	mov    %rax,%rsi
  800420164f:	48 bf cc 8f 21 04 80 	movabs $0x8004218fcc,%rdi
  8004201656:	00 00 00 
  8004201659:	b8 00 00 00 00       	mov    $0x0,%eax
  800420165e:	48 b9 90 95 20 04 80 	movabs $0x8004209590,%rcx
  8004201665:	00 00 00 
  8004201668:	ff d1                	callq  *%rcx
		if (debuginfo_rip(rip, &info) >= 0){
  800420166a:	48 8d 95 d0 fa ff ff 	lea    -0x530(%rbp),%rdx
  8004201671:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201675:	48 89 d6             	mov    %rdx,%rsi
  8004201678:	48 89 c7             	mov    %rax,%rdi
  800420167b:	48 b8 40 f0 20 04 80 	movabs $0x800420f040,%rax
  8004201682:	00 00 00 
  8004201685:	ff d0                	callq  *%rax
  8004201687:	85 c0                	test   %eax,%eax
  8004201689:	0f 88 9a 02 00 00    	js     8004201929 <mon_backtrace+0x378>
			Dwarf_Regtable_Entry *cfa_rule = &info.reg_table.cfa_rule;
  800420168f:	48 8d 85 d0 fa ff ff 	lea    -0x530(%rbp),%rax
  8004201696:	48 05 a8 00 00 00    	add    $0xa8,%rax
  800420169c:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			uint64_t cfa;

			cprintf("       %s:%d: %.*s+%016llx", info.rip_file, info.rip_line, 
				info.rip_fn_namelen, info.rip_fn_name, rip - info.rip_fn_addr);
  80042016a0:	48 8b 85 f0 fa ff ff 	mov    -0x510(%rbp),%rax
		cprintf("  rbp %016llx  rip %016llx\n", rbp, rip);
		if (debuginfo_rip(rip, &info) >= 0){
			Dwarf_Regtable_Entry *cfa_rule = &info.reg_table.cfa_rule;
			uint64_t cfa;

			cprintf("       %s:%d: %.*s+%016llx", info.rip_file, info.rip_line, 
  80042016a7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042016ab:	48 89 d7             	mov    %rdx,%rdi
  80042016ae:	48 29 c7             	sub    %rax,%rdi
  80042016b1:	48 8b b5 e0 fa ff ff 	mov    -0x520(%rbp),%rsi
  80042016b8:	8b 8d e8 fa ff ff    	mov    -0x518(%rbp),%ecx
  80042016be:	8b 95 d8 fa ff ff    	mov    -0x528(%rbp),%edx
  80042016c4:	48 8b 85 d0 fa ff ff 	mov    -0x530(%rbp),%rax
  80042016cb:	49 89 f9             	mov    %rdi,%r9
  80042016ce:	49 89 f0             	mov    %rsi,%r8
  80042016d1:	48 89 c6             	mov    %rax,%rsi
  80042016d4:	48 bf e8 8f 21 04 80 	movabs $0x8004218fe8,%rdi
  80042016db:	00 00 00 
  80042016de:	b8 00 00 00 00       	mov    $0x0,%eax
  80042016e3:	49 ba 90 95 20 04 80 	movabs $0x8004209590,%r10
  80042016ea:	00 00 00 
  80042016ed:	41 ff d2             	callq  *%r10
				info.rip_fn_namelen, info.rip_fn_name, rip - info.rip_fn_addr);

			if (cfa_rule->dw_regnum == 6) { /* 6: rbp */
  80042016f0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042016f4:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  80042016f8:	66 83 f8 06          	cmp    $0x6,%ax
  80042016fc:	75 15                	jne    8004201713 <mon_backtrace+0x162>
				cfa = (uint64_t)rbp + cfa_rule->dw_offset;
  80042016fe:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201702:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004201706:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420170a:	48 01 d0             	add    %rdx,%rax
  800420170d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004201711:	eb 28                	jmp    800420173b <mon_backtrace+0x18a>
			} else if (cfa_rule->dw_regnum == 7) { /* 7: rsp */
  8004201713:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201717:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  800420171b:	66 83 f8 07          	cmp    $0x7,%ax
  800420171f:	75 15                	jne    8004201736 <mon_backtrace+0x185>
				cfa = rsp + cfa_rule->dw_offset;
  8004201721:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201725:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004201729:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420172d:	48 01 d0             	add    %rdx,%rax
  8004201730:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004201734:	eb 05                	jmp    800420173b <mon_backtrace+0x18a>
			} else {
				goto unknown_cfa;
  8004201736:	e9 ee 01 00 00       	jmpq   8004201929 <mon_backtrace+0x378>
			}

			cprintf("  args:%d ", info.rip_fn_narg);
  800420173b:	8b 85 f8 fa ff ff    	mov    -0x508(%rbp),%eax
  8004201741:	89 c6                	mov    %eax,%esi
  8004201743:	48 bf 03 90 21 04 80 	movabs $0x8004219003,%rdi
  800420174a:	00 00 00 
  800420174d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201752:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  8004201759:	00 00 00 
  800420175c:	ff d2                	callq  *%rdx
			for (i = 0; i < info.rip_fn_narg ; i++)
  800420175e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004201765:	e9 f2 00 00 00       	jmpq   800420185c <mon_backtrace+0x2ab>
			{
				uint64_t val;
				assert(info.offset_fn_arg[i]);
  800420176a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420176d:	48 98                	cltq   
  800420176f:	48 83 c0 0a          	add    $0xa,%rax
  8004201773:	48 8b 84 c5 d8 fa ff 	mov    -0x528(%rbp,%rax,8),%rax
  800420177a:	ff 
  800420177b:	48 85 c0             	test   %rax,%rax
  800420177e:	75 35                	jne    80042017b5 <mon_backtrace+0x204>
  8004201780:	48 b9 0e 90 21 04 80 	movabs $0x800421900e,%rcx
  8004201787:	00 00 00 
  800420178a:	48 ba 24 90 21 04 80 	movabs $0x8004219024,%rdx
  8004201791:	00 00 00 
  8004201794:	be 77 00 00 00       	mov    $0x77,%esi
  8004201799:	48 bf 39 90 21 04 80 	movabs $0x8004219039,%rdi
  80042017a0:	00 00 00 
  80042017a3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042017a8:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042017af:	00 00 00 
  80042017b2:	41 ff d0             	callq  *%r8
				offset = cfa + info.offset_fn_arg[i];
  80042017b5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042017b8:	48 98                	cltq   
  80042017ba:	48 83 c0 0a          	add    $0xa,%rax
  80042017be:	48 8b 94 c5 d8 fa ff 	mov    -0x528(%rbp,%rax,8),%rdx
  80042017c5:	ff 
  80042017c6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042017ca:	48 01 d0             	add    %rdx,%rax
  80042017cd:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
				switch(info.size_fn_arg[i]) {
  80042017d1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042017d4:	48 98                	cltq   
  80042017d6:	48 83 c0 08          	add    $0x8,%rax
  80042017da:	8b 84 85 dc fa ff ff 	mov    -0x524(%rbp,%rax,4),%eax
  80042017e1:	83 f8 02             	cmp    $0x2,%eax
  80042017e4:	74 31                	je     8004201817 <mon_backtrace+0x266>
  80042017e6:	83 f8 02             	cmp    $0x2,%eax
  80042017e9:	7f 07                	jg     80042017f2 <mon_backtrace+0x241>
  80042017eb:	83 f8 01             	cmp    $0x1,%eax
  80042017ee:	74 37                	je     8004201827 <mon_backtrace+0x276>
  80042017f0:	eb 44                	jmp    8004201836 <mon_backtrace+0x285>
  80042017f2:	83 f8 04             	cmp    $0x4,%eax
  80042017f5:	74 12                	je     8004201809 <mon_backtrace+0x258>
  80042017f7:	83 f8 08             	cmp    $0x8,%eax
  80042017fa:	75 3a                	jne    8004201836 <mon_backtrace+0x285>
					case 8:
						val = *(uint64_t *) offset;
  80042017fc:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201800:	48 8b 00             	mov    (%rax),%rax
  8004201803:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
						break;
  8004201807:	eb 2d                	jmp    8004201836 <mon_backtrace+0x285>
					case 4:
						val = *(uint32_t *) offset;
  8004201809:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420180d:	8b 00                	mov    (%rax),%eax
  800420180f:	89 c0                	mov    %eax,%eax
  8004201811:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
						break;
  8004201815:	eb 1f                	jmp    8004201836 <mon_backtrace+0x285>
					case 2:
						val = *(uint16_t *) offset;
  8004201817:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420181b:	0f b7 00             	movzwl (%rax),%eax
  800420181e:	0f b7 c0             	movzwl %ax,%eax
  8004201821:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
						break;
  8004201825:	eb 0f                	jmp    8004201836 <mon_backtrace+0x285>
					case 1:
						val = *(uint8_t *) offset;
  8004201827:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420182b:	0f b6 00             	movzbl (%rax),%eax
  800420182e:	0f b6 c0             	movzbl %al,%eax
  8004201831:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
						break;
  8004201835:	90                   	nop
				}
				cprintf(" %016x", val);
  8004201836:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420183a:	48 89 c6             	mov    %rax,%rsi
  800420183d:	48 bf 48 90 21 04 80 	movabs $0x8004219048,%rdi
  8004201844:	00 00 00 
  8004201847:	b8 00 00 00 00       	mov    $0x0,%eax
  800420184c:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  8004201853:	00 00 00 
  8004201856:	ff d2                	callq  *%rdx
			} else {
				goto unknown_cfa;
			}

			cprintf("  args:%d ", info.rip_fn_narg);
			for (i = 0; i < info.rip_fn_narg ; i++)
  8004201858:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420185c:	8b 85 f8 fa ff ff    	mov    -0x508(%rbp),%eax
  8004201862:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8004201865:	0f 8f ff fe ff ff    	jg     800420176a <mon_backtrace+0x1b9>
						break;
				}
				cprintf(" %016x", val);
			}

			switch(info.reg_table.rules[6].dw_regnum) { /* 6: rbp */
  800420186b:	0f b7 85 ea fb ff ff 	movzwl -0x416(%rbp),%eax
  8004201872:	0f b7 c0             	movzwl %ax,%eax
  8004201875:	3d 0b 04 00 00       	cmp    $0x40b,%eax
  800420187a:	74 48                	je     80042018c4 <mon_backtrace+0x313>
  800420187c:	3d 9c 05 00 00       	cmp    $0x59c,%eax
  8004201881:	75 17                	jne    800420189a <mon_backtrace+0x2e9>
				case DW_FRAME_SAME_VAL:
					break;
				case DW_FRAME_CFA_COL3:
					rbp = (const uint64_t *)*(uint64_t *)(cfa + info.reg_table.rules[6].dw_offset);
  8004201883:	48 8b 95 f0 fb ff ff 	mov    -0x410(%rbp),%rdx
  800420188a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420188e:	48 01 d0             	add    %rdx,%rax
  8004201891:	48 8b 00             	mov    (%rax),%rax
  8004201894:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
					break;
  8004201898:	eb 2b                	jmp    80042018c5 <mon_backtrace+0x314>
				default:
					panic("unknown reg rule");
  800420189a:	48 ba 4f 90 21 04 80 	movabs $0x800421904f,%rdx
  80042018a1:	00 00 00 
  80042018a4:	be 91 00 00 00       	mov    $0x91,%esi
  80042018a9:	48 bf 39 90 21 04 80 	movabs $0x8004219039,%rdi
  80042018b0:	00 00 00 
  80042018b3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042018b8:	48 b9 e4 05 20 04 80 	movabs $0x80042005e4,%rcx
  80042018bf:	00 00 00 
  80042018c2:	ff d1                	callq  *%rcx
				cprintf(" %016x", val);
			}

			switch(info.reg_table.rules[6].dw_regnum) { /* 6: rbp */
				case DW_FRAME_SAME_VAL:
					break;
  80042018c4:	90                   	nop
				default:
					panic("unknown reg rule");
					break;
			}

			switch(info.reg_table.rules[16].dw_regnum) { /* 16: rip */
  80042018c5:	0f b7 85 8a fc ff ff 	movzwl -0x376(%rbp),%eax
  80042018cc:	0f b7 c0             	movzwl %ax,%eax
  80042018cf:	3d 0b 04 00 00       	cmp    $0x40b,%eax
  80042018d4:	74 48                	je     800420191e <mon_backtrace+0x36d>
  80042018d6:	3d 9c 05 00 00       	cmp    $0x59c,%eax
  80042018db:	75 17                	jne    80042018f4 <mon_backtrace+0x343>
				case DW_FRAME_SAME_VAL:
					break;
				case DW_FRAME_CFA_COL3:
					rip = *(uint64_t *)(cfa + info.reg_table.rules[16].dw_offset);
  80042018dd:	48 8b 95 90 fc ff ff 	mov    -0x370(%rbp),%rdx
  80042018e4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042018e8:	48 01 d0             	add    %rdx,%rax
  80042018eb:	48 8b 00             	mov    (%rax),%rax
  80042018ee:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
					break;
  80042018f2:	eb 2b                	jmp    800420191f <mon_backtrace+0x36e>
				default:
					panic("unknown reg rule");
  80042018f4:	48 ba 4f 90 21 04 80 	movabs $0x800421904f,%rdx
  80042018fb:	00 00 00 
  80042018fe:	be 9c 00 00 00       	mov    $0x9c,%esi
  8004201903:	48 bf 39 90 21 04 80 	movabs $0x8004219039,%rdi
  800420190a:	00 00 00 
  800420190d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201912:	48 b9 e4 05 20 04 80 	movabs $0x80042005e4,%rcx
  8004201919:	00 00 00 
  800420191c:	ff d1                	callq  *%rcx
					break;
			}

			switch(info.reg_table.rules[16].dw_regnum) { /* 16: rip */
				case DW_FRAME_SAME_VAL:
					break;
  800420191e:	90                   	nop
				default:
					panic("unknown reg rule");
					break;
			}

			rsp = cfa;
  800420191f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004201923:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004201927:	eb 17                	jmp    8004201940 <mon_backtrace+0x38f>
		} else {
unknown_cfa:
			// move to next lower stack frame
			rip = rbp[1];
  8004201929:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420192d:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004201931:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			rbp = (const uint64_t*) rbp[0];
  8004201935:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004201939:	48 8b 00             	mov    (%rax),%rax
  800420193c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		}
		cprintf("\n");
  8004201940:	48 bf 60 90 21 04 80 	movabs $0x8004219060,%rdi
  8004201947:	00 00 00 
  800420194a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420194f:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  8004201956:	00 00 00 
  8004201959:	ff d2                	callq  *%rdx
	}

	read_rip(rip);

	cprintf("Stack backtrace:\n");
	while (rbp) {
  800420195b:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004201960:	0f 85 de fc ff ff    	jne    8004201644 <mon_backtrace+0x93>
			rbp = (const uint64_t*) rbp[0];
		}
		cprintf("\n");
	}

	return 0;
  8004201966:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420196b:	c9                   	leaveq 
  800420196c:	c3                   	retq   

000000800420196d <mon_exit>:


int
mon_exit(int argc, char** argv, struct Trapframe* tf)
{
  800420196d:	55                   	push   %rbp
  800420196e:	48 89 e5             	mov    %rsp,%rbp
  8004201971:	48 83 ec 18          	sub    $0x18,%rsp
  8004201975:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004201978:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420197c:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
#ifdef VMM_GUEST
	asm("hlt");
  8004201980:	f4                   	hlt    
#endif
	return -1;
  8004201981:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  8004201986:	c9                   	leaveq 
  8004201987:	c3                   	retq   

0000008004201988 <runcmd>:
#define WHITESPACE "\t\r\n "
#define MAXARGS 16

static int
runcmd(char *buf, struct Trapframe *tf)
{
  8004201988:	55                   	push   %rbp
  8004201989:	48 89 e5             	mov    %rsp,%rbp
  800420198c:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  8004201993:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  800420199a:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
	int argc;
	char *argv[MAXARGS];
	int i;

	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
  80042019a1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	argv[argc] = 0;
  80042019a8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042019ab:	48 98                	cltq   
  80042019ad:	48 c7 84 c5 70 ff ff 	movq   $0x0,-0x90(%rbp,%rax,8)
  80042019b4:	ff 00 00 00 00 
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  80042019b9:	eb 15                	jmp    80042019d0 <runcmd+0x48>
			*buf++ = 0;
  80042019bb:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042019c2:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042019c6:	48 89 95 68 ff ff ff 	mov    %rdx,-0x98(%rbp)
  80042019cd:	c6 00 00             	movb   $0x0,(%rax)
	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
	argv[argc] = 0;
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  80042019d0:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042019d7:	0f b6 00             	movzbl (%rax),%eax
  80042019da:	84 c0                	test   %al,%al
  80042019dc:	74 2a                	je     8004201a08 <runcmd+0x80>
  80042019de:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042019e5:	0f b6 00             	movzbl (%rax),%eax
  80042019e8:	0f be c0             	movsbl %al,%eax
  80042019eb:	89 c6                	mov    %eax,%esi
  80042019ed:	48 bf 62 90 21 04 80 	movabs $0x8004219062,%rdi
  80042019f4:	00 00 00 
  80042019f7:	48 b8 61 03 21 04 80 	movabs $0x8004210361,%rax
  80042019fe:	00 00 00 
  8004201a01:	ff d0                	callq  *%rax
  8004201a03:	48 85 c0             	test   %rax,%rax
  8004201a06:	75 b3                	jne    80042019bb <runcmd+0x33>
			*buf++ = 0;
		if (*buf == 0)
  8004201a08:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201a0f:	0f b6 00             	movzbl (%rax),%eax
  8004201a12:	84 c0                	test   %al,%al
  8004201a14:	75 21                	jne    8004201a37 <runcmd+0xaf>
			break;
  8004201a16:	90                   	nop
		}
		argv[argc++] = buf;
		while (*buf && !strchr(WHITESPACE, *buf))
			buf++;
	}
	argv[argc] = 0;
  8004201a17:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201a1a:	48 98                	cltq   
  8004201a1c:	48 c7 84 c5 70 ff ff 	movq   $0x0,-0x90(%rbp,%rax,8)
  8004201a23:	ff 00 00 00 00 

	// Lookup and invoke the command
	if (argc == 0)
  8004201a28:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004201a2c:	0f 85 a1 00 00 00    	jne    8004201ad3 <runcmd+0x14b>
  8004201a32:	e9 92 00 00 00       	jmpq   8004201ac9 <runcmd+0x141>
			*buf++ = 0;
		if (*buf == 0)
			break;

		// save and scan past next arg
		if (argc == MAXARGS-1) {
  8004201a37:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
  8004201a3b:	75 2a                	jne    8004201a67 <runcmd+0xdf>
			cprintf("Too many arguments (max %d)\n", MAXARGS);
  8004201a3d:	be 10 00 00 00       	mov    $0x10,%esi
  8004201a42:	48 bf 67 90 21 04 80 	movabs $0x8004219067,%rdi
  8004201a49:	00 00 00 
  8004201a4c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201a51:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  8004201a58:	00 00 00 
  8004201a5b:	ff d2                	callq  *%rdx
			return 0;
  8004201a5d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201a62:	e9 30 01 00 00       	jmpq   8004201b97 <runcmd+0x20f>
		}
		argv[argc++] = buf;
  8004201a67:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201a6a:	8d 50 01             	lea    0x1(%rax),%edx
  8004201a6d:	89 55 fc             	mov    %edx,-0x4(%rbp)
  8004201a70:	48 98                	cltq   
  8004201a72:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
  8004201a79:	48 89 94 c5 70 ff ff 	mov    %rdx,-0x90(%rbp,%rax,8)
  8004201a80:	ff 
		while (*buf && !strchr(WHITESPACE, *buf))
  8004201a81:	eb 08                	jmp    8004201a8b <runcmd+0x103>
			buf++;
  8004201a83:	48 83 85 68 ff ff ff 	addq   $0x1,-0x98(%rbp)
  8004201a8a:	01 
		if (argc == MAXARGS-1) {
			cprintf("Too many arguments (max %d)\n", MAXARGS);
			return 0;
		}
		argv[argc++] = buf;
		while (*buf && !strchr(WHITESPACE, *buf))
  8004201a8b:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201a92:	0f b6 00             	movzbl (%rax),%eax
  8004201a95:	84 c0                	test   %al,%al
  8004201a97:	74 2a                	je     8004201ac3 <runcmd+0x13b>
  8004201a99:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201aa0:	0f b6 00             	movzbl (%rax),%eax
  8004201aa3:	0f be c0             	movsbl %al,%eax
  8004201aa6:	89 c6                	mov    %eax,%esi
  8004201aa8:	48 bf 62 90 21 04 80 	movabs $0x8004219062,%rdi
  8004201aaf:	00 00 00 
  8004201ab2:	48 b8 61 03 21 04 80 	movabs $0x8004210361,%rax
  8004201ab9:	00 00 00 
  8004201abc:	ff d0                	callq  *%rax
  8004201abe:	48 85 c0             	test   %rax,%rax
  8004201ac1:	74 c0                	je     8004201a83 <runcmd+0xfb>
			buf++;
	}
  8004201ac3:	90                   	nop
	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
	argv[argc] = 0;
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  8004201ac4:	e9 07 ff ff ff       	jmpq   80042019d0 <runcmd+0x48>
	}
	argv[argc] = 0;

	// Lookup and invoke the command
	if (argc == 0)
		return 0;
  8004201ac9:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201ace:	e9 c4 00 00 00       	jmpq   8004201b97 <runcmd+0x20f>
	for (i = 0; i < NCOMMANDS; i++) {
  8004201ad3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  8004201ada:	e9 82 00 00 00       	jmpq   8004201b61 <runcmd+0x1d9>
		if (strcmp(argv[0], commands[i].name) == 0)
  8004201adf:	48 b9 80 c5 22 04 80 	movabs $0x800422c580,%rcx
  8004201ae6:	00 00 00 
  8004201ae9:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004201aec:	48 63 d0             	movslq %eax,%rdx
  8004201aef:	48 89 d0             	mov    %rdx,%rax
  8004201af2:	48 01 c0             	add    %rax,%rax
  8004201af5:	48 01 d0             	add    %rdx,%rax
  8004201af8:	48 c1 e0 03          	shl    $0x3,%rax
  8004201afc:	48 01 c8             	add    %rcx,%rax
  8004201aff:	48 8b 10             	mov    (%rax),%rdx
  8004201b02:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004201b09:	48 89 d6             	mov    %rdx,%rsi
  8004201b0c:	48 89 c7             	mov    %rax,%rdi
  8004201b0f:	48 b8 9d 02 21 04 80 	movabs $0x800421029d,%rax
  8004201b16:	00 00 00 
  8004201b19:	ff d0                	callq  *%rax
  8004201b1b:	85 c0                	test   %eax,%eax
  8004201b1d:	75 3e                	jne    8004201b5d <runcmd+0x1d5>
			return commands[i].func(argc, argv, tf);
  8004201b1f:	48 b9 80 c5 22 04 80 	movabs $0x800422c580,%rcx
  8004201b26:	00 00 00 
  8004201b29:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004201b2c:	48 63 d0             	movslq %eax,%rdx
  8004201b2f:	48 89 d0             	mov    %rdx,%rax
  8004201b32:	48 01 c0             	add    %rax,%rax
  8004201b35:	48 01 d0             	add    %rdx,%rax
  8004201b38:	48 c1 e0 03          	shl    $0x3,%rax
  8004201b3c:	48 01 c8             	add    %rcx,%rax
  8004201b3f:	48 83 c0 10          	add    $0x10,%rax
  8004201b43:	48 8b 00             	mov    (%rax),%rax
  8004201b46:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004201b4d:	48 8d b5 70 ff ff ff 	lea    -0x90(%rbp),%rsi
  8004201b54:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004201b57:	89 cf                	mov    %ecx,%edi
  8004201b59:	ff d0                	callq  *%rax
  8004201b5b:	eb 3a                	jmp    8004201b97 <runcmd+0x20f>
	argv[argc] = 0;

	// Lookup and invoke the command
	if (argc == 0)
		return 0;
	for (i = 0; i < NCOMMANDS; i++) {
  8004201b5d:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  8004201b61:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004201b64:	83 f8 03             	cmp    $0x3,%eax
  8004201b67:	0f 86 72 ff ff ff    	jbe    8004201adf <runcmd+0x157>
		if (strcmp(argv[0], commands[i].name) == 0)
			return commands[i].func(argc, argv, tf);
	}
	cprintf("Unknown command '%s'\n", argv[0]);
  8004201b6d:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004201b74:	48 89 c6             	mov    %rax,%rsi
  8004201b77:	48 bf 84 90 21 04 80 	movabs $0x8004219084,%rdi
  8004201b7e:	00 00 00 
  8004201b81:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201b86:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  8004201b8d:	00 00 00 
  8004201b90:	ff d2                	callq  *%rdx
	return 0;
  8004201b92:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201b97:	c9                   	leaveq 
  8004201b98:	c3                   	retq   

0000008004201b99 <monitor>:

void
monitor(struct Trapframe *tf)
{
  8004201b99:	55                   	push   %rbp
  8004201b9a:	48 89 e5             	mov    %rsp,%rbp
  8004201b9d:	48 83 ec 20          	sub    $0x20,%rsp
  8004201ba1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	char *buf;

	cprintf("Welcome to the JOS kernel monitor!\n");
  8004201ba5:	48 bf a0 90 21 04 80 	movabs $0x80042190a0,%rdi
  8004201bac:	00 00 00 
  8004201baf:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201bb4:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  8004201bbb:	00 00 00 
  8004201bbe:	ff d2                	callq  *%rdx
	cprintf("Type 'help' for a list of commands.\n");
  8004201bc0:	48 bf c8 90 21 04 80 	movabs $0x80042190c8,%rdi
  8004201bc7:	00 00 00 
  8004201bca:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201bcf:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  8004201bd6:	00 00 00 
  8004201bd9:	ff d2                	callq  *%rdx


	if (tf != NULL)
  8004201bdb:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004201be0:	74 13                	je     8004201bf5 <monitor+0x5c>
		print_trapframe(tf);
  8004201be2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201be6:	48 89 c7             	mov    %rax,%rdi
  8004201be9:	48 b8 87 c2 20 04 80 	movabs $0x800420c287,%rax
  8004201bf0:	00 00 00 
  8004201bf3:	ff d0                	callq  *%rax


	while (1) {
		buf = readline("K> ");
  8004201bf5:	48 bf ed 90 21 04 80 	movabs $0x80042190ed,%rdi
  8004201bfc:	00 00 00 
  8004201bff:	48 b8 7a ff 20 04 80 	movabs $0x800420ff7a,%rax
  8004201c06:	00 00 00 
  8004201c09:	ff d0                	callq  *%rax
  8004201c0b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (buf != NULL)
  8004201c0f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004201c14:	74 20                	je     8004201c36 <monitor+0x9d>
			if (runcmd(buf, tf) < 0)
  8004201c16:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004201c1a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201c1e:	48 89 d6             	mov    %rdx,%rsi
  8004201c21:	48 89 c7             	mov    %rax,%rdi
  8004201c24:	48 b8 88 19 20 04 80 	movabs $0x8004201988,%rax
  8004201c2b:	00 00 00 
  8004201c2e:	ff d0                	callq  *%rax
  8004201c30:	85 c0                	test   %eax,%eax
  8004201c32:	79 02                	jns    8004201c36 <monitor+0x9d>
				break;
  8004201c34:	eb 02                	jmp    8004201c38 <monitor+0x9f>
	}
  8004201c36:	eb bd                	jmp    8004201bf5 <monitor+0x5c>
}
  8004201c38:	c9                   	leaveq 
  8004201c39:	c3                   	retq   

0000008004201c3a <page2ppn>:
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);


static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  8004201c3a:	55                   	push   %rbp
  8004201c3b:	48 89 e5             	mov    %rsp,%rbp
  8004201c3e:	48 83 ec 08          	sub    $0x8,%rsp
  8004201c42:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  8004201c46:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004201c4a:	48 b8 f8 c5 69 04 80 	movabs $0x800469c5f8,%rax
  8004201c51:	00 00 00 
  8004201c54:	48 8b 00             	mov    (%rax),%rax
  8004201c57:	48 29 c2             	sub    %rax,%rdx
  8004201c5a:	48 89 d0             	mov    %rdx,%rax
  8004201c5d:	48 c1 f8 04          	sar    $0x4,%rax
}
  8004201c61:	c9                   	leaveq 
  8004201c62:	c3                   	retq   

0000008004201c63 <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  8004201c63:	55                   	push   %rbp
  8004201c64:	48 89 e5             	mov    %rsp,%rbp
  8004201c67:	48 83 ec 08          	sub    $0x8,%rsp
  8004201c6b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  8004201c6f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201c73:	48 89 c7             	mov    %rax,%rdi
  8004201c76:	48 b8 3a 1c 20 04 80 	movabs $0x8004201c3a,%rax
  8004201c7d:	00 00 00 
  8004201c80:	ff d0                	callq  *%rax
  8004201c82:	48 c1 e0 0c          	shl    $0xc,%rax
}
  8004201c86:	c9                   	leaveq 
  8004201c87:	c3                   	retq   

0000008004201c88 <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  8004201c88:	55                   	push   %rbp
  8004201c89:	48 89 e5             	mov    %rsp,%rbp
  8004201c8c:	48 83 ec 10          	sub    $0x10,%rsp
  8004201c90:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  8004201c94:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201c98:	48 c1 e8 0c          	shr    $0xc,%rax
  8004201c9c:	48 89 c2             	mov    %rax,%rdx
  8004201c9f:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  8004201ca6:	00 00 00 
  8004201ca9:	48 8b 00             	mov    (%rax),%rax
  8004201cac:	48 39 c2             	cmp    %rax,%rdx
  8004201caf:	72 2a                	jb     8004201cdb <pa2page+0x53>
		panic("pa2page called with invalid pa");
  8004201cb1:	48 ba f8 90 21 04 80 	movabs $0x80042190f8,%rdx
  8004201cb8:	00 00 00 
  8004201cbb:	be 59 00 00 00       	mov    $0x59,%esi
  8004201cc0:	48 bf 17 91 21 04 80 	movabs $0x8004219117,%rdi
  8004201cc7:	00 00 00 
  8004201cca:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201ccf:	48 b9 e4 05 20 04 80 	movabs $0x80042005e4,%rcx
  8004201cd6:	00 00 00 
  8004201cd9:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  8004201cdb:	48 b8 f8 c5 69 04 80 	movabs $0x800469c5f8,%rax
  8004201ce2:	00 00 00 
  8004201ce5:	48 8b 00             	mov    (%rax),%rax
  8004201ce8:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004201cec:	48 c1 ea 0c          	shr    $0xc,%rdx
  8004201cf0:	48 c1 e2 04          	shl    $0x4,%rdx
  8004201cf4:	48 01 d0             	add    %rdx,%rax
}
  8004201cf7:	c9                   	leaveq 
  8004201cf8:	c3                   	retq   

0000008004201cf9 <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  8004201cf9:	55                   	push   %rbp
  8004201cfa:	48 89 e5             	mov    %rsp,%rbp
  8004201cfd:	48 83 ec 20          	sub    $0x20,%rsp
  8004201d01:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  8004201d05:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201d09:	48 89 c7             	mov    %rax,%rdi
  8004201d0c:	48 b8 63 1c 20 04 80 	movabs $0x8004201c63,%rax
  8004201d13:	00 00 00 
  8004201d16:	ff d0                	callq  *%rax
  8004201d18:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004201d1c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201d20:	48 c1 e8 0c          	shr    $0xc,%rax
  8004201d24:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004201d27:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004201d2a:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  8004201d31:	00 00 00 
  8004201d34:	48 8b 00             	mov    (%rax),%rax
  8004201d37:	48 39 c2             	cmp    %rax,%rdx
  8004201d3a:	72 32                	jb     8004201d6e <page2kva+0x75>
  8004201d3c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201d40:	48 89 c1             	mov    %rax,%rcx
  8004201d43:	48 ba 28 91 21 04 80 	movabs $0x8004219128,%rdx
  8004201d4a:	00 00 00 
  8004201d4d:	be 60 00 00 00       	mov    $0x60,%esi
  8004201d52:	48 bf 17 91 21 04 80 	movabs $0x8004219117,%rdi
  8004201d59:	00 00 00 
  8004201d5c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201d61:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004201d68:	00 00 00 
  8004201d6b:	41 ff d0             	callq  *%r8
  8004201d6e:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004201d75:	00 00 00 
  8004201d78:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201d7c:	48 01 d0             	add    %rdx,%rax
}
  8004201d7f:	c9                   	leaveq 
  8004201d80:	c3                   	retq   

0000008004201d81 <restrictive_type>:
   uint32_t length_low;
   uint32_t length_high;
   uint32_t type;
 } memory_map_t;

static __inline uint32_t restrictive_type(uint32_t t1, uint32_t t2) {
  8004201d81:	55                   	push   %rbp
  8004201d82:	48 89 e5             	mov    %rsp,%rbp
  8004201d85:	48 83 ec 08          	sub    $0x8,%rsp
  8004201d89:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004201d8c:	89 75 f8             	mov    %esi,-0x8(%rbp)
  if(t1==MB_TYPE_BAD || t2==MB_TYPE_BAD)
  8004201d8f:	83 7d fc 05          	cmpl   $0x5,-0x4(%rbp)
  8004201d93:	74 06                	je     8004201d9b <restrictive_type+0x1a>
  8004201d95:	83 7d f8 05          	cmpl   $0x5,-0x8(%rbp)
  8004201d99:	75 07                	jne    8004201da2 <restrictive_type+0x21>
    return MB_TYPE_BAD;
  8004201d9b:	b8 05 00 00 00       	mov    $0x5,%eax
  8004201da0:	eb 3e                	jmp    8004201de0 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_ACPI_NVS || t2==MB_TYPE_ACPI_NVS)
  8004201da2:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  8004201da6:	74 06                	je     8004201dae <restrictive_type+0x2d>
  8004201da8:	83 7d f8 04          	cmpl   $0x4,-0x8(%rbp)
  8004201dac:	75 07                	jne    8004201db5 <restrictive_type+0x34>
    return MB_TYPE_ACPI_NVS;
  8004201dae:	b8 04 00 00 00       	mov    $0x4,%eax
  8004201db3:	eb 2b                	jmp    8004201de0 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_RESERVED || t2==MB_TYPE_RESERVED)
  8004201db5:	83 7d fc 02          	cmpl   $0x2,-0x4(%rbp)
  8004201db9:	74 06                	je     8004201dc1 <restrictive_type+0x40>
  8004201dbb:	83 7d f8 02          	cmpl   $0x2,-0x8(%rbp)
  8004201dbf:	75 07                	jne    8004201dc8 <restrictive_type+0x47>
    return MB_TYPE_RESERVED;
  8004201dc1:	b8 02 00 00 00       	mov    $0x2,%eax
  8004201dc6:	eb 18                	jmp    8004201de0 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_ACPI_RECLM || t2==MB_TYPE_ACPI_RECLM)
  8004201dc8:	83 7d fc 03          	cmpl   $0x3,-0x4(%rbp)
  8004201dcc:	74 06                	je     8004201dd4 <restrictive_type+0x53>
  8004201dce:	83 7d f8 03          	cmpl   $0x3,-0x8(%rbp)
  8004201dd2:	75 07                	jne    8004201ddb <restrictive_type+0x5a>
    return MB_TYPE_ACPI_RECLM;
  8004201dd4:	b8 03 00 00 00       	mov    $0x3,%eax
  8004201dd9:	eb 05                	jmp    8004201de0 <restrictive_type+0x5f>

  return MB_TYPE_USABLE;
  8004201ddb:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8004201de0:	c9                   	leaveq 
  8004201de1:	c3                   	retq   

0000008004201de2 <nvram_read>:
// Detect machine's physical memory setup.
// --------------------------------------------------------------

static int
nvram_read(int r)
{
  8004201de2:	55                   	push   %rbp
  8004201de3:	48 89 e5             	mov    %rsp,%rbp
  8004201de6:	53                   	push   %rbx
  8004201de7:	48 83 ec 18          	sub    $0x18,%rsp
  8004201deb:	89 7d ec             	mov    %edi,-0x14(%rbp)
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
  8004201dee:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201df1:	89 c7                	mov    %eax,%edi
  8004201df3:	48 b8 14 92 20 04 80 	movabs $0x8004209214,%rax
  8004201dfa:	00 00 00 
  8004201dfd:	ff d0                	callq  *%rax
  8004201dff:	89 c3                	mov    %eax,%ebx
  8004201e01:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201e04:	83 c0 01             	add    $0x1,%eax
  8004201e07:	89 c7                	mov    %eax,%edi
  8004201e09:	48 b8 14 92 20 04 80 	movabs $0x8004209214,%rax
  8004201e10:	00 00 00 
  8004201e13:	ff d0                	callq  *%rax
  8004201e15:	c1 e0 08             	shl    $0x8,%eax
  8004201e18:	09 d8                	or     %ebx,%eax
}
  8004201e1a:	48 83 c4 18          	add    $0x18,%rsp
  8004201e1e:	5b                   	pop    %rbx
  8004201e1f:	5d                   	pop    %rbp
  8004201e20:	c3                   	retq   

0000008004201e21 <multiboot_read>:

static void
multiboot_read(multiboot_info_t* mbinfo, size_t* basemem, size_t* extmem) {
  8004201e21:	55                   	push   %rbp
  8004201e22:	48 89 e5             	mov    %rsp,%rbp
  8004201e25:	41 54                	push   %r12
  8004201e27:	53                   	push   %rbx
  8004201e28:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  8004201e2f:	48 89 bd 58 ff ff ff 	mov    %rdi,-0xa8(%rbp)
  8004201e36:	48 89 b5 50 ff ff ff 	mov    %rsi,-0xb0(%rbp)
  8004201e3d:	48 89 95 48 ff ff ff 	mov    %rdx,-0xb8(%rbp)
  8004201e44:	48 89 e0             	mov    %rsp,%rax
  8004201e47:	49 89 c4             	mov    %rax,%r12
	int i;

	memory_map_t* mmap_base = (memory_map_t*)(uintptr_t)mbinfo->mmap_addr;
  8004201e4a:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201e51:	8b 40 30             	mov    0x30(%rax),%eax
  8004201e54:	89 c0                	mov    %eax,%eax
  8004201e56:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
 	memory_map_t* mmap_list[mbinfo->mmap_length/ (sizeof(memory_map_t))];
  8004201e5a:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201e61:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004201e64:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004201e69:	f7 e2                	mul    %edx
  8004201e6b:	89 d0                	mov    %edx,%eax
  8004201e6d:	c1 e8 04             	shr    $0x4,%eax
  8004201e70:	89 c0                	mov    %eax,%eax
  8004201e72:	48 89 c2             	mov    %rax,%rdx
  8004201e75:	48 83 ea 01          	sub    $0x1,%rdx
  8004201e79:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  8004201e7d:	49 89 c0             	mov    %rax,%r8
  8004201e80:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8004201e86:	48 89 c1             	mov    %rax,%rcx
  8004201e89:	bb 00 00 00 00       	mov    $0x0,%ebx
  8004201e8e:	48 c1 e0 03          	shl    $0x3,%rax
  8004201e92:	48 8d 50 07          	lea    0x7(%rax),%rdx
  8004201e96:	b8 10 00 00 00       	mov    $0x10,%eax
  8004201e9b:	48 83 e8 01          	sub    $0x1,%rax
  8004201e9f:	48 01 d0             	add    %rdx,%rax
  8004201ea2:	bb 10 00 00 00       	mov    $0x10,%ebx
  8004201ea7:	ba 00 00 00 00       	mov    $0x0,%edx
  8004201eac:	48 f7 f3             	div    %rbx
  8004201eaf:	48 6b c0 10          	imul   $0x10,%rax,%rax
  8004201eb3:	48 29 c4             	sub    %rax,%rsp
  8004201eb6:	48 89 e0             	mov    %rsp,%rax
  8004201eb9:	48 83 c0 07          	add    $0x7,%rax
  8004201ebd:	48 c1 e8 03          	shr    $0x3,%rax
  8004201ec1:	48 c1 e0 03          	shl    $0x3,%rax
  8004201ec5:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	cprintf("\ne820 MEMORY MAP\n");
  8004201ec9:	48 bf 4b 91 21 04 80 	movabs $0x800421914b,%rdi
  8004201ed0:	00 00 00 
  8004201ed3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201ed8:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  8004201edf:	00 00 00 
  8004201ee2:	ff d2                	callq  *%rdx
	for(i = 0; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201ee4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004201eeb:	e9 6c 01 00 00       	jmpq   800420205c <multiboot_read+0x23b>
		memory_map_t* mmap = &mmap_base[i];
  8004201ef0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201ef3:	48 63 d0             	movslq %eax,%rdx
  8004201ef6:	48 89 d0             	mov    %rdx,%rax
  8004201ef9:	48 01 c0             	add    %rax,%rax
  8004201efc:	48 01 d0             	add    %rdx,%rax
  8004201eff:	48 c1 e0 03          	shl    $0x3,%rax
  8004201f03:	48 89 c2             	mov    %rax,%rdx
  8004201f06:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004201f0a:	48 01 d0             	add    %rdx,%rax
  8004201f0d:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
        //cprintf("%lx %lx %lx %lx %lx %lx\n", mmap->size, mmap->base_addr_low, mmap->base_addr_high, mmap->length_low, mmap->length_high, mmap->type);

		uint64_t addr = APPEND_HILO(mmap->base_addr_high, mmap->base_addr_low);
  8004201f11:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201f15:	8b 40 08             	mov    0x8(%rax),%eax
  8004201f18:	89 c0                	mov    %eax,%eax
  8004201f1a:	48 c1 e0 20          	shl    $0x20,%rax
  8004201f1e:	48 89 c2             	mov    %rax,%rdx
  8004201f21:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201f25:	8b 40 04             	mov    0x4(%rax),%eax
  8004201f28:	89 c0                	mov    %eax,%eax
  8004201f2a:	48 01 d0             	add    %rdx,%rax
  8004201f2d:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		uint64_t len = APPEND_HILO(mmap->length_high, mmap->length_low);
  8004201f31:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201f35:	8b 40 10             	mov    0x10(%rax),%eax
  8004201f38:	89 c0                	mov    %eax,%eax
  8004201f3a:	48 c1 e0 20          	shl    $0x20,%rax
  8004201f3e:	48 89 c2             	mov    %rax,%rdx
  8004201f41:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201f45:	8b 40 0c             	mov    0xc(%rax),%eax
  8004201f48:	89 c0                	mov    %eax,%eax
  8004201f4a:	48 01 d0             	add    %rdx,%rax
  8004201f4d:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
        
		cprintf("size: %d, address: 0x%016x, length: 0x%016x, type: %x\n", mmap->size, 
  8004201f51:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201f55:	8b 70 14             	mov    0x14(%rax),%esi
  8004201f58:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201f5c:	8b 00                	mov    (%rax),%eax
  8004201f5e:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004201f62:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004201f66:	41 89 f0             	mov    %esi,%r8d
  8004201f69:	89 c6                	mov    %eax,%esi
  8004201f6b:	48 bf 60 91 21 04 80 	movabs $0x8004219160,%rdi
  8004201f72:	00 00 00 
  8004201f75:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201f7a:	49 b9 90 95 20 04 80 	movabs $0x8004209590,%r9
  8004201f81:	00 00 00 
  8004201f84:	41 ff d1             	callq  *%r9
			addr, len, mmap->type);

		if(mmap->type > 5 || mmap->type < 1)
  8004201f87:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201f8b:	8b 40 14             	mov    0x14(%rax),%eax
  8004201f8e:	83 f8 05             	cmp    $0x5,%eax
  8004201f91:	77 0b                	ja     8004201f9e <multiboot_read+0x17d>
  8004201f93:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201f97:	8b 40 14             	mov    0x14(%rax),%eax
  8004201f9a:	85 c0                	test   %eax,%eax
  8004201f9c:	75 0b                	jne    8004201fa9 <multiboot_read+0x188>
			mmap->type = MB_TYPE_RESERVED;
  8004201f9e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201fa2:	c7 40 14 02 00 00 00 	movl   $0x2,0x14(%rax)
       
		//Insert into the sorted list
		int j = 0;
  8004201fa9:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
		for(;j<i;j++) {
  8004201fb0:	e9 85 00 00 00       	jmpq   800420203a <multiboot_read+0x219>
			memory_map_t* this = mmap_list[j];
  8004201fb5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201fb9:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004201fbc:	48 63 d2             	movslq %edx,%rdx
  8004201fbf:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004201fc3:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
  8004201fc7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004201fcb:	8b 40 08             	mov    0x8(%rax),%eax
  8004201fce:	89 c0                	mov    %eax,%eax
  8004201fd0:	48 c1 e0 20          	shl    $0x20,%rax
  8004201fd4:	48 89 c2             	mov    %rax,%rdx
  8004201fd7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004201fdb:	8b 40 04             	mov    0x4(%rax),%eax
  8004201fde:	89 c0                	mov    %eax,%eax
  8004201fe0:	48 01 d0             	add    %rdx,%rax
  8004201fe3:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			if(this_addr > addr) {
  8004201fe7:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004201feb:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004201fef:	76 45                	jbe    8004202036 <multiboot_read+0x215>
				int last = i+1;
  8004201ff1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201ff4:	83 c0 01             	add    $0x1,%eax
  8004201ff7:	89 45 e4             	mov    %eax,-0x1c(%rbp)
				while(last != j) {
  8004201ffa:	eb 30                	jmp    800420202c <multiboot_read+0x20b>
					*(mmap_list + last) = *(mmap_list + last - 1);
  8004201ffc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202000:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004202003:	48 63 d2             	movslq %edx,%rdx
  8004202006:	48 c1 e2 03          	shl    $0x3,%rdx
  800420200a:	48 01 c2             	add    %rax,%rdx
  800420200d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202011:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8004202014:	48 63 c9             	movslq %ecx,%rcx
  8004202017:	48 c1 e1 03          	shl    $0x3,%rcx
  800420201b:	48 83 e9 08          	sub    $0x8,%rcx
  800420201f:	48 01 c8             	add    %rcx,%rax
  8004202022:	48 8b 00             	mov    (%rax),%rax
  8004202025:	48 89 02             	mov    %rax,(%rdx)
					last--;
  8004202028:	83 6d e4 01          	subl   $0x1,-0x1c(%rbp)
		for(;j<i;j++) {
			memory_map_t* this = mmap_list[j];
			uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
			if(this_addr > addr) {
				int last = i+1;
				while(last != j) {
  800420202c:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420202f:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  8004202032:	75 c8                	jne    8004201ffc <multiboot_read+0x1db>
					*(mmap_list + last) = *(mmap_list + last - 1);
					last--;
				}
				break; 
  8004202034:	eb 10                	jmp    8004202046 <multiboot_read+0x225>
		if(mmap->type > 5 || mmap->type < 1)
			mmap->type = MB_TYPE_RESERVED;
       
		//Insert into the sorted list
		int j = 0;
		for(;j<i;j++) {
  8004202036:	83 45 e8 01          	addl   $0x1,-0x18(%rbp)
  800420203a:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800420203d:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004202040:	0f 8c 6f ff ff ff    	jl     8004201fb5 <multiboot_read+0x194>
					last--;
				}
				break; 
			}
		}
		mmap_list[j] = mmap;  
  8004202046:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420204a:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800420204d:	48 63 d2             	movslq %edx,%rdx
  8004202050:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004202054:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)

	memory_map_t* mmap_base = (memory_map_t*)(uintptr_t)mbinfo->mmap_addr;
 	memory_map_t* mmap_list[mbinfo->mmap_length/ (sizeof(memory_map_t))];

	cprintf("\ne820 MEMORY MAP\n");
	for(i = 0; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004202058:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  800420205c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420205f:	48 63 c8             	movslq %eax,%rcx
  8004202062:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004202069:	8b 40 2c             	mov    0x2c(%rax),%eax
  800420206c:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004202071:	f7 e2                	mul    %edx
  8004202073:	89 d0                	mov    %edx,%eax
  8004202075:	c1 e8 04             	shr    $0x4,%eax
  8004202078:	89 c0                	mov    %eax,%eax
  800420207a:	48 39 c1             	cmp    %rax,%rcx
  800420207d:	0f 82 6d fe ff ff    	jb     8004201ef0 <multiboot_read+0xcf>
				break; 
			}
		}
		mmap_list[j] = mmap;  
	}
	cprintf("\n");
  8004202083:	48 bf 97 91 21 04 80 	movabs $0x8004219197,%rdi
  800420208a:	00 00 00 
  800420208d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202092:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  8004202099:	00 00 00 
  800420209c:	ff d2                	callq  *%rdx
    
	// Sanitize the list
	for(i=1;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  800420209e:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%rbp)
  80042020a5:	e9 93 01 00 00       	jmpq   800420223d <multiboot_read+0x41c>
		memory_map_t* prev = mmap_list[i-1];
  80042020aa:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042020ad:	8d 50 ff             	lea    -0x1(%rax),%edx
  80042020b0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042020b4:	48 63 d2             	movslq %edx,%rdx
  80042020b7:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80042020bb:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		memory_map_t* this = mmap_list[i];
  80042020bf:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042020c3:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042020c6:	48 63 d2             	movslq %edx,%rdx
  80042020c9:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80042020cd:	48 89 45 90          	mov    %rax,-0x70(%rbp)

		uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
  80042020d1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042020d5:	8b 40 08             	mov    0x8(%rax),%eax
  80042020d8:	89 c0                	mov    %eax,%eax
  80042020da:	48 c1 e0 20          	shl    $0x20,%rax
  80042020de:	48 89 c2             	mov    %rax,%rdx
  80042020e1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042020e5:	8b 40 04             	mov    0x4(%rax),%eax
  80042020e8:	89 c0                	mov    %eax,%eax
  80042020ea:	48 01 d0             	add    %rdx,%rax
  80042020ed:	48 89 45 88          	mov    %rax,-0x78(%rbp)
		uint64_t prev_addr = APPEND_HILO(prev->base_addr_high, prev->base_addr_low);
  80042020f1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042020f5:	8b 40 08             	mov    0x8(%rax),%eax
  80042020f8:	89 c0                	mov    %eax,%eax
  80042020fa:	48 c1 e0 20          	shl    $0x20,%rax
  80042020fe:	48 89 c2             	mov    %rax,%rdx
  8004202101:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004202105:	8b 40 04             	mov    0x4(%rax),%eax
  8004202108:	89 c0                	mov    %eax,%eax
  800420210a:	48 01 d0             	add    %rdx,%rax
  800420210d:	48 89 45 80          	mov    %rax,-0x80(%rbp)
		uint64_t prev_length = APPEND_HILO(prev->length_high, prev->length_low);
  8004202111:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004202115:	8b 40 10             	mov    0x10(%rax),%eax
  8004202118:	89 c0                	mov    %eax,%eax
  800420211a:	48 c1 e0 20          	shl    $0x20,%rax
  800420211e:	48 89 c2             	mov    %rax,%rdx
  8004202121:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004202125:	8b 40 0c             	mov    0xc(%rax),%eax
  8004202128:	89 c0                	mov    %eax,%eax
  800420212a:	48 01 d0             	add    %rdx,%rax
  800420212d:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
		uint64_t this_length = APPEND_HILO(this->length_high, this->length_low);
  8004202134:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202138:	8b 40 10             	mov    0x10(%rax),%eax
  800420213b:	89 c0                	mov    %eax,%eax
  800420213d:	48 c1 e0 20          	shl    $0x20,%rax
  8004202141:	48 89 c2             	mov    %rax,%rdx
  8004202144:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202148:	8b 40 0c             	mov    0xc(%rax),%eax
  800420214b:	89 c0                	mov    %eax,%eax
  800420214d:	48 01 d0             	add    %rdx,%rax
  8004202150:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)

		// Merge adjacent regions with same type
		if(prev_addr + prev_length == this_addr && prev->type == this->type) {
  8004202157:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420215e:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004202162:	48 01 d0             	add    %rdx,%rax
  8004202165:	48 3b 45 88          	cmp    -0x78(%rbp),%rax
  8004202169:	75 7c                	jne    80042021e7 <multiboot_read+0x3c6>
  800420216b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420216f:	8b 50 14             	mov    0x14(%rax),%edx
  8004202172:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202176:	8b 40 14             	mov    0x14(%rax),%eax
  8004202179:	39 c2                	cmp    %eax,%edx
  800420217b:	75 6a                	jne    80042021e7 <multiboot_read+0x3c6>
			this->length_low = (uint32_t)prev_length + this_length;
  800420217d:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004202184:	89 c2                	mov    %eax,%edx
  8004202186:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  800420218d:	01 c2                	add    %eax,%edx
  800420218f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202193:	89 50 0c             	mov    %edx,0xc(%rax)
			this->length_high = (uint32_t)((prev_length + this_length)>>32);
  8004202196:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  800420219d:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  80042021a4:	48 01 d0             	add    %rdx,%rax
  80042021a7:	48 c1 e8 20          	shr    $0x20,%rax
  80042021ab:	89 c2                	mov    %eax,%edx
  80042021ad:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042021b1:	89 50 10             	mov    %edx,0x10(%rax)
			this->base_addr_low = prev->base_addr_low;
  80042021b4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042021b8:	8b 50 04             	mov    0x4(%rax),%edx
  80042021bb:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042021bf:	89 50 04             	mov    %edx,0x4(%rax)
			this->base_addr_high = prev->base_addr_high;
  80042021c2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042021c6:	8b 50 08             	mov    0x8(%rax),%edx
  80042021c9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042021cd:	89 50 08             	mov    %edx,0x8(%rax)
			mmap_list[i-1] = NULL;
  80042021d0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042021d3:	8d 50 ff             	lea    -0x1(%rax),%edx
  80042021d6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042021da:	48 63 d2             	movslq %edx,%rdx
  80042021dd:	48 c7 04 d0 00 00 00 	movq   $0x0,(%rax,%rdx,8)
  80042021e4:	00 
  80042021e5:	eb 52                	jmp    8004202239 <multiboot_read+0x418>
		} else if(prev_addr + prev_length > this_addr) {
  80042021e7:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042021ee:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  80042021f2:	48 01 d0             	add    %rdx,%rax
  80042021f5:	48 3b 45 88          	cmp    -0x78(%rbp),%rax
  80042021f9:	76 3e                	jbe    8004202239 <multiboot_read+0x418>
			//Overlapping regions
			uint32_t type = restrictive_type(prev->type, this->type);
  80042021fb:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042021ff:	8b 50 14             	mov    0x14(%rax),%edx
  8004202202:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004202206:	8b 40 14             	mov    0x14(%rax),%eax
  8004202209:	89 d6                	mov    %edx,%esi
  800420220b:	89 c7                	mov    %eax,%edi
  800420220d:	48 b8 81 1d 20 04 80 	movabs $0x8004201d81,%rax
  8004202214:	00 00 00 
  8004202217:	ff d0                	callq  *%rax
  8004202219:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
			prev->type = type;
  800420221f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004202223:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  8004202229:	89 50 14             	mov    %edx,0x14(%rax)
			this->type = type;
  800420222c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202230:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  8004202236:	89 50 14             	mov    %edx,0x14(%rax)
		mmap_list[j] = mmap;  
	}
	cprintf("\n");
    
	// Sanitize the list
	for(i=1;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004202239:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  800420223d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202240:	48 63 c8             	movslq %eax,%rcx
  8004202243:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800420224a:	8b 40 2c             	mov    0x2c(%rax),%eax
  800420224d:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004202252:	f7 e2                	mul    %edx
  8004202254:	89 d0                	mov    %edx,%eax
  8004202256:	c1 e8 04             	shr    $0x4,%eax
  8004202259:	89 c0                	mov    %eax,%eax
  800420225b:	48 39 c1             	cmp    %rax,%rcx
  800420225e:	0f 82 46 fe ff ff    	jb     80042020aa <multiboot_read+0x289>
			prev->type = type;
			this->type = type;
		}
	}

	for(i=0;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004202264:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  800420226b:	e9 dc 00 00 00       	jmpq   800420234c <multiboot_read+0x52b>
		memory_map_t* mmap = mmap_list[i];
  8004202270:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202274:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004202277:	48 63 d2             	movslq %edx,%rdx
  800420227a:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  800420227e:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
		if(mmap) {
  8004202285:	48 83 bd 60 ff ff ff 	cmpq   $0x0,-0xa0(%rbp)
  800420228c:	00 
  800420228d:	0f 84 b5 00 00 00    	je     8004202348 <multiboot_read+0x527>
			if(mmap->type == MB_TYPE_USABLE || mmap->type == MB_TYPE_ACPI_RECLM) {
  8004202293:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  800420229a:	8b 40 14             	mov    0x14(%rax),%eax
  800420229d:	83 f8 01             	cmp    $0x1,%eax
  80042022a0:	74 13                	je     80042022b5 <multiboot_read+0x494>
  80042022a2:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042022a9:	8b 40 14             	mov    0x14(%rax),%eax
  80042022ac:	83 f8 03             	cmp    $0x3,%eax
  80042022af:	0f 85 93 00 00 00    	jne    8004202348 <multiboot_read+0x527>
				if(mmap->base_addr_low < 0x100000 && mmap->base_addr_high == 0)
  80042022b5:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042022bc:	8b 40 04             	mov    0x4(%rax),%eax
  80042022bf:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
  80042022c4:	77 49                	ja     800420230f <multiboot_read+0x4ee>
  80042022c6:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042022cd:	8b 40 08             	mov    0x8(%rax),%eax
  80042022d0:	85 c0                	test   %eax,%eax
  80042022d2:	75 3b                	jne    800420230f <multiboot_read+0x4ee>
					*basemem += APPEND_HILO(mmap->length_high, mmap->length_low);
  80042022d4:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  80042022db:	48 8b 10             	mov    (%rax),%rdx
  80042022de:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042022e5:	8b 40 10             	mov    0x10(%rax),%eax
  80042022e8:	89 c0                	mov    %eax,%eax
  80042022ea:	48 c1 e0 20          	shl    $0x20,%rax
  80042022ee:	48 89 c1             	mov    %rax,%rcx
  80042022f1:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042022f8:	8b 40 0c             	mov    0xc(%rax),%eax
  80042022fb:	89 c0                	mov    %eax,%eax
  80042022fd:	48 01 c8             	add    %rcx,%rax
  8004202300:	48 01 c2             	add    %rax,%rdx
  8004202303:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  800420230a:	48 89 10             	mov    %rdx,(%rax)
  800420230d:	eb 39                	jmp    8004202348 <multiboot_read+0x527>
				else
					*extmem += APPEND_HILO(mmap->length_high, mmap->length_low);
  800420230f:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004202316:	48 8b 10             	mov    (%rax),%rdx
  8004202319:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202320:	8b 40 10             	mov    0x10(%rax),%eax
  8004202323:	89 c0                	mov    %eax,%eax
  8004202325:	48 c1 e0 20          	shl    $0x20,%rax
  8004202329:	48 89 c1             	mov    %rax,%rcx
  800420232c:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202333:	8b 40 0c             	mov    0xc(%rax),%eax
  8004202336:	89 c0                	mov    %eax,%eax
  8004202338:	48 01 c8             	add    %rcx,%rax
  800420233b:	48 01 c2             	add    %rax,%rdx
  800420233e:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004202345:	48 89 10             	mov    %rdx,(%rax)
			prev->type = type;
			this->type = type;
		}
	}

	for(i=0;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004202348:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  800420234c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420234f:	48 63 c8             	movslq %eax,%rcx
  8004202352:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004202359:	8b 40 2c             	mov    0x2c(%rax),%eax
  800420235c:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004202361:	f7 e2                	mul    %edx
  8004202363:	89 d0                	mov    %edx,%eax
  8004202365:	c1 e8 04             	shr    $0x4,%eax
  8004202368:	89 c0                	mov    %eax,%eax
  800420236a:	48 39 c1             	cmp    %rax,%rcx
  800420236d:	0f 82 fd fe ff ff    	jb     8004202270 <multiboot_read+0x44f>
  8004202373:	4c 89 e4             	mov    %r12,%rsp
				else
					*extmem += APPEND_HILO(mmap->length_high, mmap->length_low);
			}
		}
	}
}
  8004202376:	48 8d 65 f0          	lea    -0x10(%rbp),%rsp
  800420237a:	5b                   	pop    %rbx
  800420237b:	41 5c                	pop    %r12
  800420237d:	5d                   	pop    %rbp
  800420237e:	c3                   	retq   

000000800420237f <i386_detect_memory>:

static void
i386_detect_memory(void)
{
  800420237f:	55                   	push   %rbp
  8004202380:	48 89 e5             	mov    %rsp,%rbp
  8004202383:	48 83 ec 50          	sub    $0x50,%rsp
	size_t npages_extmem;
	size_t basemem = 0;
  8004202387:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  800420238e:	00 
	size_t extmem = 0;
  800420238f:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  8004202396:	00 

	// Check if the bootloader passed us a multiboot structure
	extern char multiboot_info[];
	uintptr_t* mbp = (uintptr_t*)multiboot_info;
  8004202397:	48 b8 00 70 10 00 00 	movabs $0x107000,%rax
  800420239e:	00 00 00 
  80042023a1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	multiboot_info_t * mbinfo = (multiboot_info_t*)*mbp;
  80042023a5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042023a9:	48 8b 00             	mov    (%rax),%rax
  80042023ac:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	if(mbinfo && (mbinfo->flags & MB_FLAG_MMAP)) {
  80042023b0:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042023b5:	74 2d                	je     80042023e4 <i386_detect_memory+0x65>
  80042023b7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042023bb:	8b 00                	mov    (%rax),%eax
  80042023bd:	83 e0 40             	and    $0x40,%eax
  80042023c0:	85 c0                	test   %eax,%eax
  80042023c2:	74 20                	je     80042023e4 <i386_detect_memory+0x65>
		multiboot_read(mbinfo, &basemem, &extmem);
  80042023c4:	48 8d 55 b8          	lea    -0x48(%rbp),%rdx
  80042023c8:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  80042023cc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042023d0:	48 89 ce             	mov    %rcx,%rsi
  80042023d3:	48 89 c7             	mov    %rax,%rdi
  80042023d6:	48 b8 21 1e 20 04 80 	movabs $0x8004201e21,%rax
  80042023dd:	00 00 00 
  80042023e0:	ff d0                	callq  *%rax
  80042023e2:	eb 34                	jmp    8004202418 <i386_detect_memory+0x99>
	} else {
		basemem = (nvram_read(NVRAM_BASELO) * 1024);
  80042023e4:	bf 15 00 00 00       	mov    $0x15,%edi
  80042023e9:	48 b8 e2 1d 20 04 80 	movabs $0x8004201de2,%rax
  80042023f0:	00 00 00 
  80042023f3:	ff d0                	callq  *%rax
  80042023f5:	c1 e0 0a             	shl    $0xa,%eax
  80042023f8:	48 98                	cltq   
  80042023fa:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		extmem = (nvram_read(NVRAM_EXTLO) * 1024);
  80042023fe:	bf 17 00 00 00       	mov    $0x17,%edi
  8004202403:	48 b8 e2 1d 20 04 80 	movabs $0x8004201de2,%rax
  800420240a:	00 00 00 
  800420240d:	ff d0                	callq  *%rax
  800420240f:	c1 e0 0a             	shl    $0xa,%eax
  8004202412:	48 98                	cltq   
  8004202414:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	}

	assert(basemem);
  8004202418:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420241c:	48 85 c0             	test   %rax,%rax
  800420241f:	75 35                	jne    8004202456 <i386_detect_memory+0xd7>
  8004202421:	48 b9 99 91 21 04 80 	movabs $0x8004219199,%rcx
  8004202428:	00 00 00 
  800420242b:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004202432:	00 00 00 
  8004202435:	be 8b 00 00 00       	mov    $0x8b,%esi
  800420243a:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004202441:	00 00 00 
  8004202444:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202449:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004202450:	00 00 00 
  8004202453:	41 ff d0             	callq  *%r8

	npages_basemem = basemem / PGSIZE;
  8004202456:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420245a:	48 c1 e8 0c          	shr    $0xc,%rax
  800420245e:	48 89 c2             	mov    %rax,%rdx
  8004202461:	48 b8 30 d2 49 04 80 	movabs $0x800449d230,%rax
  8004202468:	00 00 00 
  800420246b:	48 89 10             	mov    %rdx,(%rax)
	npages_extmem = extmem / PGSIZE;
  800420246e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202472:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202476:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	
	if(nvram_read(NVRAM_EXTLO) == 0xffff) {
  800420247a:	bf 17 00 00 00       	mov    $0x17,%edi
  800420247f:	48 b8 e2 1d 20 04 80 	movabs $0x8004201de2,%rax
  8004202486:	00 00 00 
  8004202489:	ff d0                	callq  *%rax
  800420248b:	3d ff ff 00 00       	cmp    $0xffff,%eax
  8004202490:	75 2c                	jne    80042024be <i386_detect_memory+0x13f>
		// EXTMEM > 16M in blocks of 64k
		size_t pextmem = nvram_read(NVRAM_EXTGT16LO) * (64 * 1024);
  8004202492:	bf 34 00 00 00       	mov    $0x34,%edi
  8004202497:	48 b8 e2 1d 20 04 80 	movabs $0x8004201de2,%rax
  800420249e:	00 00 00 
  80042024a1:	ff d0                	callq  *%rax
  80042024a3:	c1 e0 10             	shl    $0x10,%eax
  80042024a6:	48 98                	cltq   
  80042024a8:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		npages_extmem = ((16 * 1024 * 1024) + pextmem - (1 * 1024 * 1024)) / PGSIZE;
  80042024ac:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042024b0:	48 05 00 00 f0 00    	add    $0xf00000,%rax
  80042024b6:	48 c1 e8 0c          	shr    $0xc,%rax
  80042024ba:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	}
	
	// Calculate the number of physical pages available in both base
	// and extended memory.
	if (npages_extmem)
  80042024be:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042024c3:	74 1a                	je     80042024df <i386_detect_memory+0x160>
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
  80042024c5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042024c9:	48 8d 90 00 01 00 00 	lea    0x100(%rax),%rdx
  80042024d0:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  80042024d7:	00 00 00 
  80042024da:	48 89 10             	mov    %rdx,(%rax)
  80042024dd:	eb 1a                	jmp    80042024f9 <i386_detect_memory+0x17a>
	else
		npages = npages_basemem;
  80042024df:	48 b8 30 d2 49 04 80 	movabs $0x800449d230,%rax
  80042024e6:	00 00 00 
  80042024e9:	48 8b 10             	mov    (%rax),%rdx
  80042024ec:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  80042024f3:	00 00 00 
  80042024f6:	48 89 10             	mov    %rdx,(%rax)

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  80042024f9:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  8004202500:	00 00 00 
  8004202503:	48 8b 30             	mov    (%rax),%rsi
		npages * PGSIZE / (1024 * 1024),
		npages_basemem * PGSIZE / 1024,
		npages_extmem * PGSIZE / 1024,
  8004202506:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420250a:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  800420250e:	48 c1 e8 0a          	shr    $0xa,%rax
  8004202512:	48 89 c1             	mov    %rax,%rcx
		npages * PGSIZE / (1024 * 1024),
		npages_basemem * PGSIZE / 1024,
  8004202515:	48 b8 30 d2 49 04 80 	movabs $0x800449d230,%rax
  800420251c:	00 00 00 
  800420251f:	48 8b 00             	mov    (%rax),%rax
  8004202522:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  8004202526:	48 c1 e8 0a          	shr    $0xa,%rax
  800420252a:	48 89 c2             	mov    %rax,%rdx
		npages * PGSIZE / (1024 * 1024),
  800420252d:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  8004202534:	00 00 00 
  8004202537:	48 8b 00             	mov    (%rax),%rax
  800420253a:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  800420253e:	48 c1 e8 14          	shr    $0x14,%rax
  8004202542:	49 89 f0             	mov    %rsi,%r8
  8004202545:	48 89 c6             	mov    %rax,%rsi
  8004202548:	48 bf c8 91 21 04 80 	movabs $0x80042191c8,%rdi
  800420254f:	00 00 00 
  8004202552:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202557:	49 b9 90 95 20 04 80 	movabs $0x8004209590,%r9
  800420255e:	00 00 00 
  8004202561:	41 ff d1             	callq  *%r9
	//JOS 64 pages are limited by the size of both the UPAGES
	//  virtual address space, and the range from KERNBASE to UVPT.
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to 
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
  8004202564:	48 c7 45 d8 00 00 32 	movq   $0x320000,-0x28(%rbp)
  800420256b:	00 
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
  800420256c:	48 c7 45 d0 00 c0 ff 	movq   $0x7ffc000,-0x30(%rbp)
  8004202573:	07 
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n", 
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
		kern_mem_max, kern_mem_max * PGSIZE / (1024 * 1024));
  8004202574:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202578:	48 c1 e0 0c          	shl    $0xc,%rax
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to 
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n", 
  800420257c:	48 c1 e8 14          	shr    $0x14,%rax
  8004202580:	48 89 c1             	mov    %rax,%rcx
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
  8004202583:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202587:	48 c1 e0 0c          	shl    $0xc,%rax
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to 
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n", 
  800420258b:	48 c1 e8 14          	shr    $0x14,%rax
  800420258f:	48 89 c6             	mov    %rax,%rsi
  8004202592:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004202596:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420259a:	49 89 c8             	mov    %rcx,%r8
  800420259d:	48 89 d1             	mov    %rdx,%rcx
  80042025a0:	48 89 f2             	mov    %rsi,%rdx
  80042025a3:	48 89 c6             	mov    %rax,%rsi
  80042025a6:	48 bf 18 92 21 04 80 	movabs $0x8004219218,%rdi
  80042025ad:	00 00 00 
  80042025b0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042025b5:	49 b9 90 95 20 04 80 	movabs $0x8004209590,%r9
  80042025bc:	00 00 00 
  80042025bf:	41 ff d1             	callq  *%r9
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
		kern_mem_max, kern_mem_max * PGSIZE / (1024 * 1024));
	uint64_t max_npages = upages_max < kern_mem_max ? upages_max : kern_mem_max;
  80042025c2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042025c6:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  80042025ca:	48 0f 46 45 d0       	cmovbe -0x30(%rbp),%rax
  80042025cf:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	if(npages > max_npages) {
  80042025d3:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  80042025da:	00 00 00 
  80042025dd:	48 8b 00             	mov    (%rax),%rax
  80042025e0:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  80042025e4:	76 3a                	jbe    8004202620 <i386_detect_memory+0x2a1>
		npages = max_npages - 1024;
  80042025e6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042025ea:	48 8d 90 00 fc ff ff 	lea    -0x400(%rax),%rdx
  80042025f1:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  80042025f8:	00 00 00 
  80042025fb:	48 89 10             	mov    %rdx,(%rax)
		cprintf("Using only %uK of the available memory.\n", max_npages);
  80042025fe:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202602:	48 89 c6             	mov    %rax,%rsi
  8004202605:	48 bf 80 92 21 04 80 	movabs $0x8004219280,%rdi
  800420260c:	00 00 00 
  800420260f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202614:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  800420261b:	00 00 00 
  800420261e:	ff d2                	callq  *%rdx
	}
}
  8004202620:	c9                   	leaveq 
  8004202621:	c3                   	retq   

0000008004202622 <boot_alloc>:
// If we're out of memory, boot_alloc should panic.
// This function may ONLY be used during initialization,
// before the page_free_list list has been set up.
static void *
boot_alloc(uint32_t n)
{
  8004202622:	55                   	push   %rbp
  8004202623:	48 89 e5             	mov    %rsp,%rbp
  8004202626:	48 83 ec 40          	sub    $0x40,%rsp
  800420262a:	89 7d cc             	mov    %edi,-0x34(%rbp)
	// Initialize nextfree if this is the first time.
	// 'end' is a magic symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker did *not* assign
	// to any kernel code or global variables.
	if (!nextfree) {
  800420262d:	48 b8 48 d2 49 04 80 	movabs $0x800449d248,%rax
  8004202634:	00 00 00 
  8004202637:	48 8b 00             	mov    (%rax),%rax
  800420263a:	48 85 c0             	test   %rax,%rax
  800420263d:	75 4b                	jne    800420268a <boot_alloc+0x68>

#ifdef VMM_GUEST
		extern char end[];
		nextfree = ROUNDUP((char *) end, PGSIZE);
  800420263f:	48 c7 45 f8 00 10 00 	movq   $0x1000,-0x8(%rbp)
  8004202646:	00 
  8004202647:	48 b8 10 f0 6d 04 80 	movabs $0x80046df010,%rax
  800420264e:	00 00 00 
  8004202651:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  8004202655:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202659:	48 01 d0             	add    %rdx,%rax
  800420265c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004202660:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202664:	ba 00 00 00 00       	mov    $0x0,%edx
  8004202669:	48 f7 75 f8          	divq   -0x8(%rbp)
  800420266d:	48 89 d0             	mov    %rdx,%rax
  8004202670:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004202674:	48 29 c2             	sub    %rax,%rdx
  8004202677:	48 89 d0             	mov    %rdx,%rax
  800420267a:	48 89 c2             	mov    %rax,%rdx
  800420267d:	48 b8 48 d2 49 04 80 	movabs $0x800449d248,%rax
  8004202684:	00 00 00 
  8004202687:	48 89 10             	mov    %rdx,(%rax)
	// to a multiple of PGSIZE.
	//
	// LAB 2: Your code here.


	if ((uintptr_t)nextfree + n < (uintptr_t)nextfree
  800420268a:	8b 55 cc             	mov    -0x34(%rbp),%edx
  800420268d:	48 b8 48 d2 49 04 80 	movabs $0x800449d248,%rax
  8004202694:	00 00 00 
  8004202697:	48 8b 00             	mov    (%rax),%rax
  800420269a:	48 01 c2             	add    %rax,%rdx
  800420269d:	48 b8 48 d2 49 04 80 	movabs $0x800449d248,%rax
  80042026a4:	00 00 00 
  80042026a7:	48 8b 00             	mov    (%rax),%rax
  80042026aa:	48 39 c2             	cmp    %rax,%rdx
  80042026ad:	72 2f                	jb     80042026de <boot_alloc+0xbc>
            || nextfree + n > (char*) (npages * PGSIZE + KERNBASE))
  80042026af:	48 b8 48 d2 49 04 80 	movabs $0x800449d248,%rax
  80042026b6:	00 00 00 
  80042026b9:	48 8b 10             	mov    (%rax),%rdx
  80042026bc:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80042026bf:	48 01 c2             	add    %rax,%rdx
  80042026c2:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  80042026c9:	00 00 00 
  80042026cc:	48 8b 00             	mov    (%rax),%rax
  80042026cf:	48 05 00 40 00 08    	add    $0x8004000,%rax
  80042026d5:	48 c1 e0 0c          	shl    $0xc,%rax
  80042026d9:	48 39 c2             	cmp    %rax,%rdx
  80042026dc:	76 2a                	jbe    8004202708 <boot_alloc+0xe6>
		panic("out of memory during x64_vm_init");
  80042026de:	48 ba b0 92 21 04 80 	movabs $0x80042192b0,%rdx
  80042026e5:	00 00 00 
  80042026e8:	be f0 00 00 00       	mov    $0xf0,%esi
  80042026ed:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  80042026f4:	00 00 00 
  80042026f7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042026fc:	48 b9 e4 05 20 04 80 	movabs $0x80042005e4,%rcx
  8004202703:	00 00 00 
  8004202706:	ff d1                	callq  *%rcx
	result = nextfree;
  8004202708:	48 b8 48 d2 49 04 80 	movabs $0x800449d248,%rax
  800420270f:	00 00 00 
  8004202712:	48 8b 00             	mov    (%rax),%rax
  8004202715:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	nextfree = ROUNDUP(nextfree + n, PGSIZE);
  8004202719:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  8004202720:	00 
  8004202721:	48 b8 48 d2 49 04 80 	movabs $0x800449d248,%rax
  8004202728:	00 00 00 
  800420272b:	48 8b 10             	mov    (%rax),%rdx
  800420272e:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004202731:	48 01 d0             	add    %rdx,%rax
  8004202734:	48 89 c2             	mov    %rax,%rdx
  8004202737:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420273b:	48 01 d0             	add    %rdx,%rax
  800420273e:	48 83 e8 01          	sub    $0x1,%rax
  8004202742:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004202746:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420274a:	ba 00 00 00 00       	mov    $0x0,%edx
  800420274f:	48 f7 75 e0          	divq   -0x20(%rbp)
  8004202753:	48 89 d0             	mov    %rdx,%rax
  8004202756:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420275a:	48 29 c2             	sub    %rax,%rdx
  800420275d:	48 89 d0             	mov    %rdx,%rax
  8004202760:	48 89 c2             	mov    %rax,%rdx
  8004202763:	48 b8 48 d2 49 04 80 	movabs $0x800449d248,%rax
  800420276a:	00 00 00 
  800420276d:	48 89 10             	mov    %rdx,(%rax)
	return result;
  8004202770:	48 8b 45 e8          	mov    -0x18(%rbp),%rax

}
  8004202774:	c9                   	leaveq 
  8004202775:	c3                   	retq   

0000008004202776 <x64_vm_init>:
//
// From UTOP to ULIM, the user is allowed to read but not write.
// Above ULIM the user cannot read or write.
void
x64_vm_init(void)
{
  8004202776:	55                   	push   %rbp
  8004202777:	48 89 e5             	mov    %rsp,%rbp
  800420277a:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
	pml4e_t* pml4e;
	uint32_t cr0;
	uint64_t n;
	int r;
	struct Env *env;
	i386_detect_memory();
  800420277e:	48 b8 7f 23 20 04 80 	movabs $0x800420237f,%rax
  8004202785:	00 00 00 
  8004202788:	ff d0                	callq  *%rax
	//panic("i386_vm_init: This function is not finished\n");
	//////////////////////////////////////////////////////////////////////
	// create initial page directory.

	pml4e = boot_alloc(PGSIZE);
  800420278a:	bf 00 10 00 00       	mov    $0x1000,%edi
  800420278f:	48 b8 22 26 20 04 80 	movabs $0x8004202622,%rax
  8004202796:	00 00 00 
  8004202799:	ff d0                	callq  *%rax
  800420279b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	memset(pml4e, 0, PGSIZE);
  800420279f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042027a3:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042027a8:	be 00 00 00 00       	mov    $0x0,%esi
  80042027ad:	48 89 c7             	mov    %rax,%rdi
  80042027b0:	48 b8 d4 03 21 04 80 	movabs $0x80042103d4,%rax
  80042027b7:	00 00 00 
  80042027ba:	ff d0                	callq  *%rax
	boot_pml4e = pml4e;
  80042027bc:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  80042027c3:	00 00 00 
  80042027c6:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042027ca:	48 89 10             	mov    %rdx,(%rax)
	boot_cr3 = PADDR(pml4e);
  80042027cd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042027d1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042027d5:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042027dc:	00 00 00 
  80042027df:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  80042027e3:	77 32                	ja     8004202817 <x64_vm_init+0xa1>
  80042027e5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042027e9:	48 89 c1             	mov    %rax,%rcx
  80042027ec:	48 ba d8 92 21 04 80 	movabs $0x80042192d8,%rdx
  80042027f3:	00 00 00 
  80042027f6:	be 10 01 00 00       	mov    $0x110,%esi
  80042027fb:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004202802:	00 00 00 
  8004202805:	b8 00 00 00 00       	mov    $0x0,%eax
  800420280a:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004202811:	00 00 00 
  8004202814:	41 ff d0             	callq  *%r8
  8004202817:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420281e:	ff ff ff 
  8004202821:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202825:	48 01 c2             	add    %rax,%rdx
  8004202828:	48 b8 e0 c5 69 04 80 	movabs $0x800469c5e0,%rax
  800420282f:	00 00 00 
  8004202832:	48 89 10             	mov    %rdx,(%rax)
	// The kernel uses this array to keep track of physical pages: for
	// each physical page, there is a corresponding struct PageInfo in this
	// array.  'npages' is the number of physical pages in memory.
	// Your code goes here:

	n = npages * sizeof(struct PageInfo);
  8004202835:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  800420283c:	00 00 00 
  800420283f:	48 8b 00             	mov    (%rax),%rax
  8004202842:	48 c1 e0 04          	shl    $0x4,%rax
  8004202846:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	pages = (struct PageInfo *) boot_alloc(n);
  800420284a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420284e:	89 c7                	mov    %eax,%edi
  8004202850:	48 b8 22 26 20 04 80 	movabs $0x8004202622,%rax
  8004202857:	00 00 00 
  800420285a:	ff d0                	callq  *%rax
  800420285c:	48 ba f8 c5 69 04 80 	movabs $0x800469c5f8,%rdx
  8004202863:	00 00 00 
  8004202866:	48 89 02             	mov    %rax,(%rdx)
	memset(pages, 0, n);
  8004202869:	48 b8 f8 c5 69 04 80 	movabs $0x800469c5f8,%rax
  8004202870:	00 00 00 
  8004202873:	48 8b 00             	mov    (%rax),%rax
  8004202876:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420287a:	be 00 00 00 00       	mov    $0x0,%esi
  800420287f:	48 89 c7             	mov    %rax,%rdi
  8004202882:	48 b8 d4 03 21 04 80 	movabs $0x80042103d4,%rax
  8004202889:	00 00 00 
  800420288c:	ff d0                	callq  *%rax

	//////////////////////////////////////////////////////////////////////
	// Make 'envs' point to an array of size 'NENV' of 'struct Env'.
	// LAB 3: Your code here.

	envs    = boot_alloc(sizeof(struct Env)*NENV);
  800420288e:	bf 00 a0 05 00       	mov    $0x5a000,%edi
  8004202893:	48 b8 22 26 20 04 80 	movabs $0x8004202622,%rax
  800420289a:	00 00 00 
  800420289d:	ff d0                	callq  *%rax
  800420289f:	48 ba 58 d2 49 04 80 	movabs $0x800449d258,%rdx
  80042028a6:	00 00 00 
  80042028a9:	48 89 02             	mov    %rax,(%rdx)
	memset(envs, 0, sizeof(struct Env)*NENV);
  80042028ac:	48 b8 58 d2 49 04 80 	movabs $0x800449d258,%rax
  80042028b3:	00 00 00 
  80042028b6:	48 8b 00             	mov    (%rax),%rax
  80042028b9:	ba 00 a0 05 00       	mov    $0x5a000,%edx
  80042028be:	be 00 00 00 00       	mov    $0x0,%esi
  80042028c3:	48 89 c7             	mov    %rax,%rdi
  80042028c6:	48 b8 d4 03 21 04 80 	movabs $0x80042103d4,%rax
  80042028cd:	00 00 00 
  80042028d0:	ff d0                	callq  *%rax
	//////////////////////////////////////////////////////////////////////
	// Now that we've allocated the initial kernel data structures, we set
	// up the list of free physical pages. Once we've done so, all further
	// memory management will go through the page_* functions. In
	// particular, we can now map memory using boot_map_region or page_insert
	page_init();
  80042028d2:	48 b8 30 2d 20 04 80 	movabs $0x8004202d30,%rax
  80042028d9:	00 00 00 
  80042028dc:	ff d0                	callq  *%rax
	//    - the new image at UPAGES -- kernel R, us/er R
	//      (ie. perm = PTE_U | PTE_P)
	//    - pages itself -- kernel RW, user NONE
	// Your code goes here:

	n = npages*sizeof(struct PageInfo);
  80042028de:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  80042028e5:	00 00 00 
  80042028e8:	48 8b 00             	mov    (%rax),%rax
  80042028eb:	48 c1 e0 04          	shl    $0x4,%rax
  80042028ef:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	boot_map_region(boot_pml4e, UPAGES, n, PADDR(pages), PTE_U);
  80042028f3:	48 b8 f8 c5 69 04 80 	movabs $0x800469c5f8,%rax
  80042028fa:	00 00 00 
  80042028fd:	48 8b 00             	mov    (%rax),%rax
  8004202900:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004202904:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420290b:	00 00 00 
  800420290e:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  8004202912:	77 32                	ja     8004202946 <x64_vm_init+0x1d0>
  8004202914:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202918:	48 89 c1             	mov    %rax,%rcx
  800420291b:	48 ba d8 92 21 04 80 	movabs $0x80042192d8,%rdx
  8004202922:	00 00 00 
  8004202925:	be 3a 01 00 00       	mov    $0x13a,%esi
  800420292a:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004202931:	00 00 00 
  8004202934:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202939:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004202940:	00 00 00 
  8004202943:	41 ff d0             	callq  *%r8
  8004202946:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420294d:	ff ff ff 
  8004202950:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202954:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  8004202958:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  800420295f:	00 00 00 
  8004202962:	48 8b 00             	mov    (%rax),%rax
  8004202965:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004202969:	41 b8 04 00 00 00    	mov    $0x4,%r8d
  800420296f:	48 be 00 00 a0 00 80 	movabs $0x8000a00000,%rsi
  8004202976:	00 00 00 
  8004202979:	48 89 c7             	mov    %rax,%rdi
  800420297c:	48 b8 6f 38 20 04 80 	movabs $0x800420386f,%rax
  8004202983:	00 00 00 
  8004202986:	ff d0                	callq  *%rax
	// Permissions:
	//    - the new image at UENVS  -- kernel R, user R
	//    - envs itself -- kernel RW, user NONE
	// LAB 3: Your code here.

	n   = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
  8004202988:	48 c7 45 d8 00 10 00 	movq   $0x1000,-0x28(%rbp)
  800420298f:	00 
  8004202990:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202994:	48 05 ff 9f 05 00    	add    $0x59fff,%rax
  800420299a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  800420299e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042029a2:	ba 00 00 00 00       	mov    $0x0,%edx
  80042029a7:	48 f7 75 d8          	divq   -0x28(%rbp)
  80042029ab:	48 89 d0             	mov    %rdx,%rax
  80042029ae:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042029b2:	48 29 c2             	sub    %rax,%rdx
  80042029b5:	48 89 d0             	mov    %rdx,%rax
  80042029b8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	boot_map_region(boot_pml4e, UENVS, n, PADDR(envs), PTE_U|PTE_P);
  80042029bc:	48 b8 58 d2 49 04 80 	movabs $0x800449d258,%rax
  80042029c3:	00 00 00 
  80042029c6:	48 8b 00             	mov    (%rax),%rax
  80042029c9:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  80042029cd:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042029d4:	00 00 00 
  80042029d7:	48 39 45 c8          	cmp    %rax,-0x38(%rbp)
  80042029db:	77 32                	ja     8004202a0f <x64_vm_init+0x299>
  80042029dd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042029e1:	48 89 c1             	mov    %rax,%rcx
  80042029e4:	48 ba d8 92 21 04 80 	movabs $0x80042192d8,%rdx
  80042029eb:	00 00 00 
  80042029ee:	be 47 01 00 00       	mov    $0x147,%esi
  80042029f3:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  80042029fa:	00 00 00 
  80042029fd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202a02:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004202a09:	00 00 00 
  8004202a0c:	41 ff d0             	callq  *%r8
  8004202a0f:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202a16:	ff ff ff 
  8004202a19:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202a1d:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  8004202a21:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  8004202a28:	00 00 00 
  8004202a2b:	48 8b 00             	mov    (%rax),%rax
  8004202a2e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004202a32:	41 b8 05 00 00 00    	mov    $0x5,%r8d
  8004202a38:	48 be 00 00 80 00 80 	movabs $0x8000800000,%rsi
  8004202a3f:	00 00 00 
  8004202a42:	48 89 c7             	mov    %rax,%rdi
  8004202a45:	48 b8 6f 38 20 04 80 	movabs $0x800420386f,%rax
  8004202a4c:	00 00 00 
  8004202a4f:	ff d0                	callq  *%rax
	//       the kernel overflows its stack, it will fault rather than
	//       overwrite memory.  Known as a "guard page".
	//     Permissions: kernel RW, user NONE
	// Your code goes here:

	boot_map_region(boot_pml4e, KSTACKTOP-KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W|PTE_P);
  8004202a51:	48 b8 00 c0 21 04 80 	movabs $0x800421c000,%rax
  8004202a58:	00 00 00 
  8004202a5b:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004202a5f:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202a66:	00 00 00 
  8004202a69:	48 39 45 c0          	cmp    %rax,-0x40(%rbp)
  8004202a6d:	77 32                	ja     8004202aa1 <x64_vm_init+0x32b>
  8004202a6f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202a73:	48 89 c1             	mov    %rax,%rcx
  8004202a76:	48 ba d8 92 21 04 80 	movabs $0x80042192d8,%rdx
  8004202a7d:	00 00 00 
  8004202a80:	be 57 01 00 00       	mov    $0x157,%esi
  8004202a85:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004202a8c:	00 00 00 
  8004202a8f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202a94:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004202a9b:	00 00 00 
  8004202a9e:	41 ff d0             	callq  *%r8
  8004202aa1:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202aa8:	ff ff ff 
  8004202aab:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202aaf:	48 01 c2             	add    %rax,%rdx
  8004202ab2:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  8004202ab9:	00 00 00 
  8004202abc:	48 8b 00             	mov    (%rax),%rax
  8004202abf:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  8004202ac5:	48 89 d1             	mov    %rdx,%rcx
  8004202ac8:	ba 00 00 01 00       	mov    $0x10000,%edx
  8004202acd:	48 be 00 00 ff 03 80 	movabs $0x8003ff0000,%rsi
  8004202ad4:	00 00 00 
  8004202ad7:	48 89 c7             	mov    %rax,%rdi
  8004202ada:	48 b8 6f 38 20 04 80 	movabs $0x800420386f,%rax
  8004202ae1:	00 00 00 
  8004202ae4:	ff d0                	callq  *%rax
	// Ie.  the VA range [KERNBASE, npages*PGSIZE) should map to
	//      the PA range [0, npages*PGSIZE)
	// Permissions: kernel RW, user NONE
	// Your code goes here: 

	boot_map_region(boot_pml4e, KERNBASE, npages*PGSIZE, 0, PTE_W|PTE_P);
  8004202ae6:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  8004202aed:	00 00 00 
  8004202af0:	48 8b 00             	mov    (%rax),%rax
  8004202af3:	48 c1 e0 0c          	shl    $0xc,%rax
  8004202af7:	48 89 c2             	mov    %rax,%rdx
  8004202afa:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  8004202b01:	00 00 00 
  8004202b04:	48 8b 00             	mov    (%rax),%rax
  8004202b07:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  8004202b0d:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004202b12:	48 be 00 00 00 04 80 	movabs $0x8004000000,%rsi
  8004202b19:	00 00 00 
  8004202b1c:	48 89 c7             	mov    %rax,%rdi
  8004202b1f:	48 b8 6f 38 20 04 80 	movabs $0x800420386f,%rax
  8004202b26:	00 00 00 
  8004202b29:	ff d0                	callq  *%rax

	// Check that the initial page directory has been set up correctly.

	// Initialize the SMP-related parts of the memory map
	mem_init_mp();
  8004202b2b:	48 b8 45 2c 20 04 80 	movabs $0x8004202c45,%rax
  8004202b32:	00 00 00 
  8004202b35:	ff d0                	callq  *%rax



	//////////////////////////////////////////////////////////////////////
	// Permissions: kernel RW, user NONE
	pdpe_t *pdpe = KADDR(PTE_ADDR(pml4e[1]));
  8004202b37:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202b3b:	48 83 c0 08          	add    $0x8,%rax
  8004202b3f:	48 8b 00             	mov    (%rax),%rax
  8004202b42:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004202b48:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  8004202b4c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202b50:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202b54:	89 45 b4             	mov    %eax,-0x4c(%rbp)
  8004202b57:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  8004202b5a:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  8004202b61:	00 00 00 
  8004202b64:	48 8b 00             	mov    (%rax),%rax
  8004202b67:	48 39 c2             	cmp    %rax,%rdx
  8004202b6a:	72 32                	jb     8004202b9e <x64_vm_init+0x428>
  8004202b6c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202b70:	48 89 c1             	mov    %rax,%rcx
  8004202b73:	48 ba 28 91 21 04 80 	movabs $0x8004219128,%rdx
  8004202b7a:	00 00 00 
  8004202b7d:	be 6e 01 00 00       	mov    $0x16e,%esi
  8004202b82:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004202b89:	00 00 00 
  8004202b8c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202b91:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004202b98:	00 00 00 
  8004202b9b:	41 ff d0             	callq  *%r8
  8004202b9e:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202ba5:	00 00 00 
  8004202ba8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202bac:	48 01 d0             	add    %rdx,%rax
  8004202baf:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	pde_t *pgdir = KADDR(PTE_ADDR(pdpe[0]));
  8004202bb3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004202bb7:	48 8b 00             	mov    (%rax),%rax
  8004202bba:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004202bc0:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  8004202bc4:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004202bc8:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202bcc:	89 45 9c             	mov    %eax,-0x64(%rbp)
  8004202bcf:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004202bd2:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  8004202bd9:	00 00 00 
  8004202bdc:	48 8b 00             	mov    (%rax),%rax
  8004202bdf:	48 39 c2             	cmp    %rax,%rdx
  8004202be2:	72 32                	jb     8004202c16 <x64_vm_init+0x4a0>
  8004202be4:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004202be8:	48 89 c1             	mov    %rax,%rcx
  8004202beb:	48 ba 28 91 21 04 80 	movabs $0x8004219128,%rdx
  8004202bf2:	00 00 00 
  8004202bf5:	be 6f 01 00 00       	mov    $0x16f,%esi
  8004202bfa:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004202c01:	00 00 00 
  8004202c04:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202c09:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004202c10:	00 00 00 
  8004202c13:	41 ff d0             	callq  *%r8
  8004202c16:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202c1d:	00 00 00 
  8004202c20:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004202c24:	48 01 d0             	add    %rdx,%rax
  8004202c27:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	lcr3(boot_cr3);
  8004202c2b:	48 b8 e0 c5 69 04 80 	movabs $0x800469c5e0,%rax
  8004202c32:	00 00 00 
  8004202c35:	48 8b 00             	mov    (%rax),%rax
  8004202c38:	48 89 45 88          	mov    %rax,-0x78(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  8004202c3c:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004202c40:	0f 22 d8             	mov    %rax,%cr3
}
  8004202c43:	c9                   	leaveq 
  8004202c44:	c3                   	retq   

0000008004202c45 <mem_init_mp>:
// Modify mappings in boot_pml4e to support SMP
//   - Map the per-CPU stacks in the region [KSTACKTOP-PTSIZE, KSTACKTOP)
//
static void
mem_init_mp(void)
{
  8004202c45:	55                   	push   %rbp
  8004202c46:	48 89 e5             	mov    %rsp,%rbp
  8004202c49:	48 83 ec 20          	sub    $0x20,%rsp
	// LAB 4: Your code here:


	int i;
	uintptr_t kstacktop;
	for (i = 0; i < NCPU; i++) {
  8004202c4d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004202c54:	e9 cb 00 00 00       	jmpq   8004202d24 <mem_init_mp+0xdf>
		kstacktop = KSTACKTOP - (KSTKSIZE + KSTKGAP) * i;
  8004202c59:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004202c5c:	89 d0                	mov    %edx,%eax
  8004202c5e:	01 c0                	add    %eax,%eax
  8004202c60:	01 d0                	add    %edx,%eax
  8004202c62:	c1 e0 0f             	shl    $0xf,%eax
  8004202c65:	48 98                	cltq   
  8004202c67:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202c6e:	00 00 00 
  8004202c71:	48 29 c2             	sub    %rax,%rdx
  8004202c74:	48 89 d0             	mov    %rdx,%rax
  8004202c77:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		boot_map_region(boot_pml4e, kstacktop - KSTKSIZE, KSTKSIZE,
				PADDR(percpu_kstacks[i]), PTE_P|PTE_W);
  8004202c7b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004202c7e:	48 98                	cltq   
  8004202c80:	48 c1 e0 10          	shl    $0x10,%rax
  8004202c84:	48 89 c2             	mov    %rax,%rdx
  8004202c87:	48 b8 00 f0 69 04 80 	movabs $0x800469f000,%rax
  8004202c8e:	00 00 00 
  8004202c91:	48 01 d0             	add    %rdx,%rax
  8004202c94:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004202c98:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202c9f:	00 00 00 
  8004202ca2:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  8004202ca6:	77 32                	ja     8004202cda <mem_init_mp+0x95>
  8004202ca8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202cac:	48 89 c1             	mov    %rax,%rcx
  8004202caf:	48 ba d8 92 21 04 80 	movabs $0x80042192d8,%rdx
  8004202cb6:	00 00 00 
  8004202cb9:	be 92 01 00 00       	mov    $0x192,%esi
  8004202cbe:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004202cc5:	00 00 00 
  8004202cc8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202ccd:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004202cd4:	00 00 00 
  8004202cd7:	41 ff d0             	callq  *%r8
  8004202cda:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202ce1:	ff ff ff 
  8004202ce4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202ce8:	48 01 c2             	add    %rax,%rdx

	int i;
	uintptr_t kstacktop;
	for (i = 0; i < NCPU; i++) {
		kstacktop = KSTACKTOP - (KSTKSIZE + KSTKGAP) * i;
		boot_map_region(boot_pml4e, kstacktop - KSTKSIZE, KSTKSIZE,
  8004202ceb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202cef:	48 8d b0 00 00 ff ff 	lea    -0x10000(%rax),%rsi
  8004202cf6:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  8004202cfd:	00 00 00 
  8004202d00:	48 8b 00             	mov    (%rax),%rax
  8004202d03:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  8004202d09:	48 89 d1             	mov    %rdx,%rcx
  8004202d0c:	ba 00 00 01 00       	mov    $0x10000,%edx
  8004202d11:	48 89 c7             	mov    %rax,%rdi
  8004202d14:	48 b8 6f 38 20 04 80 	movabs $0x800420386f,%rax
  8004202d1b:	00 00 00 
  8004202d1e:	ff d0                	callq  *%rax
	// LAB 4: Your code here:


	int i;
	uintptr_t kstacktop;
	for (i = 0; i < NCPU; i++) {
  8004202d20:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004202d24:	83 7d fc 03          	cmpl   $0x3,-0x4(%rbp)
  8004202d28:	0f 8e 2b ff ff ff    	jle    8004202c59 <mem_init_mp+0x14>
		kstacktop = KSTACKTOP - (KSTKSIZE + KSTKGAP) * i;
		boot_map_region(boot_pml4e, kstacktop - KSTKSIZE, KSTKSIZE,
				PADDR(percpu_kstacks[i]), PTE_P|PTE_W);
	}

}
  8004202d2e:	c9                   	leaveq 
  8004202d2f:	c3                   	retq   

0000008004202d30 <page_init>:
// allocator functions below to allocate and deallocate physical
// memory via the page_free_list.
//
void
page_init(void)
{
  8004202d30:	55                   	push   %rbp
  8004202d31:	48 89 e5             	mov    %rsp,%rbp
  8004202d34:	48 83 ec 50          	sub    $0x50,%rsp
	// LAB 4:
	// Change your code to mark the physical page at MPENTRY_PADDR
	// as in use


	void *nextfree = boot_alloc(0);
  8004202d38:	bf 00 00 00 00       	mov    $0x0,%edi
  8004202d3d:	48 b8 22 26 20 04 80 	movabs $0x8004202622,%rax
  8004202d44:	00 00 00 
  8004202d47:	ff d0                	callq  *%rax
  8004202d49:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	size_t i;
	int inuse;
	struct PageInfo* last = NULL;
  8004202d4d:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004202d54:	00 
	for (i = 0; i < npages; i++) {
  8004202d55:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004202d5c:	00 
  8004202d5d:	e9 65 02 00 00       	jmpq   8004202fc7 <page_init+0x297>
		// Off-limits until proven otherwise.
		inuse = 1;
  8004202d62:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)

		// The bottom basemem bytes are free except page 0.
		if (i != 0 && i < npages_basemem)
  8004202d69:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004202d6e:	74 1a                	je     8004202d8a <page_init+0x5a>
  8004202d70:	48 b8 30 d2 49 04 80 	movabs $0x800449d230,%rax
  8004202d77:	00 00 00 
  8004202d7a:	48 8b 00             	mov    (%rax),%rax
  8004202d7d:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004202d81:	73 07                	jae    8004202d8a <page_init+0x5a>
			inuse = 0;
  8004202d83:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

		// Mark physical page at MPENTRY_PADDR as in use
		if (i == MPENTRY_PADDR / PGSIZE)
  8004202d8a:	48 83 7d f8 07       	cmpq   $0x7,-0x8(%rbp)
  8004202d8f:	75 07                	jne    8004202d98 <page_init+0x68>
			inuse = 1;
  8004202d91:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)


		// The IO hole and the kernel are non empty but
		// The memory past the kernel is free.
		if (i >= PADDR(nextfree) / PGSIZE)
  8004202d98:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202d9c:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004202da0:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202da7:	00 00 00 
  8004202daa:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  8004202dae:	77 32                	ja     8004202de2 <page_init+0xb2>
  8004202db0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202db4:	48 89 c1             	mov    %rax,%rcx
  8004202db7:	48 ba d8 92 21 04 80 	movabs $0x80042192d8,%rdx
  8004202dbe:	00 00 00 
  8004202dc1:	be c0 01 00 00       	mov    $0x1c0,%esi
  8004202dc6:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004202dcd:	00 00 00 
  8004202dd0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202dd5:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004202ddc:	00 00 00 
  8004202ddf:	41 ff d0             	callq  *%r8
  8004202de2:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202de9:	ff ff ff 
  8004202dec:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202df0:	48 01 d0             	add    %rdx,%rax
  8004202df3:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202df7:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004202dfb:	77 07                	ja     8004202e04 <page_init+0xd4>
			inuse = 0;
  8004202dfd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

		uint64_t va = KERNBASE + i*PGSIZE;
  8004202e04:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202e08:	48 05 00 40 00 08    	add    $0x8004000,%rax
  8004202e0e:	48 c1 e0 0c          	shl    $0xc,%rax
  8004202e12:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if (va>=BOOT_PAGE_TABLE_START && va<BOOT_PAGE_TABLE_END)
  8004202e16:	48 b8 00 20 10 00 00 	movabs $0x102000,%rax
  8004202e1d:	00 00 00 
  8004202e20:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004202e24:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202e28:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202e2c:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  8004202e2f:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004202e32:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  8004202e39:	00 00 00 
  8004202e3c:	48 8b 00             	mov    (%rax),%rax
  8004202e3f:	48 39 c2             	cmp    %rax,%rdx
  8004202e42:	72 32                	jb     8004202e76 <page_init+0x146>
  8004202e44:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202e48:	48 89 c1             	mov    %rax,%rcx
  8004202e4b:	48 ba 28 91 21 04 80 	movabs $0x8004219128,%rdx
  8004202e52:	00 00 00 
  8004202e55:	be c4 01 00 00       	mov    $0x1c4,%esi
  8004202e5a:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004202e61:	00 00 00 
  8004202e64:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202e69:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004202e70:	00 00 00 
  8004202e73:	41 ff d0             	callq  *%r8
  8004202e76:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202e7d:	00 00 00 
  8004202e80:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202e84:	48 01 d0             	add    %rdx,%rax
  8004202e87:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004202e8b:	0f 87 84 00 00 00    	ja     8004202f15 <page_init+0x1e5>
  8004202e91:	48 b8 00 20 10 00 00 	movabs $0x102000,%rax
  8004202e98:	00 00 00 
  8004202e9b:	48 05 00 50 00 00    	add    $0x5000,%rax
  8004202ea1:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  8004202ea5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202ea9:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202ead:	89 45 b4             	mov    %eax,-0x4c(%rbp)
  8004202eb0:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  8004202eb3:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  8004202eba:	00 00 00 
  8004202ebd:	48 8b 00             	mov    (%rax),%rax
  8004202ec0:	48 39 c2             	cmp    %rax,%rdx
  8004202ec3:	72 32                	jb     8004202ef7 <page_init+0x1c7>
  8004202ec5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202ec9:	48 89 c1             	mov    %rax,%rcx
  8004202ecc:	48 ba 28 91 21 04 80 	movabs $0x8004219128,%rdx
  8004202ed3:	00 00 00 
  8004202ed6:	be c4 01 00 00       	mov    $0x1c4,%esi
  8004202edb:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004202ee2:	00 00 00 
  8004202ee5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202eea:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004202ef1:	00 00 00 
  8004202ef4:	41 ff d0             	callq  *%r8
  8004202ef7:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202efe:	00 00 00 
  8004202f01:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202f05:	48 01 d0             	add    %rdx,%rax
  8004202f08:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004202f0c:	76 07                	jbe    8004202f15 <page_init+0x1e5>
			inuse = 1;
  8004202f0e:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)

		pages[i].pp_ref = inuse;
  8004202f15:	48 b8 f8 c5 69 04 80 	movabs $0x800469c5f8,%rax
  8004202f1c:	00 00 00 
  8004202f1f:	48 8b 00             	mov    (%rax),%rax
  8004202f22:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202f26:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202f2a:	48 01 c2             	add    %rax,%rdx
  8004202f2d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004202f30:	66 89 42 08          	mov    %ax,0x8(%rdx)
		pages[i].pp_link = NULL;
  8004202f34:	48 b8 f8 c5 69 04 80 	movabs $0x800469c5f8,%rax
  8004202f3b:	00 00 00 
  8004202f3e:	48 8b 00             	mov    (%rax),%rax
  8004202f41:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202f45:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202f49:	48 01 d0             	add    %rdx,%rax
  8004202f4c:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		if (!inuse) {
  8004202f53:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  8004202f57:	75 69                	jne    8004202fc2 <page_init+0x292>
			if (last)
  8004202f59:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004202f5e:	74 21                	je     8004202f81 <page_init+0x251>
				last->pp_link = &pages[i];
  8004202f60:	48 b8 f8 c5 69 04 80 	movabs $0x800469c5f8,%rax
  8004202f67:	00 00 00 
  8004202f6a:	48 8b 00             	mov    (%rax),%rax
  8004202f6d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202f71:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202f75:	48 01 c2             	add    %rax,%rdx
  8004202f78:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202f7c:	48 89 10             	mov    %rdx,(%rax)
  8004202f7f:	eb 25                	jmp    8004202fa6 <page_init+0x276>
			else
				page_free_list = &pages[i];
  8004202f81:	48 b8 f8 c5 69 04 80 	movabs $0x800469c5f8,%rax
  8004202f88:	00 00 00 
  8004202f8b:	48 8b 00             	mov    (%rax),%rax
  8004202f8e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202f92:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202f96:	48 01 c2             	add    %rax,%rdx
  8004202f99:	48 b8 38 d2 49 04 80 	movabs $0x800449d238,%rax
  8004202fa0:	00 00 00 
  8004202fa3:	48 89 10             	mov    %rdx,(%rax)
			last = &pages[i];
  8004202fa6:	48 b8 f8 c5 69 04 80 	movabs $0x800469c5f8,%rax
  8004202fad:	00 00 00 
  8004202fb0:	48 8b 00             	mov    (%rax),%rax
  8004202fb3:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202fb7:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202fbb:	48 01 d0             	add    %rdx,%rax
  8004202fbe:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	void *nextfree = boot_alloc(0);
	size_t i;
	int inuse;
	struct PageInfo* last = NULL;
	for (i = 0; i < npages; i++) {
  8004202fc2:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004202fc7:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  8004202fce:	00 00 00 
  8004202fd1:	48 8b 00             	mov    (%rax),%rax
  8004202fd4:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004202fd8:	0f 82 84 fd ff ff    	jb     8004202d62 <page_init+0x32>
		}

	}


}
  8004202fde:	c9                   	leaveq 
  8004202fdf:	c3                   	retq   

0000008004202fe0 <page_alloc>:
// Returns NULL if out of free memory.
//
// Hint: use page2kva and memset
struct PageInfo *
page_alloc(int alloc_flags)
{
  8004202fe0:	55                   	push   %rbp
  8004202fe1:	48 89 e5             	mov    %rsp,%rbp
  8004202fe4:	48 83 ec 20          	sub    $0x20,%rsp
  8004202fe8:	89 7d ec             	mov    %edi,-0x14(%rbp)
	// Fill this function in

	struct PageInfo *pp = page_free_list;
  8004202feb:	48 b8 38 d2 49 04 80 	movabs $0x800449d238,%rax
  8004202ff2:	00 00 00 
  8004202ff5:	48 8b 00             	mov    (%rax),%rax
  8004202ff8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (pp) {
  8004202ffc:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203001:	74 5e                	je     8004203061 <page_alloc+0x81>
		//cprintf("alloc new page: struct page %x va %x pa %x \n", pp, page2kva(pp), page2pa(pp));
		page_free_list = page_free_list->pp_link;
  8004203003:	48 b8 38 d2 49 04 80 	movabs $0x800449d238,%rax
  800420300a:	00 00 00 
  800420300d:	48 8b 00             	mov    (%rax),%rax
  8004203010:	48 8b 10             	mov    (%rax),%rdx
  8004203013:	48 b8 38 d2 49 04 80 	movabs $0x800449d238,%rax
  800420301a:	00 00 00 
  800420301d:	48 89 10             	mov    %rdx,(%rax)
		pp->pp_link = NULL;
  8004203020:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203024:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		if (alloc_flags & ALLOC_ZERO)
  800420302b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420302e:	83 e0 01             	and    $0x1,%eax
  8004203031:	85 c0                	test   %eax,%eax
  8004203033:	74 2c                	je     8004203061 <page_alloc+0x81>
			memset(page2kva(pp), 0, PGSIZE);
  8004203035:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203039:	48 89 c7             	mov    %rax,%rdi
  800420303c:	48 b8 f9 1c 20 04 80 	movabs $0x8004201cf9,%rax
  8004203043:	00 00 00 
  8004203046:	ff d0                	callq  *%rax
  8004203048:	ba 00 10 00 00       	mov    $0x1000,%edx
  800420304d:	be 00 00 00 00       	mov    $0x0,%esi
  8004203052:	48 89 c7             	mov    %rax,%rdi
  8004203055:	48 b8 d4 03 21 04 80 	movabs $0x80042103d4,%rax
  800420305c:	00 00 00 
  800420305f:	ff d0                	callq  *%rax
	}
	return pp;
  8004203061:	48 8b 45 f8          	mov    -0x8(%rbp),%rax

}
  8004203065:	c9                   	leaveq 
  8004203066:	c3                   	retq   

0000008004203067 <page_initpp>:
// The result has null links and 0 refcount.
// Note that the corresponding physical page is NOT initialized!
//
static void
page_initpp(struct PageInfo *pp)
{
  8004203067:	55                   	push   %rbp
  8004203068:	48 89 e5             	mov    %rsp,%rbp
  800420306b:	48 83 ec 10          	sub    $0x10,%rsp
  800420306f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	memset(pp, 0, sizeof(*pp));
  8004203073:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203077:	ba 10 00 00 00       	mov    $0x10,%edx
  800420307c:	be 00 00 00 00       	mov    $0x0,%esi
  8004203081:	48 89 c7             	mov    %rax,%rdi
  8004203084:	48 b8 d4 03 21 04 80 	movabs $0x80042103d4,%rax
  800420308b:	00 00 00 
  800420308e:	ff d0                	callq  *%rax
}
  8004203090:	c9                   	leaveq 
  8004203091:	c3                   	retq   

0000008004203092 <page_free>:
// Return a page to the free list.
// (This function should only be called when pp->pp_ref reaches 0.)
//
void
page_free(struct PageInfo *pp)
{
  8004203092:	55                   	push   %rbp
  8004203093:	48 89 e5             	mov    %rsp,%rbp
  8004203096:	48 83 ec 10          	sub    $0x10,%rsp
  800420309a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)

	if (pp->pp_ref || pp->pp_link) {
  800420309e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042030a2:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042030a6:	66 85 c0             	test   %ax,%ax
  80042030a9:	75 0c                	jne    80042030b7 <page_free+0x25>
  80042030ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042030af:	48 8b 00             	mov    (%rax),%rax
  80042030b2:	48 85 c0             	test   %rax,%rax
  80042030b5:	74 2c                	je     80042030e3 <page_free+0x51>
		warn("page_free: attempt to free mapped page");
  80042030b7:	48 ba 00 93 21 04 80 	movabs $0x8004219300,%rdx
  80042030be:	00 00 00 
  80042030c1:	be 06 02 00 00       	mov    $0x206,%esi
  80042030c6:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  80042030cd:	00 00 00 
  80042030d0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042030d5:	48 b9 1b 07 20 04 80 	movabs $0x800420071b,%rcx
  80042030dc:	00 00 00 
  80042030df:	ff d1                	callq  *%rcx
		return;		/* be conservative and assume page is still used */
  80042030e1:	eb 2f                	jmp    8004203112 <page_free+0x80>
	}
	pp->pp_link = page_free_list;
  80042030e3:	48 b8 38 d2 49 04 80 	movabs $0x800449d238,%rax
  80042030ea:	00 00 00 
  80042030ed:	48 8b 10             	mov    (%rax),%rdx
  80042030f0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042030f4:	48 89 10             	mov    %rdx,(%rax)
	page_free_list = pp;
  80042030f7:	48 b8 38 d2 49 04 80 	movabs $0x800449d238,%rax
  80042030fe:	00 00 00 
  8004203101:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203105:	48 89 10             	mov    %rdx,(%rax)
	pp->pp_ref = 0;
  8004203108:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420310c:	66 c7 40 08 00 00    	movw   $0x0,0x8(%rax)

}
  8004203112:	c9                   	leaveq 
  8004203113:	c3                   	retq   

0000008004203114 <page_decref>:
// Decrement the reference count on a page,
// freeing it if there are no more refs.
//
void
page_decref(struct PageInfo* pp)
{
  8004203114:	55                   	push   %rbp
  8004203115:	48 89 e5             	mov    %rsp,%rbp
  8004203118:	48 83 ec 10          	sub    $0x10,%rsp
  800420311c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (--pp->pp_ref == 0)
  8004203120:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203124:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203128:	8d 50 ff             	lea    -0x1(%rax),%edx
  800420312b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420312f:	66 89 50 08          	mov    %dx,0x8(%rax)
  8004203133:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203137:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420313b:	66 85 c0             	test   %ax,%ax
  800420313e:	75 13                	jne    8004203153 <page_decref+0x3f>
		page_free(pp);
  8004203140:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203144:	48 89 c7             	mov    %rax,%rdi
  8004203147:	48 b8 92 30 20 04 80 	movabs $0x8004203092,%rax
  800420314e:	00 00 00 
  8004203151:	ff d0                	callq  *%rax
}
  8004203153:	c9                   	leaveq 
  8004203154:	c3                   	retq   

0000008004203155 <pml4e_walk>:
// table, page directory,page directory pointer and pml4 entries.
//

pte_t *
pml4e_walk(pml4e_t *pml4e, const void *va, int create)
{
  8004203155:	55                   	push   %rbp
  8004203156:	48 89 e5             	mov    %rsp,%rbp
  8004203159:	53                   	push   %rbx
  800420315a:	48 83 ec 68          	sub    $0x68,%rsp
  800420315e:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004203162:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  8004203166:	89 55 9c             	mov    %edx,-0x64(%rbp)

	if (pml4e) {
  8004203169:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  800420316e:	0f 84 4e 02 00 00    	je     80042033c2 <pml4e_walk+0x26d>
		pdpe_t *pdpe  = (pdpe_t *)pml4e [PML4(va)];
  8004203174:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004203178:	48 c1 e8 27          	shr    $0x27,%rax
  800420317c:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203181:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203188:	00 
  8004203189:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420318d:	48 01 d0             	add    %rdx,%rax
  8004203190:	48 8b 00             	mov    (%rax),%rax
  8004203193:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		if (!((physaddr_t)pdpe & PTE_P) && create) {
  8004203197:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420319b:	83 e0 01             	and    $0x1,%eax
  800420319e:	48 85 c0             	test   %rax,%rax
  80042031a1:	0f 85 7f 01 00 00    	jne    8004203326 <pml4e_walk+0x1d1>
  80042031a7:	83 7d 9c 00          	cmpl   $0x0,-0x64(%rbp)
  80042031ab:	0f 84 75 01 00 00    	je     8004203326 <pml4e_walk+0x1d1>
			struct PageInfo *page   = NULL;
  80042031b1:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  80042031b8:	00 
			if ((page = page_alloc(ALLOC_ZERO))) {
  80042031b9:	bf 01 00 00 00       	mov    $0x1,%edi
  80042031be:	48 b8 e0 2f 20 04 80 	movabs $0x8004202fe0,%rax
  80042031c5:	00 00 00 
  80042031c8:	ff d0                	callq  *%rax
  80042031ca:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042031ce:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042031d3:	0f 84 43 01 00 00    	je     800420331c <pml4e_walk+0x1c7>
				page->pp_ref    += 1;
  80042031d9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042031dd:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042031e1:	8d 50 01             	lea    0x1(%rax),%edx
  80042031e4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042031e8:	66 89 50 08          	mov    %dx,0x8(%rax)
				pml4e [PML4(va)] = page2pa(page)|PTE_U|PTE_W|PTE_P;
  80042031ec:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042031f0:	48 c1 e8 27          	shr    $0x27,%rax
  80042031f4:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042031f9:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203200:	00 
  8004203201:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203205:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  8004203209:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420320d:	48 89 c7             	mov    %rax,%rdi
  8004203210:	48 b8 63 1c 20 04 80 	movabs $0x8004201c63,%rax
  8004203217:	00 00 00 
  800420321a:	ff d0                	callq  *%rax
  800420321c:	48 83 c8 07          	or     $0x7,%rax
  8004203220:	48 89 03             	mov    %rax,(%rbx)
				pte_t *pte= pdpe_walk(KADDR((uintptr_t)((pdpe_t *)(PTE_ADDR(pml4e [PML4(va)])))),va,create);
  8004203223:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004203227:	48 c1 e8 27          	shr    $0x27,%rax
  800420322b:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203230:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203237:	00 
  8004203238:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420323c:	48 01 d0             	add    %rdx,%rax
  800420323f:	48 8b 00             	mov    (%rax),%rax
  8004203242:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203248:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420324c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203250:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203254:	89 45 d4             	mov    %eax,-0x2c(%rbp)
  8004203257:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  800420325a:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  8004203261:	00 00 00 
  8004203264:	48 8b 00             	mov    (%rax),%rax
  8004203267:	48 39 c2             	cmp    %rax,%rdx
  800420326a:	72 32                	jb     800420329e <pml4e_walk+0x149>
  800420326c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203270:	48 89 c1             	mov    %rax,%rcx
  8004203273:	48 ba 28 91 21 04 80 	movabs $0x8004219128,%rdx
  800420327a:	00 00 00 
  800420327d:	be 3e 02 00 00       	mov    $0x23e,%esi
  8004203282:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004203289:	00 00 00 
  800420328c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203291:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004203298:	00 00 00 
  800420329b:	41 ff d0             	callq  *%r8
  800420329e:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042032a5:	00 00 00 
  80042032a8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042032ac:	48 01 d0             	add    %rdx,%rax
  80042032af:	8b 55 9c             	mov    -0x64(%rbp),%edx
  80042032b2:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  80042032b6:	48 89 ce             	mov    %rcx,%rsi
  80042032b9:	48 89 c7             	mov    %rax,%rdi
  80042032bc:	48 b8 ce 33 20 04 80 	movabs $0x80042033ce,%rax
  80042032c3:	00 00 00 
  80042032c6:	ff d0                	callq  *%rax
  80042032c8:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
				if (pte!=NULL) return pte;
  80042032cc:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  80042032d1:	74 09                	je     80042032dc <pml4e_walk+0x187>
  80042032d3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042032d7:	e9 eb 00 00 00       	jmpq   80042033c7 <pml4e_walk+0x272>
				else{
					pml4e[PML4(va)] = 0;
  80042032dc:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042032e0:	48 c1 e8 27          	shr    $0x27,%rax
  80042032e4:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042032e9:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042032f0:	00 
  80042032f1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042032f5:	48 01 d0             	add    %rdx,%rax
  80042032f8:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
					page_decref(page);
  80042032ff:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203303:	48 89 c7             	mov    %rax,%rdi
  8004203306:	48 b8 14 31 20 04 80 	movabs $0x8004203114,%rax
  800420330d:	00 00 00 
  8004203310:	ff d0                	callq  *%rax
					return NULL;
  8004203312:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203317:	e9 ab 00 00 00       	jmpq   80042033c7 <pml4e_walk+0x272>
				}
			}else 
				return NULL;
  800420331c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203321:	e9 a1 00 00 00       	jmpq   80042033c7 <pml4e_walk+0x272>
		} else if ((uint64_t)pdpe & PTE_P) {
  8004203326:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420332a:	83 e0 01             	and    $0x1,%eax
  800420332d:	48 85 c0             	test   %rax,%rax
  8004203330:	0f 84 8c 00 00 00    	je     80042033c2 <pml4e_walk+0x26d>
			return pdpe_walk(KADDR((uintptr_t)((pdpe_t *)PTE_ADDR(pdpe))),va,create);
  8004203336:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420333a:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203340:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004203344:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203348:	48 c1 e8 0c          	shr    $0xc,%rax
  800420334c:	89 45 bc             	mov    %eax,-0x44(%rbp)
  800420334f:	8b 55 bc             	mov    -0x44(%rbp),%edx
  8004203352:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  8004203359:	00 00 00 
  800420335c:	48 8b 00             	mov    (%rax),%rax
  800420335f:	48 39 c2             	cmp    %rax,%rdx
  8004203362:	72 32                	jb     8004203396 <pml4e_walk+0x241>
  8004203364:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203368:	48 89 c1             	mov    %rax,%rcx
  800420336b:	48 ba 28 91 21 04 80 	movabs $0x8004219128,%rdx
  8004203372:	00 00 00 
  8004203375:	be 48 02 00 00       	mov    $0x248,%esi
  800420337a:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004203381:	00 00 00 
  8004203384:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203389:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004203390:	00 00 00 
  8004203393:	41 ff d0             	callq  *%r8
  8004203396:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420339d:	00 00 00 
  80042033a0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042033a4:	48 01 d0             	add    %rdx,%rax
  80042033a7:	8b 55 9c             	mov    -0x64(%rbp),%edx
  80042033aa:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  80042033ae:	48 89 ce             	mov    %rcx,%rsi
  80042033b1:	48 89 c7             	mov    %rax,%rdi
  80042033b4:	48 b8 ce 33 20 04 80 	movabs $0x80042033ce,%rax
  80042033bb:	00 00 00 
  80042033be:	ff d0                	callq  *%rax
  80042033c0:	eb 05                	jmp    80042033c7 <pml4e_walk+0x272>
		}
	}
	return NULL;
  80042033c2:	b8 00 00 00 00       	mov    $0x0,%eax

}
  80042033c7:	48 83 c4 68          	add    $0x68,%rsp
  80042033cb:	5b                   	pop    %rbx
  80042033cc:	5d                   	pop    %rbp
  80042033cd:	c3                   	retq   

00000080042033ce <pdpe_walk>:
// Given a pdpe i.e page directory pointer pdpe_walk returns the pointer to page table entry
// The programming logic in this function is similar to pml4e_walk.
// It calls the pgdir_walk which returns the page_table entry pointer.
// Hints are the same as in pml4e_walk
pte_t *
pdpe_walk(pdpe_t *pdpe,const void *va,int create){
  80042033ce:	55                   	push   %rbp
  80042033cf:	48 89 e5             	mov    %rsp,%rbp
  80042033d2:	53                   	push   %rbx
  80042033d3:	48 83 ec 68          	sub    $0x68,%rsp
  80042033d7:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  80042033db:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  80042033df:	89 55 9c             	mov    %edx,-0x64(%rbp)


	if (pdpe){
  80042033e2:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  80042033e7:	0f 84 4e 02 00 00    	je     800420363b <pdpe_walk+0x26d>
		pde_t * pdp = (pde_t *)pdpe[PDPE(va)];
  80042033ed:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042033f1:	48 c1 e8 1e          	shr    $0x1e,%rax
  80042033f5:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042033fa:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203401:	00 
  8004203402:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203406:	48 01 d0             	add    %rdx,%rax
  8004203409:	48 8b 00             	mov    (%rax),%rax
  800420340c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		if(!((physaddr_t)pdp & PTE_P) && create){
  8004203410:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203414:	83 e0 01             	and    $0x1,%eax
  8004203417:	48 85 c0             	test   %rax,%rax
  800420341a:	0f 85 7f 01 00 00    	jne    800420359f <pdpe_walk+0x1d1>
  8004203420:	83 7d 9c 00          	cmpl   $0x0,-0x64(%rbp)
  8004203424:	0f 84 75 01 00 00    	je     800420359f <pdpe_walk+0x1d1>
			struct PageInfo *page   = NULL;
  800420342a:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8004203431:	00 
			if ((page = page_alloc(ALLOC_ZERO))) {
  8004203432:	bf 01 00 00 00       	mov    $0x1,%edi
  8004203437:	48 b8 e0 2f 20 04 80 	movabs $0x8004202fe0,%rax
  800420343e:	00 00 00 
  8004203441:	ff d0                	callq  *%rax
  8004203443:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004203447:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420344c:	0f 84 43 01 00 00    	je     8004203595 <pdpe_walk+0x1c7>
				page->pp_ref    += 1;
  8004203452:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203456:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420345a:	8d 50 01             	lea    0x1(%rax),%edx
  800420345d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203461:	66 89 50 08          	mov    %dx,0x8(%rax)
				pdpe [PDPE(va)] = page2pa(page)|PTE_U|PTE_W|PTE_P;
  8004203465:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004203469:	48 c1 e8 1e          	shr    $0x1e,%rax
  800420346d:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203472:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203479:	00 
  800420347a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420347e:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  8004203482:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203486:	48 89 c7             	mov    %rax,%rdi
  8004203489:	48 b8 63 1c 20 04 80 	movabs $0x8004201c63,%rax
  8004203490:	00 00 00 
  8004203493:	ff d0                	callq  *%rax
  8004203495:	48 83 c8 07          	or     $0x7,%rax
  8004203499:	48 89 03             	mov    %rax,(%rbx)
				pte_t *pte = pgdir_walk(KADDR((uintptr_t)((pde_t *)PTE_ADDR(pdpe[PDPE(va)]))),va,create);
  800420349c:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042034a0:	48 c1 e8 1e          	shr    $0x1e,%rax
  80042034a4:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042034a9:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042034b0:	00 
  80042034b1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042034b5:	48 01 d0             	add    %rdx,%rax
  80042034b8:	48 8b 00             	mov    (%rax),%rax
  80042034bb:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042034c1:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042034c5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042034c9:	48 c1 e8 0c          	shr    $0xc,%rax
  80042034cd:	89 45 d4             	mov    %eax,-0x2c(%rbp)
  80042034d0:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  80042034d3:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  80042034da:	00 00 00 
  80042034dd:	48 8b 00             	mov    (%rax),%rax
  80042034e0:	48 39 c2             	cmp    %rax,%rdx
  80042034e3:	72 32                	jb     8004203517 <pdpe_walk+0x149>
  80042034e5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042034e9:	48 89 c1             	mov    %rax,%rcx
  80042034ec:	48 ba 28 91 21 04 80 	movabs $0x8004219128,%rdx
  80042034f3:	00 00 00 
  80042034f6:	be 5f 02 00 00       	mov    $0x25f,%esi
  80042034fb:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004203502:	00 00 00 
  8004203505:	b8 00 00 00 00       	mov    $0x0,%eax
  800420350a:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004203511:	00 00 00 
  8004203514:	41 ff d0             	callq  *%r8
  8004203517:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420351e:	00 00 00 
  8004203521:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203525:	48 01 d0             	add    %rdx,%rax
  8004203528:	8b 55 9c             	mov    -0x64(%rbp),%edx
  800420352b:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  800420352f:	48 89 ce             	mov    %rcx,%rsi
  8004203532:	48 89 c7             	mov    %rax,%rdi
  8004203535:	48 b8 47 36 20 04 80 	movabs $0x8004203647,%rax
  800420353c:	00 00 00 
  800420353f:	ff d0                	callq  *%rax
  8004203541:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
				if (pte!=NULL) return pte;
  8004203545:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420354a:	74 09                	je     8004203555 <pdpe_walk+0x187>
  800420354c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203550:	e9 eb 00 00 00       	jmpq   8004203640 <pdpe_walk+0x272>
				else{
					pdpe[PDPE(va)] = 0;
  8004203555:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004203559:	48 c1 e8 1e          	shr    $0x1e,%rax
  800420355d:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203562:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203569:	00 
  800420356a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420356e:	48 01 d0             	add    %rdx,%rax
  8004203571:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
					page_decref(page);
  8004203578:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420357c:	48 89 c7             	mov    %rax,%rdi
  800420357f:	48 b8 14 31 20 04 80 	movabs $0x8004203114,%rax
  8004203586:	00 00 00 
  8004203589:	ff d0                	callq  *%rax
					return NULL;
  800420358b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203590:	e9 ab 00 00 00       	jmpq   8004203640 <pdpe_walk+0x272>
				}
			}else
				return NULL;
  8004203595:	b8 00 00 00 00       	mov    $0x0,%eax
  800420359a:	e9 a1 00 00 00       	jmpq   8004203640 <pdpe_walk+0x272>
		}else if((uint64_t)pdp & PTE_P){
  800420359f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042035a3:	83 e0 01             	and    $0x1,%eax
  80042035a6:	48 85 c0             	test   %rax,%rax
  80042035a9:	0f 84 8c 00 00 00    	je     800420363b <pdpe_walk+0x26d>
			return pgdir_walk(KADDR((uintptr_t)((pde_t *)PTE_ADDR(pdp))),va,create);
  80042035af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042035b3:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042035b9:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  80042035bd:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042035c1:	48 c1 e8 0c          	shr    $0xc,%rax
  80042035c5:	89 45 bc             	mov    %eax,-0x44(%rbp)
  80042035c8:	8b 55 bc             	mov    -0x44(%rbp),%edx
  80042035cb:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  80042035d2:	00 00 00 
  80042035d5:	48 8b 00             	mov    (%rax),%rax
  80042035d8:	48 39 c2             	cmp    %rax,%rdx
  80042035db:	72 32                	jb     800420360f <pdpe_walk+0x241>
  80042035dd:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042035e1:	48 89 c1             	mov    %rax,%rcx
  80042035e4:	48 ba 28 91 21 04 80 	movabs $0x8004219128,%rdx
  80042035eb:	00 00 00 
  80042035ee:	be 69 02 00 00       	mov    $0x269,%esi
  80042035f3:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  80042035fa:	00 00 00 
  80042035fd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203602:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004203609:	00 00 00 
  800420360c:	41 ff d0             	callq  *%r8
  800420360f:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004203616:	00 00 00 
  8004203619:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420361d:	48 01 d0             	add    %rdx,%rax
  8004203620:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004203623:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004203627:	48 89 ce             	mov    %rcx,%rsi
  800420362a:	48 89 c7             	mov    %rax,%rdi
  800420362d:	48 b8 47 36 20 04 80 	movabs $0x8004203647,%rax
  8004203634:	00 00 00 
  8004203637:	ff d0                	callq  *%rax
  8004203639:	eb 05                	jmp    8004203640 <pdpe_walk+0x272>
		}
	}
	return NULL;
  800420363b:	b8 00 00 00 00       	mov    $0x0,%eax

}
  8004203640:	48 83 c4 68          	add    $0x68,%rsp
  8004203644:	5b                   	pop    %rbx
  8004203645:	5d                   	pop    %rbp
  8004203646:	c3                   	retq   

0000008004203647 <pgdir_walk>:
// The programming logic and the hints are the same as pml4e_walk
// and pdpe_walk.

pte_t *
pgdir_walk(pde_t *pgdir, const void *va, int create)
{
  8004203647:	55                   	push   %rbp
  8004203648:	48 89 e5             	mov    %rsp,%rbp
  800420364b:	53                   	push   %rbx
  800420364c:	48 83 ec 58          	sub    $0x58,%rsp
  8004203650:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8004203654:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  8004203658:	89 55 ac             	mov    %edx,-0x54(%rbp)

	if (pgdir) {
  800420365b:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004203660:	0f 84 fd 01 00 00    	je     8004203863 <pgdir_walk+0x21c>
		pte_t *pte  = (pte_t *)pgdir [PDX(va)];
  8004203666:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420366a:	48 c1 e8 15          	shr    $0x15,%rax
  800420366e:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203673:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420367a:	00 
  800420367b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420367f:	48 01 d0             	add    %rdx,%rax
  8004203682:	48 8b 00             	mov    (%rax),%rax
  8004203685:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		if (!((physaddr_t)pte & PTE_P) && create) {
  8004203689:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420368d:	83 e0 01             	and    $0x1,%eax
  8004203690:	48 85 c0             	test   %rax,%rax
  8004203693:	0f 85 2f 01 00 00    	jne    80042037c8 <pgdir_walk+0x181>
  8004203699:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  800420369d:	0f 84 25 01 00 00    	je     80042037c8 <pgdir_walk+0x181>
			struct PageInfo *page   = NULL;
  80042036a3:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  80042036aa:	00 
			if ((page = page_alloc(ALLOC_ZERO))) {
  80042036ab:	bf 01 00 00 00       	mov    $0x1,%edi
  80042036b0:	48 b8 e0 2f 20 04 80 	movabs $0x8004202fe0,%rax
  80042036b7:	00 00 00 
  80042036ba:	ff d0                	callq  *%rax
  80042036bc:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042036c0:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042036c5:	0f 84 f3 00 00 00    	je     80042037be <pgdir_walk+0x177>
				page->pp_ref    += 1;
  80042036cb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042036cf:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042036d3:	8d 50 01             	lea    0x1(%rax),%edx
  80042036d6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042036da:	66 89 50 08          	mov    %dx,0x8(%rax)
				pgdir [PDX(va)] = page2pa(page)|PTE_U|PTE_W|PTE_P;
  80042036de:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042036e2:	48 c1 e8 15          	shr    $0x15,%rax
  80042036e6:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042036eb:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042036f2:	00 
  80042036f3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042036f7:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  80042036fb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042036ff:	48 89 c7             	mov    %rax,%rdi
  8004203702:	48 b8 63 1c 20 04 80 	movabs $0x8004201c63,%rax
  8004203709:	00 00 00 
  800420370c:	ff d0                	callq  *%rax
  800420370e:	48 83 c8 07          	or     $0x7,%rax
  8004203712:	48 89 03             	mov    %rax,(%rbx)
				return KADDR((uintptr_t)((pte_t *)(PTE_ADDR(pgdir [PDX(va)])) + PTX(va)));
  8004203715:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203719:	48 c1 e8 0c          	shr    $0xc,%rax
  800420371d:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203722:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203729:	00 
  800420372a:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420372e:	48 c1 e8 15          	shr    $0x15,%rax
  8004203732:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203737:	48 8d 0c c5 00 00 00 	lea    0x0(,%rax,8),%rcx
  800420373e:	00 
  800420373f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203743:	48 01 c8             	add    %rcx,%rax
  8004203746:	48 8b 00             	mov    (%rax),%rax
  8004203749:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420374f:	48 01 d0             	add    %rdx,%rax
  8004203752:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004203756:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420375a:	48 c1 e8 0c          	shr    $0xc,%rax
  800420375e:	89 45 d4             	mov    %eax,-0x2c(%rbp)
  8004203761:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004203764:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  800420376b:	00 00 00 
  800420376e:	48 8b 00             	mov    (%rax),%rax
  8004203771:	48 39 c2             	cmp    %rax,%rdx
  8004203774:	72 32                	jb     80042037a8 <pgdir_walk+0x161>
  8004203776:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420377a:	48 89 c1             	mov    %rax,%rcx
  800420377d:	48 ba 28 91 21 04 80 	movabs $0x8004219128,%rdx
  8004203784:	00 00 00 
  8004203787:	be 7f 02 00 00       	mov    $0x27f,%esi
  800420378c:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004203793:	00 00 00 
  8004203796:	b8 00 00 00 00       	mov    $0x0,%eax
  800420379b:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042037a2:	00 00 00 
  80042037a5:	41 ff d0             	callq  *%r8
  80042037a8:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042037af:	00 00 00 
  80042037b2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042037b6:	48 01 d0             	add    %rdx,%rax
  80042037b9:	e9 aa 00 00 00       	jmpq   8004203868 <pgdir_walk+0x221>
			}else{
				return NULL;
  80042037be:	b8 00 00 00 00       	mov    $0x0,%eax
  80042037c3:	e9 a0 00 00 00       	jmpq   8004203868 <pgdir_walk+0x221>
			}
		} else if ((uint64_t)pte & PTE_P) {
  80042037c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042037cc:	83 e0 01             	and    $0x1,%eax
  80042037cf:	48 85 c0             	test   %rax,%rax
  80042037d2:	0f 84 8b 00 00 00    	je     8004203863 <pgdir_walk+0x21c>
			return KADDR((uintptr_t)((pte_t *)PTE_ADDR(pte) + PTX(va)));
  80042037d8:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042037dc:	48 c1 e8 0c          	shr    $0xc,%rax
  80042037e0:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042037e5:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042037ec:	00 
  80042037ed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042037f1:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042037f7:	48 01 d0             	add    %rdx,%rax
  80042037fa:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  80042037fe:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203802:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203806:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  8004203809:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  800420380c:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  8004203813:	00 00 00 
  8004203816:	48 8b 00             	mov    (%rax),%rax
  8004203819:	48 39 c2             	cmp    %rax,%rdx
  800420381c:	72 32                	jb     8004203850 <pgdir_walk+0x209>
  800420381e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203822:	48 89 c1             	mov    %rax,%rcx
  8004203825:	48 ba 28 91 21 04 80 	movabs $0x8004219128,%rdx
  800420382c:	00 00 00 
  800420382f:	be 84 02 00 00       	mov    $0x284,%esi
  8004203834:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  800420383b:	00 00 00 
  800420383e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203843:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  800420384a:	00 00 00 
  800420384d:	41 ff d0             	callq  *%r8
  8004203850:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004203857:	00 00 00 
  800420385a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420385e:	48 01 d0             	add    %rdx,%rax
  8004203861:	eb 05                	jmp    8004203868 <pgdir_walk+0x221>
		}
	}
	return NULL;
  8004203863:	b8 00 00 00 00       	mov    $0x0,%eax

}
  8004203868:	48 83 c4 58          	add    $0x58,%rsp
  800420386c:	5b                   	pop    %rbx
  800420386d:	5d                   	pop    %rbp
  800420386e:	c3                   	retq   

000000800420386f <boot_map_region>:
// mapped pages.
//
// Hint: the TA solution uses pml4e_walk
static void
boot_map_region(pml4e_t *pml4e, uintptr_t la, size_t size, physaddr_t pa, int perm)
{
  800420386f:	55                   	push   %rbp
  8004203870:	48 89 e5             	mov    %rsp,%rbp
  8004203873:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  8004203877:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  800420387b:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  800420387f:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  8004203883:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
  8004203887:	44 89 45 8c          	mov    %r8d,-0x74(%rbp)

	uint64_t i,j;
	pdpe_t *pdpe;
	pde_t *pde;
	//cprintf("mapping %x at %x (size: %x)\n", la, pa, size);
	for (i = 0; i < size; i+=PGSIZE) {
  800420388b:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004203892:	00 
  8004203893:	e9 aa 02 00 00       	jmpq   8004203b42 <boot_map_region+0x2d3>
		pte_t *pte      = pml4e_walk(pml4e, (void *)(la + i), 1);
  8004203898:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420389c:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042038a0:	48 01 d0             	add    %rdx,%rax
  80042038a3:	48 89 c1             	mov    %rax,%rcx
  80042038a6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042038aa:	ba 01 00 00 00       	mov    $0x1,%edx
  80042038af:	48 89 ce             	mov    %rcx,%rsi
  80042038b2:	48 89 c7             	mov    %rax,%rdi
  80042038b5:	48 b8 55 31 20 04 80 	movabs $0x8004203155,%rax
  80042038bc:	00 00 00 
  80042038bf:	ff d0                	callq  *%rax
  80042038c1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		physaddr_t addr = pa + i;
  80042038c5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042038c9:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  80042038cd:	48 01 d0             	add    %rdx,%rax
  80042038d0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		if (pte != NULL) {
  80042038d4:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80042038d9:	74 23                	je     80042038fe <boot_map_region+0x8f>
			*pte    = PTE_ADDR(addr)|perm|PTE_P;
  80042038db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042038df:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042038e5:	48 89 c2             	mov    %rax,%rdx
  80042038e8:	8b 45 8c             	mov    -0x74(%rbp),%eax
  80042038eb:	48 98                	cltq   
  80042038ed:	48 09 d0             	or     %rdx,%rax
  80042038f0:	48 83 c8 01          	or     $0x1,%rax
  80042038f4:	48 89 c2             	mov    %rax,%rdx
  80042038f7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042038fb:	48 89 10             	mov    %rdx,(%rax)
		}
		pml4e [PML4(la+i)]   = pml4e [PML4(la+i)]|perm|PTE_P;
  80042038fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203902:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004203906:	48 01 d0             	add    %rdx,%rax
  8004203909:	48 c1 e8 27          	shr    $0x27,%rax
  800420390d:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203912:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203919:	00 
  800420391a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420391e:	48 01 d0             	add    %rdx,%rax
  8004203921:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203925:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004203929:	48 01 ca             	add    %rcx,%rdx
  800420392c:	48 c1 ea 27          	shr    $0x27,%rdx
  8004203930:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8004203936:	48 8d 0c d5 00 00 00 	lea    0x0(,%rdx,8),%rcx
  800420393d:	00 
  800420393e:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004203942:	48 01 ca             	add    %rcx,%rdx
  8004203945:	48 8b 0a             	mov    (%rdx),%rcx
  8004203948:	8b 55 8c             	mov    -0x74(%rbp),%edx
  800420394b:	48 63 d2             	movslq %edx,%rdx
  800420394e:	48 09 ca             	or     %rcx,%rdx
  8004203951:	48 83 ca 01          	or     $0x1,%rdx
  8004203955:	48 89 10             	mov    %rdx,(%rax)
		pdpe                 = (pdpe_t *)KADDR(PTE_ADDR(pml4e[PML4(la + i)]));
  8004203958:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420395c:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004203960:	48 01 d0             	add    %rdx,%rax
  8004203963:	48 c1 e8 27          	shr    $0x27,%rax
  8004203967:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420396c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203973:	00 
  8004203974:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203978:	48 01 d0             	add    %rdx,%rax
  800420397b:	48 8b 00             	mov    (%rax),%rax
  800420397e:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203984:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004203988:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420398c:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203990:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004203993:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004203996:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  800420399d:	00 00 00 
  80042039a0:	48 8b 00             	mov    (%rax),%rax
  80042039a3:	48 39 c2             	cmp    %rax,%rdx
  80042039a6:	72 32                	jb     80042039da <boot_map_region+0x16b>
  80042039a8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042039ac:	48 89 c1             	mov    %rax,%rcx
  80042039af:	48 ba 28 91 21 04 80 	movabs $0x8004219128,%rdx
  80042039b6:	00 00 00 
  80042039b9:	be a4 02 00 00       	mov    $0x2a4,%esi
  80042039be:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  80042039c5:	00 00 00 
  80042039c8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042039cd:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042039d4:	00 00 00 
  80042039d7:	41 ff d0             	callq  *%r8
  80042039da:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042039e1:	00 00 00 
  80042039e4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042039e8:	48 01 d0             	add    %rdx,%rax
  80042039eb:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		pdpe[PDPE(la+i)]     = pdpe[PDPE(la+i)]|perm|PTE_P;
  80042039ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042039f3:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042039f7:	48 01 d0             	add    %rdx,%rax
  80042039fa:	48 c1 e8 1e          	shr    $0x1e,%rax
  80042039fe:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203a03:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203a0a:	00 
  8004203a0b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203a0f:	48 01 d0             	add    %rdx,%rax
  8004203a12:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203a16:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004203a1a:	48 01 ca             	add    %rcx,%rdx
  8004203a1d:	48 c1 ea 1e          	shr    $0x1e,%rdx
  8004203a21:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8004203a27:	48 8d 0c d5 00 00 00 	lea    0x0(,%rdx,8),%rcx
  8004203a2e:	00 
  8004203a2f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004203a33:	48 01 ca             	add    %rcx,%rdx
  8004203a36:	48 8b 0a             	mov    (%rdx),%rcx
  8004203a39:	8b 55 8c             	mov    -0x74(%rbp),%edx
  8004203a3c:	48 63 d2             	movslq %edx,%rdx
  8004203a3f:	48 09 ca             	or     %rcx,%rdx
  8004203a42:	48 83 ca 01          	or     $0x1,%rdx
  8004203a46:	48 89 10             	mov    %rdx,(%rax)
		pde                  = (pde_t *) KADDR(PTE_ADDR(pdpe[PDPE(la+i)]));
  8004203a49:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203a4d:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004203a51:	48 01 d0             	add    %rdx,%rax
  8004203a54:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004203a58:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203a5d:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203a64:	00 
  8004203a65:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203a69:	48 01 d0             	add    %rdx,%rax
  8004203a6c:	48 8b 00             	mov    (%rax),%rax
  8004203a6f:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203a75:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004203a79:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203a7d:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203a81:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  8004203a84:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004203a87:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  8004203a8e:	00 00 00 
  8004203a91:	48 8b 00             	mov    (%rax),%rax
  8004203a94:	48 39 c2             	cmp    %rax,%rdx
  8004203a97:	72 32                	jb     8004203acb <boot_map_region+0x25c>
  8004203a99:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203a9d:	48 89 c1             	mov    %rax,%rcx
  8004203aa0:	48 ba 28 91 21 04 80 	movabs $0x8004219128,%rdx
  8004203aa7:	00 00 00 
  8004203aaa:	be a6 02 00 00       	mov    $0x2a6,%esi
  8004203aaf:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004203ab6:	00 00 00 
  8004203ab9:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203abe:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004203ac5:	00 00 00 
  8004203ac8:	41 ff d0             	callq  *%r8
  8004203acb:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004203ad2:	00 00 00 
  8004203ad5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203ad9:	48 01 d0             	add    %rdx,%rax
  8004203adc:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		pde[PDX(la+i)]       = pde[PDX(la+i)]|perm|PTE_P;
  8004203ae0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203ae4:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004203ae8:	48 01 d0             	add    %rdx,%rax
  8004203aeb:	48 c1 e8 15          	shr    $0x15,%rax
  8004203aef:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203af4:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203afb:	00 
  8004203afc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203b00:	48 01 d0             	add    %rdx,%rax
  8004203b03:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203b07:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004203b0b:	48 01 ca             	add    %rcx,%rdx
  8004203b0e:	48 c1 ea 15          	shr    $0x15,%rdx
  8004203b12:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8004203b18:	48 8d 0c d5 00 00 00 	lea    0x0(,%rdx,8),%rcx
  8004203b1f:	00 
  8004203b20:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004203b24:	48 01 ca             	add    %rcx,%rdx
  8004203b27:	48 8b 0a             	mov    (%rdx),%rcx
  8004203b2a:	8b 55 8c             	mov    -0x74(%rbp),%edx
  8004203b2d:	48 63 d2             	movslq %edx,%rdx
  8004203b30:	48 09 ca             	or     %rcx,%rdx
  8004203b33:	48 83 ca 01          	or     $0x1,%rdx
  8004203b37:	48 89 10             	mov    %rdx,(%rax)

	uint64_t i,j;
	pdpe_t *pdpe;
	pde_t *pde;
	//cprintf("mapping %x at %x (size: %x)\n", la, pa, size);
	for (i = 0; i < size; i+=PGSIZE) {
  8004203b3a:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004203b41:	00 
  8004203b42:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203b46:	48 3b 45 98          	cmp    -0x68(%rbp),%rax
  8004203b4a:	0f 82 48 fd ff ff    	jb     8004203898 <boot_map_region+0x29>
		pdpe[PDPE(la+i)]     = pdpe[PDPE(la+i)]|perm|PTE_P;
		pde                  = (pde_t *) KADDR(PTE_ADDR(pdpe[PDPE(la+i)]));
		pde[PDX(la+i)]       = pde[PDX(la+i)]|perm|PTE_P;
	}

}
  8004203b50:	c9                   	leaveq 
  8004203b51:	c3                   	retq   

0000008004203b52 <page_insert>:
// Hint: The TA solution is implemented using pml4e_walk, page_remove,
// and page2pa.
//
int
page_insert(pml4e_t *pml4e, struct PageInfo *pp, void *va, int perm)
{
  8004203b52:	55                   	push   %rbp
  8004203b53:	48 89 e5             	mov    %rsp,%rbp
  8004203b56:	48 83 ec 60          	sub    $0x60,%rsp
  8004203b5a:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8004203b5e:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  8004203b62:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  8004203b66:	89 4d a4             	mov    %ecx,-0x5c(%rbp)

	pdpe_t *pdpe;
	pde_t *pde;
	if (pml4e && pp) {
  8004203b69:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004203b6e:	0f 84 47 03 00 00    	je     8004203ebb <page_insert+0x369>
  8004203b74:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  8004203b79:	0f 84 3c 03 00 00    	je     8004203ebb <page_insert+0x369>
		pte_t *pte  = pml4e_walk(pml4e, va, 1);
  8004203b7f:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8004203b83:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203b87:	ba 01 00 00 00       	mov    $0x1,%edx
  8004203b8c:	48 89 ce             	mov    %rcx,%rsi
  8004203b8f:	48 89 c7             	mov    %rax,%rdi
  8004203b92:	48 b8 55 31 20 04 80 	movabs $0x8004203155,%rax
  8004203b99:	00 00 00 
  8004203b9c:	ff d0                	callq  *%rax
  8004203b9e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (pte != NULL) {
  8004203ba2:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203ba7:	0f 84 07 03 00 00    	je     8004203eb4 <page_insert+0x362>
			pml4e [PML4(va)] = pml4e [PML4(va)]|(perm&(~PTE_AVAIL));
  8004203bad:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203bb1:	48 c1 e8 27          	shr    $0x27,%rax
  8004203bb5:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203bba:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203bc1:	00 
  8004203bc2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203bc6:	48 01 d0             	add    %rdx,%rax
  8004203bc9:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004203bcd:	48 c1 ea 27          	shr    $0x27,%rdx
  8004203bd1:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8004203bd7:	48 8d 0c d5 00 00 00 	lea    0x0(,%rdx,8),%rcx
  8004203bde:	00 
  8004203bdf:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004203be3:	48 01 ca             	add    %rcx,%rdx
  8004203be6:	48 8b 0a             	mov    (%rdx),%rcx
  8004203be9:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004203bec:	80 e6 f1             	and    $0xf1,%dh
  8004203bef:	48 63 d2             	movslq %edx,%rdx
  8004203bf2:	48 09 ca             	or     %rcx,%rdx
  8004203bf5:	48 89 10             	mov    %rdx,(%rax)
			pdpe = (pdpe_t *)KADDR(PTE_ADDR(pml4e[PML4(va)]));
  8004203bf8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203bfc:	48 c1 e8 27          	shr    $0x27,%rax
  8004203c00:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203c05:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203c0c:	00 
  8004203c0d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203c11:	48 01 d0             	add    %rdx,%rax
  8004203c14:	48 8b 00             	mov    (%rax),%rax
  8004203c17:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203c1d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004203c21:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203c25:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203c29:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004203c2c:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004203c2f:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  8004203c36:	00 00 00 
  8004203c39:	48 8b 00             	mov    (%rax),%rax
  8004203c3c:	48 39 c2             	cmp    %rax,%rdx
  8004203c3f:	72 32                	jb     8004203c73 <page_insert+0x121>
  8004203c41:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203c45:	48 89 c1             	mov    %rax,%rcx
  8004203c48:	48 ba 28 91 21 04 80 	movabs $0x8004219128,%rdx
  8004203c4f:	00 00 00 
  8004203c52:	be cf 02 00 00       	mov    $0x2cf,%esi
  8004203c57:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004203c5e:	00 00 00 
  8004203c61:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203c66:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004203c6d:	00 00 00 
  8004203c70:	41 ff d0             	callq  *%r8
  8004203c73:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004203c7a:	00 00 00 
  8004203c7d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203c81:	48 01 d0             	add    %rdx,%rax
  8004203c84:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
			pdpe[PDPE(va)] = pdpe[PDPE(va)]|(perm&(~PTE_AVAIL));
  8004203c88:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203c8c:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004203c90:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203c95:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203c9c:	00 
  8004203c9d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203ca1:	48 01 d0             	add    %rdx,%rax
  8004203ca4:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004203ca8:	48 c1 ea 1e          	shr    $0x1e,%rdx
  8004203cac:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8004203cb2:	48 8d 0c d5 00 00 00 	lea    0x0(,%rdx,8),%rcx
  8004203cb9:	00 
  8004203cba:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004203cbe:	48 01 ca             	add    %rcx,%rdx
  8004203cc1:	48 8b 0a             	mov    (%rdx),%rcx
  8004203cc4:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004203cc7:	80 e6 f1             	and    $0xf1,%dh
  8004203cca:	48 63 d2             	movslq %edx,%rdx
  8004203ccd:	48 09 ca             	or     %rcx,%rdx
  8004203cd0:	48 89 10             	mov    %rdx,(%rax)
			pde = (pde_t *)KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  8004203cd3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203cd7:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004203cdb:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203ce0:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203ce7:	00 
  8004203ce8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203cec:	48 01 d0             	add    %rdx,%rax
  8004203cef:	48 8b 00             	mov    (%rax),%rax
  8004203cf2:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203cf8:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004203cfc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203d00:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203d04:	89 45 d4             	mov    %eax,-0x2c(%rbp)
  8004203d07:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004203d0a:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  8004203d11:	00 00 00 
  8004203d14:	48 8b 00             	mov    (%rax),%rax
  8004203d17:	48 39 c2             	cmp    %rax,%rdx
  8004203d1a:	72 32                	jb     8004203d4e <page_insert+0x1fc>
  8004203d1c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203d20:	48 89 c1             	mov    %rax,%rcx
  8004203d23:	48 ba 28 91 21 04 80 	movabs $0x8004219128,%rdx
  8004203d2a:	00 00 00 
  8004203d2d:	be d1 02 00 00       	mov    $0x2d1,%esi
  8004203d32:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004203d39:	00 00 00 
  8004203d3c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203d41:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004203d48:	00 00 00 
  8004203d4b:	41 ff d0             	callq  *%r8
  8004203d4e:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004203d55:	00 00 00 
  8004203d58:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203d5c:	48 01 d0             	add    %rdx,%rax
  8004203d5f:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			pde[PDX(va)] = pde[PDX(va)]|(perm&(~PTE_AVAIL));
  8004203d63:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203d67:	48 c1 e8 15          	shr    $0x15,%rax
  8004203d6b:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203d70:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203d77:	00 
  8004203d78:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203d7c:	48 01 d0             	add    %rdx,%rax
  8004203d7f:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004203d83:	48 c1 ea 15          	shr    $0x15,%rdx
  8004203d87:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8004203d8d:	48 8d 0c d5 00 00 00 	lea    0x0(,%rdx,8),%rcx
  8004203d94:	00 
  8004203d95:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004203d99:	48 01 ca             	add    %rcx,%rdx
  8004203d9c:	48 8b 0a             	mov    (%rdx),%rcx
  8004203d9f:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004203da2:	80 e6 f1             	and    $0xf1,%dh
  8004203da5:	48 63 d2             	movslq %edx,%rdx
  8004203da8:	48 09 ca             	or     %rcx,%rdx
  8004203dab:	48 89 10             	mov    %rdx,(%rax)
			if ((*pte & PTE_P) && (page2pa(pp) == PTE_ADDR(*pte))) {
  8004203dae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203db2:	48 8b 00             	mov    (%rax),%rax
  8004203db5:	83 e0 01             	and    $0x1,%eax
  8004203db8:	48 85 c0             	test   %rax,%rax
  8004203dbb:	74 70                	je     8004203e2d <page_insert+0x2db>
  8004203dbd:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203dc1:	48 89 c7             	mov    %rax,%rdi
  8004203dc4:	48 b8 63 1c 20 04 80 	movabs $0x8004201c63,%rax
  8004203dcb:	00 00 00 
  8004203dce:	ff d0                	callq  *%rax
  8004203dd0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203dd4:	48 8b 12             	mov    (%rdx),%rdx
  8004203dd7:	48 81 e2 00 f0 ff ff 	and    $0xfffffffffffff000,%rdx
  8004203dde:	48 39 d0             	cmp    %rdx,%rax
  8004203de1:	75 4a                	jne    8004203e2d <page_insert+0x2db>
				*pte    = PTE_ADDR(*pte)|perm|PTE_P;
  8004203de3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203de7:	48 8b 00             	mov    (%rax),%rax
  8004203dea:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203df0:	48 89 c2             	mov    %rax,%rdx
  8004203df3:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  8004203df6:	48 98                	cltq   
  8004203df8:	48 09 d0             	or     %rdx,%rax
  8004203dfb:	48 83 c8 01          	or     $0x1,%rax
  8004203dff:	48 89 c2             	mov    %rax,%rdx
  8004203e02:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203e06:	48 89 10             	mov    %rdx,(%rax)
				tlb_invalidate(pml4e, va);
  8004203e09:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004203e0d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203e11:	48 89 d6             	mov    %rdx,%rsi
  8004203e14:	48 89 c7             	mov    %rax,%rdi
  8004203e17:	48 b8 c0 3f 20 04 80 	movabs $0x8004203fc0,%rax
  8004203e1e:	00 00 00 
  8004203e21:	ff d0                	callq  *%rax
				return 0;
  8004203e23:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203e28:	e9 93 00 00 00       	jmpq   8004203ec0 <page_insert+0x36e>
			} else if (*pte & PTE_P) {
  8004203e2d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203e31:	48 8b 00             	mov    (%rax),%rax
  8004203e34:	83 e0 01             	and    $0x1,%eax
  8004203e37:	48 85 c0             	test   %rax,%rax
  8004203e3a:	74 1a                	je     8004203e56 <page_insert+0x304>
				page_remove(pml4e, va);
  8004203e3c:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004203e40:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203e44:	48 89 d6             	mov    %rdx,%rsi
  8004203e47:	48 89 c7             	mov    %rax,%rdi
  8004203e4a:	48 b8 4d 3f 20 04 80 	movabs $0x8004203f4d,%rax
  8004203e51:	00 00 00 
  8004203e54:	ff d0                	callq  *%rax
			}
			pp->pp_ref  += 1;
  8004203e56:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203e5a:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203e5e:	8d 50 01             	lea    0x1(%rax),%edx
  8004203e61:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203e65:	66 89 50 08          	mov    %dx,0x8(%rax)
			*pte    = page2pa(pp)|perm|PTE_P;
  8004203e69:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203e6d:	48 89 c7             	mov    %rax,%rdi
  8004203e70:	48 b8 63 1c 20 04 80 	movabs $0x8004201c63,%rax
  8004203e77:	00 00 00 
  8004203e7a:	ff d0                	callq  *%rax
  8004203e7c:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004203e7f:	48 63 d2             	movslq %edx,%rdx
  8004203e82:	48 09 d0             	or     %rdx,%rax
  8004203e85:	48 83 c8 01          	or     $0x1,%rax
  8004203e89:	48 89 c2             	mov    %rax,%rdx
  8004203e8c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203e90:	48 89 10             	mov    %rdx,(%rax)
			tlb_invalidate(pml4e, va);
  8004203e93:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004203e97:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203e9b:	48 89 d6             	mov    %rdx,%rsi
  8004203e9e:	48 89 c7             	mov    %rax,%rdi
  8004203ea1:	48 b8 c0 3f 20 04 80 	movabs $0x8004203fc0,%rax
  8004203ea8:	00 00 00 
  8004203eab:	ff d0                	callq  *%rax
			return 0;
  8004203ead:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203eb2:	eb 0c                	jmp    8004203ec0 <page_insert+0x36e>
		}else
			return -E_NO_MEM;
  8004203eb4:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8004203eb9:	eb 05                	jmp    8004203ec0 <page_insert+0x36e>
	}
	return -E_NO_MEM;
  8004203ebb:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax

}
  8004203ec0:	c9                   	leaveq 
  8004203ec1:	c3                   	retq   

0000008004203ec2 <page_lookup>:
//
// Hint: the TA solution uses pml4e_walk and pa2page.
//
struct PageInfo *
page_lookup(pml4e_t *pml4e, void *va, pte_t **pte_store)
{
  8004203ec2:	55                   	push   %rbp
  8004203ec3:	48 89 e5             	mov    %rsp,%rbp
  8004203ec6:	48 83 ec 30          	sub    $0x30,%rsp
  8004203eca:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004203ece:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004203ed2:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)

	if (pml4e != NULL) {
  8004203ed6:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203edb:	74 69                	je     8004203f46 <page_lookup+0x84>
		pte_t *pte  = pml4e_walk(pml4e, va, 0);
  8004203edd:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8004203ee1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203ee5:	ba 00 00 00 00       	mov    $0x0,%edx
  8004203eea:	48 89 ce             	mov    %rcx,%rsi
  8004203eed:	48 89 c7             	mov    %rax,%rdi
  8004203ef0:	48 b8 55 31 20 04 80 	movabs $0x8004203155,%rax
  8004203ef7:	00 00 00 
  8004203efa:	ff d0                	callq  *%rax
  8004203efc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (pte != NULL && (*pte & PTE_P)) {
  8004203f00:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203f05:	74 3f                	je     8004203f46 <page_lookup+0x84>
  8004203f07:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203f0b:	48 8b 00             	mov    (%rax),%rax
  8004203f0e:	83 e0 01             	and    $0x1,%eax
  8004203f11:	48 85 c0             	test   %rax,%rax
  8004203f14:	74 30                	je     8004203f46 <page_lookup+0x84>
			if (pte_store)
  8004203f16:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004203f1b:	74 0b                	je     8004203f28 <page_lookup+0x66>
				*pte_store  = pte;
  8004203f1d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203f21:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203f25:	48 89 10             	mov    %rdx,(%rax)
			return pa2page(PTE_ADDR(*pte));
  8004203f28:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203f2c:	48 8b 00             	mov    (%rax),%rax
  8004203f2f:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203f35:	48 89 c7             	mov    %rax,%rdi
  8004203f38:	48 b8 88 1c 20 04 80 	movabs $0x8004201c88,%rax
  8004203f3f:	00 00 00 
  8004203f42:	ff d0                	callq  *%rax
  8004203f44:	eb 05                	jmp    8004203f4b <page_lookup+0x89>
		}
	}
	return NULL;
  8004203f46:	b8 00 00 00 00       	mov    $0x0,%eax

}
  8004203f4b:	c9                   	leaveq 
  8004203f4c:	c3                   	retq   

0000008004203f4d <page_remove>:
// Hint: The TA solution is implemented using page_lookup,
// 	tlb_invalidate, and page_decref.
//
void
page_remove(pml4e_t *pml4e, void *va)
{
  8004203f4d:	55                   	push   %rbp
  8004203f4e:	48 89 e5             	mov    %rsp,%rbp
  8004203f51:	48 83 ec 20          	sub    $0x20,%rsp
  8004203f55:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004203f59:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)

	pte_t *pte;
	struct PageInfo *page   = page_lookup(pml4e, va, &pte);
  8004203f5d:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  8004203f61:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8004203f65:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203f69:	48 89 ce             	mov    %rcx,%rsi
  8004203f6c:	48 89 c7             	mov    %rax,%rdi
  8004203f6f:	48 b8 c2 3e 20 04 80 	movabs $0x8004203ec2,%rax
  8004203f76:	00 00 00 
  8004203f79:	ff d0                	callq  *%rax
  8004203f7b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (page != NULL) {
  8004203f7f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203f84:	74 38                	je     8004203fbe <page_remove+0x71>
		tlb_invalidate(pml4e, va);
  8004203f86:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004203f8a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203f8e:	48 89 d6             	mov    %rdx,%rsi
  8004203f91:	48 89 c7             	mov    %rax,%rdi
  8004203f94:	48 b8 c0 3f 20 04 80 	movabs $0x8004203fc0,%rax
  8004203f9b:	00 00 00 
  8004203f9e:	ff d0                	callq  *%rax
		page_decref(page);
  8004203fa0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203fa4:	48 89 c7             	mov    %rax,%rdi
  8004203fa7:	48 b8 14 31 20 04 80 	movabs $0x8004203114,%rax
  8004203fae:	00 00 00 
  8004203fb1:	ff d0                	callq  *%rax
		*pte    = 0;
  8004203fb3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203fb7:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	}

}
  8004203fbe:	c9                   	leaveq 
  8004203fbf:	c3                   	retq   

0000008004203fc0 <tlb_invalidate>:
// Invalidate a TLB entry, but only if the page tables being
// edited are the ones currently in use by the processor.
//
void
tlb_invalidate(pml4e_t *pml4e, void *va)
{
  8004203fc0:	55                   	push   %rbp
  8004203fc1:	48 89 e5             	mov    %rsp,%rbp
  8004203fc4:	48 83 ec 20          	sub    $0x20,%rsp
  8004203fc8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004203fcc:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Flush the entry only if we're modifying the current address space.

	assert(pml4e!=NULL);
  8004203fd0:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203fd5:	75 35                	jne    800420400c <tlb_invalidate+0x4c>
  8004203fd7:	48 b9 27 93 21 04 80 	movabs $0x8004219327,%rcx
  8004203fde:	00 00 00 
  8004203fe1:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004203fe8:	00 00 00 
  8004203feb:	be 26 03 00 00       	mov    $0x326,%esi
  8004203ff0:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004203ff7:	00 00 00 
  8004203ffa:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203fff:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004204006:	00 00 00 
  8004204009:	41 ff d0             	callq  *%r8
	if (!curenv || curenv->env_pml4e == pml4e)
  800420400c:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  8004204013:	00 00 00 
  8004204016:	ff d0                	callq  *%rax
  8004204018:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420401f:	00 00 00 
  8004204022:	48 98                	cltq   
  8004204024:	48 c1 e0 03          	shl    $0x3,%rax
  8004204028:	48 89 c1             	mov    %rax,%rcx
  800420402b:	48 c1 e1 04          	shl    $0x4,%rcx
  800420402f:	48 01 c8             	add    %rcx,%rax
  8004204032:	48 01 d0             	add    %rdx,%rax
  8004204035:	48 83 c0 08          	add    $0x8,%rax
  8004204039:	48 8b 00             	mov    (%rax),%rax
  800420403c:	48 85 c0             	test   %rax,%rax
  800420403f:	74 3d                	je     800420407e <tlb_invalidate+0xbe>
  8004204041:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  8004204048:	00 00 00 
  800420404b:	ff d0                	callq  *%rax
  800420404d:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  8004204054:	00 00 00 
  8004204057:	48 98                	cltq   
  8004204059:	48 c1 e0 03          	shl    $0x3,%rax
  800420405d:	48 89 c1             	mov    %rax,%rcx
  8004204060:	48 c1 e1 04          	shl    $0x4,%rcx
  8004204064:	48 01 c8             	add    %rcx,%rax
  8004204067:	48 01 d0             	add    %rdx,%rax
  800420406a:	48 83 c0 08          	add    $0x8,%rax
  800420406e:	48 8b 00             	mov    (%rax),%rax
  8004204071:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004204078:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  800420407c:	75 0f                	jne    800420408d <tlb_invalidate+0xcd>
  800420407e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204082:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

static __inline void 
invlpg(void *addr)
{
	__asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
  8004204086:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420408a:	0f 01 38             	invlpg (%rax)
		invlpg(va);

}
  800420408d:	c9                   	leaveq 
  800420408e:	c3                   	retq   

000000800420408f <mmio_map_region>:
// location.  Return the base of the reserved region.  size does *not*
// have to be multiple of PGSIZE.
//
void *
mmio_map_region(physaddr_t pa, size_t size)
{
  800420408f:	55                   	push   %rbp
  8004204090:	48 89 e5             	mov    %rsp,%rbp
  8004204093:	48 83 ec 30          	sub    $0x30,%rsp
  8004204097:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420409b:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	//
	// Hint: The staff solution uses boot_map_region.
	//
	// Your code here:

	uintptr_t va = base;
  800420409f:	48 b8 e0 c5 22 04 80 	movabs $0x800422c5e0,%rax
  80042040a6:	00 00 00 
  80042040a9:	48 8b 00             	mov    (%rax),%rax
  80042040ac:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	size = ROUNDUP(size, PGSIZE);
  80042040b0:	48 c7 45 f0 00 10 00 	movq   $0x1000,-0x10(%rbp)
  80042040b7:	00 
  80042040b8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042040bc:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042040c0:	48 01 d0             	add    %rdx,%rax
  80042040c3:	48 83 e8 01          	sub    $0x1,%rax
  80042040c7:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  80042040cb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042040cf:	ba 00 00 00 00       	mov    $0x0,%edx
  80042040d4:	48 f7 75 f0          	divq   -0x10(%rbp)
  80042040d8:	48 89 d0             	mov    %rdx,%rax
  80042040db:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042040df:	48 29 c2             	sub    %rax,%rdx
  80042040e2:	48 89 d0             	mov    %rdx,%rax
  80042040e5:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

	base += size;
  80042040e9:	48 b8 e0 c5 22 04 80 	movabs $0x800422c5e0,%rax
  80042040f0:	00 00 00 
  80042040f3:	48 8b 10             	mov    (%rax),%rdx
  80042040f6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042040fa:	48 01 c2             	add    %rax,%rdx
  80042040fd:	48 b8 e0 c5 22 04 80 	movabs $0x800422c5e0,%rax
  8004204104:	00 00 00 
  8004204107:	48 89 10             	mov    %rdx,(%rax)
	if (base >= MMIOLIM)
  800420410a:	48 b8 e0 c5 22 04 80 	movabs $0x800422c5e0,%rax
  8004204111:	00 00 00 
  8004204114:	48 8b 10             	mov    (%rax),%rdx
  8004204117:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  800420411e:	00 00 00 
  8004204121:	48 39 c2             	cmp    %rax,%rdx
  8004204124:	76 2a                	jbe    8004204150 <mmio_map_region+0xc1>
		panic("MMIO mappings exceeded MMIOLIM");
  8004204126:	48 ba 38 93 21 04 80 	movabs $0x8004219338,%rdx
  800420412d:	00 00 00 
  8004204130:	be 53 03 00 00       	mov    $0x353,%esi
  8004204135:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  800420413c:	00 00 00 
  800420413f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204144:	48 b9 e4 05 20 04 80 	movabs $0x80042005e4,%rcx
  800420414b:	00 00 00 
  800420414e:	ff d1                	callq  *%rcx
	boot_map_region(boot_pml4e, va, size, pa, PTE_P|PTE_W|PTE_PWT|PTE_PCD);
  8004204150:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  8004204157:	00 00 00 
  800420415a:	48 8b 00             	mov    (%rax),%rax
  800420415d:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004204161:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004204165:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  8004204169:	41 b8 1b 00 00 00    	mov    $0x1b,%r8d
  800420416f:	48 89 c7             	mov    %rax,%rdi
  8004204172:	48 b8 6f 38 20 04 80 	movabs $0x800420386f,%rax
  8004204179:	00 00 00 
  800420417c:	ff d0                	callq  *%rax
	return (void*) va;
  800420417e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax

}
  8004204182:	c9                   	leaveq 
  8004204183:	c3                   	retq   

0000008004204184 <user_mem_check>:
// Returns 0 if the user program can access this range of addresses,
// and -E_FAULT otherwise.
//
int
user_mem_check(struct Env *env, const void *va, size_t len, int perm)
{
  8004204184:	55                   	push   %rbp
  8004204185:	48 89 e5             	mov    %rsp,%rbp
  8004204188:	48 83 ec 40          	sub    $0x40,%rsp
  800420418c:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004204190:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004204194:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004204198:	89 4d c4             	mov    %ecx,-0x3c(%rbp)

	const void *endva = (const void *) ((uintptr_t) va + len);
  800420419b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420419f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042041a3:	48 01 d0             	add    %rdx,%rax
  80042041a6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	pte_t *ptep;
	if ((uintptr_t) endva >= ULIM || va > endva) {
  80042041aa:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042041ae:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  80042041b5:	00 00 00 
  80042041b8:	48 39 c2             	cmp    %rax,%rdx
  80042041bb:	77 0a                	ja     80042041c7 <user_mem_check+0x43>
  80042041bd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042041c1:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042041c5:	76 1b                	jbe    80042041e2 <user_mem_check+0x5e>
		user_mem_check_addr = (uintptr_t) va;
  80042041c7:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042041cb:	48 b8 40 d2 49 04 80 	movabs $0x800449d240,%rax
  80042041d2:	00 00 00 
  80042041d5:	48 89 10             	mov    %rdx,(%rax)
		return -E_FAULT;
  80042041d8:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  80042041dd:	e9 c0 00 00 00       	jmpq   80042042a2 <user_mem_check+0x11e>
	}
	while(va<endva){
  80042041e2:	e9 a8 00 00 00       	jmpq   800420428f <user_mem_check+0x10b>
		ptep = pml4e_walk(env->env_pml4e,va,0);
  80042041e7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042041eb:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042041f2:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  80042041f6:	ba 00 00 00 00       	mov    $0x0,%edx
  80042041fb:	48 89 ce             	mov    %rcx,%rsi
  80042041fe:	48 89 c7             	mov    %rax,%rdi
  8004204201:	48 b8 55 31 20 04 80 	movabs $0x8004203155,%rax
  8004204208:	00 00 00 
  800420420b:	ff d0                	callq  *%rax
  800420420d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		if (!ptep || (*ptep & (perm | PTE_P)) != (perm | PTE_P)) {
  8004204211:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004204216:	74 1f                	je     8004204237 <user_mem_check+0xb3>
  8004204218:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420421c:	48 8b 10             	mov    (%rax),%rdx
  800420421f:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004204222:	83 c8 01             	or     $0x1,%eax
  8004204225:	48 98                	cltq   
  8004204227:	48 21 c2             	and    %rax,%rdx
  800420422a:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800420422d:	83 c8 01             	or     $0x1,%eax
  8004204230:	48 98                	cltq   
  8004204232:	48 39 c2             	cmp    %rax,%rdx
  8004204235:	74 18                	je     800420424f <user_mem_check+0xcb>
			user_mem_check_addr = (uintptr_t) va;
  8004204237:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420423b:	48 b8 40 d2 49 04 80 	movabs $0x800449d240,%rax
  8004204242:	00 00 00 
  8004204245:	48 89 10             	mov    %rdx,(%rax)
			return -E_FAULT;
  8004204248:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  800420424d:	eb 53                	jmp    80042042a2 <user_mem_check+0x11e>
		}
		va = ROUNDUP(va+1,PGSIZE);
  800420424f:	48 c7 45 e8 00 10 00 	movq   $0x1000,-0x18(%rbp)
  8004204256:	00 
  8004204257:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420425b:	48 83 c0 01          	add    $0x1,%rax
  800420425f:	48 89 c2             	mov    %rax,%rdx
  8004204262:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204266:	48 01 d0             	add    %rdx,%rax
  8004204269:	48 83 e8 01          	sub    $0x1,%rax
  800420426d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204271:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204275:	ba 00 00 00 00       	mov    $0x0,%edx
  800420427a:	48 f7 75 e8          	divq   -0x18(%rbp)
  800420427e:	48 89 d0             	mov    %rdx,%rax
  8004204281:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004204285:	48 29 c2             	sub    %rax,%rdx
  8004204288:	48 89 d0             	mov    %rdx,%rax
  800420428b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	pte_t *ptep;
	if ((uintptr_t) endva >= ULIM || va > endva) {
		user_mem_check_addr = (uintptr_t) va;
		return -E_FAULT;
	}
	while(va<endva){
  800420428f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004204293:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204297:	0f 82 4a ff ff ff    	jb     80042041e7 <user_mem_check+0x63>
			return -E_FAULT;
		}
		va = ROUNDUP(va+1,PGSIZE);
	}

	return 0;
  800420429d:	b8 00 00 00 00       	mov    $0x0,%eax

}
  80042042a2:	c9                   	leaveq 
  80042042a3:	c3                   	retq   

00000080042042a4 <user_mem_assert>:
// If it cannot, 'env' is destroyed and, if env is the current
// environment, this function will not return.
//
void
user_mem_assert(struct Env *env, const void *va, size_t len, int perm)
{
  80042042a4:	55                   	push   %rbp
  80042042a5:	48 89 e5             	mov    %rsp,%rbp
  80042042a8:	48 83 ec 20          	sub    $0x20,%rsp
  80042042ac:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80042042b0:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80042042b4:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80042042b8:	89 4d e4             	mov    %ecx,-0x1c(%rbp)
	if (user_mem_check(env, va, len, perm | PTE_U) < 0) {
  80042042bb:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042042be:	83 c8 04             	or     $0x4,%eax
  80042042c1:	89 c1                	mov    %eax,%ecx
  80042042c3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042042c7:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  80042042cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042042cf:	48 89 c7             	mov    %rax,%rdi
  80042042d2:	48 b8 84 41 20 04 80 	movabs $0x8004204184,%rax
  80042042d9:	00 00 00 
  80042042dc:	ff d0                	callq  *%rax
  80042042de:	85 c0                	test   %eax,%eax
  80042042e0:	79 47                	jns    8004204329 <user_mem_assert+0x85>
		cprintf("[%08x] user_mem_check assertion failure for "
  80042042e2:	48 b8 40 d2 49 04 80 	movabs $0x800449d240,%rax
  80042042e9:	00 00 00 
  80042042ec:	48 8b 10             	mov    (%rax),%rdx
  80042042ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042042f3:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  80042042f9:	89 c6                	mov    %eax,%esi
  80042042fb:	48 bf 58 93 21 04 80 	movabs $0x8004219358,%rdi
  8004204302:	00 00 00 
  8004204305:	b8 00 00 00 00       	mov    $0x0,%eax
  800420430a:	48 b9 90 95 20 04 80 	movabs $0x8004209590,%rcx
  8004204311:	00 00 00 
  8004204314:	ff d1                	callq  *%rcx
			"va %08x\n", env->env_id, user_mem_check_addr);
		env_destroy(env);	// may not return
  8004204316:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420431a:	48 89 c7             	mov    %rax,%rdi
  800420431d:	48 b8 78 8e 20 04 80 	movabs $0x8004208e78,%rax
  8004204324:	00 00 00 
  8004204327:	ff d0                	callq  *%rax
	}
}
  8004204329:	c9                   	leaveq 
  800420432a:	c3                   	retq   

000000800420432b <check_page_free_list>:
// Check that the pages on the page_free_list are reasonable.
//

static void
check_page_free_list(bool only_low_memory)
{
  800420432b:	55                   	push   %rbp
  800420432c:	48 89 e5             	mov    %rsp,%rbp
  800420432f:	48 83 ec 60          	sub    $0x60,%rsp
  8004204333:	89 f8                	mov    %edi,%eax
  8004204335:	88 45 ac             	mov    %al,-0x54(%rbp)
	struct PageInfo *pp;
	unsigned pdx_limit = only_low_memory ? 1 : NPDENTRIES;
  8004204338:	80 7d ac 00          	cmpb   $0x0,-0x54(%rbp)
  800420433c:	74 07                	je     8004204345 <check_page_free_list+0x1a>
  800420433e:	b8 01 00 00 00       	mov    $0x1,%eax
  8004204343:	eb 05                	jmp    800420434a <check_page_free_list+0x1f>
  8004204345:	b8 00 02 00 00       	mov    $0x200,%eax
  800420434a:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	uint64_t nfree_basemem = 0, nfree_extmem = 0;
  800420434d:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004204354:	00 
  8004204355:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  800420435c:	00 
	char *first_free_page;

	if (!page_free_list)
  800420435d:	48 b8 38 d2 49 04 80 	movabs $0x800449d238,%rax
  8004204364:	00 00 00 
  8004204367:	48 8b 00             	mov    (%rax),%rax
  800420436a:	48 85 c0             	test   %rax,%rax
  800420436d:	75 2a                	jne    8004204399 <check_page_free_list+0x6e>
		panic("'page_free_list' is a null pointer!");
  800420436f:	48 ba 90 93 21 04 80 	movabs $0x8004219390,%rdx
  8004204376:	00 00 00 
  8004204379:	be a9 03 00 00       	mov    $0x3a9,%esi
  800420437e:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004204385:	00 00 00 
  8004204388:	b8 00 00 00 00       	mov    $0x0,%eax
  800420438d:	48 b9 e4 05 20 04 80 	movabs $0x80042005e4,%rcx
  8004204394:	00 00 00 
  8004204397:	ff d1                	callq  *%rcx

	if (only_low_memory) {
  8004204399:	80 7d ac 00          	cmpb   $0x0,-0x54(%rbp)
  800420439d:	0f 84 a9 00 00 00    	je     800420444c <check_page_free_list+0x121>
		// Move pages with lower addresses first in the free
		// list, since entry_pgdir does not map all pages.
		struct PageInfo *pp1, *pp2;
		struct PageInfo **tp[2] = { &pp1, &pp2 };
  80042043a3:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  80042043a7:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  80042043ab:	48 8d 45 c8          	lea    -0x38(%rbp),%rax
  80042043af:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		for (pp = page_free_list; pp; pp = pp->pp_link) {
  80042043b3:	48 b8 38 d2 49 04 80 	movabs $0x800449d238,%rax
  80042043ba:	00 00 00 
  80042043bd:	48 8b 00             	mov    (%rax),%rax
  80042043c0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042043c4:	eb 58                	jmp    800420441e <check_page_free_list+0xf3>
			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
  80042043c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042043ca:	48 89 c7             	mov    %rax,%rdi
  80042043cd:	48 b8 63 1c 20 04 80 	movabs $0x8004201c63,%rax
  80042043d4:	00 00 00 
  80042043d7:	ff d0                	callq  *%rax
  80042043d9:	48 c1 e8 15          	shr    $0x15,%rax
  80042043dd:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042043e2:	48 89 c2             	mov    %rax,%rdx
  80042043e5:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042043e8:	48 39 c2             	cmp    %rax,%rdx
  80042043eb:	0f 93 c0             	setae  %al
  80042043ee:	0f b6 c0             	movzbl %al,%eax
  80042043f1:	89 45 e0             	mov    %eax,-0x20(%rbp)
			*tp[pagetype] = pp;
  80042043f4:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80042043f7:	48 98                	cltq   
  80042043f9:	48 8b 44 c5 b0       	mov    -0x50(%rbp,%rax,8),%rax
  80042043fe:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004204402:	48 89 10             	mov    %rdx,(%rax)
			tp[pagetype] = &pp->pp_link;
  8004204405:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004204409:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800420440c:	48 98                	cltq   
  800420440e:	48 89 54 c5 b0       	mov    %rdx,-0x50(%rbp,%rax,8)
	if (only_low_memory) {
		// Move pages with lower addresses first in the free
		// list, since entry_pgdir does not map all pages.
		struct PageInfo *pp1, *pp2;
		struct PageInfo **tp[2] = { &pp1, &pp2 };
		for (pp = page_free_list; pp; pp = pp->pp_link) {
  8004204413:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204417:	48 8b 00             	mov    (%rax),%rax
  800420441a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420441e:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204423:	75 a1                	jne    80042043c6 <check_page_free_list+0x9b>
			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
			*tp[pagetype] = pp;
			tp[pagetype] = &pp->pp_link;
		}
		*tp[1] = 0;
  8004204425:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004204429:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		*tp[0] = pp2;
  8004204430:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004204434:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004204438:	48 89 10             	mov    %rdx,(%rax)
		page_free_list = pp1;
  800420443b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420443f:	48 b8 38 d2 49 04 80 	movabs $0x800449d238,%rax
  8004204446:	00 00 00 
  8004204449:	48 89 10             	mov    %rdx,(%rax)
	}

	// if there's a page that shouldn't be on the free list,
	// try to make sure it eventually causes trouble.
	for (pp = page_free_list; pp; pp = pp->pp_link)
  800420444c:	48 b8 38 d2 49 04 80 	movabs $0x800449d238,%rax
  8004204453:	00 00 00 
  8004204456:	48 8b 00             	mov    (%rax),%rax
  8004204459:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420445d:	eb 5e                	jmp    80042044bd <check_page_free_list+0x192>
		if (PDX(page2pa(pp)) < pdx_limit)
  800420445f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204463:	48 89 c7             	mov    %rax,%rdi
  8004204466:	48 b8 63 1c 20 04 80 	movabs $0x8004201c63,%rax
  800420446d:	00 00 00 
  8004204470:	ff d0                	callq  *%rax
  8004204472:	48 c1 e8 15          	shr    $0x15,%rax
  8004204476:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420447b:	48 89 c2             	mov    %rax,%rdx
  800420447e:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004204481:	48 39 c2             	cmp    %rax,%rdx
  8004204484:	73 2c                	jae    80042044b2 <check_page_free_list+0x187>
			memset(page2kva(pp), 0x97, 128);
  8004204486:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420448a:	48 89 c7             	mov    %rax,%rdi
  800420448d:	48 b8 f9 1c 20 04 80 	movabs $0x8004201cf9,%rax
  8004204494:	00 00 00 
  8004204497:	ff d0                	callq  *%rax
  8004204499:	ba 80 00 00 00       	mov    $0x80,%edx
  800420449e:	be 97 00 00 00       	mov    $0x97,%esi
  80042044a3:	48 89 c7             	mov    %rax,%rdi
  80042044a6:	48 b8 d4 03 21 04 80 	movabs $0x80042103d4,%rax
  80042044ad:	00 00 00 
  80042044b0:	ff d0                	callq  *%rax
		page_free_list = pp1;
	}

	// if there's a page that shouldn't be on the free list,
	// try to make sure it eventually causes trouble.
	for (pp = page_free_list; pp; pp = pp->pp_link)
  80042044b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042044b6:	48 8b 00             	mov    (%rax),%rax
  80042044b9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042044bd:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042044c2:	75 9b                	jne    800420445f <check_page_free_list+0x134>
		if (PDX(page2pa(pp)) < pdx_limit)
			memset(page2kva(pp), 0x97, 128);

	first_free_page = (char *) boot_alloc(0);
  80042044c4:	bf 00 00 00 00       	mov    $0x0,%edi
  80042044c9:	48 b8 22 26 20 04 80 	movabs $0x8004202622,%rax
  80042044d0:	00 00 00 
  80042044d3:	ff d0                	callq  *%rax
  80042044d5:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	for (pp = page_free_list; pp; pp = pp->pp_link) {
  80042044d9:	48 b8 38 d2 49 04 80 	movabs $0x800449d238,%rax
  80042044e0:	00 00 00 
  80042044e3:	48 8b 00             	mov    (%rax),%rax
  80042044e6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042044ea:	e9 20 03 00 00       	jmpq   800420480f <check_page_free_list+0x4e4>
		// check that we didn't corrupt the free list itself
		assert(pp >= pages);
  80042044ef:	48 b8 f8 c5 69 04 80 	movabs $0x800469c5f8,%rax
  80042044f6:	00 00 00 
  80042044f9:	48 8b 00             	mov    (%rax),%rax
  80042044fc:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004204500:	73 35                	jae    8004204537 <check_page_free_list+0x20c>
  8004204502:	48 b9 b4 93 21 04 80 	movabs $0x80042193b4,%rcx
  8004204509:	00 00 00 
  800420450c:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004204513:	00 00 00 
  8004204516:	be c3 03 00 00       	mov    $0x3c3,%esi
  800420451b:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004204522:	00 00 00 
  8004204525:	b8 00 00 00 00       	mov    $0x0,%eax
  800420452a:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004204531:	00 00 00 
  8004204534:	41 ff d0             	callq  *%r8
		assert(pp < pages + npages);
  8004204537:	48 b8 f8 c5 69 04 80 	movabs $0x800469c5f8,%rax
  800420453e:	00 00 00 
  8004204541:	48 8b 10             	mov    (%rax),%rdx
  8004204544:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  800420454b:	00 00 00 
  800420454e:	48 8b 00             	mov    (%rax),%rax
  8004204551:	48 c1 e0 04          	shl    $0x4,%rax
  8004204555:	48 01 d0             	add    %rdx,%rax
  8004204558:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420455c:	77 35                	ja     8004204593 <check_page_free_list+0x268>
  800420455e:	48 b9 c0 93 21 04 80 	movabs $0x80042193c0,%rcx
  8004204565:	00 00 00 
  8004204568:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  800420456f:	00 00 00 
  8004204572:	be c4 03 00 00       	mov    $0x3c4,%esi
  8004204577:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  800420457e:	00 00 00 
  8004204581:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204586:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  800420458d:	00 00 00 
  8004204590:	41 ff d0             	callq  *%r8
		assert(((char *) pp - (char *) pages) % sizeof(*pp) == 0);
  8004204593:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004204597:	48 b8 f8 c5 69 04 80 	movabs $0x800469c5f8,%rax
  800420459e:	00 00 00 
  80042045a1:	48 8b 00             	mov    (%rax),%rax
  80042045a4:	48 29 c2             	sub    %rax,%rdx
  80042045a7:	48 89 d0             	mov    %rdx,%rax
  80042045aa:	83 e0 0f             	and    $0xf,%eax
  80042045ad:	48 85 c0             	test   %rax,%rax
  80042045b0:	74 35                	je     80042045e7 <check_page_free_list+0x2bc>
  80042045b2:	48 b9 d8 93 21 04 80 	movabs $0x80042193d8,%rcx
  80042045b9:	00 00 00 
  80042045bc:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  80042045c3:	00 00 00 
  80042045c6:	be c5 03 00 00       	mov    $0x3c5,%esi
  80042045cb:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  80042045d2:	00 00 00 
  80042045d5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042045da:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042045e1:	00 00 00 
  80042045e4:	41 ff d0             	callq  *%r8

		// check a few pages that shouldn't be on the free list
		assert(page2pa(pp) != 0);
  80042045e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042045eb:	48 89 c7             	mov    %rax,%rdi
  80042045ee:	48 b8 63 1c 20 04 80 	movabs $0x8004201c63,%rax
  80042045f5:	00 00 00 
  80042045f8:	ff d0                	callq  *%rax
  80042045fa:	48 85 c0             	test   %rax,%rax
  80042045fd:	75 35                	jne    8004204634 <check_page_free_list+0x309>
  80042045ff:	48 b9 0a 94 21 04 80 	movabs $0x800421940a,%rcx
  8004204606:	00 00 00 
  8004204609:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004204610:	00 00 00 
  8004204613:	be c8 03 00 00       	mov    $0x3c8,%esi
  8004204618:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  800420461f:	00 00 00 
  8004204622:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204627:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  800420462e:	00 00 00 
  8004204631:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != IOPHYSMEM);
  8004204634:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204638:	48 89 c7             	mov    %rax,%rdi
  800420463b:	48 b8 63 1c 20 04 80 	movabs $0x8004201c63,%rax
  8004204642:	00 00 00 
  8004204645:	ff d0                	callq  *%rax
  8004204647:	48 3d 00 00 0a 00    	cmp    $0xa0000,%rax
  800420464d:	75 35                	jne    8004204684 <check_page_free_list+0x359>
  800420464f:	48 b9 1b 94 21 04 80 	movabs $0x800421941b,%rcx
  8004204656:	00 00 00 
  8004204659:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004204660:	00 00 00 
  8004204663:	be c9 03 00 00       	mov    $0x3c9,%esi
  8004204668:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  800420466f:	00 00 00 
  8004204672:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204677:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  800420467e:	00 00 00 
  8004204681:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != EXTPHYSMEM - PGSIZE);
  8004204684:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204688:	48 89 c7             	mov    %rax,%rdi
  800420468b:	48 b8 63 1c 20 04 80 	movabs $0x8004201c63,%rax
  8004204692:	00 00 00 
  8004204695:	ff d0                	callq  *%rax
  8004204697:	48 3d 00 f0 0f 00    	cmp    $0xff000,%rax
  800420469d:	75 35                	jne    80042046d4 <check_page_free_list+0x3a9>
  800420469f:	48 b9 38 94 21 04 80 	movabs $0x8004219438,%rcx
  80042046a6:	00 00 00 
  80042046a9:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  80042046b0:	00 00 00 
  80042046b3:	be ca 03 00 00       	mov    $0x3ca,%esi
  80042046b8:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  80042046bf:	00 00 00 
  80042046c2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042046c7:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042046ce:	00 00 00 
  80042046d1:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != EXTPHYSMEM);
  80042046d4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042046d8:	48 89 c7             	mov    %rax,%rdi
  80042046db:	48 b8 63 1c 20 04 80 	movabs $0x8004201c63,%rax
  80042046e2:	00 00 00 
  80042046e5:	ff d0                	callq  *%rax
  80042046e7:	48 3d 00 00 10 00    	cmp    $0x100000,%rax
  80042046ed:	75 35                	jne    8004204724 <check_page_free_list+0x3f9>
  80042046ef:	48 b9 5b 94 21 04 80 	movabs $0x800421945b,%rcx
  80042046f6:	00 00 00 
  80042046f9:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004204700:	00 00 00 
  8004204703:	be cb 03 00 00       	mov    $0x3cb,%esi
  8004204708:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  800420470f:	00 00 00 
  8004204712:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204717:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  800420471e:	00 00 00 
  8004204721:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) < EXTPHYSMEM || (char *) page2kva(pp) >= first_free_page);
  8004204724:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204728:	48 89 c7             	mov    %rax,%rdi
  800420472b:	48 b8 63 1c 20 04 80 	movabs $0x8004201c63,%rax
  8004204732:	00 00 00 
  8004204735:	ff d0                	callq  *%rax
  8004204737:	48 3d ff ff 0f 00    	cmp    $0xfffff,%rax
  800420473d:	76 4e                	jbe    800420478d <check_page_free_list+0x462>
  800420473f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204743:	48 89 c7             	mov    %rax,%rdi
  8004204746:	48 b8 f9 1c 20 04 80 	movabs $0x8004201cf9,%rax
  800420474d:	00 00 00 
  8004204750:	ff d0                	callq  *%rax
  8004204752:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004204756:	73 35                	jae    800420478d <check_page_free_list+0x462>
  8004204758:	48 b9 78 94 21 04 80 	movabs $0x8004219478,%rcx
  800420475f:	00 00 00 
  8004204762:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004204769:	00 00 00 
  800420476c:	be cc 03 00 00       	mov    $0x3cc,%esi
  8004204771:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004204778:	00 00 00 
  800420477b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204780:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004204787:	00 00 00 
  800420478a:	41 ff d0             	callq  *%r8

		// (new test for lab 4)
		assert(page2pa(pp) != MPENTRY_PADDR);
  800420478d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204791:	48 89 c7             	mov    %rax,%rdi
  8004204794:	48 b8 63 1c 20 04 80 	movabs $0x8004201c63,%rax
  800420479b:	00 00 00 
  800420479e:	ff d0                	callq  *%rax
  80042047a0:	48 3d 00 70 00 00    	cmp    $0x7000,%rax
  80042047a6:	75 35                	jne    80042047dd <check_page_free_list+0x4b2>
  80042047a8:	48 b9 bd 94 21 04 80 	movabs $0x80042194bd,%rcx
  80042047af:	00 00 00 
  80042047b2:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  80042047b9:	00 00 00 
  80042047bc:	be cf 03 00 00       	mov    $0x3cf,%esi
  80042047c1:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  80042047c8:	00 00 00 
  80042047cb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042047d0:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042047d7:	00 00 00 
  80042047da:	41 ff d0             	callq  *%r8


		if (page2pa(pp) < EXTPHYSMEM)
  80042047dd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042047e1:	48 89 c7             	mov    %rax,%rdi
  80042047e4:	48 b8 63 1c 20 04 80 	movabs $0x8004201c63,%rax
  80042047eb:	00 00 00 
  80042047ee:	ff d0                	callq  *%rax
  80042047f0:	48 3d ff ff 0f 00    	cmp    $0xfffff,%rax
  80042047f6:	77 07                	ja     80042047ff <check_page_free_list+0x4d4>
			++nfree_basemem;
  80042047f8:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  80042047fd:	eb 05                	jmp    8004204804 <check_page_free_list+0x4d9>
		else
			++nfree_extmem;
  80042047ff:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
	for (pp = page_free_list; pp; pp = pp->pp_link)
		if (PDX(page2pa(pp)) < pdx_limit)
			memset(page2kva(pp), 0x97, 128);

	first_free_page = (char *) boot_alloc(0);
	for (pp = page_free_list; pp; pp = pp->pp_link) {
  8004204804:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204808:	48 8b 00             	mov    (%rax),%rax
  800420480b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420480f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204814:	0f 85 d5 fc ff ff    	jne    80042044ef <check_page_free_list+0x1c4>
			++nfree_basemem;
		else
			++nfree_extmem;
	}

	assert(nfree_extmem > 0);
  800420481a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420481f:	75 35                	jne    8004204856 <check_page_free_list+0x52b>
  8004204821:	48 b9 da 94 21 04 80 	movabs $0x80042194da,%rcx
  8004204828:	00 00 00 
  800420482b:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004204832:	00 00 00 
  8004204835:	be d8 03 00 00       	mov    $0x3d8,%esi
  800420483a:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004204841:	00 00 00 
  8004204844:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204849:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004204850:	00 00 00 
  8004204853:	41 ff d0             	callq  *%r8
}
  8004204856:	c9                   	leaveq 
  8004204857:	c3                   	retq   

0000008004204858 <check_page_alloc>:
// Check the physical page allocator (page_alloc(), page_free(),
// and page_init()).
//
static void
check_page_alloc(void)
{
  8004204858:	55                   	push   %rbp
  8004204859:	48 89 e5             	mov    %rsp,%rbp
  800420485c:	48 83 ec 40          	sub    $0x40,%rsp
	int i;

	// if there's a page that shouldn't be on
	// the free list, try to make sure it
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004204860:	48 b8 38 d2 49 04 80 	movabs $0x800449d238,%rax
  8004204867:	00 00 00 
  800420486a:	48 8b 00             	mov    (%rax),%rax
  800420486d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204871:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  8004204878:	eb 37                	jmp    80042048b1 <check_page_alloc+0x59>
		memset(page2kva(pp0), 0x97, PGSIZE);
  800420487a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420487e:	48 89 c7             	mov    %rax,%rdi
  8004204881:	48 b8 f9 1c 20 04 80 	movabs $0x8004201cf9,%rax
  8004204888:	00 00 00 
  800420488b:	ff d0                	callq  *%rax
  800420488d:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004204892:	be 97 00 00 00       	mov    $0x97,%esi
  8004204897:	48 89 c7             	mov    %rax,%rdi
  800420489a:	48 b8 d4 03 21 04 80 	movabs $0x80042103d4,%rax
  80042048a1:	00 00 00 
  80042048a4:	ff d0                	callq  *%rax
	int i;

	// if there's a page that shouldn't be on
	// the free list, try to make sure it
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  80042048a6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042048aa:	48 8b 00             	mov    (%rax),%rax
  80042048ad:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042048b1:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042048b6:	75 c2                	jne    800420487a <check_page_alloc+0x22>
		memset(page2kva(pp0), 0x97, PGSIZE);
	}

	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  80042048b8:	48 b8 38 d2 49 04 80 	movabs $0x800449d238,%rax
  80042048bf:	00 00 00 
  80042048c2:	48 8b 00             	mov    (%rax),%rax
  80042048c5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042048c9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  80042048d0:	e9 ec 01 00 00       	jmpq   8004204ac1 <check_page_alloc+0x269>
		// check that we didn't corrupt the free list itself
		assert(pp0 >= pages);
  80042048d5:	48 b8 f8 c5 69 04 80 	movabs $0x800469c5f8,%rax
  80042048dc:	00 00 00 
  80042048df:	48 8b 00             	mov    (%rax),%rax
  80042048e2:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80042048e6:	73 35                	jae    800420491d <check_page_alloc+0xc5>
  80042048e8:	48 b9 eb 94 21 04 80 	movabs $0x80042194eb,%rcx
  80042048ef:	00 00 00 
  80042048f2:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  80042048f9:	00 00 00 
  80042048fc:	be f2 03 00 00       	mov    $0x3f2,%esi
  8004204901:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004204908:	00 00 00 
  800420490b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204910:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004204917:	00 00 00 
  800420491a:	41 ff d0             	callq  *%r8
		assert(pp0 < pages + npages);
  800420491d:	48 b8 f8 c5 69 04 80 	movabs $0x800469c5f8,%rax
  8004204924:	00 00 00 
  8004204927:	48 8b 10             	mov    (%rax),%rdx
  800420492a:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  8004204931:	00 00 00 
  8004204934:	48 8b 00             	mov    (%rax),%rax
  8004204937:	48 c1 e0 04          	shl    $0x4,%rax
  800420493b:	48 01 d0             	add    %rdx,%rax
  800420493e:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204942:	77 35                	ja     8004204979 <check_page_alloc+0x121>
  8004204944:	48 b9 f8 94 21 04 80 	movabs $0x80042194f8,%rcx
  800420494b:	00 00 00 
  800420494e:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004204955:	00 00 00 
  8004204958:	be f3 03 00 00       	mov    $0x3f3,%esi
  800420495d:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004204964:	00 00 00 
  8004204967:	b8 00 00 00 00       	mov    $0x0,%eax
  800420496c:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004204973:	00 00 00 
  8004204976:	41 ff d0             	callq  *%r8

		// check a few pages that shouldn't be on the free list
		assert(page2pa(pp0) != 0);
  8004204979:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420497d:	48 89 c7             	mov    %rax,%rdi
  8004204980:	48 b8 63 1c 20 04 80 	movabs $0x8004201c63,%rax
  8004204987:	00 00 00 
  800420498a:	ff d0                	callq  *%rax
  800420498c:	48 85 c0             	test   %rax,%rax
  800420498f:	75 35                	jne    80042049c6 <check_page_alloc+0x16e>
  8004204991:	48 b9 0d 95 21 04 80 	movabs $0x800421950d,%rcx
  8004204998:	00 00 00 
  800420499b:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  80042049a2:	00 00 00 
  80042049a5:	be f6 03 00 00       	mov    $0x3f6,%esi
  80042049aa:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  80042049b1:	00 00 00 
  80042049b4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042049b9:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042049c0:	00 00 00 
  80042049c3:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != IOPHYSMEM);
  80042049c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042049ca:	48 89 c7             	mov    %rax,%rdi
  80042049cd:	48 b8 63 1c 20 04 80 	movabs $0x8004201c63,%rax
  80042049d4:	00 00 00 
  80042049d7:	ff d0                	callq  *%rax
  80042049d9:	48 3d 00 00 0a 00    	cmp    $0xa0000,%rax
  80042049df:	75 35                	jne    8004204a16 <check_page_alloc+0x1be>
  80042049e1:	48 b9 1f 95 21 04 80 	movabs $0x800421951f,%rcx
  80042049e8:	00 00 00 
  80042049eb:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  80042049f2:	00 00 00 
  80042049f5:	be f7 03 00 00       	mov    $0x3f7,%esi
  80042049fa:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004204a01:	00 00 00 
  8004204a04:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204a09:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004204a10:	00 00 00 
  8004204a13:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != EXTPHYSMEM - PGSIZE);
  8004204a16:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204a1a:	48 89 c7             	mov    %rax,%rdi
  8004204a1d:	48 b8 63 1c 20 04 80 	movabs $0x8004201c63,%rax
  8004204a24:	00 00 00 
  8004204a27:	ff d0                	callq  *%rax
  8004204a29:	48 3d 00 f0 0f 00    	cmp    $0xff000,%rax
  8004204a2f:	75 35                	jne    8004204a66 <check_page_alloc+0x20e>
  8004204a31:	48 b9 40 95 21 04 80 	movabs $0x8004219540,%rcx
  8004204a38:	00 00 00 
  8004204a3b:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004204a42:	00 00 00 
  8004204a45:	be f8 03 00 00       	mov    $0x3f8,%esi
  8004204a4a:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004204a51:	00 00 00 
  8004204a54:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204a59:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004204a60:	00 00 00 
  8004204a63:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != EXTPHYSMEM);
  8004204a66:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204a6a:	48 89 c7             	mov    %rax,%rdi
  8004204a6d:	48 b8 63 1c 20 04 80 	movabs $0x8004201c63,%rax
  8004204a74:	00 00 00 
  8004204a77:	ff d0                	callq  *%rax
  8004204a79:	48 3d 00 00 10 00    	cmp    $0x100000,%rax
  8004204a7f:	75 35                	jne    8004204ab6 <check_page_alloc+0x25e>
  8004204a81:	48 b9 64 95 21 04 80 	movabs $0x8004219564,%rcx
  8004204a88:	00 00 00 
  8004204a8b:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004204a92:	00 00 00 
  8004204a95:	be f9 03 00 00       	mov    $0x3f9,%esi
  8004204a9a:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004204aa1:	00 00 00 
  8004204aa4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204aa9:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004204ab0:	00 00 00 
  8004204ab3:	41 ff d0             	callq  *%r8
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
		memset(page2kva(pp0), 0x97, PGSIZE);
	}

	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004204ab6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204aba:	48 8b 00             	mov    (%rax),%rax
  8004204abd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204ac1:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204ac6:	0f 85 09 fe ff ff    	jne    80042048d5 <check_page_alloc+0x7d>
		assert(page2pa(pp0) != IOPHYSMEM);
		assert(page2pa(pp0) != EXTPHYSMEM - PGSIZE);
		assert(page2pa(pp0) != EXTPHYSMEM);
	}
	// should be able to allocate three pages
	pp0 = pp1 = pp2 = 0;
  8004204acc:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004204ad3:	00 
  8004204ad4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204ad8:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204adc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204ae0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert((pp0 = page_alloc(0)));
  8004204ae4:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204ae9:	48 b8 e0 2f 20 04 80 	movabs $0x8004202fe0,%rax
  8004204af0:	00 00 00 
  8004204af3:	ff d0                	callq  *%rax
  8004204af5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204af9:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204afe:	75 35                	jne    8004204b35 <check_page_alloc+0x2dd>
  8004204b00:	48 b9 7f 95 21 04 80 	movabs $0x800421957f,%rcx
  8004204b07:	00 00 00 
  8004204b0a:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004204b11:	00 00 00 
  8004204b14:	be fd 03 00 00       	mov    $0x3fd,%esi
  8004204b19:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004204b20:	00 00 00 
  8004204b23:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204b28:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004204b2f:	00 00 00 
  8004204b32:	41 ff d0             	callq  *%r8
	assert((pp1 = page_alloc(0)));
  8004204b35:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204b3a:	48 b8 e0 2f 20 04 80 	movabs $0x8004202fe0,%rax
  8004204b41:	00 00 00 
  8004204b44:	ff d0                	callq  *%rax
  8004204b46:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204b4a:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204b4f:	75 35                	jne    8004204b86 <check_page_alloc+0x32e>
  8004204b51:	48 b9 95 95 21 04 80 	movabs $0x8004219595,%rcx
  8004204b58:	00 00 00 
  8004204b5b:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004204b62:	00 00 00 
  8004204b65:	be fe 03 00 00       	mov    $0x3fe,%esi
  8004204b6a:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004204b71:	00 00 00 
  8004204b74:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204b79:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004204b80:	00 00 00 
  8004204b83:	41 ff d0             	callq  *%r8
	assert((pp2 = page_alloc(0)));
  8004204b86:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204b8b:	48 b8 e0 2f 20 04 80 	movabs $0x8004202fe0,%rax
  8004204b92:	00 00 00 
  8004204b95:	ff d0                	callq  *%rax
  8004204b97:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004204b9b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204ba0:	75 35                	jne    8004204bd7 <check_page_alloc+0x37f>
  8004204ba2:	48 b9 ab 95 21 04 80 	movabs $0x80042195ab,%rcx
  8004204ba9:	00 00 00 
  8004204bac:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004204bb3:	00 00 00 
  8004204bb6:	be ff 03 00 00       	mov    $0x3ff,%esi
  8004204bbb:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004204bc2:	00 00 00 
  8004204bc5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204bca:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004204bd1:	00 00 00 
  8004204bd4:	41 ff d0             	callq  *%r8
	assert(pp0);
  8004204bd7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204bdc:	75 35                	jne    8004204c13 <check_page_alloc+0x3bb>
  8004204bde:	48 b9 c1 95 21 04 80 	movabs $0x80042195c1,%rcx
  8004204be5:	00 00 00 
  8004204be8:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004204bef:	00 00 00 
  8004204bf2:	be 00 04 00 00       	mov    $0x400,%esi
  8004204bf7:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004204bfe:	00 00 00 
  8004204c01:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204c06:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004204c0d:	00 00 00 
  8004204c10:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  8004204c13:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204c18:	74 0a                	je     8004204c24 <check_page_alloc+0x3cc>
  8004204c1a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204c1e:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204c22:	75 35                	jne    8004204c59 <check_page_alloc+0x401>
  8004204c24:	48 b9 c5 95 21 04 80 	movabs $0x80042195c5,%rcx
  8004204c2b:	00 00 00 
  8004204c2e:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004204c35:	00 00 00 
  8004204c38:	be 01 04 00 00       	mov    $0x401,%esi
  8004204c3d:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004204c44:	00 00 00 
  8004204c47:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204c4c:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004204c53:	00 00 00 
  8004204c56:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  8004204c59:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204c5e:	74 14                	je     8004204c74 <check_page_alloc+0x41c>
  8004204c60:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204c64:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004204c68:	74 0a                	je     8004204c74 <check_page_alloc+0x41c>
  8004204c6a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204c6e:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204c72:	75 35                	jne    8004204ca9 <check_page_alloc+0x451>
  8004204c74:	48 b9 d8 95 21 04 80 	movabs $0x80042195d8,%rcx
  8004204c7b:	00 00 00 
  8004204c7e:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004204c85:	00 00 00 
  8004204c88:	be 02 04 00 00       	mov    $0x402,%esi
  8004204c8d:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004204c94:	00 00 00 
  8004204c97:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204c9c:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004204ca3:	00 00 00 
  8004204ca6:	41 ff d0             	callq  *%r8
	assert(page2pa(pp0) < npages*PGSIZE);
  8004204ca9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204cad:	48 89 c7             	mov    %rax,%rdi
  8004204cb0:	48 b8 63 1c 20 04 80 	movabs $0x8004201c63,%rax
  8004204cb7:	00 00 00 
  8004204cba:	ff d0                	callq  *%rax
  8004204cbc:	48 ba f0 c5 69 04 80 	movabs $0x800469c5f0,%rdx
  8004204cc3:	00 00 00 
  8004204cc6:	48 8b 12             	mov    (%rdx),%rdx
  8004204cc9:	48 c1 e2 0c          	shl    $0xc,%rdx
  8004204ccd:	48 39 d0             	cmp    %rdx,%rax
  8004204cd0:	72 35                	jb     8004204d07 <check_page_alloc+0x4af>
  8004204cd2:	48 b9 f8 95 21 04 80 	movabs $0x80042195f8,%rcx
  8004204cd9:	00 00 00 
  8004204cdc:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004204ce3:	00 00 00 
  8004204ce6:	be 03 04 00 00       	mov    $0x403,%esi
  8004204ceb:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004204cf2:	00 00 00 
  8004204cf5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204cfa:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004204d01:	00 00 00 
  8004204d04:	41 ff d0             	callq  *%r8
	assert(page2pa(pp1) < npages*PGSIZE);
  8004204d07:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204d0b:	48 89 c7             	mov    %rax,%rdi
  8004204d0e:	48 b8 63 1c 20 04 80 	movabs $0x8004201c63,%rax
  8004204d15:	00 00 00 
  8004204d18:	ff d0                	callq  *%rax
  8004204d1a:	48 ba f0 c5 69 04 80 	movabs $0x800469c5f0,%rdx
  8004204d21:	00 00 00 
  8004204d24:	48 8b 12             	mov    (%rdx),%rdx
  8004204d27:	48 c1 e2 0c          	shl    $0xc,%rdx
  8004204d2b:	48 39 d0             	cmp    %rdx,%rax
  8004204d2e:	72 35                	jb     8004204d65 <check_page_alloc+0x50d>
  8004204d30:	48 b9 15 96 21 04 80 	movabs $0x8004219615,%rcx
  8004204d37:	00 00 00 
  8004204d3a:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004204d41:	00 00 00 
  8004204d44:	be 04 04 00 00       	mov    $0x404,%esi
  8004204d49:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004204d50:	00 00 00 
  8004204d53:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204d58:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004204d5f:	00 00 00 
  8004204d62:	41 ff d0             	callq  *%r8
	assert(page2pa(pp2) < npages*PGSIZE);
  8004204d65:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204d69:	48 89 c7             	mov    %rax,%rdi
  8004204d6c:	48 b8 63 1c 20 04 80 	movabs $0x8004201c63,%rax
  8004204d73:	00 00 00 
  8004204d76:	ff d0                	callq  *%rax
  8004204d78:	48 ba f0 c5 69 04 80 	movabs $0x800469c5f0,%rdx
  8004204d7f:	00 00 00 
  8004204d82:	48 8b 12             	mov    (%rdx),%rdx
  8004204d85:	48 c1 e2 0c          	shl    $0xc,%rdx
  8004204d89:	48 39 d0             	cmp    %rdx,%rax
  8004204d8c:	72 35                	jb     8004204dc3 <check_page_alloc+0x56b>
  8004204d8e:	48 b9 32 96 21 04 80 	movabs $0x8004219632,%rcx
  8004204d95:	00 00 00 
  8004204d98:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004204d9f:	00 00 00 
  8004204da2:	be 05 04 00 00       	mov    $0x405,%esi
  8004204da7:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004204dae:	00 00 00 
  8004204db1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204db6:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004204dbd:	00 00 00 
  8004204dc0:	41 ff d0             	callq  *%r8

	// temporarily steal the rest of the free pages
	fl = page_free_list;
  8004204dc3:	48 b8 38 d2 49 04 80 	movabs $0x800449d238,%rax
  8004204dca:	00 00 00 
  8004204dcd:	48 8b 00             	mov    (%rax),%rax
  8004204dd0:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	page_free_list = 0;
  8004204dd4:	48 b8 38 d2 49 04 80 	movabs $0x800449d238,%rax
  8004204ddb:	00 00 00 
  8004204dde:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// should be no free memory
	assert(!page_alloc(0));
  8004204de5:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204dea:	48 b8 e0 2f 20 04 80 	movabs $0x8004202fe0,%rax
  8004204df1:	00 00 00 
  8004204df4:	ff d0                	callq  *%rax
  8004204df6:	48 85 c0             	test   %rax,%rax
  8004204df9:	74 35                	je     8004204e30 <check_page_alloc+0x5d8>
  8004204dfb:	48 b9 4f 96 21 04 80 	movabs $0x800421964f,%rcx
  8004204e02:	00 00 00 
  8004204e05:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004204e0c:	00 00 00 
  8004204e0f:	be 0c 04 00 00       	mov    $0x40c,%esi
  8004204e14:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004204e1b:	00 00 00 
  8004204e1e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204e23:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004204e2a:	00 00 00 
  8004204e2d:	41 ff d0             	callq  *%r8

	// free and re-allocate?
	page_free(pp0);
  8004204e30:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204e34:	48 89 c7             	mov    %rax,%rdi
  8004204e37:	48 b8 92 30 20 04 80 	movabs $0x8004203092,%rax
  8004204e3e:	00 00 00 
  8004204e41:	ff d0                	callq  *%rax
	page_free(pp1);
  8004204e43:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204e47:	48 89 c7             	mov    %rax,%rdi
  8004204e4a:	48 b8 92 30 20 04 80 	movabs $0x8004203092,%rax
  8004204e51:	00 00 00 
  8004204e54:	ff d0                	callq  *%rax
	page_free(pp2);
  8004204e56:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204e5a:	48 89 c7             	mov    %rax,%rdi
  8004204e5d:	48 b8 92 30 20 04 80 	movabs $0x8004203092,%rax
  8004204e64:	00 00 00 
  8004204e67:	ff d0                	callq  *%rax
	pp0 = pp1 = pp2 = 0;
  8004204e69:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004204e70:	00 
  8004204e71:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204e75:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204e79:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204e7d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert((pp0 = page_alloc(0)));
  8004204e81:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204e86:	48 b8 e0 2f 20 04 80 	movabs $0x8004202fe0,%rax
  8004204e8d:	00 00 00 
  8004204e90:	ff d0                	callq  *%rax
  8004204e92:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204e96:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204e9b:	75 35                	jne    8004204ed2 <check_page_alloc+0x67a>
  8004204e9d:	48 b9 7f 95 21 04 80 	movabs $0x800421957f,%rcx
  8004204ea4:	00 00 00 
  8004204ea7:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004204eae:	00 00 00 
  8004204eb1:	be 13 04 00 00       	mov    $0x413,%esi
  8004204eb6:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004204ebd:	00 00 00 
  8004204ec0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204ec5:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004204ecc:	00 00 00 
  8004204ecf:	41 ff d0             	callq  *%r8
	assert((pp1 = page_alloc(0)));
  8004204ed2:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204ed7:	48 b8 e0 2f 20 04 80 	movabs $0x8004202fe0,%rax
  8004204ede:	00 00 00 
  8004204ee1:	ff d0                	callq  *%rax
  8004204ee3:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204ee7:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204eec:	75 35                	jne    8004204f23 <check_page_alloc+0x6cb>
  8004204eee:	48 b9 95 95 21 04 80 	movabs $0x8004219595,%rcx
  8004204ef5:	00 00 00 
  8004204ef8:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004204eff:	00 00 00 
  8004204f02:	be 14 04 00 00       	mov    $0x414,%esi
  8004204f07:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004204f0e:	00 00 00 
  8004204f11:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204f16:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004204f1d:	00 00 00 
  8004204f20:	41 ff d0             	callq  *%r8
	assert((pp2 = page_alloc(0)));
  8004204f23:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204f28:	48 b8 e0 2f 20 04 80 	movabs $0x8004202fe0,%rax
  8004204f2f:	00 00 00 
  8004204f32:	ff d0                	callq  *%rax
  8004204f34:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004204f38:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204f3d:	75 35                	jne    8004204f74 <check_page_alloc+0x71c>
  8004204f3f:	48 b9 ab 95 21 04 80 	movabs $0x80042195ab,%rcx
  8004204f46:	00 00 00 
  8004204f49:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004204f50:	00 00 00 
  8004204f53:	be 15 04 00 00       	mov    $0x415,%esi
  8004204f58:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004204f5f:	00 00 00 
  8004204f62:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204f67:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004204f6e:	00 00 00 
  8004204f71:	41 ff d0             	callq  *%r8
	assert(pp0);
  8004204f74:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204f79:	75 35                	jne    8004204fb0 <check_page_alloc+0x758>
  8004204f7b:	48 b9 c1 95 21 04 80 	movabs $0x80042195c1,%rcx
  8004204f82:	00 00 00 
  8004204f85:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004204f8c:	00 00 00 
  8004204f8f:	be 16 04 00 00       	mov    $0x416,%esi
  8004204f94:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004204f9b:	00 00 00 
  8004204f9e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204fa3:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004204faa:	00 00 00 
  8004204fad:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  8004204fb0:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204fb5:	74 0a                	je     8004204fc1 <check_page_alloc+0x769>
  8004204fb7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204fbb:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204fbf:	75 35                	jne    8004204ff6 <check_page_alloc+0x79e>
  8004204fc1:	48 b9 c5 95 21 04 80 	movabs $0x80042195c5,%rcx
  8004204fc8:	00 00 00 
  8004204fcb:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004204fd2:	00 00 00 
  8004204fd5:	be 17 04 00 00       	mov    $0x417,%esi
  8004204fda:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004204fe1:	00 00 00 
  8004204fe4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204fe9:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004204ff0:	00 00 00 
  8004204ff3:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  8004204ff6:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204ffb:	74 14                	je     8004205011 <check_page_alloc+0x7b9>
  8004204ffd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004205001:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004205005:	74 0a                	je     8004205011 <check_page_alloc+0x7b9>
  8004205007:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420500b:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420500f:	75 35                	jne    8004205046 <check_page_alloc+0x7ee>
  8004205011:	48 b9 d8 95 21 04 80 	movabs $0x80042195d8,%rcx
  8004205018:	00 00 00 
  800420501b:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004205022:	00 00 00 
  8004205025:	be 18 04 00 00       	mov    $0x418,%esi
  800420502a:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004205031:	00 00 00 
  8004205034:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205039:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004205040:	00 00 00 
  8004205043:	41 ff d0             	callq  *%r8
	assert(!page_alloc(0));
  8004205046:	bf 00 00 00 00       	mov    $0x0,%edi
  800420504b:	48 b8 e0 2f 20 04 80 	movabs $0x8004202fe0,%rax
  8004205052:	00 00 00 
  8004205055:	ff d0                	callq  *%rax
  8004205057:	48 85 c0             	test   %rax,%rax
  800420505a:	74 35                	je     8004205091 <check_page_alloc+0x839>
  800420505c:	48 b9 4f 96 21 04 80 	movabs $0x800421964f,%rcx
  8004205063:	00 00 00 
  8004205066:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  800420506d:	00 00 00 
  8004205070:	be 19 04 00 00       	mov    $0x419,%esi
  8004205075:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  800420507c:	00 00 00 
  800420507f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205084:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  800420508b:	00 00 00 
  800420508e:	41 ff d0             	callq  *%r8

	// test flags
	memset(page2kva(pp0), 1, PGSIZE);
  8004205091:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205095:	48 89 c7             	mov    %rax,%rdi
  8004205098:	48 b8 f9 1c 20 04 80 	movabs $0x8004201cf9,%rax
  800420509f:	00 00 00 
  80042050a2:	ff d0                	callq  *%rax
  80042050a4:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042050a9:	be 01 00 00 00       	mov    $0x1,%esi
  80042050ae:	48 89 c7             	mov    %rax,%rdi
  80042050b1:	48 b8 d4 03 21 04 80 	movabs $0x80042103d4,%rax
  80042050b8:	00 00 00 
  80042050bb:	ff d0                	callq  *%rax
	page_free(pp0);
  80042050bd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042050c1:	48 89 c7             	mov    %rax,%rdi
  80042050c4:	48 b8 92 30 20 04 80 	movabs $0x8004203092,%rax
  80042050cb:	00 00 00 
  80042050ce:	ff d0                	callq  *%rax
	assert((pp = page_alloc(ALLOC_ZERO)));
  80042050d0:	bf 01 00 00 00       	mov    $0x1,%edi
  80042050d5:	48 b8 e0 2f 20 04 80 	movabs $0x8004202fe0,%rax
  80042050dc:	00 00 00 
  80042050df:	ff d0                	callq  *%rax
  80042050e1:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  80042050e5:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80042050ea:	75 35                	jne    8004205121 <check_page_alloc+0x8c9>
  80042050ec:	48 b9 5e 96 21 04 80 	movabs $0x800421965e,%rcx
  80042050f3:	00 00 00 
  80042050f6:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  80042050fd:	00 00 00 
  8004205100:	be 1e 04 00 00       	mov    $0x41e,%esi
  8004205105:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  800420510c:	00 00 00 
  800420510f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205114:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  800420511b:	00 00 00 
  800420511e:	41 ff d0             	callq  *%r8
	assert(pp && pp0 == pp);
  8004205121:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004205126:	74 0a                	je     8004205132 <check_page_alloc+0x8da>
  8004205128:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420512c:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004205130:	74 35                	je     8004205167 <check_page_alloc+0x90f>
  8004205132:	48 b9 7c 96 21 04 80 	movabs $0x800421967c,%rcx
  8004205139:	00 00 00 
  800420513c:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004205143:	00 00 00 
  8004205146:	be 1f 04 00 00       	mov    $0x41f,%esi
  800420514b:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004205152:	00 00 00 
  8004205155:	b8 00 00 00 00       	mov    $0x0,%eax
  800420515a:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004205161:	00 00 00 
  8004205164:	41 ff d0             	callq  *%r8
	c = page2kva(pp);
  8004205167:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420516b:	48 89 c7             	mov    %rax,%rdi
  800420516e:	48 b8 f9 1c 20 04 80 	movabs $0x8004201cf9,%rax
  8004205175:	00 00 00 
  8004205178:	ff d0                	callq  *%rax
  800420517a:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	for (i = 0; i < PGSIZE; i++)
  800420517e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004205185:	eb 4d                	jmp    80042051d4 <check_page_alloc+0x97c>
		assert(c[i] == 0);
  8004205187:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420518a:	48 63 d0             	movslq %eax,%rdx
  800420518d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205191:	48 01 d0             	add    %rdx,%rax
  8004205194:	0f b6 00             	movzbl (%rax),%eax
  8004205197:	84 c0                	test   %al,%al
  8004205199:	74 35                	je     80042051d0 <check_page_alloc+0x978>
  800420519b:	48 b9 8c 96 21 04 80 	movabs $0x800421968c,%rcx
  80042051a2:	00 00 00 
  80042051a5:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  80042051ac:	00 00 00 
  80042051af:	be 22 04 00 00       	mov    $0x422,%esi
  80042051b4:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  80042051bb:	00 00 00 
  80042051be:	b8 00 00 00 00       	mov    $0x0,%eax
  80042051c3:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042051ca:	00 00 00 
  80042051cd:	41 ff d0             	callq  *%r8
	memset(page2kva(pp0), 1, PGSIZE);
	page_free(pp0);
	assert((pp = page_alloc(ALLOC_ZERO)));
	assert(pp && pp0 == pp);
	c = page2kva(pp);
	for (i = 0; i < PGSIZE; i++)
  80042051d0:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  80042051d4:	81 7d f4 ff 0f 00 00 	cmpl   $0xfff,-0xc(%rbp)
  80042051db:	7e aa                	jle    8004205187 <check_page_alloc+0x92f>
		assert(c[i] == 0);

	// give free list back
	page_free_list = fl;
  80042051dd:	48 b8 38 d2 49 04 80 	movabs $0x800449d238,%rax
  80042051e4:	00 00 00 
  80042051e7:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042051eb:	48 89 10             	mov    %rdx,(%rax)

	// free the pages we took
	page_free(pp0);
  80042051ee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042051f2:	48 89 c7             	mov    %rax,%rdi
  80042051f5:	48 b8 92 30 20 04 80 	movabs $0x8004203092,%rax
  80042051fc:	00 00 00 
  80042051ff:	ff d0                	callq  *%rax
	page_free(pp1);
  8004205201:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205205:	48 89 c7             	mov    %rax,%rdi
  8004205208:	48 b8 92 30 20 04 80 	movabs $0x8004203092,%rax
  800420520f:	00 00 00 
  8004205212:	ff d0                	callq  *%rax
	page_free(pp2);
  8004205214:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004205218:	48 89 c7             	mov    %rax,%rdi
  800420521b:	48 b8 92 30 20 04 80 	movabs $0x8004203092,%rax
  8004205222:	00 00 00 
  8004205225:	ff d0                	callq  *%rax

	cprintf("check_page_alloc() succeeded!\n");
  8004205227:	48 bf 98 96 21 04 80 	movabs $0x8004219698,%rdi
  800420522e:	00 00 00 
  8004205231:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205236:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  800420523d:	00 00 00 
  8004205240:	ff d2                	callq  *%rdx
}
  8004205242:	c9                   	leaveq 
  8004205243:	c3                   	retq   

0000008004205244 <check_boot_pml4e>:
// but it is a pretty good sanity check.
//

static void
check_boot_pml4e(pml4e_t *pml4e)
{
  8004205244:	55                   	push   %rbp
  8004205245:	48 89 e5             	mov    %rsp,%rbp
  8004205248:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  800420524f:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
	uint64_t i, n;

	pml4e = boot_pml4e;
  8004205256:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  800420525d:	00 00 00 
  8004205260:	48 8b 00             	mov    (%rax),%rax
  8004205263:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	// check pages array
	n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
  8004205267:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  800420526e:	00 
  800420526f:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  8004205276:	00 00 00 
  8004205279:	48 8b 00             	mov    (%rax),%rax
  800420527c:	48 c1 e0 04          	shl    $0x4,%rax
  8004205280:	48 89 c2             	mov    %rax,%rdx
  8004205283:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205287:	48 01 d0             	add    %rdx,%rax
  800420528a:	48 83 e8 01          	sub    $0x1,%rax
  800420528e:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004205292:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205296:	ba 00 00 00 00       	mov    $0x0,%edx
  800420529b:	48 f7 75 e0          	divq   -0x20(%rbp)
  800420529f:	48 89 d0             	mov    %rdx,%rax
  80042052a2:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042052a6:	48 29 c2             	sub    %rax,%rdx
  80042052a9:	48 89 d0             	mov    %rdx,%rax
  80042052ac:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < n; i += PGSIZE) {
  80042052b0:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042052b7:	00 
  80042052b8:	e9 d4 00 00 00       	jmpq   8004205391 <check_boot_pml4e+0x14d>
		// cprintf("%x %x %x\n",i,check_va2pa(pml4e, UPAGES + i), PADDR(pages) + i);
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
  80042052bd:	48 ba 00 00 a0 00 80 	movabs $0x8000a00000,%rdx
  80042052c4:	00 00 00 
  80042052c7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042052cb:	48 01 c2             	add    %rax,%rdx
  80042052ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042052d2:	48 89 d6             	mov    %rdx,%rsi
  80042052d5:	48 89 c7             	mov    %rax,%rdi
  80042052d8:	48 b8 92 59 20 04 80 	movabs $0x8004205992,%rax
  80042052df:	00 00 00 
  80042052e2:	ff d0                	callq  *%rax
  80042052e4:	48 ba f8 c5 69 04 80 	movabs $0x800469c5f8,%rdx
  80042052eb:	00 00 00 
  80042052ee:	48 8b 12             	mov    (%rdx),%rdx
  80042052f1:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  80042052f5:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  80042052fc:	00 00 00 
  80042052ff:	48 39 55 d0          	cmp    %rdx,-0x30(%rbp)
  8004205303:	77 32                	ja     8004205337 <check_boot_pml4e+0xf3>
  8004205305:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205309:	48 89 c1             	mov    %rax,%rcx
  800420530c:	48 ba d8 92 21 04 80 	movabs $0x80042192d8,%rdx
  8004205313:	00 00 00 
  8004205316:	be 42 04 00 00       	mov    $0x442,%esi
  800420531b:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004205322:	00 00 00 
  8004205325:	b8 00 00 00 00       	mov    $0x0,%eax
  800420532a:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004205331:	00 00 00 
  8004205334:	41 ff d0             	callq  *%r8
  8004205337:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  800420533e:	ff ff ff 
  8004205341:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004205345:	48 01 d1             	add    %rdx,%rcx
  8004205348:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420534c:	48 01 ca             	add    %rcx,%rdx
  800420534f:	48 39 d0             	cmp    %rdx,%rax
  8004205352:	74 35                	je     8004205389 <check_boot_pml4e+0x145>
  8004205354:	48 b9 b8 96 21 04 80 	movabs $0x80042196b8,%rcx
  800420535b:	00 00 00 
  800420535e:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004205365:	00 00 00 
  8004205368:	be 42 04 00 00       	mov    $0x442,%esi
  800420536d:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004205374:	00 00 00 
  8004205377:	b8 00 00 00 00       	mov    $0x0,%eax
  800420537c:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004205383:	00 00 00 
  8004205386:	41 ff d0             	callq  *%r8

	pml4e = boot_pml4e;

	// check pages array
	n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
	for (i = 0; i < n; i += PGSIZE) {
  8004205389:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004205390:	00 
  8004205391:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205395:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004205399:	0f 82 1e ff ff ff    	jb     80042052bd <check_boot_pml4e+0x79>
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
	}


	// check envs array (new test for lab 3)
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
  800420539f:	48 c7 45 c8 00 10 00 	movq   $0x1000,-0x38(%rbp)
  80042053a6:	00 
  80042053a7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042053ab:	48 05 ff 9f 05 00    	add    $0x59fff,%rax
  80042053b1:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  80042053b5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042053b9:	ba 00 00 00 00       	mov    $0x0,%edx
  80042053be:	48 f7 75 c8          	divq   -0x38(%rbp)
  80042053c2:	48 89 d0             	mov    %rdx,%rax
  80042053c5:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042053c9:	48 29 c2             	sub    %rax,%rdx
  80042053cc:	48 89 d0             	mov    %rdx,%rax
  80042053cf:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < n; i += PGSIZE)
  80042053d3:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042053da:	00 
  80042053db:	e9 d4 00 00 00       	jmpq   80042054b4 <check_boot_pml4e+0x270>
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);
  80042053e0:	48 ba 00 00 80 00 80 	movabs $0x8000800000,%rdx
  80042053e7:	00 00 00 
  80042053ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042053ee:	48 01 c2             	add    %rax,%rdx
  80042053f1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042053f5:	48 89 d6             	mov    %rdx,%rsi
  80042053f8:	48 89 c7             	mov    %rax,%rdi
  80042053fb:	48 b8 92 59 20 04 80 	movabs $0x8004205992,%rax
  8004205402:	00 00 00 
  8004205405:	ff d0                	callq  *%rax
  8004205407:	48 ba 58 d2 49 04 80 	movabs $0x800449d258,%rdx
  800420540e:	00 00 00 
  8004205411:	48 8b 12             	mov    (%rdx),%rdx
  8004205414:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004205418:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  800420541f:	00 00 00 
  8004205422:	48 39 55 b8          	cmp    %rdx,-0x48(%rbp)
  8004205426:	77 32                	ja     800420545a <check_boot_pml4e+0x216>
  8004205428:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420542c:	48 89 c1             	mov    %rax,%rcx
  800420542f:	48 ba d8 92 21 04 80 	movabs $0x80042192d8,%rdx
  8004205436:	00 00 00 
  8004205439:	be 49 04 00 00       	mov    $0x449,%esi
  800420543e:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004205445:	00 00 00 
  8004205448:	b8 00 00 00 00       	mov    $0x0,%eax
  800420544d:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004205454:	00 00 00 
  8004205457:	41 ff d0             	callq  *%r8
  800420545a:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  8004205461:	ff ff ff 
  8004205464:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004205468:	48 01 d1             	add    %rdx,%rcx
  800420546b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420546f:	48 01 ca             	add    %rcx,%rdx
  8004205472:	48 39 d0             	cmp    %rdx,%rax
  8004205475:	74 35                	je     80042054ac <check_boot_pml4e+0x268>
  8004205477:	48 b9 f0 96 21 04 80 	movabs $0x80042196f0,%rcx
  800420547e:	00 00 00 
  8004205481:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004205488:	00 00 00 
  800420548b:	be 49 04 00 00       	mov    $0x449,%esi
  8004205490:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004205497:	00 00 00 
  800420549a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420549f:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042054a6:	00 00 00 
  80042054a9:	41 ff d0             	callq  *%r8
	}


	// check envs array (new test for lab 3)
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
	for (i = 0; i < n; i += PGSIZE)
  80042054ac:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  80042054b3:	00 
  80042054b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042054b8:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  80042054bc:	0f 82 1e ff ff ff    	jb     80042053e0 <check_boot_pml4e+0x19c>
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);


	// check phys mem
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
  80042054c2:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042054c9:	00 
  80042054ca:	eb 6a                	jmp    8004205536 <check_boot_pml4e+0x2f2>
		assert(check_va2pa(pml4e, KERNBASE + i) == i);
  80042054cc:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042054d3:	00 00 00 
  80042054d6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042054da:	48 01 c2             	add    %rax,%rdx
  80042054dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042054e1:	48 89 d6             	mov    %rdx,%rsi
  80042054e4:	48 89 c7             	mov    %rax,%rdi
  80042054e7:	48 b8 92 59 20 04 80 	movabs $0x8004205992,%rax
  80042054ee:	00 00 00 
  80042054f1:	ff d0                	callq  *%rax
  80042054f3:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042054f7:	74 35                	je     800420552e <check_boot_pml4e+0x2ea>
  80042054f9:	48 b9 28 97 21 04 80 	movabs $0x8004219728,%rcx
  8004205500:	00 00 00 
  8004205503:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  800420550a:	00 00 00 
  800420550d:	be 4e 04 00 00       	mov    $0x44e,%esi
  8004205512:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004205519:	00 00 00 
  800420551c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205521:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004205528:	00 00 00 
  800420552b:	41 ff d0             	callq  *%r8
	for (i = 0; i < n; i += PGSIZE)
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);


	// check phys mem
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
  800420552e:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004205535:	00 
  8004205536:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  800420553d:	00 00 00 
  8004205540:	48 8b 00             	mov    (%rax),%rax
  8004205543:	48 c1 e0 0c          	shl    $0xc,%rax
  8004205547:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420554b:	0f 87 7b ff ff ff    	ja     80042054cc <check_boot_pml4e+0x288>
		assert(check_va2pa(pml4e, KERNBASE + i) == i);


	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
  8004205551:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004205558:	00 
  8004205559:	e9 a1 01 00 00       	jmpq   80042056ff <check_boot_pml4e+0x4bb>
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
  800420555e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004205562:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004205566:	48 89 d0             	mov    %rdx,%rax
  8004205569:	48 01 c0             	add    %rax,%rax
  800420556c:	48 01 d0             	add    %rdx,%rax
  800420556f:	48 c1 e0 0f          	shl    $0xf,%rax
  8004205573:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420557a:	00 00 00 
  800420557d:	48 29 c2             	sub    %rax,%rdx
  8004205580:	48 89 d0             	mov    %rdx,%rax
  8004205583:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
  8004205587:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420558e:	00 
  800420558f:	e9 e0 00 00 00       	jmpq   8004205674 <check_boot_pml4e+0x430>
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
  8004205594:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205598:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420559c:	48 01 d0             	add    %rdx,%rax
  800420559f:	48 8d 90 00 80 00 00 	lea    0x8000(%rax),%rdx
  80042055a6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042055aa:	48 89 d6             	mov    %rdx,%rsi
  80042055ad:	48 89 c7             	mov    %rax,%rdi
  80042055b0:	48 b8 92 59 20 04 80 	movabs $0x8004205992,%rax
  80042055b7:	00 00 00 
  80042055ba:	ff d0                	callq  *%rax
  80042055bc:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042055c0:	48 89 d1             	mov    %rdx,%rcx
  80042055c3:	48 c1 e1 10          	shl    $0x10,%rcx
  80042055c7:	48 ba 00 f0 69 04 80 	movabs $0x800469f000,%rdx
  80042055ce:	00 00 00 
  80042055d1:	48 01 ca             	add    %rcx,%rdx
  80042055d4:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  80042055d8:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  80042055df:	00 00 00 
  80042055e2:	48 39 55 a8          	cmp    %rdx,-0x58(%rbp)
  80042055e6:	77 32                	ja     800420561a <check_boot_pml4e+0x3d6>
  80042055e8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042055ec:	48 89 c1             	mov    %rax,%rcx
  80042055ef:	48 ba d8 92 21 04 80 	movabs $0x80042192d8,%rdx
  80042055f6:	00 00 00 
  80042055f9:	be 57 04 00 00       	mov    $0x457,%esi
  80042055fe:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004205605:	00 00 00 
  8004205608:	b8 00 00 00 00       	mov    $0x0,%eax
  800420560d:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004205614:	00 00 00 
  8004205617:	41 ff d0             	callq  *%r8
  800420561a:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  8004205621:	ff ff ff 
  8004205624:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004205628:	48 01 d1             	add    %rdx,%rcx
  800420562b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420562f:	48 01 ca             	add    %rcx,%rdx
  8004205632:	48 39 d0             	cmp    %rdx,%rax
  8004205635:	74 35                	je     800420566c <check_boot_pml4e+0x428>
  8004205637:	48 b9 50 97 21 04 80 	movabs $0x8004219750,%rcx
  800420563e:	00 00 00 
  8004205641:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004205648:	00 00 00 
  800420564b:	be 57 04 00 00       	mov    $0x457,%esi
  8004205650:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004205657:	00 00 00 
  800420565a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420565f:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004205666:	00 00 00 
  8004205669:	41 ff d0             	callq  *%r8

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
  800420566c:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004205673:	00 
  8004205674:	48 81 7d f8 ff ff 00 	cmpq   $0xffff,-0x8(%rbp)
  800420567b:	00 
  800420567c:	0f 86 12 ff ff ff    	jbe    8004205594 <check_boot_pml4e+0x350>
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
  8004205682:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004205689:	00 
  800420568a:	eb 64                	jmp    80042056f0 <check_boot_pml4e+0x4ac>
			assert(check_va2pa(pml4e, base + i) == ~0);
  800420568c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205690:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004205694:	48 01 c2             	add    %rax,%rdx
  8004205697:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420569b:	48 89 d6             	mov    %rdx,%rsi
  800420569e:	48 89 c7             	mov    %rax,%rdi
  80042056a1:	48 b8 92 59 20 04 80 	movabs $0x8004205992,%rax
  80042056a8:	00 00 00 
  80042056ab:	ff d0                	callq  *%rax
  80042056ad:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  80042056b1:	74 35                	je     80042056e8 <check_boot_pml4e+0x4a4>
  80042056b3:	48 b9 98 97 21 04 80 	movabs $0x8004219798,%rcx
  80042056ba:	00 00 00 
  80042056bd:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  80042056c4:	00 00 00 
  80042056c7:	be 59 04 00 00       	mov    $0x459,%esi
  80042056cc:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  80042056d3:	00 00 00 
  80042056d6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042056db:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042056e2:	00 00 00 
  80042056e5:	41 ff d0             	callq  *%r8
	for (n = 0; n < NCPU; n++) {
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
  80042056e8:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  80042056ef:	00 
  80042056f0:	48 81 7d f8 ff 7f 00 	cmpq   $0x7fff,-0x8(%rbp)
  80042056f7:	00 
  80042056f8:	76 92                	jbe    800420568c <check_boot_pml4e+0x448>
		assert(check_va2pa(pml4e, KERNBASE + i) == i);


	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
  80042056fa:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  80042056ff:	48 83 7d f0 03       	cmpq   $0x3,-0x10(%rbp)
  8004205704:	0f 86 54 fe ff ff    	jbe    800420555e <check_boot_pml4e+0x31a>
		for (i = 0; i < KSTKGAP; i += PGSIZE)
			assert(check_va2pa(pml4e, base + i) == ~0);
	}


	pdpe_t *pdpe = KADDR(PTE_ADDR(boot_pml4e[1]));
  800420570a:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  8004205711:	00 00 00 
  8004205714:	48 8b 00             	mov    (%rax),%rax
  8004205717:	48 83 c0 08          	add    $0x8,%rax
  800420571b:	48 8b 00             	mov    (%rax),%rax
  800420571e:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205724:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  8004205728:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420572c:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205730:	89 45 9c             	mov    %eax,-0x64(%rbp)
  8004205733:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004205736:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  800420573d:	00 00 00 
  8004205740:	48 8b 00             	mov    (%rax),%rax
  8004205743:	48 39 c2             	cmp    %rax,%rdx
  8004205746:	72 32                	jb     800420577a <check_boot_pml4e+0x536>
  8004205748:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420574c:	48 89 c1             	mov    %rax,%rcx
  800420574f:	48 ba 28 91 21 04 80 	movabs $0x8004219128,%rdx
  8004205756:	00 00 00 
  8004205759:	be 5d 04 00 00       	mov    $0x45d,%esi
  800420575e:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004205765:	00 00 00 
  8004205768:	b8 00 00 00 00       	mov    $0x0,%eax
  800420576d:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004205774:	00 00 00 
  8004205777:	41 ff d0             	callq  *%r8
  800420577a:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205781:	00 00 00 
  8004205784:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205788:	48 01 d0             	add    %rdx,%rax
  800420578b:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	pde_t  *pgdir = KADDR(PTE_ADDR(pdpe[0]));
  800420578f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004205793:	48 8b 00             	mov    (%rax),%rax
  8004205796:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420579c:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  80042057a0:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042057a4:	48 c1 e8 0c          	shr    $0xc,%rax
  80042057a8:	89 45 84             	mov    %eax,-0x7c(%rbp)
  80042057ab:	8b 55 84             	mov    -0x7c(%rbp),%edx
  80042057ae:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  80042057b5:	00 00 00 
  80042057b8:	48 8b 00             	mov    (%rax),%rax
  80042057bb:	48 39 c2             	cmp    %rax,%rdx
  80042057be:	72 32                	jb     80042057f2 <check_boot_pml4e+0x5ae>
  80042057c0:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042057c4:	48 89 c1             	mov    %rax,%rcx
  80042057c7:	48 ba 28 91 21 04 80 	movabs $0x8004219128,%rdx
  80042057ce:	00 00 00 
  80042057d1:	be 5e 04 00 00       	mov    $0x45e,%esi
  80042057d6:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  80042057dd:	00 00 00 
  80042057e0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042057e5:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042057ec:	00 00 00 
  80042057ef:	41 ff d0             	callq  *%r8
  80042057f2:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042057f9:	00 00 00 
  80042057fc:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004205800:	48 01 d0             	add    %rdx,%rax
  8004205803:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
	// check PDE permissions
	for (i = 0; i < NPDENTRIES; i++) {
  800420580a:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004205811:	00 
  8004205812:	e9 50 01 00 00       	jmpq   8004205967 <check_boot_pml4e+0x723>
		switch (i) {
  8004205817:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420581b:	48 83 f8 04          	cmp    $0x4,%rax
  800420581f:	72 67                	jb     8004205888 <check_boot_pml4e+0x644>
  8004205821:	48 83 f8 05          	cmp    $0x5,%rax
  8004205825:	76 06                	jbe    800420582d <check_boot_pml4e+0x5e9>
  8004205827:	48 83 f8 1f          	cmp    $0x1f,%rax
  800420582b:	75 5b                	jne    8004205888 <check_boot_pml4e+0x644>
		case PDX(KSTACKTOP - 1):
		case PDX(UPAGES):

		case PDX(UENVS):

			assert(pgdir[i] & PTE_P);
  800420582d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205831:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205838:	00 
  8004205839:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004205840:	48 01 d0             	add    %rdx,%rax
  8004205843:	48 8b 00             	mov    (%rax),%rax
  8004205846:	83 e0 01             	and    $0x1,%eax
  8004205849:	48 85 c0             	test   %rax,%rax
  800420584c:	75 35                	jne    8004205883 <check_boot_pml4e+0x63f>
  800420584e:	48 b9 bb 97 21 04 80 	movabs $0x80042197bb,%rcx
  8004205855:	00 00 00 
  8004205858:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  800420585f:	00 00 00 
  8004205862:	be 68 04 00 00       	mov    $0x468,%esi
  8004205867:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  800420586e:	00 00 00 
  8004205871:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205876:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  800420587d:	00 00 00 
  8004205880:	41 ff d0             	callq  *%r8
			break;
  8004205883:	e9 da 00 00 00       	jmpq   8004205962 <check_boot_pml4e+0x71e>
		default:
			if (i >= PDX(KERNBASE)) {
  8004205888:	48 83 7d f8 1f       	cmpq   $0x1f,-0x8(%rbp)
  800420588d:	0f 86 ce 00 00 00    	jbe    8004205961 <check_boot_pml4e+0x71d>
				if (pgdir[i] & PTE_P)
  8004205893:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205897:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420589e:	00 
  800420589f:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042058a6:	48 01 d0             	add    %rdx,%rax
  80042058a9:	48 8b 00             	mov    (%rax),%rax
  80042058ac:	83 e0 01             	and    $0x1,%eax
  80042058af:	48 85 c0             	test   %rax,%rax
  80042058b2:	74 5a                	je     800420590e <check_boot_pml4e+0x6ca>
					assert(pgdir[i] & PTE_W);
  80042058b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042058b8:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042058bf:	00 
  80042058c0:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042058c7:	48 01 d0             	add    %rdx,%rax
  80042058ca:	48 8b 00             	mov    (%rax),%rax
  80042058cd:	83 e0 02             	and    $0x2,%eax
  80042058d0:	48 85 c0             	test   %rax,%rax
  80042058d3:	0f 85 88 00 00 00    	jne    8004205961 <check_boot_pml4e+0x71d>
  80042058d9:	48 b9 cc 97 21 04 80 	movabs $0x80042197cc,%rcx
  80042058e0:	00 00 00 
  80042058e3:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  80042058ea:	00 00 00 
  80042058ed:	be 6d 04 00 00       	mov    $0x46d,%esi
  80042058f2:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  80042058f9:	00 00 00 
  80042058fc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205901:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004205908:	00 00 00 
  800420590b:	41 ff d0             	callq  *%r8
				else
					assert(pgdir[i] == 0);
  800420590e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205912:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205919:	00 
  800420591a:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004205921:	48 01 d0             	add    %rdx,%rax
  8004205924:	48 8b 00             	mov    (%rax),%rax
  8004205927:	48 85 c0             	test   %rax,%rax
  800420592a:	74 35                	je     8004205961 <check_boot_pml4e+0x71d>
  800420592c:	48 b9 dd 97 21 04 80 	movabs $0x80042197dd,%rcx
  8004205933:	00 00 00 
  8004205936:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  800420593d:	00 00 00 
  8004205940:	be 6f 04 00 00       	mov    $0x46f,%esi
  8004205945:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  800420594c:	00 00 00 
  800420594f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205954:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  800420595b:	00 00 00 
  800420595e:	41 ff d0             	callq  *%r8
			} 
			break;
  8004205961:	90                   	nop


	pdpe_t *pdpe = KADDR(PTE_ADDR(boot_pml4e[1]));
	pde_t  *pgdir = KADDR(PTE_ADDR(pdpe[0]));
	// check PDE permissions
	for (i = 0; i < NPDENTRIES; i++) {
  8004205962:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004205967:	48 81 7d f8 ff 01 00 	cmpq   $0x1ff,-0x8(%rbp)
  800420596e:	00 
  800420596f:	0f 86 a2 fe ff ff    	jbe    8004205817 <check_boot_pml4e+0x5d3>
					assert(pgdir[i] == 0);
			} 
			break;
		}
	}
	cprintf("check_boot_pml4e() succeeded!\n");
  8004205975:	48 bf f0 97 21 04 80 	movabs $0x80042197f0,%rdi
  800420597c:	00 00 00 
  800420597f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205984:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  800420598b:	00 00 00 
  800420598e:	ff d2                	callq  *%rdx
}
  8004205990:	c9                   	leaveq 
  8004205991:	c3                   	retq   

0000008004205992 <check_va2pa>:
// this functionality for us!  We define our own version to help check
// the check_boot_pml4e() function; it shouldn't be used elsewhere.

static physaddr_t
check_va2pa(pml4e_t *pml4e, uintptr_t va)
{
  8004205992:	55                   	push   %rbp
  8004205993:	48 89 e5             	mov    %rsp,%rbp
  8004205996:	48 83 ec 60          	sub    $0x60,%rsp
  800420599a:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  800420599e:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
	pte_t *pte;
	pdpe_t *pdpe;
	pde_t *pde;
	// cprintf("%x", va);
	pml4e = &pml4e[PML4(va)];
  80042059a2:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042059a6:	48 c1 e8 27          	shr    $0x27,%rax
  80042059aa:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042059af:	48 c1 e0 03          	shl    $0x3,%rax
  80042059b3:	48 01 45 a8          	add    %rax,-0x58(%rbp)
	// cprintf(" %x %x " , PML4(va), *pml4e);
	if(!(*pml4e & PTE_P))
  80042059b7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042059bb:	48 8b 00             	mov    (%rax),%rax
  80042059be:	83 e0 01             	and    $0x1,%eax
  80042059c1:	48 85 c0             	test   %rax,%rax
  80042059c4:	75 0c                	jne    80042059d2 <check_va2pa+0x40>
		return ~0;
  80042059c6:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  80042059cd:	e9 38 02 00 00       	jmpq   8004205c0a <check_va2pa+0x278>
	pdpe = (pdpe_t *) KADDR(PTE_ADDR(*pml4e));
  80042059d2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042059d6:	48 8b 00             	mov    (%rax),%rax
  80042059d9:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042059df:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042059e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042059e7:	48 c1 e8 0c          	shr    $0xc,%rax
  80042059eb:	89 45 f4             	mov    %eax,-0xc(%rbp)
  80042059ee:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042059f1:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  80042059f8:	00 00 00 
  80042059fb:	48 8b 00             	mov    (%rax),%rax
  80042059fe:	48 39 c2             	cmp    %rax,%rdx
  8004205a01:	72 32                	jb     8004205a35 <check_va2pa+0xa3>
  8004205a03:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205a07:	48 89 c1             	mov    %rax,%rcx
  8004205a0a:	48 ba 28 91 21 04 80 	movabs $0x8004219128,%rdx
  8004205a11:	00 00 00 
  8004205a14:	be 87 04 00 00       	mov    $0x487,%esi
  8004205a19:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004205a20:	00 00 00 
  8004205a23:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205a28:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004205a2f:	00 00 00 
  8004205a32:	41 ff d0             	callq  *%r8
  8004205a35:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205a3c:	00 00 00 
  8004205a3f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205a43:	48 01 d0             	add    %rdx,%rax
  8004205a46:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	// cprintf(" %x %x " , pdpe, *pdpe);
	if (!(pdpe[PDPE(va)] & PTE_P))
  8004205a4a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205a4e:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004205a52:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205a57:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205a5e:	00 
  8004205a5f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004205a63:	48 01 d0             	add    %rdx,%rax
  8004205a66:	48 8b 00             	mov    (%rax),%rax
  8004205a69:	83 e0 01             	and    $0x1,%eax
  8004205a6c:	48 85 c0             	test   %rax,%rax
  8004205a6f:	75 0c                	jne    8004205a7d <check_va2pa+0xeb>
		return ~0;
  8004205a71:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004205a78:	e9 8d 01 00 00       	jmpq   8004205c0a <check_va2pa+0x278>
	pde = (pde_t *) KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  8004205a7d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205a81:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004205a85:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205a8a:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205a91:	00 
  8004205a92:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004205a96:	48 01 d0             	add    %rdx,%rax
  8004205a99:	48 8b 00             	mov    (%rax),%rax
  8004205a9c:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205aa2:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004205aa6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205aaa:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205aae:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004205ab1:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004205ab4:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  8004205abb:	00 00 00 
  8004205abe:	48 8b 00             	mov    (%rax),%rax
  8004205ac1:	48 39 c2             	cmp    %rax,%rdx
  8004205ac4:	72 32                	jb     8004205af8 <check_va2pa+0x166>
  8004205ac6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205aca:	48 89 c1             	mov    %rax,%rcx
  8004205acd:	48 ba 28 91 21 04 80 	movabs $0x8004219128,%rdx
  8004205ad4:	00 00 00 
  8004205ad7:	be 8b 04 00 00       	mov    $0x48b,%esi
  8004205adc:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004205ae3:	00 00 00 
  8004205ae6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205aeb:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004205af2:	00 00 00 
  8004205af5:	41 ff d0             	callq  *%r8
  8004205af8:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205aff:	00 00 00 
  8004205b02:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205b06:	48 01 d0             	add    %rdx,%rax
  8004205b09:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	// cprintf(" %x %x " , pde, *pde);
	pde = &pde[PDX(va)];
  8004205b0d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205b11:	48 c1 e8 15          	shr    $0x15,%rax
  8004205b15:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205b1a:	48 c1 e0 03          	shl    $0x3,%rax
  8004205b1e:	48 01 45 d0          	add    %rax,-0x30(%rbp)
	if (!(*pde & PTE_P))
  8004205b22:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205b26:	48 8b 00             	mov    (%rax),%rax
  8004205b29:	83 e0 01             	and    $0x1,%eax
  8004205b2c:	48 85 c0             	test   %rax,%rax
  8004205b2f:	75 0c                	jne    8004205b3d <check_va2pa+0x1ab>
		return ~0;
  8004205b31:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004205b38:	e9 cd 00 00 00       	jmpq   8004205c0a <check_va2pa+0x278>
	pte = (pte_t*) KADDR(PTE_ADDR(*pde));
  8004205b3d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205b41:	48 8b 00             	mov    (%rax),%rax
  8004205b44:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205b4a:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004205b4e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205b52:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205b56:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  8004205b59:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004205b5c:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  8004205b63:	00 00 00 
  8004205b66:	48 8b 00             	mov    (%rax),%rax
  8004205b69:	48 39 c2             	cmp    %rax,%rdx
  8004205b6c:	72 32                	jb     8004205ba0 <check_va2pa+0x20e>
  8004205b6e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205b72:	48 89 c1             	mov    %rax,%rcx
  8004205b75:	48 ba 28 91 21 04 80 	movabs $0x8004219128,%rdx
  8004205b7c:	00 00 00 
  8004205b7f:	be 90 04 00 00       	mov    $0x490,%esi
  8004205b84:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004205b8b:	00 00 00 
  8004205b8e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205b93:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004205b9a:	00 00 00 
  8004205b9d:	41 ff d0             	callq  *%r8
  8004205ba0:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205ba7:	00 00 00 
  8004205baa:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205bae:	48 01 d0             	add    %rdx,%rax
  8004205bb1:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	// cprintf(" %x %x " , pte, *pte);
	if (!(pte[PTX(va)] & PTE_P))
  8004205bb5:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205bb9:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205bbd:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205bc2:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205bc9:	00 
  8004205bca:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205bce:	48 01 d0             	add    %rdx,%rax
  8004205bd1:	48 8b 00             	mov    (%rax),%rax
  8004205bd4:	83 e0 01             	and    $0x1,%eax
  8004205bd7:	48 85 c0             	test   %rax,%rax
  8004205bda:	75 09                	jne    8004205be5 <check_va2pa+0x253>
		return ~0;
  8004205bdc:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004205be3:	eb 25                	jmp    8004205c0a <check_va2pa+0x278>
	// cprintf(" %x %x\n" , PTX(va),  PTE_ADDR(pte[PTX(va)]));
	return PTE_ADDR(pte[PTX(va)]);
  8004205be5:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205be9:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205bed:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205bf2:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205bf9:	00 
  8004205bfa:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205bfe:	48 01 d0             	add    %rdx,%rax
  8004205c01:	48 8b 00             	mov    (%rax),%rax
  8004205c04:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
}
  8004205c0a:	c9                   	leaveq 
  8004205c0b:	c3                   	retq   

0000008004205c0c <page_check>:


// check page_insert, page_remove, &c
static void
page_check(void)
{
  8004205c0c:	55                   	push   %rbp
  8004205c0d:	48 89 e5             	mov    %rsp,%rbp
  8004205c10:	53                   	push   %rbx
  8004205c11:	48 81 ec 18 01 00 00 	sub    $0x118,%rsp
	void *va;
	int i;

	uintptr_t mm1, mm2;

	pp0 = pp1 = pp2 = pp3 = pp4 = pp5 =0;
  8004205c18:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8004205c1f:	00 
  8004205c20:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205c24:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004205c28:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205c2c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004205c30:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205c34:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004205c38:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205c3c:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004205c40:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205c44:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	assert(pp0 = page_alloc(0));
  8004205c48:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205c4d:	48 b8 e0 2f 20 04 80 	movabs $0x8004202fe0,%rax
  8004205c54:	00 00 00 
  8004205c57:	ff d0                	callq  *%rax
  8004205c59:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  8004205c5d:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004205c62:	75 35                	jne    8004205c99 <page_check+0x8d>
  8004205c64:	48 b9 0f 98 21 04 80 	movabs $0x800421980f,%rcx
  8004205c6b:	00 00 00 
  8004205c6e:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004205c75:	00 00 00 
  8004205c78:	be a8 04 00 00       	mov    $0x4a8,%esi
  8004205c7d:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004205c84:	00 00 00 
  8004205c87:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205c8c:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004205c93:	00 00 00 
  8004205c96:	41 ff d0             	callq  *%r8
	assert(pp1 = page_alloc(0));
  8004205c99:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205c9e:	48 b8 e0 2f 20 04 80 	movabs $0x8004202fe0,%rax
  8004205ca5:	00 00 00 
  8004205ca8:	ff d0                	callq  *%rax
  8004205caa:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004205cae:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004205cb3:	75 35                	jne    8004205cea <page_check+0xde>
  8004205cb5:	48 b9 23 98 21 04 80 	movabs $0x8004219823,%rcx
  8004205cbc:	00 00 00 
  8004205cbf:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004205cc6:	00 00 00 
  8004205cc9:	be a9 04 00 00       	mov    $0x4a9,%esi
  8004205cce:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004205cd5:	00 00 00 
  8004205cd8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205cdd:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004205ce4:	00 00 00 
  8004205ce7:	41 ff d0             	callq  *%r8
	assert(pp2 = page_alloc(0));
  8004205cea:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205cef:	48 b8 e0 2f 20 04 80 	movabs $0x8004202fe0,%rax
  8004205cf6:	00 00 00 
  8004205cf9:	ff d0                	callq  *%rax
  8004205cfb:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004205cff:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004205d04:	75 35                	jne    8004205d3b <page_check+0x12f>
  8004205d06:	48 b9 37 98 21 04 80 	movabs $0x8004219837,%rcx
  8004205d0d:	00 00 00 
  8004205d10:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004205d17:	00 00 00 
  8004205d1a:	be aa 04 00 00       	mov    $0x4aa,%esi
  8004205d1f:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004205d26:	00 00 00 
  8004205d29:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205d2e:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004205d35:	00 00 00 
  8004205d38:	41 ff d0             	callq  *%r8
	assert(pp3 = page_alloc(0));
  8004205d3b:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205d40:	48 b8 e0 2f 20 04 80 	movabs $0x8004202fe0,%rax
  8004205d47:	00 00 00 
  8004205d4a:	ff d0                	callq  *%rax
  8004205d4c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004205d50:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004205d55:	75 35                	jne    8004205d8c <page_check+0x180>
  8004205d57:	48 b9 4b 98 21 04 80 	movabs $0x800421984b,%rcx
  8004205d5e:	00 00 00 
  8004205d61:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004205d68:	00 00 00 
  8004205d6b:	be ab 04 00 00       	mov    $0x4ab,%esi
  8004205d70:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004205d77:	00 00 00 
  8004205d7a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205d7f:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004205d86:	00 00 00 
  8004205d89:	41 ff d0             	callq  *%r8
	assert(pp4 = page_alloc(0));
  8004205d8c:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205d91:	48 b8 e0 2f 20 04 80 	movabs $0x8004202fe0,%rax
  8004205d98:	00 00 00 
  8004205d9b:	ff d0                	callq  *%rax
  8004205d9d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004205da1:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004205da6:	75 35                	jne    8004205ddd <page_check+0x1d1>
  8004205da8:	48 b9 5f 98 21 04 80 	movabs $0x800421985f,%rcx
  8004205daf:	00 00 00 
  8004205db2:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004205db9:	00 00 00 
  8004205dbc:	be ac 04 00 00       	mov    $0x4ac,%esi
  8004205dc1:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004205dc8:	00 00 00 
  8004205dcb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205dd0:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004205dd7:	00 00 00 
  8004205dda:	41 ff d0             	callq  *%r8
	assert(pp5 = page_alloc(0));
  8004205ddd:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205de2:	48 b8 e0 2f 20 04 80 	movabs $0x8004202fe0,%rax
  8004205de9:	00 00 00 
  8004205dec:	ff d0                	callq  *%rax
  8004205dee:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004205df2:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004205df7:	75 35                	jne    8004205e2e <page_check+0x222>
  8004205df9:	48 b9 73 98 21 04 80 	movabs $0x8004219873,%rcx
  8004205e00:	00 00 00 
  8004205e03:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004205e0a:	00 00 00 
  8004205e0d:	be ad 04 00 00       	mov    $0x4ad,%esi
  8004205e12:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004205e19:	00 00 00 
  8004205e1c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205e21:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004205e28:	00 00 00 
  8004205e2b:	41 ff d0             	callq  *%r8

	assert(pp0);
  8004205e2e:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004205e33:	75 35                	jne    8004205e6a <page_check+0x25e>
  8004205e35:	48 b9 c1 95 21 04 80 	movabs $0x80042195c1,%rcx
  8004205e3c:	00 00 00 
  8004205e3f:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004205e46:	00 00 00 
  8004205e49:	be af 04 00 00       	mov    $0x4af,%esi
  8004205e4e:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004205e55:	00 00 00 
  8004205e58:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205e5d:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004205e64:	00 00 00 
  8004205e67:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  8004205e6a:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004205e6f:	74 0a                	je     8004205e7b <page_check+0x26f>
  8004205e71:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205e75:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205e79:	75 35                	jne    8004205eb0 <page_check+0x2a4>
  8004205e7b:	48 b9 c5 95 21 04 80 	movabs $0x80042195c5,%rcx
  8004205e82:	00 00 00 
  8004205e85:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004205e8c:	00 00 00 
  8004205e8f:	be b0 04 00 00       	mov    $0x4b0,%esi
  8004205e94:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004205e9b:	00 00 00 
  8004205e9e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205ea3:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004205eaa:	00 00 00 
  8004205ead:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  8004205eb0:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004205eb5:	74 14                	je     8004205ecb <page_check+0x2bf>
  8004205eb7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205ebb:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205ebf:	74 0a                	je     8004205ecb <page_check+0x2bf>
  8004205ec1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205ec5:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205ec9:	75 35                	jne    8004205f00 <page_check+0x2f4>
  8004205ecb:	48 b9 d8 95 21 04 80 	movabs $0x80042195d8,%rcx
  8004205ed2:	00 00 00 
  8004205ed5:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004205edc:	00 00 00 
  8004205edf:	be b1 04 00 00       	mov    $0x4b1,%esi
  8004205ee4:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004205eeb:	00 00 00 
  8004205eee:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205ef3:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004205efa:	00 00 00 
  8004205efd:	41 ff d0             	callq  *%r8
	assert(pp3 && pp3 != pp2 && pp3 != pp1 && pp3 != pp0);
  8004205f00:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004205f05:	74 1e                	je     8004205f25 <page_check+0x319>
  8004205f07:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205f0b:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004205f0f:	74 14                	je     8004205f25 <page_check+0x319>
  8004205f11:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205f15:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205f19:	74 0a                	je     8004205f25 <page_check+0x319>
  8004205f1b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205f1f:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205f23:	75 35                	jne    8004205f5a <page_check+0x34e>
  8004205f25:	48 b9 88 98 21 04 80 	movabs $0x8004219888,%rcx
  8004205f2c:	00 00 00 
  8004205f2f:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004205f36:	00 00 00 
  8004205f39:	be b2 04 00 00       	mov    $0x4b2,%esi
  8004205f3e:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004205f45:	00 00 00 
  8004205f48:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205f4d:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004205f54:	00 00 00 
  8004205f57:	41 ff d0             	callq  *%r8
	assert(pp4 && pp4 != pp3 && pp4 != pp2 && pp4 != pp1 && pp4 != pp0);
  8004205f5a:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004205f5f:	74 28                	je     8004205f89 <page_check+0x37d>
  8004205f61:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205f65:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004205f69:	74 1e                	je     8004205f89 <page_check+0x37d>
  8004205f6b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205f6f:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004205f73:	74 14                	je     8004205f89 <page_check+0x37d>
  8004205f75:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205f79:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205f7d:	74 0a                	je     8004205f89 <page_check+0x37d>
  8004205f7f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205f83:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205f87:	75 35                	jne    8004205fbe <page_check+0x3b2>
  8004205f89:	48 b9 b8 98 21 04 80 	movabs $0x80042198b8,%rcx
  8004205f90:	00 00 00 
  8004205f93:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004205f9a:	00 00 00 
  8004205f9d:	be b3 04 00 00       	mov    $0x4b3,%esi
  8004205fa2:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004205fa9:	00 00 00 
  8004205fac:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205fb1:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004205fb8:	00 00 00 
  8004205fbb:	41 ff d0             	callq  *%r8
	assert(pp5 && pp5 != pp4 && pp5 != pp3 && pp5 != pp2 && pp5 != pp1 && pp5 != pp0);
  8004205fbe:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004205fc3:	74 32                	je     8004205ff7 <page_check+0x3eb>
  8004205fc5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205fc9:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004205fcd:	74 28                	je     8004205ff7 <page_check+0x3eb>
  8004205fcf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205fd3:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004205fd7:	74 1e                	je     8004205ff7 <page_check+0x3eb>
  8004205fd9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205fdd:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004205fe1:	74 14                	je     8004205ff7 <page_check+0x3eb>
  8004205fe3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205fe7:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205feb:	74 0a                	je     8004205ff7 <page_check+0x3eb>
  8004205fed:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205ff1:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205ff5:	75 35                	jne    800420602c <page_check+0x420>
  8004205ff7:	48 b9 f8 98 21 04 80 	movabs $0x80042198f8,%rcx
  8004205ffe:	00 00 00 
  8004206001:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004206008:	00 00 00 
  800420600b:	be b4 04 00 00       	mov    $0x4b4,%esi
  8004206010:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004206017:	00 00 00 
  800420601a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420601f:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004206026:	00 00 00 
  8004206029:	41 ff d0             	callq  *%r8

	// temporarily steal the rest of the free pages
	fl = page_free_list;
  800420602c:	48 b8 38 d2 49 04 80 	movabs $0x800449d238,%rax
  8004206033:	00 00 00 
  8004206036:	48 8b 00             	mov    (%rax),%rax
  8004206039:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	page_free_list = NULL;
  800420603d:	48 b8 38 d2 49 04 80 	movabs $0x800449d238,%rax
  8004206044:	00 00 00 
  8004206047:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// should be no free memory
	assert(!page_alloc(0));
  800420604e:	bf 00 00 00 00       	mov    $0x0,%edi
  8004206053:	48 b8 e0 2f 20 04 80 	movabs $0x8004202fe0,%rax
  800420605a:	00 00 00 
  800420605d:	ff d0                	callq  *%rax
  800420605f:	48 85 c0             	test   %rax,%rax
  8004206062:	74 35                	je     8004206099 <page_check+0x48d>
  8004206064:	48 b9 4f 96 21 04 80 	movabs $0x800421964f,%rcx
  800420606b:	00 00 00 
  800420606e:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004206075:	00 00 00 
  8004206078:	be bb 04 00 00       	mov    $0x4bb,%esi
  800420607d:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004206084:	00 00 00 
  8004206087:	b8 00 00 00 00       	mov    $0x0,%eax
  800420608c:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004206093:	00 00 00 
  8004206096:	41 ff d0             	callq  *%r8

	// there is no page allocated at address 0
	assert(page_lookup(boot_pml4e, (void *) 0x0, &ptep) == NULL);
  8004206099:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  80042060a0:	00 00 00 
  80042060a3:	48 8b 00             	mov    (%rax),%rax
  80042060a6:	48 8d 95 e0 fe ff ff 	lea    -0x120(%rbp),%rdx
  80042060ad:	be 00 00 00 00       	mov    $0x0,%esi
  80042060b2:	48 89 c7             	mov    %rax,%rdi
  80042060b5:	48 b8 c2 3e 20 04 80 	movabs $0x8004203ec2,%rax
  80042060bc:	00 00 00 
  80042060bf:	ff d0                	callq  *%rax
  80042060c1:	48 85 c0             	test   %rax,%rax
  80042060c4:	74 35                	je     80042060fb <page_check+0x4ef>
  80042060c6:	48 b9 48 99 21 04 80 	movabs $0x8004219948,%rcx
  80042060cd:	00 00 00 
  80042060d0:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  80042060d7:	00 00 00 
  80042060da:	be be 04 00 00       	mov    $0x4be,%esi
  80042060df:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  80042060e6:	00 00 00 
  80042060e9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042060ee:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042060f5:	00 00 00 
  80042060f8:	41 ff d0             	callq  *%r8

	// there is no free memory, so we can't allocate a page table 
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) < 0);
  80042060fb:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  8004206102:	00 00 00 
  8004206105:	48 8b 00             	mov    (%rax),%rax
  8004206108:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420610c:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004206111:	ba 00 00 00 00       	mov    $0x0,%edx
  8004206116:	48 89 c7             	mov    %rax,%rdi
  8004206119:	48 b8 52 3b 20 04 80 	movabs $0x8004203b52,%rax
  8004206120:	00 00 00 
  8004206123:	ff d0                	callq  *%rax
  8004206125:	85 c0                	test   %eax,%eax
  8004206127:	78 35                	js     800420615e <page_check+0x552>
  8004206129:	48 b9 80 99 21 04 80 	movabs $0x8004219980,%rcx
  8004206130:	00 00 00 
  8004206133:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  800420613a:	00 00 00 
  800420613d:	be c1 04 00 00       	mov    $0x4c1,%esi
  8004206142:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004206149:	00 00 00 
  800420614c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206151:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004206158:	00 00 00 
  800420615b:	41 ff d0             	callq  *%r8

	// free pp0 and try again: pp0 should be used for page table
	page_free(pp0);
  800420615e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004206162:	48 89 c7             	mov    %rax,%rdi
  8004206165:	48 b8 92 30 20 04 80 	movabs $0x8004203092,%rax
  800420616c:	00 00 00 
  800420616f:	ff d0                	callq  *%rax
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) < 0);
  8004206171:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  8004206178:	00 00 00 
  800420617b:	48 8b 00             	mov    (%rax),%rax
  800420617e:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004206182:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004206187:	ba 00 00 00 00       	mov    $0x0,%edx
  800420618c:	48 89 c7             	mov    %rax,%rdi
  800420618f:	48 b8 52 3b 20 04 80 	movabs $0x8004203b52,%rax
  8004206196:	00 00 00 
  8004206199:	ff d0                	callq  *%rax
  800420619b:	85 c0                	test   %eax,%eax
  800420619d:	78 35                	js     80042061d4 <page_check+0x5c8>
  800420619f:	48 b9 80 99 21 04 80 	movabs $0x8004219980,%rcx
  80042061a6:	00 00 00 
  80042061a9:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  80042061b0:	00 00 00 
  80042061b3:	be c5 04 00 00       	mov    $0x4c5,%esi
  80042061b8:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  80042061bf:	00 00 00 
  80042061c2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042061c7:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042061ce:	00 00 00 
  80042061d1:	41 ff d0             	callq  *%r8
	page_free(pp2);
  80042061d4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042061d8:	48 89 c7             	mov    %rax,%rdi
  80042061db:	48 b8 92 30 20 04 80 	movabs $0x8004203092,%rax
  80042061e2:	00 00 00 
  80042061e5:	ff d0                	callq  *%rax
	page_free(pp3);
  80042061e7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042061eb:	48 89 c7             	mov    %rax,%rdi
  80042061ee:	48 b8 92 30 20 04 80 	movabs $0x8004203092,%rax
  80042061f5:	00 00 00 
  80042061f8:	ff d0                	callq  *%rax
	//cprintf("pp1 ref count = %d\n",pp1->pp_ref);
	//cprintf("pp0 ref count = %d\n",pp0->pp_ref);
	//cprintf("pp2 ref count = %d\n",pp2->pp_ref);
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) == 0);
  80042061fa:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  8004206201:	00 00 00 
  8004206204:	48 8b 00             	mov    (%rax),%rax
  8004206207:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420620b:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004206210:	ba 00 00 00 00       	mov    $0x0,%edx
  8004206215:	48 89 c7             	mov    %rax,%rdi
  8004206218:	48 b8 52 3b 20 04 80 	movabs $0x8004203b52,%rax
  800420621f:	00 00 00 
  8004206222:	ff d0                	callq  *%rax
  8004206224:	85 c0                	test   %eax,%eax
  8004206226:	74 35                	je     800420625d <page_check+0x651>
  8004206228:	48 b9 b0 99 21 04 80 	movabs $0x80042199b0,%rcx
  800420622f:	00 00 00 
  8004206232:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004206239:	00 00 00 
  800420623c:	be cb 04 00 00       	mov    $0x4cb,%esi
  8004206241:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004206248:	00 00 00 
  800420624b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206250:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004206257:	00 00 00 
  800420625a:	41 ff d0             	callq  *%r8
	assert((PTE_ADDR(boot_pml4e[0]) == page2pa(pp0) || PTE_ADDR(boot_pml4e[0]) == page2pa(pp2) || PTE_ADDR(boot_pml4e[0]) == page2pa(pp3) ));
  800420625d:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  8004206264:	00 00 00 
  8004206267:	48 8b 00             	mov    (%rax),%rax
  800420626a:	48 8b 00             	mov    (%rax),%rax
  800420626d:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206273:	48 89 c3             	mov    %rax,%rbx
  8004206276:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420627a:	48 89 c7             	mov    %rax,%rdi
  800420627d:	48 b8 63 1c 20 04 80 	movabs $0x8004201c63,%rax
  8004206284:	00 00 00 
  8004206287:	ff d0                	callq  *%rax
  8004206289:	48 39 c3             	cmp    %rax,%rbx
  800420628c:	0f 84 97 00 00 00    	je     8004206329 <page_check+0x71d>
  8004206292:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  8004206299:	00 00 00 
  800420629c:	48 8b 00             	mov    (%rax),%rax
  800420629f:	48 8b 00             	mov    (%rax),%rax
  80042062a2:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042062a8:	48 89 c3             	mov    %rax,%rbx
  80042062ab:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042062af:	48 89 c7             	mov    %rax,%rdi
  80042062b2:	48 b8 63 1c 20 04 80 	movabs $0x8004201c63,%rax
  80042062b9:	00 00 00 
  80042062bc:	ff d0                	callq  *%rax
  80042062be:	48 39 c3             	cmp    %rax,%rbx
  80042062c1:	74 66                	je     8004206329 <page_check+0x71d>
  80042062c3:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  80042062ca:	00 00 00 
  80042062cd:	48 8b 00             	mov    (%rax),%rax
  80042062d0:	48 8b 00             	mov    (%rax),%rax
  80042062d3:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042062d9:	48 89 c3             	mov    %rax,%rbx
  80042062dc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042062e0:	48 89 c7             	mov    %rax,%rdi
  80042062e3:	48 b8 63 1c 20 04 80 	movabs $0x8004201c63,%rax
  80042062ea:	00 00 00 
  80042062ed:	ff d0                	callq  *%rax
  80042062ef:	48 39 c3             	cmp    %rax,%rbx
  80042062f2:	74 35                	je     8004206329 <page_check+0x71d>
  80042062f4:	48 b9 e0 99 21 04 80 	movabs $0x80042199e0,%rcx
  80042062fb:	00 00 00 
  80042062fe:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004206305:	00 00 00 
  8004206308:	be cc 04 00 00       	mov    $0x4cc,%esi
  800420630d:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004206314:	00 00 00 
  8004206317:	b8 00 00 00 00       	mov    $0x0,%eax
  800420631c:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004206323:	00 00 00 
  8004206326:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, 0x0) == page2pa(pp1));
  8004206329:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  8004206330:	00 00 00 
  8004206333:	48 8b 00             	mov    (%rax),%rax
  8004206336:	be 00 00 00 00       	mov    $0x0,%esi
  800420633b:	48 89 c7             	mov    %rax,%rdi
  800420633e:	48 b8 92 59 20 04 80 	movabs $0x8004205992,%rax
  8004206345:	00 00 00 
  8004206348:	ff d0                	callq  *%rax
  800420634a:	48 89 c3             	mov    %rax,%rbx
  800420634d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206351:	48 89 c7             	mov    %rax,%rdi
  8004206354:	48 b8 63 1c 20 04 80 	movabs $0x8004201c63,%rax
  800420635b:	00 00 00 
  800420635e:	ff d0                	callq  *%rax
  8004206360:	48 39 c3             	cmp    %rax,%rbx
  8004206363:	74 35                	je     800420639a <page_check+0x78e>
  8004206365:	48 b9 68 9a 21 04 80 	movabs $0x8004219a68,%rcx
  800420636c:	00 00 00 
  800420636f:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004206376:	00 00 00 
  8004206379:	be cd 04 00 00       	mov    $0x4cd,%esi
  800420637e:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004206385:	00 00 00 
  8004206388:	b8 00 00 00 00       	mov    $0x0,%eax
  800420638d:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004206394:	00 00 00 
  8004206397:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 1);
  800420639a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420639e:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042063a2:	66 83 f8 01          	cmp    $0x1,%ax
  80042063a6:	74 35                	je     80042063dd <page_check+0x7d1>
  80042063a8:	48 b9 95 9a 21 04 80 	movabs $0x8004219a95,%rcx
  80042063af:	00 00 00 
  80042063b2:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  80042063b9:	00 00 00 
  80042063bc:	be ce 04 00 00       	mov    $0x4ce,%esi
  80042063c1:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  80042063c8:	00 00 00 
  80042063cb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042063d0:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042063d7:	00 00 00 
  80042063da:	41 ff d0             	callq  *%r8
	assert(pp0->pp_ref == 1);
  80042063dd:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042063e1:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042063e5:	66 83 f8 01          	cmp    $0x1,%ax
  80042063e9:	74 35                	je     8004206420 <page_check+0x814>
  80042063eb:	48 b9 a6 9a 21 04 80 	movabs $0x8004219aa6,%rcx
  80042063f2:	00 00 00 
  80042063f5:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  80042063fc:	00 00 00 
  80042063ff:	be cf 04 00 00       	mov    $0x4cf,%esi
  8004206404:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  800420640b:	00 00 00 
  800420640e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206413:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  800420641a:	00 00 00 
  800420641d:	41 ff d0             	callq  *%r8
	assert(pp2->pp_ref == 1);
  8004206420:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004206424:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206428:	66 83 f8 01          	cmp    $0x1,%ax
  800420642c:	74 35                	je     8004206463 <page_check+0x857>
  800420642e:	48 b9 b7 9a 21 04 80 	movabs $0x8004219ab7,%rcx
  8004206435:	00 00 00 
  8004206438:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  800420643f:	00 00 00 
  8004206442:	be d0 04 00 00       	mov    $0x4d0,%esi
  8004206447:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  800420644e:	00 00 00 
  8004206451:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206456:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  800420645d:	00 00 00 
  8004206460:	41 ff d0             	callq  *%r8
	//should be able to map pp3 at PGSIZE because pp0 is already allocated for page table
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, 0) == 0);
  8004206463:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  800420646a:	00 00 00 
  800420646d:	48 8b 00             	mov    (%rax),%rax
  8004206470:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004206474:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004206479:	ba 00 10 00 00       	mov    $0x1000,%edx
  800420647e:	48 89 c7             	mov    %rax,%rdi
  8004206481:	48 b8 52 3b 20 04 80 	movabs $0x8004203b52,%rax
  8004206488:	00 00 00 
  800420648b:	ff d0                	callq  *%rax
  800420648d:	85 c0                	test   %eax,%eax
  800420648f:	74 35                	je     80042064c6 <page_check+0x8ba>
  8004206491:	48 b9 c8 9a 21 04 80 	movabs $0x8004219ac8,%rcx
  8004206498:	00 00 00 
  800420649b:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  80042064a2:	00 00 00 
  80042064a5:	be d2 04 00 00       	mov    $0x4d2,%esi
  80042064aa:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  80042064b1:	00 00 00 
  80042064b4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042064b9:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042064c0:	00 00 00 
  80042064c3:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  80042064c6:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  80042064cd:	00 00 00 
  80042064d0:	48 8b 00             	mov    (%rax),%rax
  80042064d3:	be 00 10 00 00       	mov    $0x1000,%esi
  80042064d8:	48 89 c7             	mov    %rax,%rdi
  80042064db:	48 b8 92 59 20 04 80 	movabs $0x8004205992,%rax
  80042064e2:	00 00 00 
  80042064e5:	ff d0                	callq  *%rax
  80042064e7:	48 89 c3             	mov    %rax,%rbx
  80042064ea:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042064ee:	48 89 c7             	mov    %rax,%rdi
  80042064f1:	48 b8 63 1c 20 04 80 	movabs $0x8004201c63,%rax
  80042064f8:	00 00 00 
  80042064fb:	ff d0                	callq  *%rax
  80042064fd:	48 39 c3             	cmp    %rax,%rbx
  8004206500:	74 35                	je     8004206537 <page_check+0x92b>
  8004206502:	48 b9 00 9b 21 04 80 	movabs $0x8004219b00,%rcx
  8004206509:	00 00 00 
  800420650c:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004206513:	00 00 00 
  8004206516:	be d3 04 00 00       	mov    $0x4d3,%esi
  800420651b:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004206522:	00 00 00 
  8004206525:	b8 00 00 00 00       	mov    $0x0,%eax
  800420652a:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004206531:	00 00 00 
  8004206534:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  8004206537:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420653b:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420653f:	66 83 f8 02          	cmp    $0x2,%ax
  8004206543:	74 35                	je     800420657a <page_check+0x96e>
  8004206545:	48 b9 30 9b 21 04 80 	movabs $0x8004219b30,%rcx
  800420654c:	00 00 00 
  800420654f:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004206556:	00 00 00 
  8004206559:	be d4 04 00 00       	mov    $0x4d4,%esi
  800420655e:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004206565:	00 00 00 
  8004206568:	b8 00 00 00 00       	mov    $0x0,%eax
  800420656d:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004206574:	00 00 00 
  8004206577:	41 ff d0             	callq  *%r8

	// should be no free memory
	assert(!page_alloc(0));
  800420657a:	bf 00 00 00 00       	mov    $0x0,%edi
  800420657f:	48 b8 e0 2f 20 04 80 	movabs $0x8004202fe0,%rax
  8004206586:	00 00 00 
  8004206589:	ff d0                	callq  *%rax
  800420658b:	48 85 c0             	test   %rax,%rax
  800420658e:	74 35                	je     80042065c5 <page_check+0x9b9>
  8004206590:	48 b9 4f 96 21 04 80 	movabs $0x800421964f,%rcx
  8004206597:	00 00 00 
  800420659a:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  80042065a1:	00 00 00 
  80042065a4:	be d7 04 00 00       	mov    $0x4d7,%esi
  80042065a9:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  80042065b0:	00 00 00 
  80042065b3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042065b8:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042065bf:	00 00 00 
  80042065c2:	41 ff d0             	callq  *%r8

	// should be able to map pp3 at PGSIZE because it's already there
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, 0) == 0);
  80042065c5:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  80042065cc:	00 00 00 
  80042065cf:	48 8b 00             	mov    (%rax),%rax
  80042065d2:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042065d6:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042065db:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042065e0:	48 89 c7             	mov    %rax,%rdi
  80042065e3:	48 b8 52 3b 20 04 80 	movabs $0x8004203b52,%rax
  80042065ea:	00 00 00 
  80042065ed:	ff d0                	callq  *%rax
  80042065ef:	85 c0                	test   %eax,%eax
  80042065f1:	74 35                	je     8004206628 <page_check+0xa1c>
  80042065f3:	48 b9 c8 9a 21 04 80 	movabs $0x8004219ac8,%rcx
  80042065fa:	00 00 00 
  80042065fd:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004206604:	00 00 00 
  8004206607:	be da 04 00 00       	mov    $0x4da,%esi
  800420660c:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004206613:	00 00 00 
  8004206616:	b8 00 00 00 00       	mov    $0x0,%eax
  800420661b:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004206622:	00 00 00 
  8004206625:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  8004206628:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  800420662f:	00 00 00 
  8004206632:	48 8b 00             	mov    (%rax),%rax
  8004206635:	be 00 10 00 00       	mov    $0x1000,%esi
  800420663a:	48 89 c7             	mov    %rax,%rdi
  800420663d:	48 b8 92 59 20 04 80 	movabs $0x8004205992,%rax
  8004206644:	00 00 00 
  8004206647:	ff d0                	callq  *%rax
  8004206649:	48 89 c3             	mov    %rax,%rbx
  800420664c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206650:	48 89 c7             	mov    %rax,%rdi
  8004206653:	48 b8 63 1c 20 04 80 	movabs $0x8004201c63,%rax
  800420665a:	00 00 00 
  800420665d:	ff d0                	callq  *%rax
  800420665f:	48 39 c3             	cmp    %rax,%rbx
  8004206662:	74 35                	je     8004206699 <page_check+0xa8d>
  8004206664:	48 b9 00 9b 21 04 80 	movabs $0x8004219b00,%rcx
  800420666b:	00 00 00 
  800420666e:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004206675:	00 00 00 
  8004206678:	be db 04 00 00       	mov    $0x4db,%esi
  800420667d:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004206684:	00 00 00 
  8004206687:	b8 00 00 00 00       	mov    $0x0,%eax
  800420668c:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004206693:	00 00 00 
  8004206696:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  8004206699:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420669d:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042066a1:	66 83 f8 02          	cmp    $0x2,%ax
  80042066a5:	74 35                	je     80042066dc <page_check+0xad0>
  80042066a7:	48 b9 30 9b 21 04 80 	movabs $0x8004219b30,%rcx
  80042066ae:	00 00 00 
  80042066b1:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  80042066b8:	00 00 00 
  80042066bb:	be dc 04 00 00       	mov    $0x4dc,%esi
  80042066c0:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  80042066c7:	00 00 00 
  80042066ca:	b8 00 00 00 00       	mov    $0x0,%eax
  80042066cf:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042066d6:	00 00 00 
  80042066d9:	41 ff d0             	callq  *%r8

	// pp3 should NOT be on the free list
	// could happen in ref counts are handled sloppily in page_insert
	assert(!page_alloc(0));
  80042066dc:	bf 00 00 00 00       	mov    $0x0,%edi
  80042066e1:	48 b8 e0 2f 20 04 80 	movabs $0x8004202fe0,%rax
  80042066e8:	00 00 00 
  80042066eb:	ff d0                	callq  *%rax
  80042066ed:	48 85 c0             	test   %rax,%rax
  80042066f0:	74 35                	je     8004206727 <page_check+0xb1b>
  80042066f2:	48 b9 4f 96 21 04 80 	movabs $0x800421964f,%rcx
  80042066f9:	00 00 00 
  80042066fc:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004206703:	00 00 00 
  8004206706:	be e0 04 00 00       	mov    $0x4e0,%esi
  800420670b:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004206712:	00 00 00 
  8004206715:	b8 00 00 00 00       	mov    $0x0,%eax
  800420671a:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004206721:	00 00 00 
  8004206724:	41 ff d0             	callq  *%r8
	// check that pgdir_walk returns a pointer to the pte
	pdpe = KADDR(PTE_ADDR(boot_pml4e[PML4(PGSIZE)]));
  8004206727:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  800420672e:	00 00 00 
  8004206731:	48 8b 00             	mov    (%rax),%rax
  8004206734:	48 8b 00             	mov    (%rax),%rax
  8004206737:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420673d:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  8004206741:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004206745:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206749:	89 45 a4             	mov    %eax,-0x5c(%rbp)
  800420674c:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  800420674f:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  8004206756:	00 00 00 
  8004206759:	48 8b 00             	mov    (%rax),%rax
  800420675c:	48 39 c2             	cmp    %rax,%rdx
  800420675f:	72 32                	jb     8004206793 <page_check+0xb87>
  8004206761:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004206765:	48 89 c1             	mov    %rax,%rcx
  8004206768:	48 ba 28 91 21 04 80 	movabs $0x8004219128,%rdx
  800420676f:	00 00 00 
  8004206772:	be e2 04 00 00       	mov    $0x4e2,%esi
  8004206777:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  800420677e:	00 00 00 
  8004206781:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206786:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  800420678d:	00 00 00 
  8004206790:	41 ff d0             	callq  *%r8
  8004206793:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420679a:	00 00 00 
  800420679d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042067a1:	48 01 d0             	add    %rdx,%rax
  80042067a4:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde = KADDR(PTE_ADDR(pdpe[PDPE(PGSIZE)]));
  80042067a8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042067ac:	48 8b 00             	mov    (%rax),%rax
  80042067af:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042067b5:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  80042067b9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042067bd:	48 c1 e8 0c          	shr    $0xc,%rax
  80042067c1:	89 45 8c             	mov    %eax,-0x74(%rbp)
  80042067c4:	8b 55 8c             	mov    -0x74(%rbp),%edx
  80042067c7:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  80042067ce:	00 00 00 
  80042067d1:	48 8b 00             	mov    (%rax),%rax
  80042067d4:	48 39 c2             	cmp    %rax,%rdx
  80042067d7:	72 32                	jb     800420680b <page_check+0xbff>
  80042067d9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042067dd:	48 89 c1             	mov    %rax,%rcx
  80042067e0:	48 ba 28 91 21 04 80 	movabs $0x8004219128,%rdx
  80042067e7:	00 00 00 
  80042067ea:	be e3 04 00 00       	mov    $0x4e3,%esi
  80042067ef:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  80042067f6:	00 00 00 
  80042067f9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042067fe:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004206805:	00 00 00 
  8004206808:	41 ff d0             	callq  *%r8
  800420680b:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206812:	00 00 00 
  8004206815:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004206819:	48 01 d0             	add    %rdx,%rax
  800420681c:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep = KADDR(PTE_ADDR(pde[PDX(PGSIZE)]));
  8004206820:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004206824:	48 8b 00             	mov    (%rax),%rax
  8004206827:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420682d:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  8004206834:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420683b:	48 c1 e8 0c          	shr    $0xc,%rax
  800420683f:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%rbp)
  8004206845:	8b 95 74 ff ff ff    	mov    -0x8c(%rbp),%edx
  800420684b:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  8004206852:	00 00 00 
  8004206855:	48 8b 00             	mov    (%rax),%rax
  8004206858:	48 39 c2             	cmp    %rax,%rdx
  800420685b:	72 35                	jb     8004206892 <page_check+0xc86>
  800420685d:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004206864:	48 89 c1             	mov    %rax,%rcx
  8004206867:	48 ba 28 91 21 04 80 	movabs $0x8004219128,%rdx
  800420686e:	00 00 00 
  8004206871:	be e4 04 00 00       	mov    $0x4e4,%esi
  8004206876:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  800420687d:	00 00 00 
  8004206880:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206885:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  800420688c:	00 00 00 
  800420688f:	41 ff d0             	callq  *%r8
  8004206892:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206899:	00 00 00 
  800420689c:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042068a3:	48 01 d0             	add    %rdx,%rax
  80042068a6:	48 89 85 e0 fe ff ff 	mov    %rax,-0x120(%rbp)
	assert(pml4e_walk(boot_pml4e, (void*)PGSIZE, 0) == ptep+PTX(PGSIZE));
  80042068ad:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  80042068b4:	00 00 00 
  80042068b7:	48 8b 00             	mov    (%rax),%rax
  80042068ba:	ba 00 00 00 00       	mov    $0x0,%edx
  80042068bf:	be 00 10 00 00       	mov    $0x1000,%esi
  80042068c4:	48 89 c7             	mov    %rax,%rdi
  80042068c7:	48 b8 55 31 20 04 80 	movabs $0x8004203155,%rax
  80042068ce:	00 00 00 
  80042068d1:	ff d0                	callq  *%rax
  80042068d3:	48 8b 95 e0 fe ff ff 	mov    -0x120(%rbp),%rdx
  80042068da:	48 83 c2 08          	add    $0x8,%rdx
  80042068de:	48 39 d0             	cmp    %rdx,%rax
  80042068e1:	74 35                	je     8004206918 <page_check+0xd0c>
  80042068e3:	48 b9 48 9b 21 04 80 	movabs $0x8004219b48,%rcx
  80042068ea:	00 00 00 
  80042068ed:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  80042068f4:	00 00 00 
  80042068f7:	be e5 04 00 00       	mov    $0x4e5,%esi
  80042068fc:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004206903:	00 00 00 
  8004206906:	b8 00 00 00 00       	mov    $0x0,%eax
  800420690b:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004206912:	00 00 00 
  8004206915:	41 ff d0             	callq  *%r8

	// should be able to change permissions too.
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, PTE_U) == 0);
  8004206918:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  800420691f:	00 00 00 
  8004206922:	48 8b 00             	mov    (%rax),%rax
  8004206925:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004206929:	b9 04 00 00 00       	mov    $0x4,%ecx
  800420692e:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206933:	48 89 c7             	mov    %rax,%rdi
  8004206936:	48 b8 52 3b 20 04 80 	movabs $0x8004203b52,%rax
  800420693d:	00 00 00 
  8004206940:	ff d0                	callq  *%rax
  8004206942:	85 c0                	test   %eax,%eax
  8004206944:	74 35                	je     800420697b <page_check+0xd6f>
  8004206946:	48 b9 88 9b 21 04 80 	movabs $0x8004219b88,%rcx
  800420694d:	00 00 00 
  8004206950:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004206957:	00 00 00 
  800420695a:	be e8 04 00 00       	mov    $0x4e8,%esi
  800420695f:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004206966:	00 00 00 
  8004206969:	b8 00 00 00 00       	mov    $0x0,%eax
  800420696e:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004206975:	00 00 00 
  8004206978:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  800420697b:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  8004206982:	00 00 00 
  8004206985:	48 8b 00             	mov    (%rax),%rax
  8004206988:	be 00 10 00 00       	mov    $0x1000,%esi
  800420698d:	48 89 c7             	mov    %rax,%rdi
  8004206990:	48 b8 92 59 20 04 80 	movabs $0x8004205992,%rax
  8004206997:	00 00 00 
  800420699a:	ff d0                	callq  *%rax
  800420699c:	48 89 c3             	mov    %rax,%rbx
  800420699f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042069a3:	48 89 c7             	mov    %rax,%rdi
  80042069a6:	48 b8 63 1c 20 04 80 	movabs $0x8004201c63,%rax
  80042069ad:	00 00 00 
  80042069b0:	ff d0                	callq  *%rax
  80042069b2:	48 39 c3             	cmp    %rax,%rbx
  80042069b5:	74 35                	je     80042069ec <page_check+0xde0>
  80042069b7:	48 b9 00 9b 21 04 80 	movabs $0x8004219b00,%rcx
  80042069be:	00 00 00 
  80042069c1:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  80042069c8:	00 00 00 
  80042069cb:	be e9 04 00 00       	mov    $0x4e9,%esi
  80042069d0:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  80042069d7:	00 00 00 
  80042069da:	b8 00 00 00 00       	mov    $0x0,%eax
  80042069df:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042069e6:	00 00 00 
  80042069e9:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  80042069ec:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042069f0:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042069f4:	66 83 f8 02          	cmp    $0x2,%ax
  80042069f8:	74 35                	je     8004206a2f <page_check+0xe23>
  80042069fa:	48 b9 30 9b 21 04 80 	movabs $0x8004219b30,%rcx
  8004206a01:	00 00 00 
  8004206a04:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004206a0b:	00 00 00 
  8004206a0e:	be ea 04 00 00       	mov    $0x4ea,%esi
  8004206a13:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004206a1a:	00 00 00 
  8004206a1d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206a22:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004206a29:	00 00 00 
  8004206a2c:	41 ff d0             	callq  *%r8
	assert(*pml4e_walk(boot_pml4e, (void*) PGSIZE, 0) & PTE_U);
  8004206a2f:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  8004206a36:	00 00 00 
  8004206a39:	48 8b 00             	mov    (%rax),%rax
  8004206a3c:	ba 00 00 00 00       	mov    $0x0,%edx
  8004206a41:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206a46:	48 89 c7             	mov    %rax,%rdi
  8004206a49:	48 b8 55 31 20 04 80 	movabs $0x8004203155,%rax
  8004206a50:	00 00 00 
  8004206a53:	ff d0                	callq  *%rax
  8004206a55:	48 8b 00             	mov    (%rax),%rax
  8004206a58:	83 e0 04             	and    $0x4,%eax
  8004206a5b:	48 85 c0             	test   %rax,%rax
  8004206a5e:	75 35                	jne    8004206a95 <page_check+0xe89>
  8004206a60:	48 b9 c8 9b 21 04 80 	movabs $0x8004219bc8,%rcx
  8004206a67:	00 00 00 
  8004206a6a:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004206a71:	00 00 00 
  8004206a74:	be eb 04 00 00       	mov    $0x4eb,%esi
  8004206a79:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004206a80:	00 00 00 
  8004206a83:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206a88:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004206a8f:	00 00 00 
  8004206a92:	41 ff d0             	callq  *%r8
	assert(boot_pml4e[0] & PTE_U);
  8004206a95:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  8004206a9c:	00 00 00 
  8004206a9f:	48 8b 00             	mov    (%rax),%rax
  8004206aa2:	48 8b 00             	mov    (%rax),%rax
  8004206aa5:	83 e0 04             	and    $0x4,%eax
  8004206aa8:	48 85 c0             	test   %rax,%rax
  8004206aab:	75 35                	jne    8004206ae2 <page_check+0xed6>
  8004206aad:	48 b9 fb 9b 21 04 80 	movabs $0x8004219bfb,%rcx
  8004206ab4:	00 00 00 
  8004206ab7:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004206abe:	00 00 00 
  8004206ac1:	be ec 04 00 00       	mov    $0x4ec,%esi
  8004206ac6:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004206acd:	00 00 00 
  8004206ad0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206ad5:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004206adc:	00 00 00 
  8004206adf:	41 ff d0             	callq  *%r8


	// should not be able to map at PTSIZE because need free page for page table
	assert(page_insert(boot_pml4e, pp0, (void*) PTSIZE, 0) < 0);
  8004206ae2:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  8004206ae9:	00 00 00 
  8004206aec:	48 8b 00             	mov    (%rax),%rax
  8004206aef:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004206af3:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004206af8:	ba 00 00 20 00       	mov    $0x200000,%edx
  8004206afd:	48 89 c7             	mov    %rax,%rdi
  8004206b00:	48 b8 52 3b 20 04 80 	movabs $0x8004203b52,%rax
  8004206b07:	00 00 00 
  8004206b0a:	ff d0                	callq  *%rax
  8004206b0c:	85 c0                	test   %eax,%eax
  8004206b0e:	78 35                	js     8004206b45 <page_check+0xf39>
  8004206b10:	48 b9 18 9c 21 04 80 	movabs $0x8004219c18,%rcx
  8004206b17:	00 00 00 
  8004206b1a:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004206b21:	00 00 00 
  8004206b24:	be f0 04 00 00       	mov    $0x4f0,%esi
  8004206b29:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004206b30:	00 00 00 
  8004206b33:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206b38:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004206b3f:	00 00 00 
  8004206b42:	41 ff d0             	callq  *%r8

	// insert pp1 at PGSIZE (replacing pp3)
	assert(page_insert(boot_pml4e, pp1, (void*) PGSIZE, 0) == 0);
  8004206b45:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  8004206b4c:	00 00 00 
  8004206b4f:	48 8b 00             	mov    (%rax),%rax
  8004206b52:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004206b56:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004206b5b:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206b60:	48 89 c7             	mov    %rax,%rdi
  8004206b63:	48 b8 52 3b 20 04 80 	movabs $0x8004203b52,%rax
  8004206b6a:	00 00 00 
  8004206b6d:	ff d0                	callq  *%rax
  8004206b6f:	85 c0                	test   %eax,%eax
  8004206b71:	74 35                	je     8004206ba8 <page_check+0xf9c>
  8004206b73:	48 b9 50 9c 21 04 80 	movabs $0x8004219c50,%rcx
  8004206b7a:	00 00 00 
  8004206b7d:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004206b84:	00 00 00 
  8004206b87:	be f3 04 00 00       	mov    $0x4f3,%esi
  8004206b8c:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004206b93:	00 00 00 
  8004206b96:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206b9b:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004206ba2:	00 00 00 
  8004206ba5:	41 ff d0             	callq  *%r8
	assert(!(*pml4e_walk(boot_pml4e, (void*) PGSIZE, 0) & PTE_U));
  8004206ba8:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  8004206baf:	00 00 00 
  8004206bb2:	48 8b 00             	mov    (%rax),%rax
  8004206bb5:	ba 00 00 00 00       	mov    $0x0,%edx
  8004206bba:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206bbf:	48 89 c7             	mov    %rax,%rdi
  8004206bc2:	48 b8 55 31 20 04 80 	movabs $0x8004203155,%rax
  8004206bc9:	00 00 00 
  8004206bcc:	ff d0                	callq  *%rax
  8004206bce:	48 8b 00             	mov    (%rax),%rax
  8004206bd1:	83 e0 04             	and    $0x4,%eax
  8004206bd4:	48 85 c0             	test   %rax,%rax
  8004206bd7:	74 35                	je     8004206c0e <page_check+0x1002>
  8004206bd9:	48 b9 88 9c 21 04 80 	movabs $0x8004219c88,%rcx
  8004206be0:	00 00 00 
  8004206be3:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004206bea:	00 00 00 
  8004206bed:	be f4 04 00 00       	mov    $0x4f4,%esi
  8004206bf2:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004206bf9:	00 00 00 
  8004206bfc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206c01:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004206c08:	00 00 00 
  8004206c0b:	41 ff d0             	callq  *%r8

	// should have pp1 at both 0 and PGSIZE
	assert(check_va2pa(boot_pml4e, 0) == page2pa(pp1));
  8004206c0e:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  8004206c15:	00 00 00 
  8004206c18:	48 8b 00             	mov    (%rax),%rax
  8004206c1b:	be 00 00 00 00       	mov    $0x0,%esi
  8004206c20:	48 89 c7             	mov    %rax,%rdi
  8004206c23:	48 b8 92 59 20 04 80 	movabs $0x8004205992,%rax
  8004206c2a:	00 00 00 
  8004206c2d:	ff d0                	callq  *%rax
  8004206c2f:	48 89 c3             	mov    %rax,%rbx
  8004206c32:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206c36:	48 89 c7             	mov    %rax,%rdi
  8004206c39:	48 b8 63 1c 20 04 80 	movabs $0x8004201c63,%rax
  8004206c40:	00 00 00 
  8004206c43:	ff d0                	callq  *%rax
  8004206c45:	48 39 c3             	cmp    %rax,%rbx
  8004206c48:	74 35                	je     8004206c7f <page_check+0x1073>
  8004206c4a:	48 b9 c0 9c 21 04 80 	movabs $0x8004219cc0,%rcx
  8004206c51:	00 00 00 
  8004206c54:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004206c5b:	00 00 00 
  8004206c5e:	be f7 04 00 00       	mov    $0x4f7,%esi
  8004206c63:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004206c6a:	00 00 00 
  8004206c6d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206c72:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004206c79:	00 00 00 
  8004206c7c:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp1));
  8004206c7f:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  8004206c86:	00 00 00 
  8004206c89:	48 8b 00             	mov    (%rax),%rax
  8004206c8c:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206c91:	48 89 c7             	mov    %rax,%rdi
  8004206c94:	48 b8 92 59 20 04 80 	movabs $0x8004205992,%rax
  8004206c9b:	00 00 00 
  8004206c9e:	ff d0                	callq  *%rax
  8004206ca0:	48 89 c3             	mov    %rax,%rbx
  8004206ca3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206ca7:	48 89 c7             	mov    %rax,%rdi
  8004206caa:	48 b8 63 1c 20 04 80 	movabs $0x8004201c63,%rax
  8004206cb1:	00 00 00 
  8004206cb4:	ff d0                	callq  *%rax
  8004206cb6:	48 39 c3             	cmp    %rax,%rbx
  8004206cb9:	74 35                	je     8004206cf0 <page_check+0x10e4>
  8004206cbb:	48 b9 f0 9c 21 04 80 	movabs $0x8004219cf0,%rcx
  8004206cc2:	00 00 00 
  8004206cc5:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004206ccc:	00 00 00 
  8004206ccf:	be f8 04 00 00       	mov    $0x4f8,%esi
  8004206cd4:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004206cdb:	00 00 00 
  8004206cde:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206ce3:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004206cea:	00 00 00 
  8004206ced:	41 ff d0             	callq  *%r8
	// ... and ref counts should reflect this
	assert(pp1->pp_ref == 2);
  8004206cf0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206cf4:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206cf8:	66 83 f8 02          	cmp    $0x2,%ax
  8004206cfc:	74 35                	je     8004206d33 <page_check+0x1127>
  8004206cfe:	48 b9 20 9d 21 04 80 	movabs $0x8004219d20,%rcx
  8004206d05:	00 00 00 
  8004206d08:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004206d0f:	00 00 00 
  8004206d12:	be fa 04 00 00       	mov    $0x4fa,%esi
  8004206d17:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004206d1e:	00 00 00 
  8004206d21:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206d26:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004206d2d:	00 00 00 
  8004206d30:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  8004206d33:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206d37:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206d3b:	66 83 f8 01          	cmp    $0x1,%ax
  8004206d3f:	74 35                	je     8004206d76 <page_check+0x116a>
  8004206d41:	48 b9 31 9d 21 04 80 	movabs $0x8004219d31,%rcx
  8004206d48:	00 00 00 
  8004206d4b:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004206d52:	00 00 00 
  8004206d55:	be fb 04 00 00       	mov    $0x4fb,%esi
  8004206d5a:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004206d61:	00 00 00 
  8004206d64:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206d69:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004206d70:	00 00 00 
  8004206d73:	41 ff d0             	callq  *%r8


	// unmapping pp1 at 0 should keep pp1 at PGSIZE
	page_remove(boot_pml4e, 0x0);
  8004206d76:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  8004206d7d:	00 00 00 
  8004206d80:	48 8b 00             	mov    (%rax),%rax
  8004206d83:	be 00 00 00 00       	mov    $0x0,%esi
  8004206d88:	48 89 c7             	mov    %rax,%rdi
  8004206d8b:	48 b8 4d 3f 20 04 80 	movabs $0x8004203f4d,%rax
  8004206d92:	00 00 00 
  8004206d95:	ff d0                	callq  *%rax
	assert(check_va2pa(boot_pml4e, 0x0) == ~0);
  8004206d97:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  8004206d9e:	00 00 00 
  8004206da1:	48 8b 00             	mov    (%rax),%rax
  8004206da4:	be 00 00 00 00       	mov    $0x0,%esi
  8004206da9:	48 89 c7             	mov    %rax,%rdi
  8004206dac:	48 b8 92 59 20 04 80 	movabs $0x8004205992,%rax
  8004206db3:	00 00 00 
  8004206db6:	ff d0                	callq  *%rax
  8004206db8:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004206dbc:	74 35                	je     8004206df3 <page_check+0x11e7>
  8004206dbe:	48 b9 48 9d 21 04 80 	movabs $0x8004219d48,%rcx
  8004206dc5:	00 00 00 
  8004206dc8:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004206dcf:	00 00 00 
  8004206dd2:	be 00 05 00 00       	mov    $0x500,%esi
  8004206dd7:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004206dde:	00 00 00 
  8004206de1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206de6:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004206ded:	00 00 00 
  8004206df0:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp1));
  8004206df3:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  8004206dfa:	00 00 00 
  8004206dfd:	48 8b 00             	mov    (%rax),%rax
  8004206e00:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206e05:	48 89 c7             	mov    %rax,%rdi
  8004206e08:	48 b8 92 59 20 04 80 	movabs $0x8004205992,%rax
  8004206e0f:	00 00 00 
  8004206e12:	ff d0                	callq  *%rax
  8004206e14:	48 89 c3             	mov    %rax,%rbx
  8004206e17:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206e1b:	48 89 c7             	mov    %rax,%rdi
  8004206e1e:	48 b8 63 1c 20 04 80 	movabs $0x8004201c63,%rax
  8004206e25:	00 00 00 
  8004206e28:	ff d0                	callq  *%rax
  8004206e2a:	48 39 c3             	cmp    %rax,%rbx
  8004206e2d:	74 35                	je     8004206e64 <page_check+0x1258>
  8004206e2f:	48 b9 f0 9c 21 04 80 	movabs $0x8004219cf0,%rcx
  8004206e36:	00 00 00 
  8004206e39:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004206e40:	00 00 00 
  8004206e43:	be 01 05 00 00       	mov    $0x501,%esi
  8004206e48:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004206e4f:	00 00 00 
  8004206e52:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206e57:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004206e5e:	00 00 00 
  8004206e61:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 1);
  8004206e64:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206e68:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206e6c:	66 83 f8 01          	cmp    $0x1,%ax
  8004206e70:	74 35                	je     8004206ea7 <page_check+0x129b>
  8004206e72:	48 b9 95 9a 21 04 80 	movabs $0x8004219a95,%rcx
  8004206e79:	00 00 00 
  8004206e7c:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004206e83:	00 00 00 
  8004206e86:	be 02 05 00 00       	mov    $0x502,%esi
  8004206e8b:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004206e92:	00 00 00 
  8004206e95:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206e9a:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004206ea1:	00 00 00 
  8004206ea4:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  8004206ea7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206eab:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206eaf:	66 83 f8 01          	cmp    $0x1,%ax
  8004206eb3:	74 35                	je     8004206eea <page_check+0x12de>
  8004206eb5:	48 b9 31 9d 21 04 80 	movabs $0x8004219d31,%rcx
  8004206ebc:	00 00 00 
  8004206ebf:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004206ec6:	00 00 00 
  8004206ec9:	be 03 05 00 00       	mov    $0x503,%esi
  8004206ece:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004206ed5:	00 00 00 
  8004206ed8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206edd:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004206ee4:	00 00 00 
  8004206ee7:	41 ff d0             	callq  *%r8

	// Test re-inserting pp1 at PGSIZE.
	// Thanks to Varun Agrawal for suggesting this test case.
	assert(page_insert(boot_pml4e, pp1, (void*) PGSIZE, 0) == 0);
  8004206eea:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  8004206ef1:	00 00 00 
  8004206ef4:	48 8b 00             	mov    (%rax),%rax
  8004206ef7:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004206efb:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004206f00:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206f05:	48 89 c7             	mov    %rax,%rdi
  8004206f08:	48 b8 52 3b 20 04 80 	movabs $0x8004203b52,%rax
  8004206f0f:	00 00 00 
  8004206f12:	ff d0                	callq  *%rax
  8004206f14:	85 c0                	test   %eax,%eax
  8004206f16:	74 35                	je     8004206f4d <page_check+0x1341>
  8004206f18:	48 b9 50 9c 21 04 80 	movabs $0x8004219c50,%rcx
  8004206f1f:	00 00 00 
  8004206f22:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004206f29:	00 00 00 
  8004206f2c:	be 07 05 00 00       	mov    $0x507,%esi
  8004206f31:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004206f38:	00 00 00 
  8004206f3b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206f40:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004206f47:	00 00 00 
  8004206f4a:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref);
  8004206f4d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206f51:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206f55:	66 85 c0             	test   %ax,%ax
  8004206f58:	75 35                	jne    8004206f8f <page_check+0x1383>
  8004206f5a:	48 b9 6b 9d 21 04 80 	movabs $0x8004219d6b,%rcx
  8004206f61:	00 00 00 
  8004206f64:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004206f6b:	00 00 00 
  8004206f6e:	be 08 05 00 00       	mov    $0x508,%esi
  8004206f73:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004206f7a:	00 00 00 
  8004206f7d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206f82:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004206f89:	00 00 00 
  8004206f8c:	41 ff d0             	callq  *%r8
	assert(pp1->pp_link == NULL);
  8004206f8f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206f93:	48 8b 00             	mov    (%rax),%rax
  8004206f96:	48 85 c0             	test   %rax,%rax
  8004206f99:	74 35                	je     8004206fd0 <page_check+0x13c4>
  8004206f9b:	48 b9 77 9d 21 04 80 	movabs $0x8004219d77,%rcx
  8004206fa2:	00 00 00 
  8004206fa5:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004206fac:	00 00 00 
  8004206faf:	be 09 05 00 00       	mov    $0x509,%esi
  8004206fb4:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004206fbb:	00 00 00 
  8004206fbe:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206fc3:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004206fca:	00 00 00 
  8004206fcd:	41 ff d0             	callq  *%r8

	// unmapping pp1 at PGSIZE should free it
	page_remove(boot_pml4e, (void*) PGSIZE);
  8004206fd0:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  8004206fd7:	00 00 00 
  8004206fda:	48 8b 00             	mov    (%rax),%rax
  8004206fdd:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206fe2:	48 89 c7             	mov    %rax,%rdi
  8004206fe5:	48 b8 4d 3f 20 04 80 	movabs $0x8004203f4d,%rax
  8004206fec:	00 00 00 
  8004206fef:	ff d0                	callq  *%rax
	assert(check_va2pa(boot_pml4e, 0x0) == ~0);
  8004206ff1:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  8004206ff8:	00 00 00 
  8004206ffb:	48 8b 00             	mov    (%rax),%rax
  8004206ffe:	be 00 00 00 00       	mov    $0x0,%esi
  8004207003:	48 89 c7             	mov    %rax,%rdi
  8004207006:	48 b8 92 59 20 04 80 	movabs $0x8004205992,%rax
  800420700d:	00 00 00 
  8004207010:	ff d0                	callq  *%rax
  8004207012:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004207016:	74 35                	je     800420704d <page_check+0x1441>
  8004207018:	48 b9 48 9d 21 04 80 	movabs $0x8004219d48,%rcx
  800420701f:	00 00 00 
  8004207022:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004207029:	00 00 00 
  800420702c:	be 0d 05 00 00       	mov    $0x50d,%esi
  8004207031:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004207038:	00 00 00 
  800420703b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207040:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004207047:	00 00 00 
  800420704a:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == ~0);
  800420704d:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  8004207054:	00 00 00 
  8004207057:	48 8b 00             	mov    (%rax),%rax
  800420705a:	be 00 10 00 00       	mov    $0x1000,%esi
  800420705f:	48 89 c7             	mov    %rax,%rdi
  8004207062:	48 b8 92 59 20 04 80 	movabs $0x8004205992,%rax
  8004207069:	00 00 00 
  800420706c:	ff d0                	callq  *%rax
  800420706e:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004207072:	74 35                	je     80042070a9 <page_check+0x149d>
  8004207074:	48 b9 90 9d 21 04 80 	movabs $0x8004219d90,%rcx
  800420707b:	00 00 00 
  800420707e:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004207085:	00 00 00 
  8004207088:	be 0e 05 00 00       	mov    $0x50e,%esi
  800420708d:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004207094:	00 00 00 
  8004207097:	b8 00 00 00 00       	mov    $0x0,%eax
  800420709c:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042070a3:	00 00 00 
  80042070a6:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 0);
  80042070a9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042070ad:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042070b1:	66 85 c0             	test   %ax,%ax
  80042070b4:	74 35                	je     80042070eb <page_check+0x14df>
  80042070b6:	48 b9 b6 9d 21 04 80 	movabs $0x8004219db6,%rcx
  80042070bd:	00 00 00 
  80042070c0:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  80042070c7:	00 00 00 
  80042070ca:	be 0f 05 00 00       	mov    $0x50f,%esi
  80042070cf:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  80042070d6:	00 00 00 
  80042070d9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042070de:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042070e5:	00 00 00 
  80042070e8:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  80042070eb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042070ef:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042070f3:	66 83 f8 01          	cmp    $0x1,%ax
  80042070f7:	74 35                	je     800420712e <page_check+0x1522>
  80042070f9:	48 b9 31 9d 21 04 80 	movabs $0x8004219d31,%rcx
  8004207100:	00 00 00 
  8004207103:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  800420710a:	00 00 00 
  800420710d:	be 10 05 00 00       	mov    $0x510,%esi
  8004207112:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004207119:	00 00 00 
  800420711c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207121:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004207128:	00 00 00 
  800420712b:	41 ff d0             	callq  *%r8
	page_remove(boot_pgdir, 0x0);
	assert(pp2->pp_ref == 0);
#endif

	// forcibly take pp3 back
	struct PageInfo *pp_l1 = pa2page(PTE_ADDR(boot_pml4e[0]));
  800420712e:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  8004207135:	00 00 00 
  8004207138:	48 8b 00             	mov    (%rax),%rax
  800420713b:	48 8b 00             	mov    (%rax),%rax
  800420713e:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207144:	48 89 c7             	mov    %rax,%rdi
  8004207147:	48 b8 88 1c 20 04 80 	movabs $0x8004201c88,%rax
  800420714e:	00 00 00 
  8004207151:	ff d0                	callq  *%rax
  8004207153:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
	boot_pml4e[0] = 0;
  800420715a:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  8004207161:	00 00 00 
  8004207164:	48 8b 00             	mov    (%rax),%rax
  8004207167:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	assert(pp3->pp_ref == 1);
  800420716e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207172:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004207176:	66 83 f8 01          	cmp    $0x1,%ax
  800420717a:	74 35                	je     80042071b1 <page_check+0x15a5>
  800420717c:	48 b9 31 9d 21 04 80 	movabs $0x8004219d31,%rcx
  8004207183:	00 00 00 
  8004207186:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  800420718d:	00 00 00 
  8004207190:	be 26 05 00 00       	mov    $0x526,%esi
  8004207195:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  800420719c:	00 00 00 
  800420719f:	b8 00 00 00 00       	mov    $0x0,%eax
  80042071a4:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042071ab:	00 00 00 
  80042071ae:	41 ff d0             	callq  *%r8
	page_decref(pp_l1);
  80042071b1:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042071b8:	48 89 c7             	mov    %rax,%rdi
  80042071bb:	48 b8 14 31 20 04 80 	movabs $0x8004203114,%rax
  80042071c2:	00 00 00 
  80042071c5:	ff d0                	callq  *%rax
	// check pointer arithmetic in pml4e_walk
	if (pp_l1 != pp3) page_decref(pp3);
  80042071c7:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042071ce:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042071d2:	74 13                	je     80042071e7 <page_check+0x15db>
  80042071d4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042071d8:	48 89 c7             	mov    %rax,%rdi
  80042071db:	48 b8 14 31 20 04 80 	movabs $0x8004203114,%rax
  80042071e2:	00 00 00 
  80042071e5:	ff d0                	callq  *%rax
	if (pp_l1 != pp2) page_decref(pp2);
  80042071e7:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042071ee:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  80042071f2:	74 13                	je     8004207207 <page_check+0x15fb>
  80042071f4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042071f8:	48 89 c7             	mov    %rax,%rdi
  80042071fb:	48 b8 14 31 20 04 80 	movabs $0x8004203114,%rax
  8004207202:	00 00 00 
  8004207205:	ff d0                	callq  *%rax
	if (pp_l1 != pp0) page_decref(pp0);
  8004207207:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420720e:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004207212:	74 13                	je     8004207227 <page_check+0x161b>
  8004207214:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004207218:	48 89 c7             	mov    %rax,%rdi
  800420721b:	48 b8 14 31 20 04 80 	movabs $0x8004203114,%rax
  8004207222:	00 00 00 
  8004207225:	ff d0                	callq  *%rax
	va = (void*)(PGSIZE * 100);
  8004207227:	48 c7 85 60 ff ff ff 	movq   $0x64000,-0xa0(%rbp)
  800420722e:	00 40 06 00 
	ptep = pml4e_walk(boot_pml4e, va, 1);
  8004207232:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  8004207239:	00 00 00 
  800420723c:	48 8b 00             	mov    (%rax),%rax
  800420723f:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004207246:	ba 01 00 00 00       	mov    $0x1,%edx
  800420724b:	48 89 ce             	mov    %rcx,%rsi
  800420724e:	48 89 c7             	mov    %rax,%rdi
  8004207251:	48 b8 55 31 20 04 80 	movabs $0x8004203155,%rax
  8004207258:	00 00 00 
  800420725b:	ff d0                	callq  *%rax
  800420725d:	48 89 85 e0 fe ff ff 	mov    %rax,-0x120(%rbp)
	pdpe = KADDR(PTE_ADDR(boot_pml4e[PML4(va)]));
  8004207264:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  800420726b:	00 00 00 
  800420726e:	48 8b 00             	mov    (%rax),%rax
  8004207271:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004207278:	48 c1 ea 27          	shr    $0x27,%rdx
  800420727c:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8004207282:	48 c1 e2 03          	shl    $0x3,%rdx
  8004207286:	48 01 d0             	add    %rdx,%rax
  8004207289:	48 8b 00             	mov    (%rax),%rax
  800420728c:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207292:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
  8004207299:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042072a0:	48 c1 e8 0c          	shr    $0xc,%rax
  80042072a4:	89 85 54 ff ff ff    	mov    %eax,-0xac(%rbp)
  80042072aa:	8b 95 54 ff ff ff    	mov    -0xac(%rbp),%edx
  80042072b0:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  80042072b7:	00 00 00 
  80042072ba:	48 8b 00             	mov    (%rax),%rax
  80042072bd:	48 39 c2             	cmp    %rax,%rdx
  80042072c0:	72 35                	jb     80042072f7 <page_check+0x16eb>
  80042072c2:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042072c9:	48 89 c1             	mov    %rax,%rcx
  80042072cc:	48 ba 28 91 21 04 80 	movabs $0x8004219128,%rdx
  80042072d3:	00 00 00 
  80042072d6:	be 2e 05 00 00       	mov    $0x52e,%esi
  80042072db:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  80042072e2:	00 00 00 
  80042072e5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042072ea:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042072f1:	00 00 00 
  80042072f4:	41 ff d0             	callq  *%r8
  80042072f7:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042072fe:	00 00 00 
  8004207301:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004207308:	48 01 d0             	add    %rdx,%rax
  800420730b:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde  = KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  800420730f:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004207316:	48 c1 e8 1e          	shr    $0x1e,%rax
  800420731a:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420731f:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004207326:	00 
  8004207327:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420732b:	48 01 d0             	add    %rdx,%rax
  800420732e:	48 8b 00             	mov    (%rax),%rax
  8004207331:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207337:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
  800420733e:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004207345:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207349:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%rbp)
  800420734f:	8b 95 44 ff ff ff    	mov    -0xbc(%rbp),%edx
  8004207355:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  800420735c:	00 00 00 
  800420735f:	48 8b 00             	mov    (%rax),%rax
  8004207362:	48 39 c2             	cmp    %rax,%rdx
  8004207365:	72 35                	jb     800420739c <page_check+0x1790>
  8004207367:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  800420736e:	48 89 c1             	mov    %rax,%rcx
  8004207371:	48 ba 28 91 21 04 80 	movabs $0x8004219128,%rdx
  8004207378:	00 00 00 
  800420737b:	be 2f 05 00 00       	mov    $0x52f,%esi
  8004207380:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004207387:	00 00 00 
  800420738a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420738f:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004207396:	00 00 00 
  8004207399:	41 ff d0             	callq  *%r8
  800420739c:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042073a3:	00 00 00 
  80042073a6:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  80042073ad:	48 01 d0             	add    %rdx,%rax
  80042073b0:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep1 = KADDR(PTE_ADDR(pde[PDX(va)]));
  80042073b4:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042073bb:	48 c1 e8 15          	shr    $0x15,%rax
  80042073bf:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042073c4:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042073cb:	00 
  80042073cc:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042073d0:	48 01 d0             	add    %rdx,%rax
  80042073d3:	48 8b 00             	mov    (%rax),%rax
  80042073d6:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042073dc:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  80042073e3:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  80042073ea:	48 c1 e8 0c          	shr    $0xc,%rax
  80042073ee:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%rbp)
  80042073f4:	8b 95 34 ff ff ff    	mov    -0xcc(%rbp),%edx
  80042073fa:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  8004207401:	00 00 00 
  8004207404:	48 8b 00             	mov    (%rax),%rax
  8004207407:	48 39 c2             	cmp    %rax,%rdx
  800420740a:	72 35                	jb     8004207441 <page_check+0x1835>
  800420740c:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  8004207413:	48 89 c1             	mov    %rax,%rcx
  8004207416:	48 ba 28 91 21 04 80 	movabs $0x8004219128,%rdx
  800420741d:	00 00 00 
  8004207420:	be 30 05 00 00       	mov    $0x530,%esi
  8004207425:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  800420742c:	00 00 00 
  800420742f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207434:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  800420743b:	00 00 00 
  800420743e:	41 ff d0             	callq  *%r8
  8004207441:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207448:	00 00 00 
  800420744b:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  8004207452:	48 01 d0             	add    %rdx,%rax
  8004207455:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	assert(ptep == ptep1 + PTX(va));
  800420745c:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004207463:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207467:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420746c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004207473:	00 
  8004207474:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800420747b:	48 01 c2             	add    %rax,%rdx
  800420747e:	48 8b 85 e0 fe ff ff 	mov    -0x120(%rbp),%rax
  8004207485:	48 39 c2             	cmp    %rax,%rdx
  8004207488:	74 35                	je     80042074bf <page_check+0x18b3>
  800420748a:	48 b9 c7 9d 21 04 80 	movabs $0x8004219dc7,%rcx
  8004207491:	00 00 00 
  8004207494:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  800420749b:	00 00 00 
  800420749e:	be 31 05 00 00       	mov    $0x531,%esi
  80042074a3:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  80042074aa:	00 00 00 
  80042074ad:	b8 00 00 00 00       	mov    $0x0,%eax
  80042074b2:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042074b9:	00 00 00 
  80042074bc:	41 ff d0             	callq  *%r8

	// check that new page tables get cleared
	memset(page2kva(pp4), 0xFF, PGSIZE);
  80042074bf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042074c3:	48 89 c7             	mov    %rax,%rdi
  80042074c6:	48 b8 f9 1c 20 04 80 	movabs $0x8004201cf9,%rax
  80042074cd:	00 00 00 
  80042074d0:	ff d0                	callq  *%rax
  80042074d2:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042074d7:	be ff 00 00 00       	mov    $0xff,%esi
  80042074dc:	48 89 c7             	mov    %rax,%rdi
  80042074df:	48 b8 d4 03 21 04 80 	movabs $0x80042103d4,%rax
  80042074e6:	00 00 00 
  80042074e9:	ff d0                	callq  *%rax
	pml4e_walk(boot_pml4e, 0x0, 1);
  80042074eb:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  80042074f2:	00 00 00 
  80042074f5:	48 8b 00             	mov    (%rax),%rax
  80042074f8:	ba 01 00 00 00       	mov    $0x1,%edx
  80042074fd:	be 00 00 00 00       	mov    $0x0,%esi
  8004207502:	48 89 c7             	mov    %rax,%rdi
  8004207505:	48 b8 55 31 20 04 80 	movabs $0x8004203155,%rax
  800420750c:	00 00 00 
  800420750f:	ff d0                	callq  *%rax
	pdpe = KADDR(PTE_ADDR(boot_pml4e[0]));
  8004207511:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  8004207518:	00 00 00 
  800420751b:	48 8b 00             	mov    (%rax),%rax
  800420751e:	48 8b 00             	mov    (%rax),%rax
  8004207521:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207527:	48 89 85 20 ff ff ff 	mov    %rax,-0xe0(%rbp)
  800420752e:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  8004207535:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207539:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%rbp)
  800420753f:	8b 95 1c ff ff ff    	mov    -0xe4(%rbp),%edx
  8004207545:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  800420754c:	00 00 00 
  800420754f:	48 8b 00             	mov    (%rax),%rax
  8004207552:	48 39 c2             	cmp    %rax,%rdx
  8004207555:	72 35                	jb     800420758c <page_check+0x1980>
  8004207557:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  800420755e:	48 89 c1             	mov    %rax,%rcx
  8004207561:	48 ba 28 91 21 04 80 	movabs $0x8004219128,%rdx
  8004207568:	00 00 00 
  800420756b:	be 36 05 00 00       	mov    $0x536,%esi
  8004207570:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004207577:	00 00 00 
  800420757a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420757f:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004207586:	00 00 00 
  8004207589:	41 ff d0             	callq  *%r8
  800420758c:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207593:	00 00 00 
  8004207596:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  800420759d:	48 01 d0             	add    %rdx,%rax
  80042075a0:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde  = KADDR(PTE_ADDR(pdpe[0]));
  80042075a4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042075a8:	48 8b 00             	mov    (%rax),%rax
  80042075ab:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042075b1:	48 89 85 10 ff ff ff 	mov    %rax,-0xf0(%rbp)
  80042075b8:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  80042075bf:	48 c1 e8 0c          	shr    $0xc,%rax
  80042075c3:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%rbp)
  80042075c9:	8b 95 0c ff ff ff    	mov    -0xf4(%rbp),%edx
  80042075cf:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  80042075d6:	00 00 00 
  80042075d9:	48 8b 00             	mov    (%rax),%rax
  80042075dc:	48 39 c2             	cmp    %rax,%rdx
  80042075df:	72 35                	jb     8004207616 <page_check+0x1a0a>
  80042075e1:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  80042075e8:	48 89 c1             	mov    %rax,%rcx
  80042075eb:	48 ba 28 91 21 04 80 	movabs $0x8004219128,%rdx
  80042075f2:	00 00 00 
  80042075f5:	be 37 05 00 00       	mov    $0x537,%esi
  80042075fa:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004207601:	00 00 00 
  8004207604:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207609:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004207610:	00 00 00 
  8004207613:	41 ff d0             	callq  *%r8
  8004207616:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420761d:	00 00 00 
  8004207620:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004207627:	48 01 d0             	add    %rdx,%rax
  800420762a:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep  = KADDR(PTE_ADDR(pde[0]));
  800420762e:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004207632:	48 8b 00             	mov    (%rax),%rax
  8004207635:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420763b:	48 89 85 00 ff ff ff 	mov    %rax,-0x100(%rbp)
  8004207642:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
  8004207649:	48 c1 e8 0c          	shr    $0xc,%rax
  800420764d:	89 85 fc fe ff ff    	mov    %eax,-0x104(%rbp)
  8004207653:	8b 95 fc fe ff ff    	mov    -0x104(%rbp),%edx
  8004207659:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  8004207660:	00 00 00 
  8004207663:	48 8b 00             	mov    (%rax),%rax
  8004207666:	48 39 c2             	cmp    %rax,%rdx
  8004207669:	72 35                	jb     80042076a0 <page_check+0x1a94>
  800420766b:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
  8004207672:	48 89 c1             	mov    %rax,%rcx
  8004207675:	48 ba 28 91 21 04 80 	movabs $0x8004219128,%rdx
  800420767c:	00 00 00 
  800420767f:	be 38 05 00 00       	mov    $0x538,%esi
  8004207684:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  800420768b:	00 00 00 
  800420768e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207693:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  800420769a:	00 00 00 
  800420769d:	41 ff d0             	callq  *%r8
  80042076a0:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042076a7:	00 00 00 
  80042076aa:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
  80042076b1:	48 01 d0             	add    %rdx,%rax
  80042076b4:	48 89 85 e0 fe ff ff 	mov    %rax,-0x120(%rbp)
	for(i=0; i<NPTENTRIES; i++)
  80042076bb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  80042076c2:	eb 58                	jmp    800420771c <page_check+0x1b10>
		assert((ptep[i] & PTE_P) == 0);
  80042076c4:	48 8b 85 e0 fe ff ff 	mov    -0x120(%rbp),%rax
  80042076cb:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042076ce:	48 63 d2             	movslq %edx,%rdx
  80042076d1:	48 c1 e2 03          	shl    $0x3,%rdx
  80042076d5:	48 01 d0             	add    %rdx,%rax
  80042076d8:	48 8b 00             	mov    (%rax),%rax
  80042076db:	83 e0 01             	and    $0x1,%eax
  80042076de:	48 85 c0             	test   %rax,%rax
  80042076e1:	74 35                	je     8004207718 <page_check+0x1b0c>
  80042076e3:	48 b9 df 9d 21 04 80 	movabs $0x8004219ddf,%rcx
  80042076ea:	00 00 00 
  80042076ed:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  80042076f4:	00 00 00 
  80042076f7:	be 3a 05 00 00       	mov    $0x53a,%esi
  80042076fc:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004207703:	00 00 00 
  8004207706:	b8 00 00 00 00       	mov    $0x0,%eax
  800420770b:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004207712:	00 00 00 
  8004207715:	41 ff d0             	callq  *%r8
	memset(page2kva(pp4), 0xFF, PGSIZE);
	pml4e_walk(boot_pml4e, 0x0, 1);
	pdpe = KADDR(PTE_ADDR(boot_pml4e[0]));
	pde  = KADDR(PTE_ADDR(pdpe[0]));
	ptep  = KADDR(PTE_ADDR(pde[0]));
	for(i=0; i<NPTENTRIES; i++)
  8004207718:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  800420771c:	81 7d ec ff 01 00 00 	cmpl   $0x1ff,-0x14(%rbp)
  8004207723:	7e 9f                	jle    80042076c4 <page_check+0x1ab8>
		assert((ptep[i] & PTE_P) == 0);
	boot_pml4e[0] = 0;
  8004207725:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  800420772c:	00 00 00 
  800420772f:	48 8b 00             	mov    (%rax),%rax
  8004207732:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// give free list back
	page_free_list = fl;
  8004207739:	48 b8 38 d2 49 04 80 	movabs $0x800449d238,%rax
  8004207740:	00 00 00 
  8004207743:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004207747:	48 89 10             	mov    %rdx,(%rax)

	// free the pages we took
	page_decref(pp0);
  800420774a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420774e:	48 89 c7             	mov    %rax,%rdi
  8004207751:	48 b8 14 31 20 04 80 	movabs $0x8004203114,%rax
  8004207758:	00 00 00 
  800420775b:	ff d0                	callq  *%rax
	page_decref(pp2);
  800420775d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207761:	48 89 c7             	mov    %rax,%rdi
  8004207764:	48 b8 14 31 20 04 80 	movabs $0x8004203114,%rax
  800420776b:	00 00 00 
  800420776e:	ff d0                	callq  *%rax
	page_decref(pp3);
  8004207770:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207774:	48 89 c7             	mov    %rax,%rdi
  8004207777:	48 b8 14 31 20 04 80 	movabs $0x8004203114,%rax
  800420777e:	00 00 00 
  8004207781:	ff d0                	callq  *%rax

	// Triple check that we got the ref counts right
	assert(pp0->pp_ref == 0);
  8004207783:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004207787:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420778b:	66 85 c0             	test   %ax,%ax
  800420778e:	74 35                	je     80042077c5 <page_check+0x1bb9>
  8004207790:	48 b9 f6 9d 21 04 80 	movabs $0x8004219df6,%rcx
  8004207797:	00 00 00 
  800420779a:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  80042077a1:	00 00 00 
  80042077a4:	be 46 05 00 00       	mov    $0x546,%esi
  80042077a9:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  80042077b0:	00 00 00 
  80042077b3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042077b8:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042077bf:	00 00 00 
  80042077c2:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 0);
  80042077c5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042077c9:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042077cd:	66 85 c0             	test   %ax,%ax
  80042077d0:	74 35                	je     8004207807 <page_check+0x1bfb>
  80042077d2:	48 b9 b6 9d 21 04 80 	movabs $0x8004219db6,%rcx
  80042077d9:	00 00 00 
  80042077dc:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  80042077e3:	00 00 00 
  80042077e6:	be 47 05 00 00       	mov    $0x547,%esi
  80042077eb:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  80042077f2:	00 00 00 
  80042077f5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042077fa:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004207801:	00 00 00 
  8004207804:	41 ff d0             	callq  *%r8
	assert(pp2->pp_ref == 0);
  8004207807:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420780b:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420780f:	66 85 c0             	test   %ax,%ax
  8004207812:	74 35                	je     8004207849 <page_check+0x1c3d>
  8004207814:	48 b9 07 9e 21 04 80 	movabs $0x8004219e07,%rcx
  800420781b:	00 00 00 
  800420781e:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004207825:	00 00 00 
  8004207828:	be 48 05 00 00       	mov    $0x548,%esi
  800420782d:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004207834:	00 00 00 
  8004207837:	b8 00 00 00 00       	mov    $0x0,%eax
  800420783c:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004207843:	00 00 00 
  8004207846:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 0);
  8004207849:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420784d:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004207851:	66 85 c0             	test   %ax,%ax
  8004207854:	74 35                	je     800420788b <page_check+0x1c7f>
  8004207856:	48 b9 18 9e 21 04 80 	movabs $0x8004219e18,%rcx
  800420785d:	00 00 00 
  8004207860:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004207867:	00 00 00 
  800420786a:	be 49 05 00 00       	mov    $0x549,%esi
  800420786f:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004207876:	00 00 00 
  8004207879:	b8 00 00 00 00       	mov    $0x0,%eax
  800420787e:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004207885:	00 00 00 
  8004207888:	41 ff d0             	callq  *%r8
	assert(pp4->pp_ref == 0);
  800420788b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420788f:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004207893:	66 85 c0             	test   %ax,%ax
  8004207896:	74 35                	je     80042078cd <page_check+0x1cc1>
  8004207898:	48 b9 29 9e 21 04 80 	movabs $0x8004219e29,%rcx
  800420789f:	00 00 00 
  80042078a2:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  80042078a9:	00 00 00 
  80042078ac:	be 4a 05 00 00       	mov    $0x54a,%esi
  80042078b1:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  80042078b8:	00 00 00 
  80042078bb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042078c0:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042078c7:	00 00 00 
  80042078ca:	41 ff d0             	callq  *%r8
	assert(pp5->pp_ref == 0);
  80042078cd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042078d1:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042078d5:	66 85 c0             	test   %ax,%ax
  80042078d8:	74 35                	je     800420790f <page_check+0x1d03>
  80042078da:	48 b9 3a 9e 21 04 80 	movabs $0x8004219e3a,%rcx
  80042078e1:	00 00 00 
  80042078e4:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  80042078eb:	00 00 00 
  80042078ee:	be 4b 05 00 00       	mov    $0x54b,%esi
  80042078f3:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  80042078fa:	00 00 00 
  80042078fd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207902:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004207909:	00 00 00 
  800420790c:	41 ff d0             	callq  *%r8


	// test mmio_map_region
	mm1 = (uintptr_t) mmio_map_region(0, 4097);
  800420790f:	be 01 10 00 00       	mov    $0x1001,%esi
  8004207914:	bf 00 00 00 00       	mov    $0x0,%edi
  8004207919:	48 b8 8f 40 20 04 80 	movabs $0x800420408f,%rax
  8004207920:	00 00 00 
  8004207923:	ff d0                	callq  *%rax
  8004207925:	48 89 85 f0 fe ff ff 	mov    %rax,-0x110(%rbp)
	mm2 = (uintptr_t) mmio_map_region(0, 4096);
  800420792c:	be 00 10 00 00       	mov    $0x1000,%esi
  8004207931:	bf 00 00 00 00       	mov    $0x0,%edi
  8004207936:	48 b8 8f 40 20 04 80 	movabs $0x800420408f,%rax
  800420793d:	00 00 00 
  8004207940:	ff d0                	callq  *%rax
  8004207942:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
	// check that they're in the right region
	assert(mm1 >= MMIOBASE && mm1 + 8096 < MMIOLIM);
  8004207949:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004207950:	00 00 00 
  8004207953:	48 39 85 f0 fe ff ff 	cmp    %rax,-0x110(%rbp)
  800420795a:	76 1d                	jbe    8004207979 <page_check+0x1d6d>
  800420795c:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004207963:	48 8d 90 a0 1f 00 00 	lea    0x1fa0(%rax),%rdx
  800420796a:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  8004207971:	00 00 00 
  8004207974:	48 39 c2             	cmp    %rax,%rdx
  8004207977:	76 35                	jbe    80042079ae <page_check+0x1da2>
  8004207979:	48 b9 50 9e 21 04 80 	movabs $0x8004219e50,%rcx
  8004207980:	00 00 00 
  8004207983:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  800420798a:	00 00 00 
  800420798d:	be 52 05 00 00       	mov    $0x552,%esi
  8004207992:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004207999:	00 00 00 
  800420799c:	b8 00 00 00 00       	mov    $0x0,%eax
  80042079a1:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042079a8:	00 00 00 
  80042079ab:	41 ff d0             	callq  *%r8
	assert(mm2 >= MMIOBASE && mm2 + 8096 < MMIOLIM);
  80042079ae:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  80042079b5:	00 00 00 
  80042079b8:	48 39 85 e8 fe ff ff 	cmp    %rax,-0x118(%rbp)
  80042079bf:	76 1d                	jbe    80042079de <page_check+0x1dd2>
  80042079c1:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  80042079c8:	48 8d 90 a0 1f 00 00 	lea    0x1fa0(%rax),%rdx
  80042079cf:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  80042079d6:	00 00 00 
  80042079d9:	48 39 c2             	cmp    %rax,%rdx
  80042079dc:	76 35                	jbe    8004207a13 <page_check+0x1e07>
  80042079de:	48 b9 78 9e 21 04 80 	movabs $0x8004219e78,%rcx
  80042079e5:	00 00 00 
  80042079e8:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  80042079ef:	00 00 00 
  80042079f2:	be 53 05 00 00       	mov    $0x553,%esi
  80042079f7:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  80042079fe:	00 00 00 
  8004207a01:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207a06:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004207a0d:	00 00 00 
  8004207a10:	41 ff d0             	callq  *%r8
	// check that they're page-aligned
	assert(mm1 % PGSIZE == 0 && mm2 % PGSIZE == 0);
  8004207a13:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004207a1a:	25 ff 0f 00 00       	and    $0xfff,%eax
  8004207a1f:	48 85 c0             	test   %rax,%rax
  8004207a22:	75 11                	jne    8004207a35 <page_check+0x1e29>
  8004207a24:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  8004207a2b:	25 ff 0f 00 00       	and    $0xfff,%eax
  8004207a30:	48 85 c0             	test   %rax,%rax
  8004207a33:	74 35                	je     8004207a6a <page_check+0x1e5e>
  8004207a35:	48 b9 a0 9e 21 04 80 	movabs $0x8004219ea0,%rcx
  8004207a3c:	00 00 00 
  8004207a3f:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004207a46:	00 00 00 
  8004207a49:	be 55 05 00 00       	mov    $0x555,%esi
  8004207a4e:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004207a55:	00 00 00 
  8004207a58:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207a5d:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004207a64:	00 00 00 
  8004207a67:	41 ff d0             	callq  *%r8
	// check that they don't overlap
	assert(mm1 + 8096 <= mm2);
  8004207a6a:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004207a71:	48 05 a0 1f 00 00    	add    $0x1fa0,%rax
  8004207a77:	48 3b 85 e8 fe ff ff 	cmp    -0x118(%rbp),%rax
  8004207a7e:	76 35                	jbe    8004207ab5 <page_check+0x1ea9>
  8004207a80:	48 b9 c7 9e 21 04 80 	movabs $0x8004219ec7,%rcx
  8004207a87:	00 00 00 
  8004207a8a:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004207a91:	00 00 00 
  8004207a94:	be 57 05 00 00       	mov    $0x557,%esi
  8004207a99:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004207aa0:	00 00 00 
  8004207aa3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207aa8:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004207aaf:	00 00 00 
  8004207ab2:	41 ff d0             	callq  *%r8
	// check page mappings

	assert(check_va2pa(boot_pml4e, mm1) == 0);
  8004207ab5:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  8004207abc:	00 00 00 
  8004207abf:	48 8b 00             	mov    (%rax),%rax
  8004207ac2:	48 8b 95 f0 fe ff ff 	mov    -0x110(%rbp),%rdx
  8004207ac9:	48 89 d6             	mov    %rdx,%rsi
  8004207acc:	48 89 c7             	mov    %rax,%rdi
  8004207acf:	48 b8 92 59 20 04 80 	movabs $0x8004205992,%rax
  8004207ad6:	00 00 00 
  8004207ad9:	ff d0                	callq  *%rax
  8004207adb:	48 85 c0             	test   %rax,%rax
  8004207ade:	74 35                	je     8004207b15 <page_check+0x1f09>
  8004207ae0:	48 b9 e0 9e 21 04 80 	movabs $0x8004219ee0,%rcx
  8004207ae7:	00 00 00 
  8004207aea:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004207af1:	00 00 00 
  8004207af4:	be 5a 05 00 00       	mov    $0x55a,%esi
  8004207af9:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004207b00:	00 00 00 
  8004207b03:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207b08:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004207b0f:	00 00 00 
  8004207b12:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm1+PGSIZE) == PGSIZE);
  8004207b15:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004207b1c:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  8004207b23:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  8004207b2a:	00 00 00 
  8004207b2d:	48 8b 00             	mov    (%rax),%rax
  8004207b30:	48 89 d6             	mov    %rdx,%rsi
  8004207b33:	48 89 c7             	mov    %rax,%rdi
  8004207b36:	48 b8 92 59 20 04 80 	movabs $0x8004205992,%rax
  8004207b3d:	00 00 00 
  8004207b40:	ff d0                	callq  *%rax
  8004207b42:	48 3d 00 10 00 00    	cmp    $0x1000,%rax
  8004207b48:	74 35                	je     8004207b7f <page_check+0x1f73>
  8004207b4a:	48 b9 08 9f 21 04 80 	movabs $0x8004219f08,%rcx
  8004207b51:	00 00 00 
  8004207b54:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004207b5b:	00 00 00 
  8004207b5e:	be 5b 05 00 00       	mov    $0x55b,%esi
  8004207b63:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004207b6a:	00 00 00 
  8004207b6d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207b72:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004207b79:	00 00 00 
  8004207b7c:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm2) == 0);
  8004207b7f:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  8004207b86:	00 00 00 
  8004207b89:	48 8b 00             	mov    (%rax),%rax
  8004207b8c:	48 8b 95 e8 fe ff ff 	mov    -0x118(%rbp),%rdx
  8004207b93:	48 89 d6             	mov    %rdx,%rsi
  8004207b96:	48 89 c7             	mov    %rax,%rdi
  8004207b99:	48 b8 92 59 20 04 80 	movabs $0x8004205992,%rax
  8004207ba0:	00 00 00 
  8004207ba3:	ff d0                	callq  *%rax
  8004207ba5:	48 85 c0             	test   %rax,%rax
  8004207ba8:	74 35                	je     8004207bdf <page_check+0x1fd3>
  8004207baa:	48 b9 38 9f 21 04 80 	movabs $0x8004219f38,%rcx
  8004207bb1:	00 00 00 
  8004207bb4:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004207bbb:	00 00 00 
  8004207bbe:	be 5c 05 00 00       	mov    $0x55c,%esi
  8004207bc3:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004207bca:	00 00 00 
  8004207bcd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207bd2:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004207bd9:	00 00 00 
  8004207bdc:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm2+PGSIZE) == ~0);
  8004207bdf:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  8004207be6:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  8004207bed:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  8004207bf4:	00 00 00 
  8004207bf7:	48 8b 00             	mov    (%rax),%rax
  8004207bfa:	48 89 d6             	mov    %rdx,%rsi
  8004207bfd:	48 89 c7             	mov    %rax,%rdi
  8004207c00:	48 b8 92 59 20 04 80 	movabs $0x8004205992,%rax
  8004207c07:	00 00 00 
  8004207c0a:	ff d0                	callq  *%rax
  8004207c0c:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004207c10:	74 35                	je     8004207c47 <page_check+0x203b>
  8004207c12:	48 b9 60 9f 21 04 80 	movabs $0x8004219f60,%rcx
  8004207c19:	00 00 00 
  8004207c1c:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004207c23:	00 00 00 
  8004207c26:	be 5d 05 00 00       	mov    $0x55d,%esi
  8004207c2b:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004207c32:	00 00 00 
  8004207c35:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207c3a:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004207c41:	00 00 00 
  8004207c44:	41 ff d0             	callq  *%r8
	// check permissions
	assert(*pml4e_walk(boot_pml4e, (void*) mm1, 0) & (PTE_W|PTE_PWT|PTE_PCD));
  8004207c47:	48 8b 8d f0 fe ff ff 	mov    -0x110(%rbp),%rcx
  8004207c4e:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  8004207c55:	00 00 00 
  8004207c58:	48 8b 00             	mov    (%rax),%rax
  8004207c5b:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207c60:	48 89 ce             	mov    %rcx,%rsi
  8004207c63:	48 89 c7             	mov    %rax,%rdi
  8004207c66:	48 b8 55 31 20 04 80 	movabs $0x8004203155,%rax
  8004207c6d:	00 00 00 
  8004207c70:	ff d0                	callq  *%rax
  8004207c72:	48 8b 00             	mov    (%rax),%rax
  8004207c75:	83 e0 1a             	and    $0x1a,%eax
  8004207c78:	48 85 c0             	test   %rax,%rax
  8004207c7b:	75 35                	jne    8004207cb2 <page_check+0x20a6>
  8004207c7d:	48 b9 90 9f 21 04 80 	movabs $0x8004219f90,%rcx
  8004207c84:	00 00 00 
  8004207c87:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004207c8e:	00 00 00 
  8004207c91:	be 5f 05 00 00       	mov    $0x55f,%esi
  8004207c96:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004207c9d:	00 00 00 
  8004207ca0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207ca5:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004207cac:	00 00 00 
  8004207caf:	41 ff d0             	callq  *%r8
	assert(!(*pml4e_walk(boot_pml4e, (void*) mm1, 0) & PTE_U));
  8004207cb2:	48 8b 8d f0 fe ff ff 	mov    -0x110(%rbp),%rcx
  8004207cb9:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  8004207cc0:	00 00 00 
  8004207cc3:	48 8b 00             	mov    (%rax),%rax
  8004207cc6:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207ccb:	48 89 ce             	mov    %rcx,%rsi
  8004207cce:	48 89 c7             	mov    %rax,%rdi
  8004207cd1:	48 b8 55 31 20 04 80 	movabs $0x8004203155,%rax
  8004207cd8:	00 00 00 
  8004207cdb:	ff d0                	callq  *%rax
  8004207cdd:	48 8b 00             	mov    (%rax),%rax
  8004207ce0:	83 e0 04             	and    $0x4,%eax
  8004207ce3:	48 85 c0             	test   %rax,%rax
  8004207ce6:	74 35                	je     8004207d1d <page_check+0x2111>
  8004207ce8:	48 b9 d8 9f 21 04 80 	movabs $0x8004219fd8,%rcx
  8004207cef:	00 00 00 
  8004207cf2:	48 ba a1 91 21 04 80 	movabs $0x80042191a1,%rdx
  8004207cf9:	00 00 00 
  8004207cfc:	be 60 05 00 00       	mov    $0x560,%esi
  8004207d01:	48 bf b6 91 21 04 80 	movabs $0x80042191b6,%rdi
  8004207d08:	00 00 00 
  8004207d0b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207d10:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004207d17:	00 00 00 
  8004207d1a:	41 ff d0             	callq  *%r8
	// clear the mappings
	*pml4e_walk(boot_pml4e, (void*) mm1, 0) = 0;
  8004207d1d:	48 8b 8d f0 fe ff ff 	mov    -0x110(%rbp),%rcx
  8004207d24:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  8004207d2b:	00 00 00 
  8004207d2e:	48 8b 00             	mov    (%rax),%rax
  8004207d31:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207d36:	48 89 ce             	mov    %rcx,%rsi
  8004207d39:	48 89 c7             	mov    %rax,%rdi
  8004207d3c:	48 b8 55 31 20 04 80 	movabs $0x8004203155,%rax
  8004207d43:	00 00 00 
  8004207d46:	ff d0                	callq  *%rax
  8004207d48:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	*pml4e_walk(boot_pml4e, (void*) mm1 + PGSIZE, 0) = 0;
  8004207d4f:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004207d56:	48 05 00 10 00 00    	add    $0x1000,%rax
  8004207d5c:	48 89 c1             	mov    %rax,%rcx
  8004207d5f:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  8004207d66:	00 00 00 
  8004207d69:	48 8b 00             	mov    (%rax),%rax
  8004207d6c:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207d71:	48 89 ce             	mov    %rcx,%rsi
  8004207d74:	48 89 c7             	mov    %rax,%rdi
  8004207d77:	48 b8 55 31 20 04 80 	movabs $0x8004203155,%rax
  8004207d7e:	00 00 00 
  8004207d81:	ff d0                	callq  *%rax
  8004207d83:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	*pml4e_walk(boot_pml4e, (void*) mm2, 0) = 0;
  8004207d8a:	48 8b 8d e8 fe ff ff 	mov    -0x118(%rbp),%rcx
  8004207d91:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  8004207d98:	00 00 00 
  8004207d9b:	48 8b 00             	mov    (%rax),%rax
  8004207d9e:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207da3:	48 89 ce             	mov    %rcx,%rsi
  8004207da6:	48 89 c7             	mov    %rax,%rdi
  8004207da9:	48 b8 55 31 20 04 80 	movabs $0x8004203155,%rax
  8004207db0:	00 00 00 
  8004207db3:	ff d0                	callq  *%rax
  8004207db5:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)


	cprintf("check_page() succeeded!\n");
  8004207dbc:	48 bf 0b a0 21 04 80 	movabs $0x800421a00b,%rdi
  8004207dc3:	00 00 00 
  8004207dc6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207dcb:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  8004207dd2:	00 00 00 
  8004207dd5:	ff d2                	callq  *%rdx
}
  8004207dd7:	48 81 c4 18 01 00 00 	add    $0x118,%rsp
  8004207dde:	5b                   	pop    %rbx
  8004207ddf:	5d                   	pop    %rbp
  8004207de0:	c3                   	retq   

0000008004207de1 <page2ppn>:
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);


static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  8004207de1:	55                   	push   %rbp
  8004207de2:	48 89 e5             	mov    %rsp,%rbp
  8004207de5:	48 83 ec 08          	sub    $0x8,%rsp
  8004207de9:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  8004207ded:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207df1:	48 b8 f8 c5 69 04 80 	movabs $0x800469c5f8,%rax
  8004207df8:	00 00 00 
  8004207dfb:	48 8b 00             	mov    (%rax),%rax
  8004207dfe:	48 29 c2             	sub    %rax,%rdx
  8004207e01:	48 89 d0             	mov    %rdx,%rax
  8004207e04:	48 c1 f8 04          	sar    $0x4,%rax
}
  8004207e08:	c9                   	leaveq 
  8004207e09:	c3                   	retq   

0000008004207e0a <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  8004207e0a:	55                   	push   %rbp
  8004207e0b:	48 89 e5             	mov    %rsp,%rbp
  8004207e0e:	48 83 ec 08          	sub    $0x8,%rsp
  8004207e12:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  8004207e16:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207e1a:	48 89 c7             	mov    %rax,%rdi
  8004207e1d:	48 b8 e1 7d 20 04 80 	movabs $0x8004207de1,%rax
  8004207e24:	00 00 00 
  8004207e27:	ff d0                	callq  *%rax
  8004207e29:	48 c1 e0 0c          	shl    $0xc,%rax
}
  8004207e2d:	c9                   	leaveq 
  8004207e2e:	c3                   	retq   

0000008004207e2f <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  8004207e2f:	55                   	push   %rbp
  8004207e30:	48 89 e5             	mov    %rsp,%rbp
  8004207e33:	48 83 ec 10          	sub    $0x10,%rsp
  8004207e37:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  8004207e3b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207e3f:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207e43:	48 89 c2             	mov    %rax,%rdx
  8004207e46:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  8004207e4d:	00 00 00 
  8004207e50:	48 8b 00             	mov    (%rax),%rax
  8004207e53:	48 39 c2             	cmp    %rax,%rdx
  8004207e56:	72 2a                	jb     8004207e82 <pa2page+0x53>
		panic("pa2page called with invalid pa");
  8004207e58:	48 ba 28 a0 21 04 80 	movabs $0x800421a028,%rdx
  8004207e5f:	00 00 00 
  8004207e62:	be 59 00 00 00       	mov    $0x59,%esi
  8004207e67:	48 bf 47 a0 21 04 80 	movabs $0x800421a047,%rdi
  8004207e6e:	00 00 00 
  8004207e71:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207e76:	48 b9 e4 05 20 04 80 	movabs $0x80042005e4,%rcx
  8004207e7d:	00 00 00 
  8004207e80:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  8004207e82:	48 b8 f8 c5 69 04 80 	movabs $0x800469c5f8,%rax
  8004207e89:	00 00 00 
  8004207e8c:	48 8b 00             	mov    (%rax),%rax
  8004207e8f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207e93:	48 c1 ea 0c          	shr    $0xc,%rdx
  8004207e97:	48 c1 e2 04          	shl    $0x4,%rdx
  8004207e9b:	48 01 d0             	add    %rdx,%rax
}
  8004207e9e:	c9                   	leaveq 
  8004207e9f:	c3                   	retq   

0000008004207ea0 <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  8004207ea0:	55                   	push   %rbp
  8004207ea1:	48 89 e5             	mov    %rsp,%rbp
  8004207ea4:	48 83 ec 20          	sub    $0x20,%rsp
  8004207ea8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  8004207eac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207eb0:	48 89 c7             	mov    %rax,%rdi
  8004207eb3:	48 b8 0a 7e 20 04 80 	movabs $0x8004207e0a,%rax
  8004207eba:	00 00 00 
  8004207ebd:	ff d0                	callq  *%rax
  8004207ebf:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004207ec3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207ec7:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207ecb:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004207ece:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004207ed1:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  8004207ed8:	00 00 00 
  8004207edb:	48 8b 00             	mov    (%rax),%rax
  8004207ede:	48 39 c2             	cmp    %rax,%rdx
  8004207ee1:	72 32                	jb     8004207f15 <page2kva+0x75>
  8004207ee3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207ee7:	48 89 c1             	mov    %rax,%rcx
  8004207eea:	48 ba 58 a0 21 04 80 	movabs $0x800421a058,%rdx
  8004207ef1:	00 00 00 
  8004207ef4:	be 60 00 00 00       	mov    $0x60,%esi
  8004207ef9:	48 bf 47 a0 21 04 80 	movabs $0x800421a047,%rdi
  8004207f00:	00 00 00 
  8004207f03:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207f08:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004207f0f:	00 00 00 
  8004207f12:	41 ff d0             	callq  *%r8
  8004207f15:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207f1c:	00 00 00 
  8004207f1f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207f23:	48 01 d0             	add    %rdx,%rax
}
  8004207f26:	c9                   	leaveq 
  8004207f27:	c3                   	retq   

0000008004207f28 <unlock_kernel>:

static inline void
unlock_kernel(void)
{
  8004207f28:	55                   	push   %rbp
  8004207f29:	48 89 e5             	mov    %rsp,%rbp
	spin_unlock(&kernel_lock);
  8004207f2c:	48 bf 60 c7 22 04 80 	movabs $0x800422c760,%rdi
  8004207f33:	00 00 00 
  8004207f36:	48 b8 34 78 21 04 80 	movabs $0x8004217834,%rax
  8004207f3d:	00 00 00 
  8004207f40:	ff d0                	callq  *%rax

	// Normally we wouldn't need to do this, but QEMU only runs
	// one CPU at a time and has a long time-slice.  Without the
	// pause, this CPU is likely to reacquire the lock before
	// another CPU has even been given a chance to acquire it.
	asm volatile("pause");
  8004207f42:	f3 90                	pause  
}
  8004207f44:	5d                   	pop    %rbp
  8004207f45:	c3                   	retq   

0000008004207f46 <envid2env>:
//   On success, sets *env_store to the environment.
//   On error, sets *env_store to NULL.
//
int
envid2env(envid_t envid, struct Env **env_store, bool checkperm)
{
  8004207f46:	55                   	push   %rbp
  8004207f47:	48 89 e5             	mov    %rsp,%rbp
  8004207f4a:	53                   	push   %rbx
  8004207f4b:	48 83 ec 28          	sub    $0x28,%rsp
  8004207f4f:	89 7d dc             	mov    %edi,-0x24(%rbp)
  8004207f52:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004207f56:	89 d0                	mov    %edx,%eax
  8004207f58:	88 45 d8             	mov    %al,-0x28(%rbp)
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
  8004207f5b:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004207f5f:	75 41                	jne    8004207fa2 <envid2env+0x5c>
		*env_store = curenv;
  8004207f61:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  8004207f68:	00 00 00 
  8004207f6b:	ff d0                	callq  *%rax
  8004207f6d:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  8004207f74:	00 00 00 
  8004207f77:	48 98                	cltq   
  8004207f79:	48 c1 e0 03          	shl    $0x3,%rax
  8004207f7d:	48 89 c1             	mov    %rax,%rcx
  8004207f80:	48 c1 e1 04          	shl    $0x4,%rcx
  8004207f84:	48 01 c8             	add    %rcx,%rax
  8004207f87:	48 01 d0             	add    %rdx,%rax
  8004207f8a:	48 83 c0 08          	add    $0x8,%rax
  8004207f8e:	48 8b 10             	mov    (%rax),%rdx
  8004207f91:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207f95:	48 89 10             	mov    %rdx,(%rax)
		return 0;
  8004207f98:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207f9d:	e9 fd 00 00 00       	jmpq   800420809f <envid2env+0x159>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
  8004207fa2:	48 b8 58 d2 49 04 80 	movabs $0x800449d258,%rax
  8004207fa9:	00 00 00 
  8004207fac:	48 8b 10             	mov    (%rax),%rdx
  8004207faf:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004207fb2:	48 98                	cltq   
  8004207fb4:	25 ff 03 00 00       	and    $0x3ff,%eax
  8004207fb9:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  8004207fc0:	48 01 d0             	add    %rdx,%rax
  8004207fc3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
  8004207fc7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207fcb:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  8004207fd1:	85 c0                	test   %eax,%eax
  8004207fd3:	74 0f                	je     8004207fe4 <envid2env+0x9e>
  8004207fd5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207fd9:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004207fdf:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  8004207fe2:	74 15                	je     8004207ff9 <envid2env+0xb3>
		*env_store = 0;
  8004207fe4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207fe8:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return -E_BAD_ENV;
  8004207fef:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8004207ff4:	e9 a6 00 00 00       	jmpq   800420809f <envid2env+0x159>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	if (checkperm && e != curenv && e->env_parent_id != curenv->env_id) {
  8004207ff9:	80 7d d8 00          	cmpb   $0x0,-0x28(%rbp)
  8004207ffd:	0f 84 8c 00 00 00    	je     800420808f <envid2env+0x149>
  8004208003:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420800a:	00 00 00 
  800420800d:	ff d0                	callq  *%rax
  800420800f:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  8004208016:	00 00 00 
  8004208019:	48 98                	cltq   
  800420801b:	48 c1 e0 03          	shl    $0x3,%rax
  800420801f:	48 89 c1             	mov    %rax,%rcx
  8004208022:	48 c1 e1 04          	shl    $0x4,%rcx
  8004208026:	48 01 c8             	add    %rcx,%rax
  8004208029:	48 01 d0             	add    %rdx,%rax
  800420802c:	48 83 c0 08          	add    $0x8,%rax
  8004208030:	48 8b 00             	mov    (%rax),%rax
  8004208033:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004208037:	74 56                	je     800420808f <envid2env+0x149>
  8004208039:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420803d:	8b 98 cc 00 00 00    	mov    0xcc(%rax),%ebx
  8004208043:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420804a:	00 00 00 
  800420804d:	ff d0                	callq  *%rax
  800420804f:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  8004208056:	00 00 00 
  8004208059:	48 98                	cltq   
  800420805b:	48 c1 e0 03          	shl    $0x3,%rax
  800420805f:	48 89 c1             	mov    %rax,%rcx
  8004208062:	48 c1 e1 04          	shl    $0x4,%rcx
  8004208066:	48 01 c8             	add    %rcx,%rax
  8004208069:	48 01 d0             	add    %rdx,%rax
  800420806c:	48 83 c0 08          	add    $0x8,%rax
  8004208070:	48 8b 00             	mov    (%rax),%rax
  8004208073:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004208079:	39 c3                	cmp    %eax,%ebx
  800420807b:	74 12                	je     800420808f <envid2env+0x149>
		*env_store = 0;
  800420807d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208081:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return -E_BAD_ENV;
  8004208088:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420808d:	eb 10                	jmp    800420809f <envid2env+0x159>
	}

	*env_store = e;
  800420808f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208093:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004208097:	48 89 10             	mov    %rdx,(%rax)
	return 0;
  800420809a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420809f:	48 83 c4 28          	add    $0x28,%rsp
  80042080a3:	5b                   	pop    %rbx
  80042080a4:	5d                   	pop    %rbp
  80042080a5:	c3                   	retq   

00000080042080a6 <env_init>:
// they are in the envs array (i.e., so that the first call to
// env_alloc() returns envs[0]).
//
void
env_init(void)
{
  80042080a6:	55                   	push   %rbp
  80042080a7:	48 89 e5             	mov    %rsp,%rbp
  80042080aa:	48 83 ec 10          	sub    $0x10,%rsp
	// Set up envs array
	// LAB 3: Your code here.

	int i;
	for (i = 0; i < NENV; i++) {
  80042080ae:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042080b5:	eb 6d                	jmp    8004208124 <env_init+0x7e>
		envs[i].env_status = ENV_FREE;
  80042080b7:	48 b8 58 d2 49 04 80 	movabs $0x800449d258,%rax
  80042080be:	00 00 00 
  80042080c1:	48 8b 10             	mov    (%rax),%rdx
  80042080c4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042080c7:	48 98                	cltq   
  80042080c9:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  80042080d0:	48 01 d0             	add    %rdx,%rax
  80042080d3:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  80042080da:	00 00 00 
		envs[i].env_link = &envs[i+1];
  80042080dd:	48 b8 58 d2 49 04 80 	movabs $0x800449d258,%rax
  80042080e4:	00 00 00 
  80042080e7:	48 8b 10             	mov    (%rax),%rdx
  80042080ea:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042080ed:	48 98                	cltq   
  80042080ef:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  80042080f6:	48 01 c2             	add    %rax,%rdx
  80042080f9:	48 b8 58 d2 49 04 80 	movabs $0x800449d258,%rax
  8004208100:	00 00 00 
  8004208103:	48 8b 08             	mov    (%rax),%rcx
  8004208106:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004208109:	48 98                	cltq   
  800420810b:	48 83 c0 01          	add    $0x1,%rax
  800420810f:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  8004208116:	48 01 c8             	add    %rcx,%rax
  8004208119:	48 89 82 c0 00 00 00 	mov    %rax,0xc0(%rdx)
{
	// Set up envs array
	// LAB 3: Your code here.

	int i;
	for (i = 0; i < NENV; i++) {
  8004208120:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004208124:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  800420812b:	7e 8a                	jle    80042080b7 <env_init+0x11>
		envs[i].env_status = ENV_FREE;
		envs[i].env_link = &envs[i+1];
	}
	envs[NENV-1].env_link = NULL;
  800420812d:	48 b8 58 d2 49 04 80 	movabs $0x800449d258,%rax
  8004208134:	00 00 00 
  8004208137:	48 8b 00             	mov    (%rax),%rax
  800420813a:	48 05 98 9e 05 00    	add    $0x59e98,%rax
  8004208140:	48 c7 80 c0 00 00 00 	movq   $0x0,0xc0(%rax)
  8004208147:	00 00 00 00 
	env_free_list = &envs[0];
  800420814b:	48 b8 58 d2 49 04 80 	movabs $0x800449d258,%rax
  8004208152:	00 00 00 
  8004208155:	48 8b 10             	mov    (%rax),%rdx
  8004208158:	48 b8 60 d2 49 04 80 	movabs $0x800449d260,%rax
  800420815f:	00 00 00 
  8004208162:	48 89 10             	mov    %rdx,(%rax)


	// Per-CPU part of the initialization
	env_init_percpu();
  8004208165:	48 b8 73 81 20 04 80 	movabs $0x8004208173,%rax
  800420816c:	00 00 00 
  800420816f:	ff d0                	callq  *%rax
}
  8004208171:	c9                   	leaveq 
  8004208172:	c3                   	retq   

0000008004208173 <env_init_percpu>:

// Load GDT and segment descriptors.
void
env_init_percpu(void)
{
  8004208173:	55                   	push   %rbp
  8004208174:	48 89 e5             	mov    %rsp,%rbp
  8004208177:	53                   	push   %rbx
  8004208178:	48 83 ec 10          	sub    $0x10,%rsp
  800420817c:	48 b8 68 c6 22 04 80 	movabs $0x800422c668,%rax
  8004208183:	00 00 00 
  8004208186:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}

static __inline void
lgdt(void *p)
{
	__asm __volatile("lgdt (%0)" : : "r" (p));
  800420818a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420818e:	0f 01 10             	lgdt   (%rax)
	lgdt(&gdt_pd);

	// The kernel never uses GS or FS, so we leave those set to
	// the user data segment.
	asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
  8004208191:	b8 23 00 00 00       	mov    $0x23,%eax
  8004208196:	8e e8                	mov    %eax,%gs
	asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
  8004208198:	b8 23 00 00 00       	mov    $0x23,%eax
  800420819d:	8e e0                	mov    %eax,%fs
	// The kernel does use ES, DS, and SS.  We'll change between
	// the kernel and user data segments as needed.
	asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
  800420819f:	b8 10 00 00 00       	mov    $0x10,%eax
  80042081a4:	8e c0                	mov    %eax,%es
	asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
  80042081a6:	b8 10 00 00 00       	mov    $0x10,%eax
  80042081ab:	8e d8                	mov    %eax,%ds
	asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
  80042081ad:	b8 10 00 00 00       	mov    $0x10,%eax
  80042081b2:	8e d0                	mov    %eax,%ss
	// Load the kernel text segment into CS.
	asm volatile("pushq %%rbx \n \t movabs $1f,%%rax \n \t pushq %%rax \n\t lretq \n 1:\n" :: "b" (GD_KT):"cc","memory");
  80042081b4:	b8 08 00 00 00       	mov    $0x8,%eax
  80042081b9:	89 c3                	mov    %eax,%ebx
  80042081bb:	53                   	push   %rbx
  80042081bc:	48 b8 c9 81 20 04 80 	movabs $0x80042081c9,%rax
  80042081c3:	00 00 00 
  80042081c6:	50                   	push   %rax
  80042081c7:	48 cb                	lretq  
  80042081c9:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
}

static __inline void
lldt(uint16_t sel)
{
	__asm __volatile("lldt %0" : : "r" (sel));
  80042081cf:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80042081d3:	0f 00 d0             	lldt   %ax
	// For good measure, clear the local descriptor table (LDT),
	// since we don't use it.
	lldt(0);
}
  80042081d6:	48 83 c4 10          	add    $0x10,%rsp
  80042081da:	5b                   	pop    %rbx
  80042081db:	5d                   	pop    %rbp
  80042081dc:	c3                   	retq   

00000080042081dd <env_setup_vm>:
// Returns 0 on success, < 0 on error.  Errors include:
//	-E_NO_MEM if page directory or table could not be allocated.
//
static int
env_setup_vm(struct Env *e)
{
  80042081dd:	55                   	push   %rbp
  80042081de:	48 89 e5             	mov    %rsp,%rbp
  80042081e1:	48 83 ec 20          	sub    $0x20,%rsp
  80042081e5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int r;
	int i;
	struct PageInfo *p = NULL;
  80042081e9:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042081f0:	00 

	// Allocate a page for the page directory
	if (!(p = page_alloc(ALLOC_ZERO)))
  80042081f1:	bf 01 00 00 00       	mov    $0x1,%edi
  80042081f6:	48 b8 e0 2f 20 04 80 	movabs $0x8004202fe0,%rax
  80042081fd:	00 00 00 
  8004208200:	ff d0                	callq  *%rax
  8004208202:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004208206:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420820b:	75 0a                	jne    8004208217 <env_setup_vm+0x3a>
		return -E_NO_MEM;
  800420820d:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8004208212:	e9 bc 00 00 00       	jmpq   80042082d3 <env_setup_vm+0xf6>
	//	pp_ref for env_free to work correctly.
	//    - The functions in kern/pmap.h are handy.

	// LAB 3: Your code here.

	p->pp_ref       += 1;
  8004208217:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420821b:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420821f:	8d 50 01             	lea    0x1(%rax),%edx
  8004208222:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208226:	66 89 50 08          	mov    %dx,0x8(%rax)
	e->env_pml4e    = page2kva(p);
  800420822a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420822e:	48 89 c7             	mov    %rax,%rdi
  8004208231:	48 b8 a0 7e 20 04 80 	movabs $0x8004207ea0,%rax
  8004208238:	00 00 00 
  800420823b:	ff d0                	callq  *%rax
  800420823d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004208241:	48 89 82 e0 00 00 00 	mov    %rax,0xe0(%rdx)
	e->env_cr3      = page2pa(p);
  8004208248:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420824c:	48 89 c7             	mov    %rax,%rdi
  800420824f:	48 b8 0a 7e 20 04 80 	movabs $0x8004207e0a,%rax
  8004208256:	00 00 00 
  8004208259:	ff d0                	callq  *%rax
  800420825b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420825f:	48 89 82 e8 00 00 00 	mov    %rax,0xe8(%rdx)

	memset(e->env_pml4e, 0, PGSIZE);
  8004208266:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420826a:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208271:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004208276:	be 00 00 00 00       	mov    $0x0,%esi
  800420827b:	48 89 c7             	mov    %rax,%rdi
  800420827e:	48 b8 d4 03 21 04 80 	movabs $0x80042103d4,%rax
  8004208285:	00 00 00 
  8004208288:	ff d0                	callq  *%rax
	e->env_pml4e[1] = boot_pml4e[1];
  800420828a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420828e:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208295:	48 8d 50 08          	lea    0x8(%rax),%rdx
  8004208299:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  80042082a0:	00 00 00 
  80042082a3:	48 8b 00             	mov    (%rax),%rax
  80042082a6:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042082aa:	48 89 02             	mov    %rax,(%rdx)


	// UVPT maps the env's own page table read-only.
	// Permissions: kernel R, user R
	e->env_pml4e[PML4(UVPT)] = e->env_cr3 | PTE_P | PTE_U;
  80042082ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042082b1:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042082b8:	48 8d 50 10          	lea    0x10(%rax),%rdx
  80042082bc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042082c0:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  80042082c7:	48 83 c8 05          	or     $0x5,%rax
  80042082cb:	48 89 02             	mov    %rax,(%rdx)

	return 0;
  80042082ce:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042082d3:	c9                   	leaveq 
  80042082d4:	c3                   	retq   

00000080042082d5 <env_alloc>:
//	-E_NO_FREE_ENV if all NENVS environments are allocated
//	-E_NO_MEM on memory exhaustion
//
int
env_alloc(struct Env **newenv_store, envid_t parent_id)
{
  80042082d5:	55                   	push   %rbp
  80042082d6:	48 89 e5             	mov    %rsp,%rbp
  80042082d9:	48 83 ec 30          	sub    $0x30,%rsp
  80042082dd:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042082e1:	89 75 d4             	mov    %esi,-0x2c(%rbp)
	int32_t generation;
	int r;
	struct Env *e;

	if (!(e = env_free_list))
  80042082e4:	48 b8 60 d2 49 04 80 	movabs $0x800449d260,%rax
  80042082eb:	00 00 00 
  80042082ee:	48 8b 00             	mov    (%rax),%rax
  80042082f1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042082f5:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80042082fa:	75 0a                	jne    8004208306 <env_alloc+0x31>
		return -E_NO_FREE_ENV;
  80042082fc:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  8004208301:	e9 69 01 00 00       	jmpq   800420846f <env_alloc+0x19a>

	// Allocate and set up the page directory for this environment.
	if ((r = env_setup_vm(e)) < 0)
  8004208306:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420830a:	48 89 c7             	mov    %rax,%rdi
  800420830d:	48 b8 dd 81 20 04 80 	movabs $0x80042081dd,%rax
  8004208314:	00 00 00 
  8004208317:	ff d0                	callq  *%rax
  8004208319:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420831c:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  8004208320:	79 08                	jns    800420832a <env_alloc+0x55>
		return r;
  8004208322:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004208325:	e9 45 01 00 00       	jmpq   800420846f <env_alloc+0x19a>

	// Generate an env_id for this environment.
	generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NENV - 1);
  800420832a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420832e:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004208334:	05 00 10 00 00       	add    $0x1000,%eax
  8004208339:	25 00 fc ff ff       	and    $0xfffffc00,%eax
  800420833e:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (generation <= 0)	// Don't create a negative env_id.
  8004208341:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004208345:	7f 07                	jg     800420834e <env_alloc+0x79>
		generation = 1 << ENVGENSHIFT;
  8004208347:	c7 45 fc 00 10 00 00 	movl   $0x1000,-0x4(%rbp)
	e->env_id = generation | (e - envs);
  800420834e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004208352:	48 b8 58 d2 49 04 80 	movabs $0x800449d258,%rax
  8004208359:	00 00 00 
  800420835c:	48 8b 00             	mov    (%rax),%rax
  800420835f:	48 29 c2             	sub    %rax,%rdx
  8004208362:	48 89 d0             	mov    %rdx,%rax
  8004208365:	48 c1 f8 03          	sar    $0x3,%rax
  8004208369:	48 89 c2             	mov    %rax,%rdx
  800420836c:	48 b8 a5 4f fa a4 4f 	movabs $0x4fa4fa4fa4fa4fa5,%rax
  8004208373:	fa a4 4f 
  8004208376:	48 0f af c2          	imul   %rdx,%rax
  800420837a:	0b 45 fc             	or     -0x4(%rbp),%eax
  800420837d:	89 c2                	mov    %eax,%edx
  800420837f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208383:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)

	// Set the basic status variables.
	e->env_parent_id = parent_id;
  8004208389:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420838d:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004208390:	89 90 cc 00 00 00    	mov    %edx,0xcc(%rax)
	e->env_type = ENV_TYPE_USER;
  8004208396:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420839a:	c7 80 d0 00 00 00 00 	movl   $0x0,0xd0(%rax)
  80042083a1:	00 00 00 
	e->env_status = ENV_RUNNABLE;
  80042083a4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042083a8:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  80042083af:	00 00 00 
	e->env_runs = 0;
  80042083b2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042083b6:	c7 80 d8 00 00 00 00 	movl   $0x0,0xd8(%rax)
  80042083bd:	00 00 00 

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(&e->env_tf, 0, sizeof(e->env_tf));
  80042083c0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042083c4:	ba c0 00 00 00       	mov    $0xc0,%edx
  80042083c9:	be 00 00 00 00       	mov    $0x0,%esi
  80042083ce:	48 89 c7             	mov    %rax,%rdi
  80042083d1:	48 b8 d4 03 21 04 80 	movabs $0x80042103d4,%rax
  80042083d8:	00 00 00 
  80042083db:	ff d0                	callq  *%rax
	// The low 2 bits of each segment register contains the
	// Requestor Privilege Level (RPL); 3 means user mode.  When
	// we switch privilege levels, the hardware does various
	// checks involving the RPL and the Descriptor Privilege Level
	// (DPL) stored in the descriptors themselves.
	e->env_tf.tf_ds = GD_UD | 3;
  80042083dd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042083e1:	66 c7 80 80 00 00 00 	movw   $0x23,0x80(%rax)
  80042083e8:	23 00 
	e->env_tf.tf_es = GD_UD | 3;
  80042083ea:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042083ee:	66 c7 40 78 23 00    	movw   $0x23,0x78(%rax)
	e->env_tf.tf_ss = GD_UD | 3;
  80042083f4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042083f8:	66 c7 80 b8 00 00 00 	movw   $0x23,0xb8(%rax)
  80042083ff:	23 00 
	e->env_tf.tf_rsp = USTACKTOP;
  8004208401:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208405:	b9 00 e0 7f ef       	mov    $0xef7fe000,%ecx
  800420840a:	48 89 88 b0 00 00 00 	mov    %rcx,0xb0(%rax)
	e->env_tf.tf_cs = GD_UT | 3;
  8004208411:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208415:	66 c7 80 a0 00 00 00 	movw   $0x1b,0xa0(%rax)
  800420841c:	1b 00 


	// Enable interrupts while in user mode.
	// LAB 4: Your code here.

	e->env_tf.tf_eflags = FL_IF; // interrupts enabled
  800420841e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208422:	48 c7 80 a8 00 00 00 	movq   $0x200,0xa8(%rax)
  8004208429:	00 02 00 00 


	// Clear the page fault handler until user installs one.
	e->env_pgfault_upcall = 0;
  800420842d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208431:	48 c7 80 f0 00 00 00 	movq   $0x0,0xf0(%rax)
  8004208438:	00 00 00 00 

	// Also clear the IPC receiving flag.
	e->env_ipc_recving = 0;
  800420843c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208440:	c6 80 f8 00 00 00 00 	movb   $0x0,0xf8(%rax)


	// commit the allocation
	env_free_list = e->env_link;
  8004208447:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420844b:	48 8b 90 c0 00 00 00 	mov    0xc0(%rax),%rdx
  8004208452:	48 b8 60 d2 49 04 80 	movabs $0x800449d260,%rax
  8004208459:	00 00 00 
  800420845c:	48 89 10             	mov    %rdx,(%rax)
	*newenv_store = e;
  800420845f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004208463:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004208467:	48 89 10             	mov    %rdx,(%rax)


	// cprintf("[%08x] new env %08x\n", curenv ? curenv->env_id : 0, e->env_id);

	return 0;
  800420846a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420846f:	c9                   	leaveq 
  8004208470:	c3                   	retq   

0000008004208471 <region_alloc>:
// Pages should be writable by user and kernel.
// Panic if any allocation attempt fails.
//
static void
region_alloc(struct Env *e, void *va, size_t len)
{
  8004208471:	55                   	push   %rbp
  8004208472:	48 89 e5             	mov    %rsp,%rbp
  8004208475:	48 83 ec 40          	sub    $0x40,%rsp
  8004208479:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420847d:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004208481:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)

	int r;
	struct PageInfo *pp;
	void *endva = (uint8_t*) va + len;
  8004208485:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208489:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420848d:	48 01 d0             	add    %rdx,%rax
  8004208490:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	while (va < endva) {
  8004208494:	e9 c8 00 00 00       	jmpq   8004208561 <region_alloc+0xf0>
		// Allocate and map a page covering virtual address va.
		if (!(pp = page_alloc(0)))
  8004208499:	bf 00 00 00 00       	mov    $0x0,%edi
  800420849e:	48 b8 e0 2f 20 04 80 	movabs $0x8004202fe0,%rax
  80042084a5:	00 00 00 
  80042084a8:	ff d0                	callq  *%rax
  80042084aa:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042084ae:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80042084b3:	75 30                	jne    80042084e5 <region_alloc+0x74>
			panic("map_segment: could not alloc page: %e\n", -E_NO_MEM);
  80042084b5:	b9 fc ff ff ff       	mov    $0xfffffffc,%ecx
  80042084ba:	48 ba 80 a0 21 04 80 	movabs $0x800421a080,%rdx
  80042084c1:	00 00 00 
  80042084c4:	be c0 01 00 00       	mov    $0x1c0,%esi
  80042084c9:	48 bf a7 a0 21 04 80 	movabs $0x800421a0a7,%rdi
  80042084d0:	00 00 00 
  80042084d3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042084d8:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042084df:	00 00 00 
  80042084e2:	41 ff d0             	callq  *%r8

		// Insert the page into the env's address space
		if ((r = page_insert(e->env_pml4e, pp, va, PTE_P|PTE_W|PTE_U)) < 0)
  80042084e5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042084e9:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042084f0:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042084f4:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  80042084f8:	b9 07 00 00 00       	mov    $0x7,%ecx
  80042084fd:	48 89 c7             	mov    %rax,%rdi
  8004208500:	48 b8 52 3b 20 04 80 	movabs $0x8004203b52,%rax
  8004208507:	00 00 00 
  800420850a:	ff d0                	callq  *%rax
  800420850c:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420850f:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  8004208513:	79 30                	jns    8004208545 <region_alloc+0xd4>
			panic("map_segment: could not insert page: %e\n", r);
  8004208515:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004208518:	89 c1                	mov    %eax,%ecx
  800420851a:	48 ba b8 a0 21 04 80 	movabs $0x800421a0b8,%rdx
  8004208521:	00 00 00 
  8004208524:	be c4 01 00 00       	mov    $0x1c4,%esi
  8004208529:	48 bf a7 a0 21 04 80 	movabs $0x800421a0a7,%rdi
  8004208530:	00 00 00 
  8004208533:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208538:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  800420853f:	00 00 00 
  8004208542:	41 ff d0             	callq  *%r8

		va = ROUNDDOWN((uint8_t*) va + PGSIZE, PGSIZE);
  8004208545:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208549:	48 05 00 10 00 00    	add    $0x1000,%rax
  800420854f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004208553:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208557:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420855d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

	int r;
	struct PageInfo *pp;
	void *endva = (uint8_t*) va + len;

	while (va < endva) {
  8004208561:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208565:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004208569:	0f 82 2a ff ff ff    	jb     8004208499 <region_alloc+0x28>
	//
	// Hint: It is easier to use region_alloc if the caller can pass
	//   'va' and 'len' values that are not page-aligned.
	//   You should round va down, and round (va + len) up.
	//   (Watch out for corner-cases!)
}
  800420856f:	c9                   	leaveq 
  8004208570:	c3                   	retq   

0000008004208571 <load_icode>:
// load_icode panics if it encounters problems.
//  - How might load_icode fail?  What might be wrong with the given input?
//
void
load_icode(struct Env *e, uint8_t *binary)
{
  8004208571:	55                   	push   %rbp
  8004208572:	48 89 e5             	mov    %rsp,%rbp
  8004208575:	53                   	push   %rbx
  8004208576:	48 83 ec 78          	sub    $0x78,%rsp
  800420857a:	48 89 7d 88          	mov    %rdi,-0x78(%rbp)
  800420857e:	48 89 75 80          	mov    %rsi,-0x80(%rbp)

	struct Elf *elf = (struct Elf *)binary;
  8004208582:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004208586:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	struct Proghdr *ph, *eph;

	if (elf && elf->e_magic == ELF_MAGIC) {
  800420858a:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420858f:	0f 84 6f 03 00 00    	je     8004208904 <load_icode+0x393>
  8004208595:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208599:	8b 00                	mov    (%rax),%eax
  800420859b:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
  80042085a0:	0f 85 5e 03 00 00    	jne    8004208904 <load_icode+0x393>
		lcr3(PADDR((uint64_t)e->env_pml4e));
  80042085a6:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042085aa:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042085b1:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  80042085b5:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042085bc:	00 00 00 
  80042085bf:	48 39 45 c8          	cmp    %rax,-0x38(%rbp)
  80042085c3:	77 32                	ja     80042085f7 <load_icode+0x86>
  80042085c5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042085c9:	48 89 c1             	mov    %rax,%rcx
  80042085cc:	48 ba e0 a0 21 04 80 	movabs $0x800421a0e0,%rdx
  80042085d3:	00 00 00 
  80042085d6:	be f0 01 00 00       	mov    $0x1f0,%esi
  80042085db:	48 bf a7 a0 21 04 80 	movabs $0x800421a0a7,%rdi
  80042085e2:	00 00 00 
  80042085e5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042085ea:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042085f1:	00 00 00 
  80042085f4:	41 ff d0             	callq  *%r8
  80042085f7:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  80042085fe:	ff ff ff 
  8004208601:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208605:	48 01 d0             	add    %rdx,%rax
  8004208608:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  800420860c:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004208610:	0f 22 d8             	mov    %rax,%cr3
		ph  = (struct Proghdr *)((uint8_t *)elf + elf->e_phoff);
  8004208613:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208617:	48 8b 50 20          	mov    0x20(%rax),%rdx
  800420861b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420861f:	48 01 d0             	add    %rdx,%rax
  8004208622:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		eph = ph + elf->e_phnum;
  8004208626:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420862a:	0f b7 40 38          	movzwl 0x38(%rax),%eax
  800420862e:	0f b7 c0             	movzwl %ax,%eax
  8004208631:	48 c1 e0 03          	shl    $0x3,%rax
  8004208635:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420863c:	00 
  800420863d:	48 29 c2             	sub    %rax,%rdx
  8004208640:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208644:	48 01 d0             	add    %rdx,%rax
  8004208647:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		for(;ph < eph; ph++) {
  800420864b:	e9 bd 00 00 00       	jmpq   800420870d <load_icode+0x19c>
			if (ph->p_type == ELF_PROG_LOAD) {
  8004208650:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208654:	8b 00                	mov    (%rax),%eax
  8004208656:	83 f8 01             	cmp    $0x1,%eax
  8004208659:	0f 85 a9 00 00 00    	jne    8004208708 <load_icode+0x197>
				region_alloc(e, (void *)ph->p_va, ph->p_memsz);
  800420865f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208663:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004208667:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420866b:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420866f:	48 89 c1             	mov    %rax,%rcx
  8004208672:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004208676:	48 89 ce             	mov    %rcx,%rsi
  8004208679:	48 89 c7             	mov    %rax,%rdi
  800420867c:	48 b8 71 84 20 04 80 	movabs $0x8004208471,%rax
  8004208683:	00 00 00 
  8004208686:	ff d0                	callq  *%rax
				memcpy((void *)ph->p_va, (void *)((uint8_t *)elf + ph->p_offset), ph->p_filesz);
  8004208688:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420868c:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004208690:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208694:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004208698:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420869c:	48 01 c1             	add    %rax,%rcx
  800420869f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042086a3:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042086a7:	48 89 ce             	mov    %rcx,%rsi
  80042086aa:	48 89 c7             	mov    %rax,%rdi
  80042086ad:	48 b8 76 05 21 04 80 	movabs $0x8004210576,%rax
  80042086b4:	00 00 00 
  80042086b7:	ff d0                	callq  *%rax
				if (ph->p_filesz < ph->p_memsz) {
  80042086b9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042086bd:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042086c1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042086c5:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042086c9:	48 39 c2             	cmp    %rax,%rdx
  80042086cc:	73 3a                	jae    8004208708 <load_icode+0x197>
					memset((void *)(ph->p_va + ph->p_filesz), 0, ph->p_memsz-ph->p_filesz);
  80042086ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042086d2:	48 8b 50 28          	mov    0x28(%rax),%rdx
  80042086d6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042086da:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042086de:	48 29 c2             	sub    %rax,%rdx
  80042086e1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042086e5:	48 8b 48 10          	mov    0x10(%rax),%rcx
  80042086e9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042086ed:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042086f1:	48 01 c8             	add    %rcx,%rax
  80042086f4:	be 00 00 00 00       	mov    $0x0,%esi
  80042086f9:	48 89 c7             	mov    %rax,%rdi
  80042086fc:	48 b8 d4 03 21 04 80 	movabs $0x80042103d4,%rax
  8004208703:	00 00 00 
  8004208706:	ff d0                	callq  *%rax

	if (elf && elf->e_magic == ELF_MAGIC) {
		lcr3(PADDR((uint64_t)e->env_pml4e));
		ph  = (struct Proghdr *)((uint8_t *)elf + elf->e_phoff);
		eph = ph + elf->e_phnum;
		for(;ph < eph; ph++) {
  8004208708:	48 83 45 e8 38       	addq   $0x38,-0x18(%rbp)
  800420870d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208711:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004208715:	0f 82 35 ff ff ff    	jb     8004208650 <load_icode+0xdf>
				if (ph->p_filesz < ph->p_memsz) {
					memset((void *)(ph->p_va + ph->p_filesz), 0, ph->p_memsz-ph->p_filesz);
				}
			}
		}
		region_alloc(e, (void*) (USTACKTOP - PGSIZE), PGSIZE);
  800420871b:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800420871f:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004208724:	be 00 d0 7f ef       	mov    $0xef7fd000,%esi
  8004208729:	48 89 c7             	mov    %rax,%rdi
  800420872c:	48 b8 71 84 20 04 80 	movabs $0x8004208471,%rax
  8004208733:	00 00 00 
  8004208736:	ff d0                	callq  *%rax
		e->env_tf.tf_rip    = elf->e_entry;
  8004208738:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420873c:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004208740:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004208744:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
		e->env_tf.tf_rsp    = USTACKTOP; //keeping stack 8 byte aligned
  800420874b:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800420874f:	bb 00 e0 7f ef       	mov    $0xef7fe000,%ebx
  8004208754:	48 89 98 b0 00 00 00 	mov    %rbx,0xb0(%rax)

		uintptr_t debug_address = USTABDATA;
  800420875b:	48 c7 45 e0 00 00 20 	movq   $0x200000,-0x20(%rbp)
  8004208762:	00 
		struct Secthdr *sh = (struct Secthdr *)(((uint8_t *)elf + elf->e_shoff));
  8004208763:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208767:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420876b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420876f:	48 01 d0             	add    %rdx,%rax
  8004208772:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		struct Secthdr *shstr_tab = sh + elf->e_shstrndx;
  8004208776:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420877a:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  800420877e:	0f b7 c0             	movzwl %ax,%eax
  8004208781:	48 c1 e0 06          	shl    $0x6,%rax
  8004208785:	48 89 c2             	mov    %rax,%rdx
  8004208788:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420878c:	48 01 d0             	add    %rdx,%rax
  800420878f:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		struct Secthdr* esh = sh + elf->e_shnum;
  8004208793:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208797:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  800420879b:	0f b7 c0             	movzwl %ax,%eax
  800420879e:	48 c1 e0 06          	shl    $0x6,%rax
  80042087a2:	48 89 c2             	mov    %rax,%rdx
  80042087a5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042087a9:	48 01 d0             	add    %rdx,%rax
  80042087ac:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
		for(;sh < esh; sh++) {
  80042087b0:	e9 27 01 00 00       	jmpq   80042088dc <load_icode+0x36b>
			char* name = (char*)((uint8_t*)elf + shstr_tab->sh_offset) + sh->sh_name;
  80042087b5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042087b9:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042087bd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042087c1:	8b 00                	mov    (%rax),%eax
  80042087c3:	89 c0                	mov    %eax,%eax
  80042087c5:	48 01 c2             	add    %rax,%rdx
  80042087c8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042087cc:	48 01 d0             	add    %rdx,%rax
  80042087cf:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			if(!strcmp(name, ".debug_info") || !strcmp(name, ".debug_abbrev")
  80042087d3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042087d7:	48 be 04 a1 21 04 80 	movabs $0x800421a104,%rsi
  80042087de:	00 00 00 
  80042087e1:	48 89 c7             	mov    %rax,%rdi
  80042087e4:	48 b8 9d 02 21 04 80 	movabs $0x800421029d,%rax
  80042087eb:	00 00 00 
  80042087ee:	ff d0                	callq  *%rax
  80042087f0:	85 c0                	test   %eax,%eax
  80042087f2:	0f 84 84 00 00 00    	je     800420887c <load_icode+0x30b>
  80042087f8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042087fc:	48 be 10 a1 21 04 80 	movabs $0x800421a110,%rsi
  8004208803:	00 00 00 
  8004208806:	48 89 c7             	mov    %rax,%rdi
  8004208809:	48 b8 9d 02 21 04 80 	movabs $0x800421029d,%rax
  8004208810:	00 00 00 
  8004208813:	ff d0                	callq  *%rax
  8004208815:	85 c0                	test   %eax,%eax
  8004208817:	74 63                	je     800420887c <load_icode+0x30b>
			   || !strcmp(name, ".debug_line") || !strcmp(name, ".eh_frame")
  8004208819:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420881d:	48 be 1e a1 21 04 80 	movabs $0x800421a11e,%rsi
  8004208824:	00 00 00 
  8004208827:	48 89 c7             	mov    %rax,%rdi
  800420882a:	48 b8 9d 02 21 04 80 	movabs $0x800421029d,%rax
  8004208831:	00 00 00 
  8004208834:	ff d0                	callq  *%rax
  8004208836:	85 c0                	test   %eax,%eax
  8004208838:	74 42                	je     800420887c <load_icode+0x30b>
  800420883a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420883e:	48 be 2a a1 21 04 80 	movabs $0x800421a12a,%rsi
  8004208845:	00 00 00 
  8004208848:	48 89 c7             	mov    %rax,%rdi
  800420884b:	48 b8 9d 02 21 04 80 	movabs $0x800421029d,%rax
  8004208852:	00 00 00 
  8004208855:	ff d0                	callq  *%rax
  8004208857:	85 c0                	test   %eax,%eax
  8004208859:	74 21                	je     800420887c <load_icode+0x30b>
			   || !strcmp(name, ".debug_str")) {
  800420885b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420885f:	48 be 34 a1 21 04 80 	movabs $0x800421a134,%rsi
  8004208866:	00 00 00 
  8004208869:	48 89 c7             	mov    %rax,%rdi
  800420886c:	48 b8 9d 02 21 04 80 	movabs $0x800421029d,%rax
  8004208873:	00 00 00 
  8004208876:	ff d0                	callq  *%rax
  8004208878:	85 c0                	test   %eax,%eax
  800420887a:	75 5b                	jne    80042088d7 <load_icode+0x366>
				region_alloc(e ,(void*)debug_address, sh->sh_size);
  800420887c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004208880:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004208884:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8004208888:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800420888c:	48 89 ce             	mov    %rcx,%rsi
  800420888f:	48 89 c7             	mov    %rax,%rdi
  8004208892:	48 b8 71 84 20 04 80 	movabs $0x8004208471,%rax
  8004208899:	00 00 00 
  800420889c:	ff d0                	callq  *%rax
				memcpy((void *)debug_address, (void *)((uint8_t *)elf + sh->sh_offset), 
  800420889e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042088a2:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042088a6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042088aa:	48 8b 48 18          	mov    0x18(%rax),%rcx
  80042088ae:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042088b2:	48 01 c1             	add    %rax,%rcx
  80042088b5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042088b9:	48 89 ce             	mov    %rcx,%rsi
  80042088bc:	48 89 c7             	mov    %rax,%rdi
  80042088bf:	48 b8 76 05 21 04 80 	movabs $0x8004210576,%rax
  80042088c6:	00 00 00 
  80042088c9:	ff d0                	callq  *%rax
				       sh->sh_size);
				debug_address += sh->sh_size;
  80042088cb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042088cf:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042088d3:	48 01 45 e0          	add    %rax,-0x20(%rbp)

		uintptr_t debug_address = USTABDATA;
		struct Secthdr *sh = (struct Secthdr *)(((uint8_t *)elf + elf->e_shoff));
		struct Secthdr *shstr_tab = sh + elf->e_shstrndx;
		struct Secthdr* esh = sh + elf->e_shnum;
		for(;sh < esh; sh++) {
  80042088d7:	48 83 45 d8 40       	addq   $0x40,-0x28(%rbp)
  80042088dc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042088e0:	48 3b 45 b0          	cmp    -0x50(%rbp),%rax
  80042088e4:	0f 82 cb fe ff ff    	jb     80042087b5 <load_icode+0x244>
				memcpy((void *)debug_address, (void *)((uint8_t *)elf + sh->sh_offset), 
				       sh->sh_size);
				debug_address += sh->sh_size;
			}
		}
		lcr3(boot_cr3);
  80042088ea:	48 b8 e0 c5 69 04 80 	movabs $0x800469c5e0,%rax
  80042088f1:	00 00 00 
  80042088f4:	48 8b 00             	mov    (%rax),%rax
  80042088f7:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  80042088fb:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042088ff:	0f 22 d8             	mov    %rax,%cr3
{

	struct Elf *elf = (struct Elf *)binary;
	struct Proghdr *ph, *eph;

	if (elf && elf->e_magic == ELF_MAGIC) {
  8004208902:	eb 2a                	jmp    800420892e <load_icode+0x3bd>
				debug_address += sh->sh_size;
			}
		}
		lcr3(boot_cr3);
	} else {
		panic("Invalid Binary");
  8004208904:	48 ba 3f a1 21 04 80 	movabs $0x800421a13f,%rdx
  800420890b:	00 00 00 
  800420890e:	be 11 02 00 00       	mov    $0x211,%esi
  8004208913:	48 bf a7 a0 21 04 80 	movabs $0x800421a0a7,%rdi
  800420891a:	00 00 00 
  800420891d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208922:	48 b9 e4 05 20 04 80 	movabs $0x80042005e4,%rcx
  8004208929:	00 00 00 
  800420892c:	ff d1                	callq  *%rcx
	}
	// Give environment a stack

	e->elf = binary;
  800420892e:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004208932:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004208936:	48 89 90 18 01 00 00 	mov    %rdx,0x118(%rax)

}
  800420893d:	48 83 c4 78          	add    $0x78,%rsp
  8004208941:	5b                   	pop    %rbx
  8004208942:	5d                   	pop    %rbp
  8004208943:	c3                   	retq   

0000008004208944 <env_create>:
// before running the first user-mode environment.
// The new env's parent ID is set to 0.
//
void
env_create(uint8_t *binary, enum EnvType type)
{
  8004208944:	55                   	push   %rbp
  8004208945:	48 89 e5             	mov    %rsp,%rbp
  8004208948:	48 83 ec 20          	sub    $0x20,%rsp
  800420894c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004208950:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	// LAB 3: Your code here.

	int r;
	struct Env *e;
	if ((r = env_alloc(&e, 0)) < 0)
  8004208953:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  8004208957:	be 00 00 00 00       	mov    $0x0,%esi
  800420895c:	48 89 c7             	mov    %rax,%rdi
  800420895f:	48 b8 d5 82 20 04 80 	movabs $0x80042082d5,%rax
  8004208966:	00 00 00 
  8004208969:	ff d0                	callq  *%rax
  800420896b:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420896e:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004208972:	79 30                	jns    80042089a4 <env_create+0x60>
		panic("env_create: could not allocate env: %e\n", r);
  8004208974:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004208977:	89 c1                	mov    %eax,%ecx
  8004208979:	48 ba 50 a1 21 04 80 	movabs $0x800421a150,%rdx
  8004208980:	00 00 00 
  8004208983:	be 28 02 00 00       	mov    $0x228,%esi
  8004208988:	48 bf a7 a0 21 04 80 	movabs $0x800421a0a7,%rdi
  800420898f:	00 00 00 
  8004208992:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208997:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  800420899e:	00 00 00 
  80042089a1:	41 ff d0             	callq  *%r8
	load_icode(e, binary);
  80042089a4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042089a8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042089ac:	48 89 d6             	mov    %rdx,%rsi
  80042089af:	48 89 c7             	mov    %rax,%rdi
  80042089b2:	48 b8 71 85 20 04 80 	movabs $0x8004208571,%rax
  80042089b9:	00 00 00 
  80042089bc:	ff d0                	callq  *%rax
	e->env_type = type;
  80042089be:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042089c2:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80042089c5:	89 90 d0 00 00 00    	mov    %edx,0xd0(%rax)


	// If this is the file server (type == ENV_TYPE_FS) give it I/O privileges.
	// LAB 5: Your code here.

	if (type == ENV_TYPE_FS)
  80042089cb:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  80042089cf:	75 19                	jne    80042089ea <env_create+0xa6>
		e->env_tf.tf_eflags |= FL_IOPL_3;
  80042089d1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042089d5:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042089d9:	48 8b 92 a8 00 00 00 	mov    0xa8(%rdx),%rdx
  80042089e0:	80 ce 30             	or     $0x30,%dh
  80042089e3:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)

}
  80042089ea:	c9                   	leaveq 
  80042089eb:	c3                   	retq   

00000080042089ec <env_free>:
//
// Frees env e and all memory it uses.
//
void
env_free(struct Env *e)
{
  80042089ec:	55                   	push   %rbp
  80042089ed:	48 89 e5             	mov    %rsp,%rbp
  80042089f0:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
  80042089f7:	48 89 bd 78 ff ff ff 	mov    %rdi,-0x88(%rbp)


	// If freeing the current environment, switch to kern_pgdir
	// before freeing the page directory, just in case the page
	// gets reused.
	if (e == curenv)
  80042089fe:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  8004208a05:	00 00 00 
  8004208a08:	ff d0                	callq  *%rax
  8004208a0a:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  8004208a11:	00 00 00 
  8004208a14:	48 98                	cltq   
  8004208a16:	48 c1 e0 03          	shl    $0x3,%rax
  8004208a1a:	48 89 c1             	mov    %rax,%rcx
  8004208a1d:	48 c1 e1 04          	shl    $0x4,%rcx
  8004208a21:	48 01 c8             	add    %rcx,%rax
  8004208a24:	48 01 d0             	add    %rdx,%rax
  8004208a27:	48 83 c0 08          	add    $0x8,%rax
  8004208a2b:	48 8b 00             	mov    (%rax),%rax
  8004208a2e:	48 3b 85 78 ff ff ff 	cmp    -0x88(%rbp),%rax
  8004208a35:	75 18                	jne    8004208a4f <env_free+0x63>
		lcr3(boot_cr3);
  8004208a37:	48 b8 e0 c5 69 04 80 	movabs $0x800469c5e0,%rax
  8004208a3e:	00 00 00 
  8004208a41:	48 8b 00             	mov    (%rax),%rax
  8004208a44:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  8004208a48:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004208a4c:	0f 22 d8             	mov    %rax,%cr3

	// cprintf("[%08x] free env %08x\n", curenv ? curenv->env_id : 0, e->env_id);


	// Flush all mapped pages in the user portion of the address space
	pdpe_t *env_pdpe = KADDR(PTE_ADDR(e->env_pml4e[0]));
  8004208a4f:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208a56:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208a5d:	48 8b 00             	mov    (%rax),%rax
  8004208a60:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208a66:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004208a6a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208a6e:	48 c1 e8 0c          	shr    $0xc,%rax
  8004208a72:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004208a75:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004208a78:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  8004208a7f:	00 00 00 
  8004208a82:	48 8b 00             	mov    (%rax),%rax
  8004208a85:	48 39 c2             	cmp    %rax,%rdx
  8004208a88:	72 32                	jb     8004208abc <env_free+0xd0>
  8004208a8a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208a8e:	48 89 c1             	mov    %rax,%rcx
  8004208a91:	48 ba 58 a0 21 04 80 	movabs $0x800421a058,%rdx
  8004208a98:	00 00 00 
  8004208a9b:	be 54 02 00 00       	mov    $0x254,%esi
  8004208aa0:	48 bf a7 a0 21 04 80 	movabs $0x800421a0a7,%rdi
  8004208aa7:	00 00 00 
  8004208aaa:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208aaf:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004208ab6:	00 00 00 
  8004208ab9:	41 ff d0             	callq  *%r8
  8004208abc:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004208ac3:	00 00 00 
  8004208ac6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208aca:	48 01 d0             	add    %rdx,%rax
  8004208acd:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	int pdeno_limit;
	uint64_t pdpe_index;
	// using 3 instead of NPDPENTRIES as we have only first three indices
	// set for 4GB of address space.
	for(pdpe_index=0;pdpe_index<=3;pdpe_index++){
  8004208ad1:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004208ad8:	00 
  8004208ad9:	e9 ab 02 00 00       	jmpq   8004208d89 <env_free+0x39d>
		if(!(env_pdpe[pdpe_index] & PTE_P))
  8004208ade:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208ae2:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208ae9:	00 
  8004208aea:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208aee:	48 01 d0             	add    %rdx,%rax
  8004208af1:	48 8b 00             	mov    (%rax),%rax
  8004208af4:	83 e0 01             	and    $0x1,%eax
  8004208af7:	48 85 c0             	test   %rax,%rax
  8004208afa:	75 05                	jne    8004208b01 <env_free+0x115>
			continue;
  8004208afc:	e9 83 02 00 00       	jmpq   8004208d84 <env_free+0x398>
		pde_t *env_pgdir = KADDR(PTE_ADDR(env_pdpe[pdpe_index]));
  8004208b01:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208b05:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208b0c:	00 
  8004208b0d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208b11:	48 01 d0             	add    %rdx,%rax
  8004208b14:	48 8b 00             	mov    (%rax),%rax
  8004208b17:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208b1d:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004208b21:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208b25:	48 c1 e8 0c          	shr    $0xc,%rax
  8004208b29:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  8004208b2c:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004208b2f:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  8004208b36:	00 00 00 
  8004208b39:	48 8b 00             	mov    (%rax),%rax
  8004208b3c:	48 39 c2             	cmp    %rax,%rdx
  8004208b3f:	72 32                	jb     8004208b73 <env_free+0x187>
  8004208b41:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208b45:	48 89 c1             	mov    %rax,%rcx
  8004208b48:	48 ba 58 a0 21 04 80 	movabs $0x800421a058,%rdx
  8004208b4f:	00 00 00 
  8004208b52:	be 5c 02 00 00       	mov    $0x25c,%esi
  8004208b57:	48 bf a7 a0 21 04 80 	movabs $0x800421a0a7,%rdi
  8004208b5e:	00 00 00 
  8004208b61:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208b66:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004208b6d:	00 00 00 
  8004208b70:	41 ff d0             	callq  *%r8
  8004208b73:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004208b7a:	00 00 00 
  8004208b7d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208b81:	48 01 d0             	add    %rdx,%rax
  8004208b84:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		pdeno_limit  = pdpe_index==3?PDX(UTOP):PDX(0xFFFFFFFF);
  8004208b88:	48 83 7d e8 03       	cmpq   $0x3,-0x18(%rbp)
  8004208b8d:	75 07                	jne    8004208b96 <env_free+0x1aa>
  8004208b8f:	b8 04 00 00 00       	mov    $0x4,%eax
  8004208b94:	eb 05                	jmp    8004208b9b <env_free+0x1af>
  8004208b96:	b8 ff 01 00 00       	mov    $0x1ff,%eax
  8004208b9b:	89 45 b4             	mov    %eax,-0x4c(%rbp)
		static_assert(UTOP % PTSIZE == 0);
		for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {
  8004208b9e:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004208ba5:	00 
  8004208ba6:	e9 6e 01 00 00       	jmpq   8004208d19 <env_free+0x32d>

			// only look at mapped page tables
			if (!(env_pgdir[pdeno] & PTE_P))
  8004208bab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208baf:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208bb6:	00 
  8004208bb7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004208bbb:	48 01 d0             	add    %rdx,%rax
  8004208bbe:	48 8b 00             	mov    (%rax),%rax
  8004208bc1:	83 e0 01             	and    $0x1,%eax
  8004208bc4:	48 85 c0             	test   %rax,%rax
  8004208bc7:	75 05                	jne    8004208bce <env_free+0x1e2>
				continue;
  8004208bc9:	e9 46 01 00 00       	jmpq   8004208d14 <env_free+0x328>
			// find the pa and va of the page table
			pa = PTE_ADDR(env_pgdir[pdeno]);
  8004208bce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208bd2:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208bd9:	00 
  8004208bda:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004208bde:	48 01 d0             	add    %rdx,%rax
  8004208be1:	48 8b 00             	mov    (%rax),%rax
  8004208be4:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208bea:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			pt = (pte_t*) KADDR(pa);
  8004208bee:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004208bf2:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  8004208bf6:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004208bfa:	48 c1 e8 0c          	shr    $0xc,%rax
  8004208bfe:	89 45 9c             	mov    %eax,-0x64(%rbp)
  8004208c01:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004208c04:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  8004208c0b:	00 00 00 
  8004208c0e:	48 8b 00             	mov    (%rax),%rax
  8004208c11:	48 39 c2             	cmp    %rax,%rdx
  8004208c14:	72 32                	jb     8004208c48 <env_free+0x25c>
  8004208c16:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004208c1a:	48 89 c1             	mov    %rax,%rcx
  8004208c1d:	48 ba 58 a0 21 04 80 	movabs $0x800421a058,%rdx
  8004208c24:	00 00 00 
  8004208c27:	be 66 02 00 00       	mov    $0x266,%esi
  8004208c2c:	48 bf a7 a0 21 04 80 	movabs $0x800421a0a7,%rdi
  8004208c33:	00 00 00 
  8004208c36:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208c3b:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004208c42:	00 00 00 
  8004208c45:	41 ff d0             	callq  *%r8
  8004208c48:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004208c4f:	00 00 00 
  8004208c52:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004208c56:	48 01 d0             	add    %rdx,%rax
  8004208c59:	48 89 45 90          	mov    %rax,-0x70(%rbp)

			// unmap all PTEs in this page table
			for (pteno = 0; pteno < PTX(~0); pteno++) {
  8004208c5d:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004208c64:	00 
  8004208c65:	eb 67                	jmp    8004208cce <env_free+0x2e2>
				if (pt[pteno] & PTE_P){
  8004208c67:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208c6b:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208c72:	00 
  8004208c73:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004208c77:	48 01 d0             	add    %rdx,%rax
  8004208c7a:	48 8b 00             	mov    (%rax),%rax
  8004208c7d:	83 e0 01             	and    $0x1,%eax
  8004208c80:	48 85 c0             	test   %rax,%rax
  8004208c83:	74 44                	je     8004208cc9 <env_free+0x2dd>
					page_remove(e->env_pml4e, PGADDR((uint64_t)0,pdpe_index,pdeno, pteno, 0));
  8004208c85:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208c89:	48 c1 e0 1e          	shl    $0x1e,%rax
  8004208c8d:	48 89 c2             	mov    %rax,%rdx
  8004208c90:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208c94:	48 c1 e0 15          	shl    $0x15,%rax
  8004208c98:	48 09 c2             	or     %rax,%rdx
  8004208c9b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208c9f:	48 c1 e0 0c          	shl    $0xc,%rax
  8004208ca3:	48 09 d0             	or     %rdx,%rax
  8004208ca6:	48 89 c2             	mov    %rax,%rdx
  8004208ca9:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208cb0:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208cb7:	48 89 d6             	mov    %rdx,%rsi
  8004208cba:	48 89 c7             	mov    %rax,%rdi
  8004208cbd:	48 b8 4d 3f 20 04 80 	movabs $0x8004203f4d,%rax
  8004208cc4:	00 00 00 
  8004208cc7:	ff d0                	callq  *%rax
			// find the pa and va of the page table
			pa = PTE_ADDR(env_pgdir[pdeno]);
			pt = (pte_t*) KADDR(pa);

			// unmap all PTEs in this page table
			for (pteno = 0; pteno < PTX(~0); pteno++) {
  8004208cc9:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  8004208cce:	48 81 7d f0 fe 01 00 	cmpq   $0x1fe,-0x10(%rbp)
  8004208cd5:	00 
  8004208cd6:	76 8f                	jbe    8004208c67 <env_free+0x27b>
					page_remove(e->env_pml4e, PGADDR((uint64_t)0,pdpe_index,pdeno, pteno, 0));
				}
			}

			// free the page table itself
			env_pgdir[pdeno] = 0;
  8004208cd8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208cdc:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208ce3:	00 
  8004208ce4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004208ce8:	48 01 d0             	add    %rdx,%rax
  8004208ceb:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			page_decref(pa2page(pa));
  8004208cf2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004208cf6:	48 89 c7             	mov    %rax,%rdi
  8004208cf9:	48 b8 2f 7e 20 04 80 	movabs $0x8004207e2f,%rax
  8004208d00:	00 00 00 
  8004208d03:	ff d0                	callq  *%rax
  8004208d05:	48 89 c7             	mov    %rax,%rdi
  8004208d08:	48 b8 14 31 20 04 80 	movabs $0x8004203114,%rax
  8004208d0f:	00 00 00 
  8004208d12:	ff d0                	callq  *%rax
		if(!(env_pdpe[pdpe_index] & PTE_P))
			continue;
		pde_t *env_pgdir = KADDR(PTE_ADDR(env_pdpe[pdpe_index]));
		pdeno_limit  = pdpe_index==3?PDX(UTOP):PDX(0xFFFFFFFF);
		static_assert(UTOP % PTSIZE == 0);
		for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {
  8004208d14:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004208d19:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8004208d1c:	48 98                	cltq   
  8004208d1e:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004208d22:	0f 87 83 fe ff ff    	ja     8004208bab <env_free+0x1bf>
			// free the page table itself
			env_pgdir[pdeno] = 0;
			page_decref(pa2page(pa));
		}
		// free the page directory
		pa = PTE_ADDR(env_pdpe[pdpe_index]);
  8004208d28:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208d2c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208d33:	00 
  8004208d34:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208d38:	48 01 d0             	add    %rdx,%rax
  8004208d3b:	48 8b 00             	mov    (%rax),%rax
  8004208d3e:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208d44:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
		env_pdpe[pdpe_index] = 0;
  8004208d48:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208d4c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208d53:	00 
  8004208d54:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208d58:	48 01 d0             	add    %rdx,%rax
  8004208d5b:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		page_decref(pa2page(pa));
  8004208d62:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004208d66:	48 89 c7             	mov    %rax,%rdi
  8004208d69:	48 b8 2f 7e 20 04 80 	movabs $0x8004207e2f,%rax
  8004208d70:	00 00 00 
  8004208d73:	ff d0                	callq  *%rax
  8004208d75:	48 89 c7             	mov    %rax,%rdi
  8004208d78:	48 b8 14 31 20 04 80 	movabs $0x8004203114,%rax
  8004208d7f:	00 00 00 
  8004208d82:	ff d0                	callq  *%rax
	pdpe_t *env_pdpe = KADDR(PTE_ADDR(e->env_pml4e[0]));
	int pdeno_limit;
	uint64_t pdpe_index;
	// using 3 instead of NPDPENTRIES as we have only first three indices
	// set for 4GB of address space.
	for(pdpe_index=0;pdpe_index<=3;pdpe_index++){
  8004208d84:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  8004208d89:	48 83 7d e8 03       	cmpq   $0x3,-0x18(%rbp)
  8004208d8e:	0f 86 4a fd ff ff    	jbe    8004208ade <env_free+0xf2>
		pa = PTE_ADDR(env_pdpe[pdpe_index]);
		env_pdpe[pdpe_index] = 0;
		page_decref(pa2page(pa));
	}
	// free the page directory pointer
	page_decref(pa2page(PTE_ADDR(e->env_pml4e[0])));
  8004208d94:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208d9b:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208da2:	48 8b 00             	mov    (%rax),%rax
  8004208da5:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208dab:	48 89 c7             	mov    %rax,%rdi
  8004208dae:	48 b8 2f 7e 20 04 80 	movabs $0x8004207e2f,%rax
  8004208db5:	00 00 00 
  8004208db8:	ff d0                	callq  *%rax
  8004208dba:	48 89 c7             	mov    %rax,%rdi
  8004208dbd:	48 b8 14 31 20 04 80 	movabs $0x8004203114,%rax
  8004208dc4:	00 00 00 
  8004208dc7:	ff d0                	callq  *%rax
	// free the page map level 4 (PML4)
	e->env_pml4e[0] = 0;
  8004208dc9:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208dd0:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208dd7:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	pa = e->env_cr3;
  8004208dde:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208de5:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004208dec:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	e->env_pml4e = 0;
  8004208df0:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208df7:	48 c7 80 e0 00 00 00 	movq   $0x0,0xe0(%rax)
  8004208dfe:	00 00 00 00 
	e->env_cr3 = 0;
  8004208e02:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208e09:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
  8004208e10:	00 00 00 00 
	page_decref(pa2page(pa));
  8004208e14:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004208e18:	48 89 c7             	mov    %rax,%rdi
  8004208e1b:	48 b8 2f 7e 20 04 80 	movabs $0x8004207e2f,%rax
  8004208e22:	00 00 00 
  8004208e25:	ff d0                	callq  *%rax
  8004208e27:	48 89 c7             	mov    %rax,%rdi
  8004208e2a:	48 b8 14 31 20 04 80 	movabs $0x8004203114,%rax
  8004208e31:	00 00 00 
  8004208e34:	ff d0                	callq  *%rax

	// return the environment to the free list
	e->env_status = ENV_FREE;
  8004208e36:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208e3d:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  8004208e44:	00 00 00 
	e->env_link = env_free_list;
  8004208e47:	48 b8 60 d2 49 04 80 	movabs $0x800449d260,%rax
  8004208e4e:	00 00 00 
  8004208e51:	48 8b 10             	mov    (%rax),%rdx
  8004208e54:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208e5b:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
	env_free_list = e;
  8004208e62:	48 b8 60 d2 49 04 80 	movabs $0x800449d260,%rax
  8004208e69:	00 00 00 
  8004208e6c:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  8004208e73:	48 89 10             	mov    %rdx,(%rax)
}
  8004208e76:	c9                   	leaveq 
  8004208e77:	c3                   	retq   

0000008004208e78 <env_destroy>:
// to the caller).

//
void
env_destroy(struct Env *e)
{
  8004208e78:	55                   	push   %rbp
  8004208e79:	48 89 e5             	mov    %rsp,%rbp
  8004208e7c:	48 83 ec 10          	sub    $0x10,%rsp
  8004208e80:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)

	// If e is currently running on other CPUs, we change its state to
	// ENV_DYING. A zombie environment will be freed the next time
	// it traps to the kernel.
	if (e->env_status == ENV_RUNNING && curenv != e) {
  8004208e84:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208e88:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  8004208e8e:	83 f8 03             	cmp    $0x3,%eax
  8004208e91:	75 49                	jne    8004208edc <env_destroy+0x64>
  8004208e93:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  8004208e9a:	00 00 00 
  8004208e9d:	ff d0                	callq  *%rax
  8004208e9f:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  8004208ea6:	00 00 00 
  8004208ea9:	48 98                	cltq   
  8004208eab:	48 c1 e0 03          	shl    $0x3,%rax
  8004208eaf:	48 89 c1             	mov    %rax,%rcx
  8004208eb2:	48 c1 e1 04          	shl    $0x4,%rcx
  8004208eb6:	48 01 c8             	add    %rcx,%rax
  8004208eb9:	48 01 d0             	add    %rdx,%rax
  8004208ebc:	48 83 c0 08          	add    $0x8,%rax
  8004208ec0:	48 8b 00             	mov    (%rax),%rax
  8004208ec3:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004208ec7:	74 13                	je     8004208edc <env_destroy+0x64>
		e->env_status = ENV_DYING;
  8004208ec9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208ecd:	c7 80 d4 00 00 00 01 	movl   $0x1,0xd4(%rax)
  8004208ed4:	00 00 00 
		return;
  8004208ed7:	e9 89 00 00 00       	jmpq   8004208f65 <env_destroy+0xed>
	}

	env_free(e);
  8004208edc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208ee0:	48 89 c7             	mov    %rax,%rdi
  8004208ee3:	48 b8 ec 89 20 04 80 	movabs $0x80042089ec,%rax
  8004208eea:	00 00 00 
  8004208eed:	ff d0                	callq  *%rax
	if (curenv == e) {
  8004208eef:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  8004208ef6:	00 00 00 
  8004208ef9:	ff d0                	callq  *%rax
  8004208efb:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  8004208f02:	00 00 00 
  8004208f05:	48 98                	cltq   
  8004208f07:	48 c1 e0 03          	shl    $0x3,%rax
  8004208f0b:	48 89 c1             	mov    %rax,%rcx
  8004208f0e:	48 c1 e1 04          	shl    $0x4,%rcx
  8004208f12:	48 01 c8             	add    %rcx,%rax
  8004208f15:	48 01 d0             	add    %rdx,%rax
  8004208f18:	48 83 c0 08          	add    $0x8,%rax
  8004208f1c:	48 8b 00             	mov    (%rax),%rax
  8004208f1f:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004208f23:	75 40                	jne    8004208f65 <env_destroy+0xed>
		curenv = NULL;
  8004208f25:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  8004208f2c:	00 00 00 
  8004208f2f:	ff d0                	callq  *%rax
  8004208f31:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  8004208f38:	00 00 00 
  8004208f3b:	48 98                	cltq   
  8004208f3d:	48 c1 e0 03          	shl    $0x3,%rax
  8004208f41:	48 89 c1             	mov    %rax,%rcx
  8004208f44:	48 c1 e1 04          	shl    $0x4,%rcx
  8004208f48:	48 01 c8             	add    %rcx,%rax
  8004208f4b:	48 01 d0             	add    %rdx,%rax
  8004208f4e:	48 83 c0 08          	add    $0x8,%rax
  8004208f52:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		sched_yield();
  8004208f59:	48 b8 d5 d2 20 04 80 	movabs $0x800420d2d5,%rax
  8004208f60:	00 00 00 
  8004208f63:	ff d0                	callq  *%rax
	}

}
  8004208f65:	c9                   	leaveq 
  8004208f66:	c3                   	retq   

0000008004208f67 <env_pop_tf>:
//
// This function does not return.
//
void
env_pop_tf(struct Trapframe *tf)
{
  8004208f67:	55                   	push   %rbp
  8004208f68:	48 89 e5             	mov    %rsp,%rbp
  8004208f6b:	53                   	push   %rbx
  8004208f6c:	48 83 ec 18          	sub    $0x18,%rsp
  8004208f70:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)

	// Record the CPU we are running on for user-space debugging
	curenv->env_cpunum = cpunum();
  8004208f74:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  8004208f7b:	00 00 00 
  8004208f7e:	ff d0                	callq  *%rax
  8004208f80:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  8004208f87:	00 00 00 
  8004208f8a:	48 98                	cltq   
  8004208f8c:	48 c1 e0 03          	shl    $0x3,%rax
  8004208f90:	48 89 c1             	mov    %rax,%rcx
  8004208f93:	48 c1 e1 04          	shl    $0x4,%rcx
  8004208f97:	48 01 c8             	add    %rcx,%rax
  8004208f9a:	48 01 d0             	add    %rdx,%rax
  8004208f9d:	48 83 c0 08          	add    $0x8,%rax
  8004208fa1:	48 8b 18             	mov    (%rax),%rbx
  8004208fa4:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  8004208fab:	00 00 00 
  8004208fae:	ff d0                	callq  *%rax
  8004208fb0:	89 83 dc 00 00 00    	mov    %eax,0xdc(%rbx)

	__asm __volatile("movq %0,%%rsp\n"
  8004208fb6:	48 8b 65 e8          	mov    -0x18(%rbp),%rsp
  8004208fba:	4c 8b 3c 24          	mov    (%rsp),%r15
  8004208fbe:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  8004208fc3:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  8004208fc8:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  8004208fcd:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  8004208fd2:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  8004208fd7:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  8004208fdc:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  8004208fe1:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  8004208fe6:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  8004208feb:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  8004208ff0:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  8004208ff5:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  8004208ffa:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  8004208fff:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  8004209004:	48 83 c4 78          	add    $0x78,%rsp
  8004209008:	8e 04 24             	mov    (%rsp),%es
  800420900b:	8e 5c 24 08          	mov    0x8(%rsp),%ds
  800420900f:	48 83 c4 10          	add    $0x10,%rsp
  8004209013:	48 83 c4 10          	add    $0x10,%rsp
  8004209017:	48 cf                	iretq  
			 "movw 8(%%rsp),%%ds\n"
			 "addq $16,%%rsp\n"
			 "\taddq $16,%%rsp\n" /* skip tf_trapno and tf_errcode */
			 "\tiretq"
			 : : "g" (tf) : "memory");
	panic("iret failed");  /* mostly to placate the compiler */
  8004209019:	48 ba 78 a1 21 04 80 	movabs $0x800421a178,%rdx
  8004209020:	00 00 00 
  8004209023:	be b8 02 00 00       	mov    $0x2b8,%esi
  8004209028:	48 bf a7 a0 21 04 80 	movabs $0x800421a0a7,%rdi
  800420902f:	00 00 00 
  8004209032:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209037:	48 b9 e4 05 20 04 80 	movabs $0x80042005e4,%rcx
  800420903e:	00 00 00 
  8004209041:	ff d1                	callq  *%rcx

0000008004209043 <env_run>:
//
// This function does not return.
//
void
env_run(struct Env *e)
{
  8004209043:	55                   	push   %rbp
  8004209044:	48 89 e5             	mov    %rsp,%rbp
  8004209047:	48 83 ec 20          	sub    $0x20,%rsp
  800420904b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)

	// Is this a context switch or just a return?
	if (curenv != e) {
  800420904f:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  8004209056:	00 00 00 
  8004209059:	ff d0                	callq  *%rax
  800420905b:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  8004209062:	00 00 00 
  8004209065:	48 98                	cltq   
  8004209067:	48 c1 e0 03          	shl    $0x3,%rax
  800420906b:	48 89 c1             	mov    %rax,%rcx
  800420906e:	48 c1 e1 04          	shl    $0x4,%rcx
  8004209072:	48 01 c8             	add    %rcx,%rax
  8004209075:	48 01 d0             	add    %rdx,%rax
  8004209078:	48 83 c0 08          	add    $0x8,%rax
  800420907c:	48 8b 00             	mov    (%rax),%rax
  800420907f:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004209083:	0f 84 28 01 00 00    	je     80042091b1 <env_run+0x16e>
		if (curenv && curenv->env_status == ENV_RUNNING)
  8004209089:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  8004209090:	00 00 00 
  8004209093:	ff d0                	callq  *%rax
  8004209095:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420909c:	00 00 00 
  800420909f:	48 98                	cltq   
  80042090a1:	48 c1 e0 03          	shl    $0x3,%rax
  80042090a5:	48 89 c1             	mov    %rax,%rcx
  80042090a8:	48 c1 e1 04          	shl    $0x4,%rcx
  80042090ac:	48 01 c8             	add    %rcx,%rax
  80042090af:	48 01 d0             	add    %rdx,%rax
  80042090b2:	48 83 c0 08          	add    $0x8,%rax
  80042090b6:	48 8b 00             	mov    (%rax),%rax
  80042090b9:	48 85 c0             	test   %rax,%rax
  80042090bc:	74 75                	je     8004209133 <env_run+0xf0>
  80042090be:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  80042090c5:	00 00 00 
  80042090c8:	ff d0                	callq  *%rax
  80042090ca:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  80042090d1:	00 00 00 
  80042090d4:	48 98                	cltq   
  80042090d6:	48 c1 e0 03          	shl    $0x3,%rax
  80042090da:	48 89 c1             	mov    %rax,%rcx
  80042090dd:	48 c1 e1 04          	shl    $0x4,%rcx
  80042090e1:	48 01 c8             	add    %rcx,%rax
  80042090e4:	48 01 d0             	add    %rdx,%rax
  80042090e7:	48 83 c0 08          	add    $0x8,%rax
  80042090eb:	48 8b 00             	mov    (%rax),%rax
  80042090ee:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  80042090f4:	83 f8 03             	cmp    $0x3,%eax
  80042090f7:	75 3a                	jne    8004209133 <env_run+0xf0>
			curenv->env_status = ENV_RUNNABLE;
  80042090f9:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  8004209100:	00 00 00 
  8004209103:	ff d0                	callq  *%rax
  8004209105:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420910c:	00 00 00 
  800420910f:	48 98                	cltq   
  8004209111:	48 c1 e0 03          	shl    $0x3,%rax
  8004209115:	48 89 c1             	mov    %rax,%rcx
  8004209118:	48 c1 e1 04          	shl    $0x4,%rcx
  800420911c:	48 01 c8             	add    %rcx,%rax
  800420911f:	48 01 d0             	add    %rdx,%rax
  8004209122:	48 83 c0 08          	add    $0x8,%rax
  8004209126:	48 8b 00             	mov    (%rax),%rax
  8004209129:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  8004209130:	00 00 00 
		//cprintf("cpu %d switch from env %d to env %d\n",
		//	cpunum(), curenv ? curenv - envs : -1, e - envs);

		// keep track of which environment we're currently
		// running
		curenv = e;
  8004209133:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420913a:	00 00 00 
  800420913d:	ff d0                	callq  *%rax
  800420913f:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  8004209146:	00 00 00 
  8004209149:	48 98                	cltq   
  800420914b:	48 c1 e0 03          	shl    $0x3,%rax
  800420914f:	48 89 c1             	mov    %rax,%rcx
  8004209152:	48 c1 e1 04          	shl    $0x4,%rcx
  8004209156:	48 01 c8             	add    %rcx,%rax
  8004209159:	48 01 d0             	add    %rdx,%rax
  800420915c:	48 8d 50 08          	lea    0x8(%rax),%rdx
  8004209160:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209164:	48 89 02             	mov    %rax,(%rdx)
		e->env_status = ENV_RUNNING;
  8004209167:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420916b:	c7 80 d4 00 00 00 03 	movl   $0x3,0xd4(%rax)
  8004209172:	00 00 00 
		e->env_runs++;
  8004209175:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209179:	8b 80 d8 00 00 00    	mov    0xd8(%rax),%eax
  800420917f:	8d 50 01             	lea    0x1(%rax),%edx
  8004209182:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209186:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)

		// restore e's address space

		if(e->env_type != ENV_TYPE_GUEST)
  800420918c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209190:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  8004209196:	83 f8 03             	cmp    $0x3,%eax
  8004209199:	74 16                	je     80042091b1 <env_run+0x16e>
			lcr3(e->env_cr3);
  800420919b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420919f:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  80042091a6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042091aa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042091ae:	0f 22 d8             	mov    %rax,%cr3

	}

	assert(e->env_status == ENV_RUNNING);
  80042091b1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042091b5:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  80042091bb:	83 f8 03             	cmp    $0x3,%eax
  80042091be:	74 35                	je     80042091f5 <env_run+0x1b2>
  80042091c0:	48 b9 84 a1 21 04 80 	movabs $0x800421a184,%rcx
  80042091c7:	00 00 00 
  80042091ca:	48 ba a1 a1 21 04 80 	movabs $0x800421a1a1,%rdx
  80042091d1:	00 00 00 
  80042091d4:	be da 02 00 00       	mov    $0x2da,%esi
  80042091d9:	48 bf a7 a0 21 04 80 	movabs $0x800421a0a7,%rdi
  80042091e0:	00 00 00 
  80042091e3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042091e8:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042091ef:	00 00 00 
  80042091f2:	41 ff d0             	callq  *%r8
	else {
		unlock_kernel();
		env_pop_tf(&e->env_tf);
	}
#else	/* VMM_GUEST */
	unlock_kernel();
  80042091f5:	48 b8 28 7f 20 04 80 	movabs $0x8004207f28,%rax
  80042091fc:	00 00 00 
  80042091ff:	ff d0                	callq  *%rax
	env_pop_tf(&e->env_tf);
  8004209201:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209205:	48 89 c7             	mov    %rax,%rdi
  8004209208:	48 b8 67 8f 20 04 80 	movabs $0x8004208f67,%rax
  800420920f:	00 00 00 
  8004209212:	ff d0                	callq  *%rax

0000008004209214 <mc146818_read>:
#include <kern/kclock.h>


unsigned
mc146818_read(unsigned reg)
{
  8004209214:	55                   	push   %rbp
  8004209215:	48 89 e5             	mov    %rsp,%rbp
  8004209218:	48 83 ec 14          	sub    $0x14,%rsp
  800420921c:	89 7d ec             	mov    %edi,-0x14(%rbp)
	outb(IO_RTC, reg);
  800420921f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004209222:	0f b6 c0             	movzbl %al,%eax
  8004209225:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%rbp)
  800420922c:	88 45 fb             	mov    %al,-0x5(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  800420922f:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004209233:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209236:	ee                   	out    %al,(%dx)
  8004209237:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  800420923e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004209241:	89 c2                	mov    %eax,%edx
  8004209243:	ec                   	in     (%dx),%al
  8004209244:	88 45 f3             	mov    %al,-0xd(%rbp)
	return data;
  8004209247:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
	return inb(IO_RTC+1);
  800420924b:	0f b6 c0             	movzbl %al,%eax
}
  800420924e:	c9                   	leaveq 
  800420924f:	c3                   	retq   

0000008004209250 <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
  8004209250:	55                   	push   %rbp
  8004209251:	48 89 e5             	mov    %rsp,%rbp
  8004209254:	48 83 ec 18          	sub    $0x18,%rsp
  8004209258:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420925b:	89 75 e8             	mov    %esi,-0x18(%rbp)
	outb(IO_RTC, reg);
  800420925e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004209261:	0f b6 c0             	movzbl %al,%eax
  8004209264:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%rbp)
  800420926b:	88 45 fb             	mov    %al,-0x5(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  800420926e:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004209272:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209275:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
  8004209276:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004209279:	0f b6 c0             	movzbl %al,%eax
  800420927c:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%rbp)
  8004209283:	88 45 f3             	mov    %al,-0xd(%rbp)
  8004209286:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  800420928a:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800420928d:	ee                   	out    %al,(%dx)
}
  800420928e:	c9                   	leaveq 
  800420928f:	c3                   	retq   

0000008004209290 <pic_init>:
static bool didinit;

/* Initialize the 8259A interrupt controllers. */
void
pic_init(void)
{
  8004209290:	55                   	push   %rbp
  8004209291:	48 89 e5             	mov    %rsp,%rbp
  8004209294:	48 83 ec 70          	sub    $0x70,%rsp
	didinit = 1;
  8004209298:	48 b8 68 d2 49 04 80 	movabs $0x800449d268,%rax
  800420929f:	00 00 00 
  80042092a2:	c6 00 01             	movb   $0x1,(%rax)
  80042092a5:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%rbp)
  80042092ac:	c6 45 fb ff          	movb   $0xff,-0x5(%rbp)
  80042092b0:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  80042092b4:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042092b7:	ee                   	out    %al,(%dx)
  80042092b8:	c7 45 f4 a1 00 00 00 	movl   $0xa1,-0xc(%rbp)
  80042092bf:	c6 45 f3 ff          	movb   $0xff,-0xd(%rbp)
  80042092c3:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  80042092c7:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042092ca:	ee                   	out    %al,(%dx)
  80042092cb:	c7 45 ec 20 00 00 00 	movl   $0x20,-0x14(%rbp)
  80042092d2:	c6 45 eb 11          	movb   $0x11,-0x15(%rbp)
  80042092d6:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  80042092da:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042092dd:	ee                   	out    %al,(%dx)
  80042092de:	c7 45 e4 21 00 00 00 	movl   $0x21,-0x1c(%rbp)
  80042092e5:	c6 45 e3 20          	movb   $0x20,-0x1d(%rbp)
  80042092e9:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  80042092ed:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80042092f0:	ee                   	out    %al,(%dx)
  80042092f1:	c7 45 dc 21 00 00 00 	movl   $0x21,-0x24(%rbp)
  80042092f8:	c6 45 db 04          	movb   $0x4,-0x25(%rbp)
  80042092fc:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004209300:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004209303:	ee                   	out    %al,(%dx)
  8004209304:	c7 45 d4 21 00 00 00 	movl   $0x21,-0x2c(%rbp)
  800420930b:	c6 45 d3 03          	movb   $0x3,-0x2d(%rbp)
  800420930f:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004209313:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004209316:	ee                   	out    %al,(%dx)
  8004209317:	c7 45 cc a0 00 00 00 	movl   $0xa0,-0x34(%rbp)
  800420931e:	c6 45 cb 11          	movb   $0x11,-0x35(%rbp)
  8004209322:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  8004209326:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004209329:	ee                   	out    %al,(%dx)
  800420932a:	c7 45 c4 a1 00 00 00 	movl   $0xa1,-0x3c(%rbp)
  8004209331:	c6 45 c3 28          	movb   $0x28,-0x3d(%rbp)
  8004209335:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
  8004209339:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  800420933c:	ee                   	out    %al,(%dx)
  800420933d:	c7 45 bc a1 00 00 00 	movl   $0xa1,-0x44(%rbp)
  8004209344:	c6 45 bb 02          	movb   $0x2,-0x45(%rbp)
  8004209348:	0f b6 45 bb          	movzbl -0x45(%rbp),%eax
  800420934c:	8b 55 bc             	mov    -0x44(%rbp),%edx
  800420934f:	ee                   	out    %al,(%dx)
  8004209350:	c7 45 b4 a1 00 00 00 	movl   $0xa1,-0x4c(%rbp)
  8004209357:	c6 45 b3 01          	movb   $0x1,-0x4d(%rbp)
  800420935b:	0f b6 45 b3          	movzbl -0x4d(%rbp),%eax
  800420935f:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  8004209362:	ee                   	out    %al,(%dx)
  8004209363:	c7 45 ac 20 00 00 00 	movl   $0x20,-0x54(%rbp)
  800420936a:	c6 45 ab 68          	movb   $0x68,-0x55(%rbp)
  800420936e:	0f b6 45 ab          	movzbl -0x55(%rbp),%eax
  8004209372:	8b 55 ac             	mov    -0x54(%rbp),%edx
  8004209375:	ee                   	out    %al,(%dx)
  8004209376:	c7 45 a4 20 00 00 00 	movl   $0x20,-0x5c(%rbp)
  800420937d:	c6 45 a3 0a          	movb   $0xa,-0x5d(%rbp)
  8004209381:	0f b6 45 a3          	movzbl -0x5d(%rbp),%eax
  8004209385:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004209388:	ee                   	out    %al,(%dx)
  8004209389:	c7 45 9c a0 00 00 00 	movl   $0xa0,-0x64(%rbp)
  8004209390:	c6 45 9b 68          	movb   $0x68,-0x65(%rbp)
  8004209394:	0f b6 45 9b          	movzbl -0x65(%rbp),%eax
  8004209398:	8b 55 9c             	mov    -0x64(%rbp),%edx
  800420939b:	ee                   	out    %al,(%dx)
  800420939c:	c7 45 94 a0 00 00 00 	movl   $0xa0,-0x6c(%rbp)
  80042093a3:	c6 45 93 0a          	movb   $0xa,-0x6d(%rbp)
  80042093a7:	0f b6 45 93          	movzbl -0x6d(%rbp),%eax
  80042093ab:	8b 55 94             	mov    -0x6c(%rbp),%edx
  80042093ae:	ee                   	out    %al,(%dx)
	outb(IO_PIC1, 0x0a);             /* read IRR by default */

	outb(IO_PIC2, 0x68);               /* OCW3 */
	outb(IO_PIC2, 0x0a);               /* OCW3 */

	if (irq_mask_8259A != 0xFFFF)
  80042093af:	48 b8 72 c6 22 04 80 	movabs $0x800422c672,%rax
  80042093b6:	00 00 00 
  80042093b9:	0f b7 00             	movzwl (%rax),%eax
  80042093bc:	66 83 f8 ff          	cmp    $0xffff,%ax
  80042093c0:	74 1e                	je     80042093e0 <pic_init+0x150>
		irq_setmask_8259A(irq_mask_8259A);
  80042093c2:	48 b8 72 c6 22 04 80 	movabs $0x800422c672,%rax
  80042093c9:	00 00 00 
  80042093cc:	0f b7 00             	movzwl (%rax),%eax
  80042093cf:	0f b7 c0             	movzwl %ax,%eax
  80042093d2:	89 c7                	mov    %eax,%edi
  80042093d4:	48 b8 e2 93 20 04 80 	movabs $0x80042093e2,%rax
  80042093db:	00 00 00 
  80042093de:	ff d0                	callq  *%rax
}
  80042093e0:	c9                   	leaveq 
  80042093e1:	c3                   	retq   

00000080042093e2 <irq_setmask_8259A>:

void
irq_setmask_8259A(uint16_t mask)
{
  80042093e2:	55                   	push   %rbp
  80042093e3:	48 89 e5             	mov    %rsp,%rbp
  80042093e6:	48 83 ec 30          	sub    $0x30,%rsp
  80042093ea:	89 f8                	mov    %edi,%eax
  80042093ec:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
	int i;
	irq_mask_8259A = mask;
  80042093f0:	48 b8 72 c6 22 04 80 	movabs $0x800422c672,%rax
  80042093f7:	00 00 00 
  80042093fa:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  80042093fe:	66 89 10             	mov    %dx,(%rax)
	if (!didinit)
  8004209401:	48 b8 68 d2 49 04 80 	movabs $0x800449d268,%rax
  8004209408:	00 00 00 
  800420940b:	0f b6 00             	movzbl (%rax),%eax
  800420940e:	83 f0 01             	xor    $0x1,%eax
  8004209411:	84 c0                	test   %al,%al
  8004209413:	74 05                	je     800420941a <irq_setmask_8259A+0x38>
		return;
  8004209415:	e9 b7 00 00 00       	jmpq   80042094d1 <irq_setmask_8259A+0xef>
	outb(IO_PIC1+1, (char)mask);
  800420941a:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  800420941e:	0f b6 c0             	movzbl %al,%eax
  8004209421:	c7 45 f8 21 00 00 00 	movl   $0x21,-0x8(%rbp)
  8004209428:	88 45 f7             	mov    %al,-0x9(%rbp)
  800420942b:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  800420942f:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004209432:	ee                   	out    %al,(%dx)
	outb(IO_PIC2+1, (char)(mask >> 8));
  8004209433:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  8004209437:	66 c1 e8 08          	shr    $0x8,%ax
  800420943b:	0f b6 c0             	movzbl %al,%eax
  800420943e:	c7 45 f0 a1 00 00 00 	movl   $0xa1,-0x10(%rbp)
  8004209445:	88 45 ef             	mov    %al,-0x11(%rbp)
  8004209448:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  800420944c:	8b 55 f0             	mov    -0x10(%rbp),%edx
  800420944f:	ee                   	out    %al,(%dx)
	cprintf("enabled interrupts:");
  8004209450:	48 bf b6 a1 21 04 80 	movabs $0x800421a1b6,%rdi
  8004209457:	00 00 00 
  800420945a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420945f:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  8004209466:	00 00 00 
  8004209469:	ff d2                	callq  *%rdx
	for (i = 0; i < 16; i++)
  800420946b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004209472:	eb 3c                	jmp    80042094b0 <irq_setmask_8259A+0xce>
		if (~mask & (1<<i))
  8004209474:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  8004209478:	f7 d0                	not    %eax
  800420947a:	89 c2                	mov    %eax,%edx
  800420947c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420947f:	89 c1                	mov    %eax,%ecx
  8004209481:	d3 fa                	sar    %cl,%edx
  8004209483:	89 d0                	mov    %edx,%eax
  8004209485:	83 e0 01             	and    $0x1,%eax
  8004209488:	85 c0                	test   %eax,%eax
  800420948a:	74 20                	je     80042094ac <irq_setmask_8259A+0xca>
			cprintf(" %d", i);
  800420948c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420948f:	89 c6                	mov    %eax,%esi
  8004209491:	48 bf ca a1 21 04 80 	movabs $0x800421a1ca,%rdi
  8004209498:	00 00 00 
  800420949b:	b8 00 00 00 00       	mov    $0x0,%eax
  80042094a0:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  80042094a7:	00 00 00 
  80042094aa:	ff d2                	callq  *%rdx
	if (!didinit)
		return;
	outb(IO_PIC1+1, (char)mask);
	outb(IO_PIC2+1, (char)(mask >> 8));
	cprintf("enabled interrupts:");
	for (i = 0; i < 16; i++)
  80042094ac:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042094b0:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
  80042094b4:	7e be                	jle    8004209474 <irq_setmask_8259A+0x92>
		if (~mask & (1<<i))
			cprintf(" %d", i);
	cprintf("\n");
  80042094b6:	48 bf ce a1 21 04 80 	movabs $0x800421a1ce,%rdi
  80042094bd:	00 00 00 
  80042094c0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042094c5:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  80042094cc:	00 00 00 
  80042094cf:	ff d2                	callq  *%rdx
}
  80042094d1:	c9                   	leaveq 
  80042094d2:	c3                   	retq   

00000080042094d3 <irq_eoi>:


void
irq_eoi(void)
{
  80042094d3:	55                   	push   %rbp
  80042094d4:	48 89 e5             	mov    %rsp,%rbp
  80042094d7:	48 83 ec 10          	sub    $0x10,%rsp
  80042094db:	c7 45 fc 20 00 00 00 	movl   $0x20,-0x4(%rbp)
  80042094e2:	c6 45 fb 20          	movb   $0x20,-0x5(%rbp)
  80042094e6:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  80042094ea:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042094ed:	ee                   	out    %al,(%dx)
  80042094ee:	c7 45 f4 a0 00 00 00 	movl   $0xa0,-0xc(%rbp)
  80042094f5:	c6 45 f3 20          	movb   $0x20,-0xd(%rbp)
  80042094f9:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  80042094fd:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004209500:	ee                   	out    %al,(%dx)
	//   s: specific
	//   e: end-of-interrupt
	// xxx: specific interrupt line
	outb(IO_PIC1, 0x20);
	outb(IO_PIC2, 0x20);
}
  8004209501:	c9                   	leaveq 
  8004209502:	c3                   	retq   

0000008004209503 <putch>:
#include <inc/stdarg.h>


static void
putch(int ch, int *cnt)
{
  8004209503:	55                   	push   %rbp
  8004209504:	48 89 e5             	mov    %rsp,%rbp
  8004209507:	48 83 ec 10          	sub    $0x10,%rsp
  800420950b:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800420950e:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	cputchar(ch);
  8004209512:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004209515:	89 c7                	mov    %eax,%edi
  8004209517:	48 b8 3a 13 20 04 80 	movabs $0x800420133a,%rax
  800420951e:	00 00 00 
  8004209521:	ff d0                	callq  *%rax
	*cnt++;
  8004209523:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004209527:	48 83 c0 04          	add    $0x4,%rax
  800420952b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}
  800420952f:	c9                   	leaveq 
  8004209530:	c3                   	retq   

0000008004209531 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
  8004209531:	55                   	push   %rbp
  8004209532:	48 89 e5             	mov    %rsp,%rbp
  8004209535:	48 83 ec 30          	sub    $0x30,%rsp
  8004209539:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420953d:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int cnt = 0;
  8004209541:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	va_list aq;
	va_copy(aq,ap);
  8004209548:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  800420954c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004209550:	48 8b 0a             	mov    (%rdx),%rcx
  8004209553:	48 89 08             	mov    %rcx,(%rax)
  8004209556:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420955a:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420955e:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8004209562:	48 89 50 10          	mov    %rdx,0x10(%rax)
	vprintfmt((void*)putch, &cnt, fmt, aq);
  8004209566:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  800420956a:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420956e:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  8004209572:	48 89 c6             	mov    %rax,%rsi
  8004209575:	48 bf 03 95 20 04 80 	movabs $0x8004209503,%rdi
  800420957c:	00 00 00 
  800420957f:	48 b8 e4 f7 20 04 80 	movabs $0x800420f7e4,%rax
  8004209586:	00 00 00 
  8004209589:	ff d0                	callq  *%rax
	va_end(aq);
	return cnt;
  800420958b:	8b 45 fc             	mov    -0x4(%rbp),%eax

}
  800420958e:	c9                   	leaveq 
  800420958f:	c3                   	retq   

0000008004209590 <cprintf>:

int
cprintf(const char *fmt, ...)
{
  8004209590:	55                   	push   %rbp
  8004209591:	48 89 e5             	mov    %rsp,%rbp
  8004209594:	48 81 ec 00 01 00 00 	sub    $0x100,%rsp
  800420959b:	48 89 b5 58 ff ff ff 	mov    %rsi,-0xa8(%rbp)
  80042095a2:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
  80042095a9:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  80042095b0:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  80042095b7:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  80042095be:	84 c0                	test   %al,%al
  80042095c0:	74 20                	je     80042095e2 <cprintf+0x52>
  80042095c2:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  80042095c6:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  80042095ca:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  80042095ce:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  80042095d2:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  80042095d6:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  80042095da:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  80042095de:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  80042095e2:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
	va_list ap;
	int cnt;
	va_start(ap, fmt);
  80042095e9:	c7 85 30 ff ff ff 08 	movl   $0x8,-0xd0(%rbp)
  80042095f0:	00 00 00 
  80042095f3:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  80042095fa:	00 00 00 
  80042095fd:	48 8d 45 10          	lea    0x10(%rbp),%rax
  8004209601:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  8004209608:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420960f:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_list aq;
	va_copy(aq,ap);
  8004209616:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  800420961d:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  8004209624:	48 8b 0a             	mov    (%rdx),%rcx
  8004209627:	48 89 08             	mov    %rcx,(%rax)
  800420962a:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420962e:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8004209632:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8004209636:	48 89 50 10          	mov    %rdx,0x10(%rax)
	cnt = vcprintf(fmt, aq);
  800420963a:	48 8d 95 18 ff ff ff 	lea    -0xe8(%rbp),%rdx
  8004209641:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004209648:	48 89 d6             	mov    %rdx,%rsi
  800420964b:	48 89 c7             	mov    %rax,%rdi
  800420964e:	48 b8 31 95 20 04 80 	movabs $0x8004209531,%rax
  8004209655:	00 00 00 
  8004209658:	ff d0                	callq  *%rax
  800420965a:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return cnt;
  8004209660:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  8004209666:	c9                   	leaveq 
  8004209667:	c3                   	retq   

0000008004209668 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  8004209668:	55                   	push   %rbp
  8004209669:	48 89 e5             	mov    %rsp,%rbp
  800420966c:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004209670:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004209674:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  8004209677:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420967b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420967e:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004209682:	f0 87 02             	lock xchg %eax,(%rdx)
  8004209685:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  8004209688:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420968b:	c9                   	leaveq 
  800420968c:	c3                   	retq   

000000800420968d <lock_kernel>:

extern struct spinlock kernel_lock;

static inline void
lock_kernel(void)
{
  800420968d:	55                   	push   %rbp
  800420968e:	48 89 e5             	mov    %rsp,%rbp
	spin_lock(&kernel_lock);
  8004209691:	48 bf 60 c7 22 04 80 	movabs $0x800422c760,%rdi
  8004209698:	00 00 00 
  800420969b:	48 b8 5d 77 21 04 80 	movabs $0x800421775d,%rax
  80042096a2:	00 00 00 
  80042096a5:	ff d0                	callq  *%rax
}
  80042096a7:	5d                   	pop    %rbp
  80042096a8:	c3                   	retq   

00000080042096a9 <trapname>:
struct Gatedesc idt[256] = { { 0 } };
struct Pseudodesc idt_pd = {0,0};


static const char *trapname(int trapno)
{
  80042096a9:	55                   	push   %rbp
  80042096aa:	48 89 e5             	mov    %rsp,%rbp
  80042096ad:	48 83 ec 04          	sub    $0x4,%rsp
  80042096b1:	89 7d fc             	mov    %edi,-0x4(%rbp)
		"Alignment Check",
		"Machine-Check",
		"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
  80042096b4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042096b7:	83 f8 13             	cmp    $0x13,%eax
  80042096ba:	77 16                	ja     80042096d2 <trapname+0x29>
		return excnames[trapno];
  80042096bc:	48 b8 e0 a5 21 04 80 	movabs $0x800421a5e0,%rax
  80042096c3:	00 00 00 
  80042096c6:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042096c9:	48 63 d2             	movslq %edx,%rdx
  80042096cc:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80042096d0:	eb 34                	jmp    8004209706 <trapname+0x5d>
	if (trapno == T_SYSCALL)
  80042096d2:	83 7d fc 30          	cmpl   $0x30,-0x4(%rbp)
  80042096d6:	75 0c                	jne    80042096e4 <trapname+0x3b>
		return "System call";
  80042096d8:	48 b8 e0 a1 21 04 80 	movabs $0x800421a1e0,%rax
  80042096df:	00 00 00 
  80042096e2:	eb 22                	jmp    8004209706 <trapname+0x5d>

	if (trapno >= IRQ_OFFSET && trapno < IRQ_OFFSET + 16)
  80042096e4:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  80042096e8:	7e 12                	jle    80042096fc <trapname+0x53>
  80042096ea:	83 7d fc 2f          	cmpl   $0x2f,-0x4(%rbp)
  80042096ee:	7f 0c                	jg     80042096fc <trapname+0x53>
		return "Hardware Interrupt";
  80042096f0:	48 b8 ec a1 21 04 80 	movabs $0x800421a1ec,%rax
  80042096f7:	00 00 00 
  80042096fa:	eb 0a                	jmp    8004209706 <trapname+0x5d>

	return "(unknown trap)";
  80042096fc:	48 b8 ff a1 21 04 80 	movabs $0x800421a1ff,%rax
  8004209703:	00 00 00 
}
  8004209706:	c9                   	leaveq 
  8004209707:	c3                   	retq   

0000008004209708 <trap_init>:


void
trap_init(void)
{
  8004209708:	55                   	push   %rbp
  8004209709:	48 89 e5             	mov    %rsp,%rbp
  800420970c:	48 83 ec 10          	sub    $0x10,%rsp
	// check that IRQ_OFFSET is a multiple of 8
	static_assert((IRQ_OFFSET & 7) == 0);


	// install a default handler
	for (i = 0; i < sizeof(idt)/sizeof(idt[0]); i++)
  8004209710:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004209717:	e9 7d 01 00 00       	jmpq   8004209899 <trap_init+0x191>
		SETGATE(idt[i], 0, GD_KT, &Xdefault, 0);
  800420971c:	48 b8 16 d2 20 04 80 	movabs $0x800420d216,%rax
  8004209723:	00 00 00 
  8004209726:	48 ba 80 d2 49 04 80 	movabs $0x800449d280,%rdx
  800420972d:	00 00 00 
  8004209730:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004209733:	48 63 c9             	movslq %ecx,%rcx
  8004209736:	48 c1 e1 04          	shl    $0x4,%rcx
  800420973a:	48 01 ca             	add    %rcx,%rdx
  800420973d:	66 89 02             	mov    %ax,(%rdx)
  8004209740:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209747:	00 00 00 
  800420974a:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420974d:	48 63 d2             	movslq %edx,%rdx
  8004209750:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209754:	48 01 d0             	add    %rdx,%rax
  8004209757:	66 c7 40 02 08 00    	movw   $0x8,0x2(%rax)
  800420975d:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209764:	00 00 00 
  8004209767:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420976a:	48 63 d2             	movslq %edx,%rdx
  800420976d:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209771:	48 01 d0             	add    %rdx,%rax
  8004209774:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  8004209778:	83 e2 f8             	and    $0xfffffff8,%edx
  800420977b:	88 50 04             	mov    %dl,0x4(%rax)
  800420977e:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209785:	00 00 00 
  8004209788:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420978b:	48 63 d2             	movslq %edx,%rdx
  800420978e:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209792:	48 01 d0             	add    %rdx,%rax
  8004209795:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  8004209799:	83 e2 07             	and    $0x7,%edx
  800420979c:	88 50 04             	mov    %dl,0x4(%rax)
  800420979f:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  80042097a6:	00 00 00 
  80042097a9:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042097ac:	48 63 d2             	movslq %edx,%rdx
  80042097af:	48 c1 e2 04          	shl    $0x4,%rdx
  80042097b3:	48 01 d0             	add    %rdx,%rax
  80042097b6:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  80042097ba:	83 e2 f0             	and    $0xfffffff0,%edx
  80042097bd:	83 ca 0e             	or     $0xe,%edx
  80042097c0:	88 50 05             	mov    %dl,0x5(%rax)
  80042097c3:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  80042097ca:	00 00 00 
  80042097cd:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042097d0:	48 63 d2             	movslq %edx,%rdx
  80042097d3:	48 c1 e2 04          	shl    $0x4,%rdx
  80042097d7:	48 01 d0             	add    %rdx,%rax
  80042097da:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  80042097de:	83 e2 ef             	and    $0xffffffef,%edx
  80042097e1:	88 50 05             	mov    %dl,0x5(%rax)
  80042097e4:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  80042097eb:	00 00 00 
  80042097ee:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042097f1:	48 63 d2             	movslq %edx,%rdx
  80042097f4:	48 c1 e2 04          	shl    $0x4,%rdx
  80042097f8:	48 01 d0             	add    %rdx,%rax
  80042097fb:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  80042097ff:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209802:	88 50 05             	mov    %dl,0x5(%rax)
  8004209805:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420980c:	00 00 00 
  800420980f:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209812:	48 63 d2             	movslq %edx,%rdx
  8004209815:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209819:	48 01 d0             	add    %rdx,%rax
  800420981c:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004209820:	83 ca 80             	or     $0xffffff80,%edx
  8004209823:	88 50 05             	mov    %dl,0x5(%rax)
  8004209826:	48 b8 16 d2 20 04 80 	movabs $0x800420d216,%rax
  800420982d:	00 00 00 
  8004209830:	48 c1 e8 10          	shr    $0x10,%rax
  8004209834:	48 ba 80 d2 49 04 80 	movabs $0x800449d280,%rdx
  800420983b:	00 00 00 
  800420983e:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004209841:	48 63 c9             	movslq %ecx,%rcx
  8004209844:	48 c1 e1 04          	shl    $0x4,%rcx
  8004209848:	48 01 ca             	add    %rcx,%rdx
  800420984b:	66 89 42 06          	mov    %ax,0x6(%rdx)
  800420984f:	48 b8 16 d2 20 04 80 	movabs $0x800420d216,%rax
  8004209856:	00 00 00 
  8004209859:	48 c1 e8 20          	shr    $0x20,%rax
  800420985d:	48 ba 80 d2 49 04 80 	movabs $0x800449d280,%rdx
  8004209864:	00 00 00 
  8004209867:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  800420986a:	48 63 c9             	movslq %ecx,%rcx
  800420986d:	48 c1 e1 04          	shl    $0x4,%rcx
  8004209871:	48 01 ca             	add    %rcx,%rdx
  8004209874:	89 42 08             	mov    %eax,0x8(%rdx)
  8004209877:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420987e:	00 00 00 
  8004209881:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209884:	48 63 d2             	movslq %edx,%rdx
  8004209887:	48 c1 e2 04          	shl    $0x4,%rdx
  800420988b:	48 01 d0             	add    %rdx,%rax
  800420988e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%rax)
	// check that IRQ_OFFSET is a multiple of 8
	static_assert((IRQ_OFFSET & 7) == 0);


	// install a default handler
	for (i = 0; i < sizeof(idt)/sizeof(idt[0]); i++)
  8004209895:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004209899:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420989c:	3d ff 00 00 00       	cmp    $0xff,%eax
  80042098a1:	0f 86 75 fe ff ff    	jbe    800420971c <trap_init+0x14>
		SETGATE(idt[i], 0, GD_KT, &Xdefault, 0);

	SETGATE(idt[T_DIVIDE], 0, GD_KT, &Xdivide, 0);
  80042098a7:	48 b8 d0 d0 20 04 80 	movabs $0x800420d0d0,%rax
  80042098ae:	00 00 00 
  80042098b1:	89 c2                	mov    %eax,%edx
  80042098b3:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  80042098ba:	00 00 00 
  80042098bd:	66 89 10             	mov    %dx,(%rax)
  80042098c0:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  80042098c7:	00 00 00 
  80042098ca:	66 c7 40 02 08 00    	movw   $0x8,0x2(%rax)
  80042098d0:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  80042098d7:	00 00 00 
  80042098da:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  80042098de:	83 e2 f8             	and    $0xfffffff8,%edx
  80042098e1:	88 50 04             	mov    %dl,0x4(%rax)
  80042098e4:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  80042098eb:	00 00 00 
  80042098ee:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  80042098f2:	83 e2 07             	and    $0x7,%edx
  80042098f5:	88 50 04             	mov    %dl,0x4(%rax)
  80042098f8:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  80042098ff:	00 00 00 
  8004209902:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004209906:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209909:	83 ca 0e             	or     $0xe,%edx
  800420990c:	88 50 05             	mov    %dl,0x5(%rax)
  800420990f:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209916:	00 00 00 
  8004209919:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420991d:	83 e2 ef             	and    $0xffffffef,%edx
  8004209920:	88 50 05             	mov    %dl,0x5(%rax)
  8004209923:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420992a:	00 00 00 
  800420992d:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004209931:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209934:	88 50 05             	mov    %dl,0x5(%rax)
  8004209937:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420993e:	00 00 00 
  8004209941:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004209945:	83 ca 80             	or     $0xffffff80,%edx
  8004209948:	88 50 05             	mov    %dl,0x5(%rax)
  800420994b:	48 b8 d0 d0 20 04 80 	movabs $0x800420d0d0,%rax
  8004209952:	00 00 00 
  8004209955:	48 c1 e8 10          	shr    $0x10,%rax
  8004209959:	89 c2                	mov    %eax,%edx
  800420995b:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209962:	00 00 00 
  8004209965:	66 89 50 06          	mov    %dx,0x6(%rax)
  8004209969:	48 b8 d0 d0 20 04 80 	movabs $0x800420d0d0,%rax
  8004209970:	00 00 00 
  8004209973:	48 c1 e8 20          	shr    $0x20,%rax
  8004209977:	89 c2                	mov    %eax,%edx
  8004209979:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209980:	00 00 00 
  8004209983:	89 50 08             	mov    %edx,0x8(%rax)
  8004209986:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420998d:	00 00 00 
  8004209990:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%rax)
	SETGATE(idt[T_DEBUG],  0, GD_KT, &Xdebug,  0);
  8004209997:	48 b8 da d0 20 04 80 	movabs $0x800420d0da,%rax
  800420999e:	00 00 00 
  80042099a1:	89 c2                	mov    %eax,%edx
  80042099a3:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  80042099aa:	00 00 00 
  80042099ad:	66 89 50 10          	mov    %dx,0x10(%rax)
  80042099b1:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  80042099b8:	00 00 00 
  80042099bb:	66 c7 40 12 08 00    	movw   $0x8,0x12(%rax)
  80042099c1:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  80042099c8:	00 00 00 
  80042099cb:	0f b6 50 14          	movzbl 0x14(%rax),%edx
  80042099cf:	83 e2 f8             	and    $0xfffffff8,%edx
  80042099d2:	88 50 14             	mov    %dl,0x14(%rax)
  80042099d5:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  80042099dc:	00 00 00 
  80042099df:	0f b6 50 14          	movzbl 0x14(%rax),%edx
  80042099e3:	83 e2 07             	and    $0x7,%edx
  80042099e6:	88 50 14             	mov    %dl,0x14(%rax)
  80042099e9:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  80042099f0:	00 00 00 
  80042099f3:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  80042099f7:	83 e2 f0             	and    $0xfffffff0,%edx
  80042099fa:	83 ca 0e             	or     $0xe,%edx
  80042099fd:	88 50 15             	mov    %dl,0x15(%rax)
  8004209a00:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209a07:	00 00 00 
  8004209a0a:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  8004209a0e:	83 e2 ef             	and    $0xffffffef,%edx
  8004209a11:	88 50 15             	mov    %dl,0x15(%rax)
  8004209a14:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209a1b:	00 00 00 
  8004209a1e:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  8004209a22:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209a25:	88 50 15             	mov    %dl,0x15(%rax)
  8004209a28:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209a2f:	00 00 00 
  8004209a32:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  8004209a36:	83 ca 80             	or     $0xffffff80,%edx
  8004209a39:	88 50 15             	mov    %dl,0x15(%rax)
  8004209a3c:	48 b8 da d0 20 04 80 	movabs $0x800420d0da,%rax
  8004209a43:	00 00 00 
  8004209a46:	48 c1 e8 10          	shr    $0x10,%rax
  8004209a4a:	89 c2                	mov    %eax,%edx
  8004209a4c:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209a53:	00 00 00 
  8004209a56:	66 89 50 16          	mov    %dx,0x16(%rax)
  8004209a5a:	48 b8 da d0 20 04 80 	movabs $0x800420d0da,%rax
  8004209a61:	00 00 00 
  8004209a64:	48 c1 e8 20          	shr    $0x20,%rax
  8004209a68:	89 c2                	mov    %eax,%edx
  8004209a6a:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209a71:	00 00 00 
  8004209a74:	89 50 18             	mov    %edx,0x18(%rax)
  8004209a77:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209a7e:	00 00 00 
  8004209a81:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%rax)
	SETGATE(idt[T_NMI],    0, GD_KT, &Xnmi,    0);
  8004209a88:	48 b8 e4 d0 20 04 80 	movabs $0x800420d0e4,%rax
  8004209a8f:	00 00 00 
  8004209a92:	89 c2                	mov    %eax,%edx
  8004209a94:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209a9b:	00 00 00 
  8004209a9e:	66 89 50 20          	mov    %dx,0x20(%rax)
  8004209aa2:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209aa9:	00 00 00 
  8004209aac:	66 c7 40 22 08 00    	movw   $0x8,0x22(%rax)
  8004209ab2:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209ab9:	00 00 00 
  8004209abc:	0f b6 50 24          	movzbl 0x24(%rax),%edx
  8004209ac0:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209ac3:	88 50 24             	mov    %dl,0x24(%rax)
  8004209ac6:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209acd:	00 00 00 
  8004209ad0:	0f b6 50 24          	movzbl 0x24(%rax),%edx
  8004209ad4:	83 e2 07             	and    $0x7,%edx
  8004209ad7:	88 50 24             	mov    %dl,0x24(%rax)
  8004209ada:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209ae1:	00 00 00 
  8004209ae4:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  8004209ae8:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209aeb:	83 ca 0e             	or     $0xe,%edx
  8004209aee:	88 50 25             	mov    %dl,0x25(%rax)
  8004209af1:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209af8:	00 00 00 
  8004209afb:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  8004209aff:	83 e2 ef             	and    $0xffffffef,%edx
  8004209b02:	88 50 25             	mov    %dl,0x25(%rax)
  8004209b05:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209b0c:	00 00 00 
  8004209b0f:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  8004209b13:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209b16:	88 50 25             	mov    %dl,0x25(%rax)
  8004209b19:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209b20:	00 00 00 
  8004209b23:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  8004209b27:	83 ca 80             	or     $0xffffff80,%edx
  8004209b2a:	88 50 25             	mov    %dl,0x25(%rax)
  8004209b2d:	48 b8 e4 d0 20 04 80 	movabs $0x800420d0e4,%rax
  8004209b34:	00 00 00 
  8004209b37:	48 c1 e8 10          	shr    $0x10,%rax
  8004209b3b:	89 c2                	mov    %eax,%edx
  8004209b3d:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209b44:	00 00 00 
  8004209b47:	66 89 50 26          	mov    %dx,0x26(%rax)
  8004209b4b:	48 b8 e4 d0 20 04 80 	movabs $0x800420d0e4,%rax
  8004209b52:	00 00 00 
  8004209b55:	48 c1 e8 20          	shr    $0x20,%rax
  8004209b59:	89 c2                	mov    %eax,%edx
  8004209b5b:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209b62:	00 00 00 
  8004209b65:	89 50 28             	mov    %edx,0x28(%rax)
  8004209b68:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209b6f:	00 00 00 
  8004209b72:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%rax)
	SETGATE(idt[T_BRKPT],  0, GD_KT, &Xbrkpt,  3);
  8004209b79:	48 b8 ee d0 20 04 80 	movabs $0x800420d0ee,%rax
  8004209b80:	00 00 00 
  8004209b83:	89 c2                	mov    %eax,%edx
  8004209b85:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209b8c:	00 00 00 
  8004209b8f:	66 89 50 30          	mov    %dx,0x30(%rax)
  8004209b93:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209b9a:	00 00 00 
  8004209b9d:	66 c7 40 32 08 00    	movw   $0x8,0x32(%rax)
  8004209ba3:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209baa:	00 00 00 
  8004209bad:	0f b6 50 34          	movzbl 0x34(%rax),%edx
  8004209bb1:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209bb4:	88 50 34             	mov    %dl,0x34(%rax)
  8004209bb7:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209bbe:	00 00 00 
  8004209bc1:	0f b6 50 34          	movzbl 0x34(%rax),%edx
  8004209bc5:	83 e2 07             	and    $0x7,%edx
  8004209bc8:	88 50 34             	mov    %dl,0x34(%rax)
  8004209bcb:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209bd2:	00 00 00 
  8004209bd5:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  8004209bd9:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209bdc:	83 ca 0e             	or     $0xe,%edx
  8004209bdf:	88 50 35             	mov    %dl,0x35(%rax)
  8004209be2:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209be9:	00 00 00 
  8004209bec:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  8004209bf0:	83 e2 ef             	and    $0xffffffef,%edx
  8004209bf3:	88 50 35             	mov    %dl,0x35(%rax)
  8004209bf6:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209bfd:	00 00 00 
  8004209c00:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  8004209c04:	83 ca 60             	or     $0x60,%edx
  8004209c07:	88 50 35             	mov    %dl,0x35(%rax)
  8004209c0a:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209c11:	00 00 00 
  8004209c14:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  8004209c18:	83 ca 80             	or     $0xffffff80,%edx
  8004209c1b:	88 50 35             	mov    %dl,0x35(%rax)
  8004209c1e:	48 b8 ee d0 20 04 80 	movabs $0x800420d0ee,%rax
  8004209c25:	00 00 00 
  8004209c28:	48 c1 e8 10          	shr    $0x10,%rax
  8004209c2c:	89 c2                	mov    %eax,%edx
  8004209c2e:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209c35:	00 00 00 
  8004209c38:	66 89 50 36          	mov    %dx,0x36(%rax)
  8004209c3c:	48 b8 ee d0 20 04 80 	movabs $0x800420d0ee,%rax
  8004209c43:	00 00 00 
  8004209c46:	48 c1 e8 20          	shr    $0x20,%rax
  8004209c4a:	89 c2                	mov    %eax,%edx
  8004209c4c:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209c53:	00 00 00 
  8004209c56:	89 50 38             	mov    %edx,0x38(%rax)
  8004209c59:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209c60:	00 00 00 
  8004209c63:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%rax)
	SETGATE(idt[T_OFLOW],  0, GD_KT, &Xoflow,  0);
  8004209c6a:	48 b8 f8 d0 20 04 80 	movabs $0x800420d0f8,%rax
  8004209c71:	00 00 00 
  8004209c74:	89 c2                	mov    %eax,%edx
  8004209c76:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209c7d:	00 00 00 
  8004209c80:	66 89 50 40          	mov    %dx,0x40(%rax)
  8004209c84:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209c8b:	00 00 00 
  8004209c8e:	66 c7 40 42 08 00    	movw   $0x8,0x42(%rax)
  8004209c94:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209c9b:	00 00 00 
  8004209c9e:	0f b6 50 44          	movzbl 0x44(%rax),%edx
  8004209ca2:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209ca5:	88 50 44             	mov    %dl,0x44(%rax)
  8004209ca8:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209caf:	00 00 00 
  8004209cb2:	0f b6 50 44          	movzbl 0x44(%rax),%edx
  8004209cb6:	83 e2 07             	and    $0x7,%edx
  8004209cb9:	88 50 44             	mov    %dl,0x44(%rax)
  8004209cbc:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209cc3:	00 00 00 
  8004209cc6:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  8004209cca:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209ccd:	83 ca 0e             	or     $0xe,%edx
  8004209cd0:	88 50 45             	mov    %dl,0x45(%rax)
  8004209cd3:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209cda:	00 00 00 
  8004209cdd:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  8004209ce1:	83 e2 ef             	and    $0xffffffef,%edx
  8004209ce4:	88 50 45             	mov    %dl,0x45(%rax)
  8004209ce7:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209cee:	00 00 00 
  8004209cf1:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  8004209cf5:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209cf8:	88 50 45             	mov    %dl,0x45(%rax)
  8004209cfb:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209d02:	00 00 00 
  8004209d05:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  8004209d09:	83 ca 80             	or     $0xffffff80,%edx
  8004209d0c:	88 50 45             	mov    %dl,0x45(%rax)
  8004209d0f:	48 b8 f8 d0 20 04 80 	movabs $0x800420d0f8,%rax
  8004209d16:	00 00 00 
  8004209d19:	48 c1 e8 10          	shr    $0x10,%rax
  8004209d1d:	89 c2                	mov    %eax,%edx
  8004209d1f:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209d26:	00 00 00 
  8004209d29:	66 89 50 46          	mov    %dx,0x46(%rax)
  8004209d2d:	48 b8 f8 d0 20 04 80 	movabs $0x800420d0f8,%rax
  8004209d34:	00 00 00 
  8004209d37:	48 c1 e8 20          	shr    $0x20,%rax
  8004209d3b:	89 c2                	mov    %eax,%edx
  8004209d3d:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209d44:	00 00 00 
  8004209d47:	89 50 48             	mov    %edx,0x48(%rax)
  8004209d4a:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209d51:	00 00 00 
  8004209d54:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%rax)
	SETGATE(idt[T_BOUND],  0, GD_KT, &Xbound,  0);
  8004209d5b:	48 b8 02 d1 20 04 80 	movabs $0x800420d102,%rax
  8004209d62:	00 00 00 
  8004209d65:	89 c2                	mov    %eax,%edx
  8004209d67:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209d6e:	00 00 00 
  8004209d71:	66 89 50 50          	mov    %dx,0x50(%rax)
  8004209d75:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209d7c:	00 00 00 
  8004209d7f:	66 c7 40 52 08 00    	movw   $0x8,0x52(%rax)
  8004209d85:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209d8c:	00 00 00 
  8004209d8f:	0f b6 50 54          	movzbl 0x54(%rax),%edx
  8004209d93:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209d96:	88 50 54             	mov    %dl,0x54(%rax)
  8004209d99:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209da0:	00 00 00 
  8004209da3:	0f b6 50 54          	movzbl 0x54(%rax),%edx
  8004209da7:	83 e2 07             	and    $0x7,%edx
  8004209daa:	88 50 54             	mov    %dl,0x54(%rax)
  8004209dad:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209db4:	00 00 00 
  8004209db7:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  8004209dbb:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209dbe:	83 ca 0e             	or     $0xe,%edx
  8004209dc1:	88 50 55             	mov    %dl,0x55(%rax)
  8004209dc4:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209dcb:	00 00 00 
  8004209dce:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  8004209dd2:	83 e2 ef             	and    $0xffffffef,%edx
  8004209dd5:	88 50 55             	mov    %dl,0x55(%rax)
  8004209dd8:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209ddf:	00 00 00 
  8004209de2:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  8004209de6:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209de9:	88 50 55             	mov    %dl,0x55(%rax)
  8004209dec:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209df3:	00 00 00 
  8004209df6:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  8004209dfa:	83 ca 80             	or     $0xffffff80,%edx
  8004209dfd:	88 50 55             	mov    %dl,0x55(%rax)
  8004209e00:	48 b8 02 d1 20 04 80 	movabs $0x800420d102,%rax
  8004209e07:	00 00 00 
  8004209e0a:	48 c1 e8 10          	shr    $0x10,%rax
  8004209e0e:	89 c2                	mov    %eax,%edx
  8004209e10:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209e17:	00 00 00 
  8004209e1a:	66 89 50 56          	mov    %dx,0x56(%rax)
  8004209e1e:	48 b8 02 d1 20 04 80 	movabs $0x800420d102,%rax
  8004209e25:	00 00 00 
  8004209e28:	48 c1 e8 20          	shr    $0x20,%rax
  8004209e2c:	89 c2                	mov    %eax,%edx
  8004209e2e:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209e35:	00 00 00 
  8004209e38:	89 50 58             	mov    %edx,0x58(%rax)
  8004209e3b:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209e42:	00 00 00 
  8004209e45:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%rax)
	SETGATE(idt[T_ILLOP],  0, GD_KT, &Xillop,  0);
  8004209e4c:	48 b8 0c d1 20 04 80 	movabs $0x800420d10c,%rax
  8004209e53:	00 00 00 
  8004209e56:	89 c2                	mov    %eax,%edx
  8004209e58:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209e5f:	00 00 00 
  8004209e62:	66 89 50 60          	mov    %dx,0x60(%rax)
  8004209e66:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209e6d:	00 00 00 
  8004209e70:	66 c7 40 62 08 00    	movw   $0x8,0x62(%rax)
  8004209e76:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209e7d:	00 00 00 
  8004209e80:	0f b6 50 64          	movzbl 0x64(%rax),%edx
  8004209e84:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209e87:	88 50 64             	mov    %dl,0x64(%rax)
  8004209e8a:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209e91:	00 00 00 
  8004209e94:	0f b6 50 64          	movzbl 0x64(%rax),%edx
  8004209e98:	83 e2 07             	and    $0x7,%edx
  8004209e9b:	88 50 64             	mov    %dl,0x64(%rax)
  8004209e9e:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209ea5:	00 00 00 
  8004209ea8:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  8004209eac:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209eaf:	83 ca 0e             	or     $0xe,%edx
  8004209eb2:	88 50 65             	mov    %dl,0x65(%rax)
  8004209eb5:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209ebc:	00 00 00 
  8004209ebf:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  8004209ec3:	83 e2 ef             	and    $0xffffffef,%edx
  8004209ec6:	88 50 65             	mov    %dl,0x65(%rax)
  8004209ec9:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209ed0:	00 00 00 
  8004209ed3:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  8004209ed7:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209eda:	88 50 65             	mov    %dl,0x65(%rax)
  8004209edd:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209ee4:	00 00 00 
  8004209ee7:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  8004209eeb:	83 ca 80             	or     $0xffffff80,%edx
  8004209eee:	88 50 65             	mov    %dl,0x65(%rax)
  8004209ef1:	48 b8 0c d1 20 04 80 	movabs $0x800420d10c,%rax
  8004209ef8:	00 00 00 
  8004209efb:	48 c1 e8 10          	shr    $0x10,%rax
  8004209eff:	89 c2                	mov    %eax,%edx
  8004209f01:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209f08:	00 00 00 
  8004209f0b:	66 89 50 66          	mov    %dx,0x66(%rax)
  8004209f0f:	48 b8 0c d1 20 04 80 	movabs $0x800420d10c,%rax
  8004209f16:	00 00 00 
  8004209f19:	48 c1 e8 20          	shr    $0x20,%rax
  8004209f1d:	89 c2                	mov    %eax,%edx
  8004209f1f:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209f26:	00 00 00 
  8004209f29:	89 50 68             	mov    %edx,0x68(%rax)
  8004209f2c:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209f33:	00 00 00 
  8004209f36:	c7 40 6c 00 00 00 00 	movl   $0x0,0x6c(%rax)
	SETGATE(idt[T_DEVICE], 0, GD_KT, &Xdevice, 0);
  8004209f3d:	48 b8 16 d1 20 04 80 	movabs $0x800420d116,%rax
  8004209f44:	00 00 00 
  8004209f47:	89 c2                	mov    %eax,%edx
  8004209f49:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209f50:	00 00 00 
  8004209f53:	66 89 50 70          	mov    %dx,0x70(%rax)
  8004209f57:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209f5e:	00 00 00 
  8004209f61:	66 c7 40 72 08 00    	movw   $0x8,0x72(%rax)
  8004209f67:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209f6e:	00 00 00 
  8004209f71:	0f b6 50 74          	movzbl 0x74(%rax),%edx
  8004209f75:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209f78:	88 50 74             	mov    %dl,0x74(%rax)
  8004209f7b:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209f82:	00 00 00 
  8004209f85:	0f b6 50 74          	movzbl 0x74(%rax),%edx
  8004209f89:	83 e2 07             	and    $0x7,%edx
  8004209f8c:	88 50 74             	mov    %dl,0x74(%rax)
  8004209f8f:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209f96:	00 00 00 
  8004209f99:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  8004209f9d:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209fa0:	83 ca 0e             	or     $0xe,%edx
  8004209fa3:	88 50 75             	mov    %dl,0x75(%rax)
  8004209fa6:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209fad:	00 00 00 
  8004209fb0:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  8004209fb4:	83 e2 ef             	and    $0xffffffef,%edx
  8004209fb7:	88 50 75             	mov    %dl,0x75(%rax)
  8004209fba:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209fc1:	00 00 00 
  8004209fc4:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  8004209fc8:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209fcb:	88 50 75             	mov    %dl,0x75(%rax)
  8004209fce:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209fd5:	00 00 00 
  8004209fd8:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  8004209fdc:	83 ca 80             	or     $0xffffff80,%edx
  8004209fdf:	88 50 75             	mov    %dl,0x75(%rax)
  8004209fe2:	48 b8 16 d1 20 04 80 	movabs $0x800420d116,%rax
  8004209fe9:	00 00 00 
  8004209fec:	48 c1 e8 10          	shr    $0x10,%rax
  8004209ff0:	89 c2                	mov    %eax,%edx
  8004209ff2:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209ff9:	00 00 00 
  8004209ffc:	66 89 50 76          	mov    %dx,0x76(%rax)
  800420a000:	48 b8 16 d1 20 04 80 	movabs $0x800420d116,%rax
  800420a007:	00 00 00 
  800420a00a:	48 c1 e8 20          	shr    $0x20,%rax
  800420a00e:	89 c2                	mov    %eax,%edx
  800420a010:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a017:	00 00 00 
  800420a01a:	89 50 78             	mov    %edx,0x78(%rax)
  800420a01d:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a024:	00 00 00 
  800420a027:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%rax)
	SETGATE(idt[T_DBLFLT], 0, GD_KT, &Xdblflt, 0);
  800420a02e:	48 b8 20 d1 20 04 80 	movabs $0x800420d120,%rax
  800420a035:	00 00 00 
  800420a038:	89 c2                	mov    %eax,%edx
  800420a03a:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a041:	00 00 00 
  800420a044:	66 89 90 80 00 00 00 	mov    %dx,0x80(%rax)
  800420a04b:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a052:	00 00 00 
  800420a055:	66 c7 80 82 00 00 00 	movw   $0x8,0x82(%rax)
  800420a05c:	08 00 
  800420a05e:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a065:	00 00 00 
  800420a068:	0f b6 90 84 00 00 00 	movzbl 0x84(%rax),%edx
  800420a06f:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a072:	88 90 84 00 00 00    	mov    %dl,0x84(%rax)
  800420a078:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a07f:	00 00 00 
  800420a082:	0f b6 90 84 00 00 00 	movzbl 0x84(%rax),%edx
  800420a089:	83 e2 07             	and    $0x7,%edx
  800420a08c:	88 90 84 00 00 00    	mov    %dl,0x84(%rax)
  800420a092:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a099:	00 00 00 
  800420a09c:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  800420a0a3:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a0a6:	83 ca 0e             	or     $0xe,%edx
  800420a0a9:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  800420a0af:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a0b6:	00 00 00 
  800420a0b9:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  800420a0c0:	83 e2 ef             	and    $0xffffffef,%edx
  800420a0c3:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  800420a0c9:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a0d0:	00 00 00 
  800420a0d3:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  800420a0da:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a0dd:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  800420a0e3:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a0ea:	00 00 00 
  800420a0ed:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  800420a0f4:	83 ca 80             	or     $0xffffff80,%edx
  800420a0f7:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  800420a0fd:	48 b8 20 d1 20 04 80 	movabs $0x800420d120,%rax
  800420a104:	00 00 00 
  800420a107:	48 c1 e8 10          	shr    $0x10,%rax
  800420a10b:	89 c2                	mov    %eax,%edx
  800420a10d:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a114:	00 00 00 
  800420a117:	66 89 90 86 00 00 00 	mov    %dx,0x86(%rax)
  800420a11e:	48 b8 20 d1 20 04 80 	movabs $0x800420d120,%rax
  800420a125:	00 00 00 
  800420a128:	48 c1 e8 20          	shr    $0x20,%rax
  800420a12c:	89 c2                	mov    %eax,%edx
  800420a12e:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a135:	00 00 00 
  800420a138:	89 90 88 00 00 00    	mov    %edx,0x88(%rax)
  800420a13e:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a145:	00 00 00 
  800420a148:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%rax)
  800420a14f:	00 00 00 
	SETGATE(idt[T_TSS],    0, GD_KT, &Xtss,    0);
  800420a152:	48 b8 28 d1 20 04 80 	movabs $0x800420d128,%rax
  800420a159:	00 00 00 
  800420a15c:	89 c2                	mov    %eax,%edx
  800420a15e:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a165:	00 00 00 
  800420a168:	66 89 90 a0 00 00 00 	mov    %dx,0xa0(%rax)
  800420a16f:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a176:	00 00 00 
  800420a179:	66 c7 80 a2 00 00 00 	movw   $0x8,0xa2(%rax)
  800420a180:	08 00 
  800420a182:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a189:	00 00 00 
  800420a18c:	0f b6 90 a4 00 00 00 	movzbl 0xa4(%rax),%edx
  800420a193:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a196:	88 90 a4 00 00 00    	mov    %dl,0xa4(%rax)
  800420a19c:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a1a3:	00 00 00 
  800420a1a6:	0f b6 90 a4 00 00 00 	movzbl 0xa4(%rax),%edx
  800420a1ad:	83 e2 07             	and    $0x7,%edx
  800420a1b0:	88 90 a4 00 00 00    	mov    %dl,0xa4(%rax)
  800420a1b6:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a1bd:	00 00 00 
  800420a1c0:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  800420a1c7:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a1ca:	83 ca 0e             	or     $0xe,%edx
  800420a1cd:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  800420a1d3:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a1da:	00 00 00 
  800420a1dd:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  800420a1e4:	83 e2 ef             	and    $0xffffffef,%edx
  800420a1e7:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  800420a1ed:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a1f4:	00 00 00 
  800420a1f7:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  800420a1fe:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a201:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  800420a207:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a20e:	00 00 00 
  800420a211:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  800420a218:	83 ca 80             	or     $0xffffff80,%edx
  800420a21b:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  800420a221:	48 b8 28 d1 20 04 80 	movabs $0x800420d128,%rax
  800420a228:	00 00 00 
  800420a22b:	48 c1 e8 10          	shr    $0x10,%rax
  800420a22f:	89 c2                	mov    %eax,%edx
  800420a231:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a238:	00 00 00 
  800420a23b:	66 89 90 a6 00 00 00 	mov    %dx,0xa6(%rax)
  800420a242:	48 b8 28 d1 20 04 80 	movabs $0x800420d128,%rax
  800420a249:	00 00 00 
  800420a24c:	48 c1 e8 20          	shr    $0x20,%rax
  800420a250:	89 c2                	mov    %eax,%edx
  800420a252:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a259:	00 00 00 
  800420a25c:	89 90 a8 00 00 00    	mov    %edx,0xa8(%rax)
  800420a262:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a269:	00 00 00 
  800420a26c:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%rax)
  800420a273:	00 00 00 
	SETGATE(idt[T_SEGNP],  0, GD_KT, &Xsegnp,  0);
  800420a276:	48 b8 30 d1 20 04 80 	movabs $0x800420d130,%rax
  800420a27d:	00 00 00 
  800420a280:	89 c2                	mov    %eax,%edx
  800420a282:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a289:	00 00 00 
  800420a28c:	66 89 90 b0 00 00 00 	mov    %dx,0xb0(%rax)
  800420a293:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a29a:	00 00 00 
  800420a29d:	66 c7 80 b2 00 00 00 	movw   $0x8,0xb2(%rax)
  800420a2a4:	08 00 
  800420a2a6:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a2ad:	00 00 00 
  800420a2b0:	0f b6 90 b4 00 00 00 	movzbl 0xb4(%rax),%edx
  800420a2b7:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a2ba:	88 90 b4 00 00 00    	mov    %dl,0xb4(%rax)
  800420a2c0:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a2c7:	00 00 00 
  800420a2ca:	0f b6 90 b4 00 00 00 	movzbl 0xb4(%rax),%edx
  800420a2d1:	83 e2 07             	and    $0x7,%edx
  800420a2d4:	88 90 b4 00 00 00    	mov    %dl,0xb4(%rax)
  800420a2da:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a2e1:	00 00 00 
  800420a2e4:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  800420a2eb:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a2ee:	83 ca 0e             	or     $0xe,%edx
  800420a2f1:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  800420a2f7:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a2fe:	00 00 00 
  800420a301:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  800420a308:	83 e2 ef             	and    $0xffffffef,%edx
  800420a30b:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  800420a311:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a318:	00 00 00 
  800420a31b:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  800420a322:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a325:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  800420a32b:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a332:	00 00 00 
  800420a335:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  800420a33c:	83 ca 80             	or     $0xffffff80,%edx
  800420a33f:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  800420a345:	48 b8 30 d1 20 04 80 	movabs $0x800420d130,%rax
  800420a34c:	00 00 00 
  800420a34f:	48 c1 e8 10          	shr    $0x10,%rax
  800420a353:	89 c2                	mov    %eax,%edx
  800420a355:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a35c:	00 00 00 
  800420a35f:	66 89 90 b6 00 00 00 	mov    %dx,0xb6(%rax)
  800420a366:	48 b8 30 d1 20 04 80 	movabs $0x800420d130,%rax
  800420a36d:	00 00 00 
  800420a370:	48 c1 e8 20          	shr    $0x20,%rax
  800420a374:	89 c2                	mov    %eax,%edx
  800420a376:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a37d:	00 00 00 
  800420a380:	89 90 b8 00 00 00    	mov    %edx,0xb8(%rax)
  800420a386:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a38d:	00 00 00 
  800420a390:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%rax)
  800420a397:	00 00 00 
	SETGATE(idt[T_STACK],  0, GD_KT, &Xstack,  0);
  800420a39a:	48 b8 38 d1 20 04 80 	movabs $0x800420d138,%rax
  800420a3a1:	00 00 00 
  800420a3a4:	89 c2                	mov    %eax,%edx
  800420a3a6:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a3ad:	00 00 00 
  800420a3b0:	66 89 90 c0 00 00 00 	mov    %dx,0xc0(%rax)
  800420a3b7:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a3be:	00 00 00 
  800420a3c1:	66 c7 80 c2 00 00 00 	movw   $0x8,0xc2(%rax)
  800420a3c8:	08 00 
  800420a3ca:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a3d1:	00 00 00 
  800420a3d4:	0f b6 90 c4 00 00 00 	movzbl 0xc4(%rax),%edx
  800420a3db:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a3de:	88 90 c4 00 00 00    	mov    %dl,0xc4(%rax)
  800420a3e4:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a3eb:	00 00 00 
  800420a3ee:	0f b6 90 c4 00 00 00 	movzbl 0xc4(%rax),%edx
  800420a3f5:	83 e2 07             	and    $0x7,%edx
  800420a3f8:	88 90 c4 00 00 00    	mov    %dl,0xc4(%rax)
  800420a3fe:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a405:	00 00 00 
  800420a408:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  800420a40f:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a412:	83 ca 0e             	or     $0xe,%edx
  800420a415:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  800420a41b:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a422:	00 00 00 
  800420a425:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  800420a42c:	83 e2 ef             	and    $0xffffffef,%edx
  800420a42f:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  800420a435:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a43c:	00 00 00 
  800420a43f:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  800420a446:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a449:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  800420a44f:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a456:	00 00 00 
  800420a459:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  800420a460:	83 ca 80             	or     $0xffffff80,%edx
  800420a463:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  800420a469:	48 b8 38 d1 20 04 80 	movabs $0x800420d138,%rax
  800420a470:	00 00 00 
  800420a473:	48 c1 e8 10          	shr    $0x10,%rax
  800420a477:	89 c2                	mov    %eax,%edx
  800420a479:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a480:	00 00 00 
  800420a483:	66 89 90 c6 00 00 00 	mov    %dx,0xc6(%rax)
  800420a48a:	48 b8 38 d1 20 04 80 	movabs $0x800420d138,%rax
  800420a491:	00 00 00 
  800420a494:	48 c1 e8 20          	shr    $0x20,%rax
  800420a498:	89 c2                	mov    %eax,%edx
  800420a49a:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a4a1:	00 00 00 
  800420a4a4:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)
  800420a4aa:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a4b1:	00 00 00 
  800420a4b4:	c7 80 cc 00 00 00 00 	movl   $0x0,0xcc(%rax)
  800420a4bb:	00 00 00 
	SETGATE(idt[T_GPFLT],  0, GD_KT, &Xgpflt,  0);
  800420a4be:	48 b8 40 d1 20 04 80 	movabs $0x800420d140,%rax
  800420a4c5:	00 00 00 
  800420a4c8:	89 c2                	mov    %eax,%edx
  800420a4ca:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a4d1:	00 00 00 
  800420a4d4:	66 89 90 d0 00 00 00 	mov    %dx,0xd0(%rax)
  800420a4db:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a4e2:	00 00 00 
  800420a4e5:	66 c7 80 d2 00 00 00 	movw   $0x8,0xd2(%rax)
  800420a4ec:	08 00 
  800420a4ee:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a4f5:	00 00 00 
  800420a4f8:	0f b6 90 d4 00 00 00 	movzbl 0xd4(%rax),%edx
  800420a4ff:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a502:	88 90 d4 00 00 00    	mov    %dl,0xd4(%rax)
  800420a508:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a50f:	00 00 00 
  800420a512:	0f b6 90 d4 00 00 00 	movzbl 0xd4(%rax),%edx
  800420a519:	83 e2 07             	and    $0x7,%edx
  800420a51c:	88 90 d4 00 00 00    	mov    %dl,0xd4(%rax)
  800420a522:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a529:	00 00 00 
  800420a52c:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  800420a533:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a536:	83 ca 0e             	or     $0xe,%edx
  800420a539:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  800420a53f:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a546:	00 00 00 
  800420a549:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  800420a550:	83 e2 ef             	and    $0xffffffef,%edx
  800420a553:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  800420a559:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a560:	00 00 00 
  800420a563:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  800420a56a:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a56d:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  800420a573:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a57a:	00 00 00 
  800420a57d:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  800420a584:	83 ca 80             	or     $0xffffff80,%edx
  800420a587:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  800420a58d:	48 b8 40 d1 20 04 80 	movabs $0x800420d140,%rax
  800420a594:	00 00 00 
  800420a597:	48 c1 e8 10          	shr    $0x10,%rax
  800420a59b:	89 c2                	mov    %eax,%edx
  800420a59d:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a5a4:	00 00 00 
  800420a5a7:	66 89 90 d6 00 00 00 	mov    %dx,0xd6(%rax)
  800420a5ae:	48 b8 40 d1 20 04 80 	movabs $0x800420d140,%rax
  800420a5b5:	00 00 00 
  800420a5b8:	48 c1 e8 20          	shr    $0x20,%rax
  800420a5bc:	89 c2                	mov    %eax,%edx
  800420a5be:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a5c5:	00 00 00 
  800420a5c8:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)
  800420a5ce:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a5d5:	00 00 00 
  800420a5d8:	c7 80 dc 00 00 00 00 	movl   $0x0,0xdc(%rax)
  800420a5df:	00 00 00 
	SETGATE(idt[T_PGFLT],  0, GD_KT, &Xpgflt,  0);
  800420a5e2:	48 b8 48 d1 20 04 80 	movabs $0x800420d148,%rax
  800420a5e9:	00 00 00 
  800420a5ec:	89 c2                	mov    %eax,%edx
  800420a5ee:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a5f5:	00 00 00 
  800420a5f8:	66 89 90 e0 00 00 00 	mov    %dx,0xe0(%rax)
  800420a5ff:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a606:	00 00 00 
  800420a609:	66 c7 80 e2 00 00 00 	movw   $0x8,0xe2(%rax)
  800420a610:	08 00 
  800420a612:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a619:	00 00 00 
  800420a61c:	0f b6 90 e4 00 00 00 	movzbl 0xe4(%rax),%edx
  800420a623:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a626:	88 90 e4 00 00 00    	mov    %dl,0xe4(%rax)
  800420a62c:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a633:	00 00 00 
  800420a636:	0f b6 90 e4 00 00 00 	movzbl 0xe4(%rax),%edx
  800420a63d:	83 e2 07             	and    $0x7,%edx
  800420a640:	88 90 e4 00 00 00    	mov    %dl,0xe4(%rax)
  800420a646:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a64d:	00 00 00 
  800420a650:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  800420a657:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a65a:	83 ca 0e             	or     $0xe,%edx
  800420a65d:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  800420a663:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a66a:	00 00 00 
  800420a66d:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  800420a674:	83 e2 ef             	and    $0xffffffef,%edx
  800420a677:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  800420a67d:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a684:	00 00 00 
  800420a687:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  800420a68e:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a691:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  800420a697:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a69e:	00 00 00 
  800420a6a1:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  800420a6a8:	83 ca 80             	or     $0xffffff80,%edx
  800420a6ab:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  800420a6b1:	48 b8 48 d1 20 04 80 	movabs $0x800420d148,%rax
  800420a6b8:	00 00 00 
  800420a6bb:	48 c1 e8 10          	shr    $0x10,%rax
  800420a6bf:	89 c2                	mov    %eax,%edx
  800420a6c1:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a6c8:	00 00 00 
  800420a6cb:	66 89 90 e6 00 00 00 	mov    %dx,0xe6(%rax)
  800420a6d2:	48 b8 48 d1 20 04 80 	movabs $0x800420d148,%rax
  800420a6d9:	00 00 00 
  800420a6dc:	48 c1 e8 20          	shr    $0x20,%rax
  800420a6e0:	89 c2                	mov    %eax,%edx
  800420a6e2:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a6e9:	00 00 00 
  800420a6ec:	89 90 e8 00 00 00    	mov    %edx,0xe8(%rax)
  800420a6f2:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a6f9:	00 00 00 
  800420a6fc:	c7 80 ec 00 00 00 00 	movl   $0x0,0xec(%rax)
  800420a703:	00 00 00 
	SETGATE(idt[T_FPERR],  0, GD_KT, &Xfperr,  0);
  800420a706:	48 b8 50 d1 20 04 80 	movabs $0x800420d150,%rax
  800420a70d:	00 00 00 
  800420a710:	89 c2                	mov    %eax,%edx
  800420a712:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a719:	00 00 00 
  800420a71c:	66 89 90 00 01 00 00 	mov    %dx,0x100(%rax)
  800420a723:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a72a:	00 00 00 
  800420a72d:	66 c7 80 02 01 00 00 	movw   $0x8,0x102(%rax)
  800420a734:	08 00 
  800420a736:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a73d:	00 00 00 
  800420a740:	0f b6 90 04 01 00 00 	movzbl 0x104(%rax),%edx
  800420a747:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a74a:	88 90 04 01 00 00    	mov    %dl,0x104(%rax)
  800420a750:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a757:	00 00 00 
  800420a75a:	0f b6 90 04 01 00 00 	movzbl 0x104(%rax),%edx
  800420a761:	83 e2 07             	and    $0x7,%edx
  800420a764:	88 90 04 01 00 00    	mov    %dl,0x104(%rax)
  800420a76a:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a771:	00 00 00 
  800420a774:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  800420a77b:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a77e:	83 ca 0e             	or     $0xe,%edx
  800420a781:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  800420a787:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a78e:	00 00 00 
  800420a791:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  800420a798:	83 e2 ef             	and    $0xffffffef,%edx
  800420a79b:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  800420a7a1:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a7a8:	00 00 00 
  800420a7ab:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  800420a7b2:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a7b5:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  800420a7bb:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a7c2:	00 00 00 
  800420a7c5:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  800420a7cc:	83 ca 80             	or     $0xffffff80,%edx
  800420a7cf:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  800420a7d5:	48 b8 50 d1 20 04 80 	movabs $0x800420d150,%rax
  800420a7dc:	00 00 00 
  800420a7df:	48 c1 e8 10          	shr    $0x10,%rax
  800420a7e3:	89 c2                	mov    %eax,%edx
  800420a7e5:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a7ec:	00 00 00 
  800420a7ef:	66 89 90 06 01 00 00 	mov    %dx,0x106(%rax)
  800420a7f6:	48 b8 50 d1 20 04 80 	movabs $0x800420d150,%rax
  800420a7fd:	00 00 00 
  800420a800:	48 c1 e8 20          	shr    $0x20,%rax
  800420a804:	89 c2                	mov    %eax,%edx
  800420a806:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a80d:	00 00 00 
  800420a810:	89 90 08 01 00 00    	mov    %edx,0x108(%rax)
  800420a816:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a81d:	00 00 00 
  800420a820:	c7 80 0c 01 00 00 00 	movl   $0x0,0x10c(%rax)
  800420a827:	00 00 00 
	SETGATE(idt[T_ALIGN],  0, GD_KT, &Xalign,  0);
  800420a82a:	48 b8 5a d1 20 04 80 	movabs $0x800420d15a,%rax
  800420a831:	00 00 00 
  800420a834:	89 c2                	mov    %eax,%edx
  800420a836:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a83d:	00 00 00 
  800420a840:	66 89 90 10 01 00 00 	mov    %dx,0x110(%rax)
  800420a847:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a84e:	00 00 00 
  800420a851:	66 c7 80 12 01 00 00 	movw   $0x8,0x112(%rax)
  800420a858:	08 00 
  800420a85a:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a861:	00 00 00 
  800420a864:	0f b6 90 14 01 00 00 	movzbl 0x114(%rax),%edx
  800420a86b:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a86e:	88 90 14 01 00 00    	mov    %dl,0x114(%rax)
  800420a874:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a87b:	00 00 00 
  800420a87e:	0f b6 90 14 01 00 00 	movzbl 0x114(%rax),%edx
  800420a885:	83 e2 07             	and    $0x7,%edx
  800420a888:	88 90 14 01 00 00    	mov    %dl,0x114(%rax)
  800420a88e:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a895:	00 00 00 
  800420a898:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  800420a89f:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a8a2:	83 ca 0e             	or     $0xe,%edx
  800420a8a5:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  800420a8ab:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a8b2:	00 00 00 
  800420a8b5:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  800420a8bc:	83 e2 ef             	and    $0xffffffef,%edx
  800420a8bf:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  800420a8c5:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a8cc:	00 00 00 
  800420a8cf:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  800420a8d6:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a8d9:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  800420a8df:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a8e6:	00 00 00 
  800420a8e9:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  800420a8f0:	83 ca 80             	or     $0xffffff80,%edx
  800420a8f3:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  800420a8f9:	48 b8 5a d1 20 04 80 	movabs $0x800420d15a,%rax
  800420a900:	00 00 00 
  800420a903:	48 c1 e8 10          	shr    $0x10,%rax
  800420a907:	89 c2                	mov    %eax,%edx
  800420a909:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a910:	00 00 00 
  800420a913:	66 89 90 16 01 00 00 	mov    %dx,0x116(%rax)
  800420a91a:	48 b8 5a d1 20 04 80 	movabs $0x800420d15a,%rax
  800420a921:	00 00 00 
  800420a924:	48 c1 e8 20          	shr    $0x20,%rax
  800420a928:	89 c2                	mov    %eax,%edx
  800420a92a:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a931:	00 00 00 
  800420a934:	89 90 18 01 00 00    	mov    %edx,0x118(%rax)
  800420a93a:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a941:	00 00 00 
  800420a944:	c7 80 1c 01 00 00 00 	movl   $0x0,0x11c(%rax)
  800420a94b:	00 00 00 
	SETGATE(idt[T_MCHK],   0, GD_KT, &Xmchk,   0);
  800420a94e:	48 b8 62 d1 20 04 80 	movabs $0x800420d162,%rax
  800420a955:	00 00 00 
  800420a958:	89 c2                	mov    %eax,%edx
  800420a95a:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a961:	00 00 00 
  800420a964:	66 89 90 20 01 00 00 	mov    %dx,0x120(%rax)
  800420a96b:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a972:	00 00 00 
  800420a975:	66 c7 80 22 01 00 00 	movw   $0x8,0x122(%rax)
  800420a97c:	08 00 
  800420a97e:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a985:	00 00 00 
  800420a988:	0f b6 90 24 01 00 00 	movzbl 0x124(%rax),%edx
  800420a98f:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a992:	88 90 24 01 00 00    	mov    %dl,0x124(%rax)
  800420a998:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a99f:	00 00 00 
  800420a9a2:	0f b6 90 24 01 00 00 	movzbl 0x124(%rax),%edx
  800420a9a9:	83 e2 07             	and    $0x7,%edx
  800420a9ac:	88 90 24 01 00 00    	mov    %dl,0x124(%rax)
  800420a9b2:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a9b9:	00 00 00 
  800420a9bc:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420a9c3:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a9c6:	83 ca 0e             	or     $0xe,%edx
  800420a9c9:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420a9cf:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a9d6:	00 00 00 
  800420a9d9:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420a9e0:	83 e2 ef             	and    $0xffffffef,%edx
  800420a9e3:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420a9e9:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420a9f0:	00 00 00 
  800420a9f3:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420a9fa:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a9fd:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420aa03:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420aa0a:	00 00 00 
  800420aa0d:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420aa14:	83 ca 80             	or     $0xffffff80,%edx
  800420aa17:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420aa1d:	48 b8 62 d1 20 04 80 	movabs $0x800420d162,%rax
  800420aa24:	00 00 00 
  800420aa27:	48 c1 e8 10          	shr    $0x10,%rax
  800420aa2b:	89 c2                	mov    %eax,%edx
  800420aa2d:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420aa34:	00 00 00 
  800420aa37:	66 89 90 26 01 00 00 	mov    %dx,0x126(%rax)
  800420aa3e:	48 b8 62 d1 20 04 80 	movabs $0x800420d162,%rax
  800420aa45:	00 00 00 
  800420aa48:	48 c1 e8 20          	shr    $0x20,%rax
  800420aa4c:	89 c2                	mov    %eax,%edx
  800420aa4e:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420aa55:	00 00 00 
  800420aa58:	89 90 28 01 00 00    	mov    %edx,0x128(%rax)
  800420aa5e:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420aa65:	00 00 00 
  800420aa68:	c7 80 2c 01 00 00 00 	movl   $0x0,0x12c(%rax)
  800420aa6f:	00 00 00 


	SETGATE(idt[IRQ_OFFSET + 0], 0, GD_KT, &Xirq0, 0);
  800420aa72:	48 b8 6c d1 20 04 80 	movabs $0x800420d16c,%rax
  800420aa79:	00 00 00 
  800420aa7c:	89 c2                	mov    %eax,%edx
  800420aa7e:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420aa85:	00 00 00 
  800420aa88:	66 89 90 00 02 00 00 	mov    %dx,0x200(%rax)
  800420aa8f:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420aa96:	00 00 00 
  800420aa99:	66 c7 80 02 02 00 00 	movw   $0x8,0x202(%rax)
  800420aaa0:	08 00 
  800420aaa2:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420aaa9:	00 00 00 
  800420aaac:	0f b6 90 04 02 00 00 	movzbl 0x204(%rax),%edx
  800420aab3:	83 e2 f8             	and    $0xfffffff8,%edx
  800420aab6:	88 90 04 02 00 00    	mov    %dl,0x204(%rax)
  800420aabc:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420aac3:	00 00 00 
  800420aac6:	0f b6 90 04 02 00 00 	movzbl 0x204(%rax),%edx
  800420aacd:	83 e2 07             	and    $0x7,%edx
  800420aad0:	88 90 04 02 00 00    	mov    %dl,0x204(%rax)
  800420aad6:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420aadd:	00 00 00 
  800420aae0:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420aae7:	83 e2 f0             	and    $0xfffffff0,%edx
  800420aaea:	83 ca 0e             	or     $0xe,%edx
  800420aaed:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420aaf3:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420aafa:	00 00 00 
  800420aafd:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420ab04:	83 e2 ef             	and    $0xffffffef,%edx
  800420ab07:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420ab0d:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420ab14:	00 00 00 
  800420ab17:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420ab1e:	83 e2 9f             	and    $0xffffff9f,%edx
  800420ab21:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420ab27:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420ab2e:	00 00 00 
  800420ab31:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420ab38:	83 ca 80             	or     $0xffffff80,%edx
  800420ab3b:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420ab41:	48 b8 6c d1 20 04 80 	movabs $0x800420d16c,%rax
  800420ab48:	00 00 00 
  800420ab4b:	48 c1 e8 10          	shr    $0x10,%rax
  800420ab4f:	89 c2                	mov    %eax,%edx
  800420ab51:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420ab58:	00 00 00 
  800420ab5b:	66 89 90 06 02 00 00 	mov    %dx,0x206(%rax)
  800420ab62:	48 b8 6c d1 20 04 80 	movabs $0x800420d16c,%rax
  800420ab69:	00 00 00 
  800420ab6c:	48 c1 e8 20          	shr    $0x20,%rax
  800420ab70:	89 c2                	mov    %eax,%edx
  800420ab72:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420ab79:	00 00 00 
  800420ab7c:	89 90 08 02 00 00    	mov    %edx,0x208(%rax)
  800420ab82:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420ab89:	00 00 00 
  800420ab8c:	c7 80 0c 02 00 00 00 	movl   $0x0,0x20c(%rax)
  800420ab93:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 1], 0, GD_KT, &Xirq1, 0);
  800420ab96:	48 b8 76 d1 20 04 80 	movabs $0x800420d176,%rax
  800420ab9d:	00 00 00 
  800420aba0:	89 c2                	mov    %eax,%edx
  800420aba2:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420aba9:	00 00 00 
  800420abac:	66 89 90 10 02 00 00 	mov    %dx,0x210(%rax)
  800420abb3:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420abba:	00 00 00 
  800420abbd:	66 c7 80 12 02 00 00 	movw   $0x8,0x212(%rax)
  800420abc4:	08 00 
  800420abc6:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420abcd:	00 00 00 
  800420abd0:	0f b6 90 14 02 00 00 	movzbl 0x214(%rax),%edx
  800420abd7:	83 e2 f8             	and    $0xfffffff8,%edx
  800420abda:	88 90 14 02 00 00    	mov    %dl,0x214(%rax)
  800420abe0:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420abe7:	00 00 00 
  800420abea:	0f b6 90 14 02 00 00 	movzbl 0x214(%rax),%edx
  800420abf1:	83 e2 07             	and    $0x7,%edx
  800420abf4:	88 90 14 02 00 00    	mov    %dl,0x214(%rax)
  800420abfa:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420ac01:	00 00 00 
  800420ac04:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420ac0b:	83 e2 f0             	and    $0xfffffff0,%edx
  800420ac0e:	83 ca 0e             	or     $0xe,%edx
  800420ac11:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420ac17:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420ac1e:	00 00 00 
  800420ac21:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420ac28:	83 e2 ef             	and    $0xffffffef,%edx
  800420ac2b:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420ac31:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420ac38:	00 00 00 
  800420ac3b:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420ac42:	83 e2 9f             	and    $0xffffff9f,%edx
  800420ac45:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420ac4b:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420ac52:	00 00 00 
  800420ac55:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420ac5c:	83 ca 80             	or     $0xffffff80,%edx
  800420ac5f:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420ac65:	48 b8 76 d1 20 04 80 	movabs $0x800420d176,%rax
  800420ac6c:	00 00 00 
  800420ac6f:	48 c1 e8 10          	shr    $0x10,%rax
  800420ac73:	89 c2                	mov    %eax,%edx
  800420ac75:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420ac7c:	00 00 00 
  800420ac7f:	66 89 90 16 02 00 00 	mov    %dx,0x216(%rax)
  800420ac86:	48 b8 76 d1 20 04 80 	movabs $0x800420d176,%rax
  800420ac8d:	00 00 00 
  800420ac90:	48 c1 e8 20          	shr    $0x20,%rax
  800420ac94:	89 c2                	mov    %eax,%edx
  800420ac96:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420ac9d:	00 00 00 
  800420aca0:	89 90 18 02 00 00    	mov    %edx,0x218(%rax)
  800420aca6:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420acad:	00 00 00 
  800420acb0:	c7 80 1c 02 00 00 00 	movl   $0x0,0x21c(%rax)
  800420acb7:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 2], 0, GD_KT, &Xirq2, 0);
  800420acba:	48 b8 80 d1 20 04 80 	movabs $0x800420d180,%rax
  800420acc1:	00 00 00 
  800420acc4:	89 c2                	mov    %eax,%edx
  800420acc6:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420accd:	00 00 00 
  800420acd0:	66 89 90 20 02 00 00 	mov    %dx,0x220(%rax)
  800420acd7:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420acde:	00 00 00 
  800420ace1:	66 c7 80 22 02 00 00 	movw   $0x8,0x222(%rax)
  800420ace8:	08 00 
  800420acea:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420acf1:	00 00 00 
  800420acf4:	0f b6 90 24 02 00 00 	movzbl 0x224(%rax),%edx
  800420acfb:	83 e2 f8             	and    $0xfffffff8,%edx
  800420acfe:	88 90 24 02 00 00    	mov    %dl,0x224(%rax)
  800420ad04:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420ad0b:	00 00 00 
  800420ad0e:	0f b6 90 24 02 00 00 	movzbl 0x224(%rax),%edx
  800420ad15:	83 e2 07             	and    $0x7,%edx
  800420ad18:	88 90 24 02 00 00    	mov    %dl,0x224(%rax)
  800420ad1e:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420ad25:	00 00 00 
  800420ad28:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420ad2f:	83 e2 f0             	and    $0xfffffff0,%edx
  800420ad32:	83 ca 0e             	or     $0xe,%edx
  800420ad35:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420ad3b:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420ad42:	00 00 00 
  800420ad45:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420ad4c:	83 e2 ef             	and    $0xffffffef,%edx
  800420ad4f:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420ad55:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420ad5c:	00 00 00 
  800420ad5f:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420ad66:	83 e2 9f             	and    $0xffffff9f,%edx
  800420ad69:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420ad6f:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420ad76:	00 00 00 
  800420ad79:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420ad80:	83 ca 80             	or     $0xffffff80,%edx
  800420ad83:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420ad89:	48 b8 80 d1 20 04 80 	movabs $0x800420d180,%rax
  800420ad90:	00 00 00 
  800420ad93:	48 c1 e8 10          	shr    $0x10,%rax
  800420ad97:	89 c2                	mov    %eax,%edx
  800420ad99:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420ada0:	00 00 00 
  800420ada3:	66 89 90 26 02 00 00 	mov    %dx,0x226(%rax)
  800420adaa:	48 b8 80 d1 20 04 80 	movabs $0x800420d180,%rax
  800420adb1:	00 00 00 
  800420adb4:	48 c1 e8 20          	shr    $0x20,%rax
  800420adb8:	89 c2                	mov    %eax,%edx
  800420adba:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420adc1:	00 00 00 
  800420adc4:	89 90 28 02 00 00    	mov    %edx,0x228(%rax)
  800420adca:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420add1:	00 00 00 
  800420add4:	c7 80 2c 02 00 00 00 	movl   $0x0,0x22c(%rax)
  800420addb:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 3], 0, GD_KT, &Xirq3, 0);
  800420adde:	48 b8 8a d1 20 04 80 	movabs $0x800420d18a,%rax
  800420ade5:	00 00 00 
  800420ade8:	89 c2                	mov    %eax,%edx
  800420adea:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420adf1:	00 00 00 
  800420adf4:	66 89 90 30 02 00 00 	mov    %dx,0x230(%rax)
  800420adfb:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420ae02:	00 00 00 
  800420ae05:	66 c7 80 32 02 00 00 	movw   $0x8,0x232(%rax)
  800420ae0c:	08 00 
  800420ae0e:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420ae15:	00 00 00 
  800420ae18:	0f b6 90 34 02 00 00 	movzbl 0x234(%rax),%edx
  800420ae1f:	83 e2 f8             	and    $0xfffffff8,%edx
  800420ae22:	88 90 34 02 00 00    	mov    %dl,0x234(%rax)
  800420ae28:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420ae2f:	00 00 00 
  800420ae32:	0f b6 90 34 02 00 00 	movzbl 0x234(%rax),%edx
  800420ae39:	83 e2 07             	and    $0x7,%edx
  800420ae3c:	88 90 34 02 00 00    	mov    %dl,0x234(%rax)
  800420ae42:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420ae49:	00 00 00 
  800420ae4c:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420ae53:	83 e2 f0             	and    $0xfffffff0,%edx
  800420ae56:	83 ca 0e             	or     $0xe,%edx
  800420ae59:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420ae5f:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420ae66:	00 00 00 
  800420ae69:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420ae70:	83 e2 ef             	and    $0xffffffef,%edx
  800420ae73:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420ae79:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420ae80:	00 00 00 
  800420ae83:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420ae8a:	83 e2 9f             	and    $0xffffff9f,%edx
  800420ae8d:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420ae93:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420ae9a:	00 00 00 
  800420ae9d:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420aea4:	83 ca 80             	or     $0xffffff80,%edx
  800420aea7:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420aead:	48 b8 8a d1 20 04 80 	movabs $0x800420d18a,%rax
  800420aeb4:	00 00 00 
  800420aeb7:	48 c1 e8 10          	shr    $0x10,%rax
  800420aebb:	89 c2                	mov    %eax,%edx
  800420aebd:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420aec4:	00 00 00 
  800420aec7:	66 89 90 36 02 00 00 	mov    %dx,0x236(%rax)
  800420aece:	48 b8 8a d1 20 04 80 	movabs $0x800420d18a,%rax
  800420aed5:	00 00 00 
  800420aed8:	48 c1 e8 20          	shr    $0x20,%rax
  800420aedc:	89 c2                	mov    %eax,%edx
  800420aede:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420aee5:	00 00 00 
  800420aee8:	89 90 38 02 00 00    	mov    %edx,0x238(%rax)
  800420aeee:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420aef5:	00 00 00 
  800420aef8:	c7 80 3c 02 00 00 00 	movl   $0x0,0x23c(%rax)
  800420aeff:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 4], 0, GD_KT, &Xirq4, 0);
  800420af02:	48 b8 94 d1 20 04 80 	movabs $0x800420d194,%rax
  800420af09:	00 00 00 
  800420af0c:	89 c2                	mov    %eax,%edx
  800420af0e:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420af15:	00 00 00 
  800420af18:	66 89 90 40 02 00 00 	mov    %dx,0x240(%rax)
  800420af1f:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420af26:	00 00 00 
  800420af29:	66 c7 80 42 02 00 00 	movw   $0x8,0x242(%rax)
  800420af30:	08 00 
  800420af32:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420af39:	00 00 00 
  800420af3c:	0f b6 90 44 02 00 00 	movzbl 0x244(%rax),%edx
  800420af43:	83 e2 f8             	and    $0xfffffff8,%edx
  800420af46:	88 90 44 02 00 00    	mov    %dl,0x244(%rax)
  800420af4c:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420af53:	00 00 00 
  800420af56:	0f b6 90 44 02 00 00 	movzbl 0x244(%rax),%edx
  800420af5d:	83 e2 07             	and    $0x7,%edx
  800420af60:	88 90 44 02 00 00    	mov    %dl,0x244(%rax)
  800420af66:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420af6d:	00 00 00 
  800420af70:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420af77:	83 e2 f0             	and    $0xfffffff0,%edx
  800420af7a:	83 ca 0e             	or     $0xe,%edx
  800420af7d:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420af83:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420af8a:	00 00 00 
  800420af8d:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420af94:	83 e2 ef             	and    $0xffffffef,%edx
  800420af97:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420af9d:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420afa4:	00 00 00 
  800420afa7:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420afae:	83 e2 9f             	and    $0xffffff9f,%edx
  800420afb1:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420afb7:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420afbe:	00 00 00 
  800420afc1:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420afc8:	83 ca 80             	or     $0xffffff80,%edx
  800420afcb:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420afd1:	48 b8 94 d1 20 04 80 	movabs $0x800420d194,%rax
  800420afd8:	00 00 00 
  800420afdb:	48 c1 e8 10          	shr    $0x10,%rax
  800420afdf:	89 c2                	mov    %eax,%edx
  800420afe1:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420afe8:	00 00 00 
  800420afeb:	66 89 90 46 02 00 00 	mov    %dx,0x246(%rax)
  800420aff2:	48 b8 94 d1 20 04 80 	movabs $0x800420d194,%rax
  800420aff9:	00 00 00 
  800420affc:	48 c1 e8 20          	shr    $0x20,%rax
  800420b000:	89 c2                	mov    %eax,%edx
  800420b002:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b009:	00 00 00 
  800420b00c:	89 90 48 02 00 00    	mov    %edx,0x248(%rax)
  800420b012:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b019:	00 00 00 
  800420b01c:	c7 80 4c 02 00 00 00 	movl   $0x0,0x24c(%rax)
  800420b023:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 5], 0, GD_KT, &Xirq5, 0);
  800420b026:	48 b8 9e d1 20 04 80 	movabs $0x800420d19e,%rax
  800420b02d:	00 00 00 
  800420b030:	89 c2                	mov    %eax,%edx
  800420b032:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b039:	00 00 00 
  800420b03c:	66 89 90 50 02 00 00 	mov    %dx,0x250(%rax)
  800420b043:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b04a:	00 00 00 
  800420b04d:	66 c7 80 52 02 00 00 	movw   $0x8,0x252(%rax)
  800420b054:	08 00 
  800420b056:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b05d:	00 00 00 
  800420b060:	0f b6 90 54 02 00 00 	movzbl 0x254(%rax),%edx
  800420b067:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b06a:	88 90 54 02 00 00    	mov    %dl,0x254(%rax)
  800420b070:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b077:	00 00 00 
  800420b07a:	0f b6 90 54 02 00 00 	movzbl 0x254(%rax),%edx
  800420b081:	83 e2 07             	and    $0x7,%edx
  800420b084:	88 90 54 02 00 00    	mov    %dl,0x254(%rax)
  800420b08a:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b091:	00 00 00 
  800420b094:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420b09b:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b09e:	83 ca 0e             	or     $0xe,%edx
  800420b0a1:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420b0a7:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b0ae:	00 00 00 
  800420b0b1:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420b0b8:	83 e2 ef             	and    $0xffffffef,%edx
  800420b0bb:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420b0c1:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b0c8:	00 00 00 
  800420b0cb:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420b0d2:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b0d5:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420b0db:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b0e2:	00 00 00 
  800420b0e5:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420b0ec:	83 ca 80             	or     $0xffffff80,%edx
  800420b0ef:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420b0f5:	48 b8 9e d1 20 04 80 	movabs $0x800420d19e,%rax
  800420b0fc:	00 00 00 
  800420b0ff:	48 c1 e8 10          	shr    $0x10,%rax
  800420b103:	89 c2                	mov    %eax,%edx
  800420b105:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b10c:	00 00 00 
  800420b10f:	66 89 90 56 02 00 00 	mov    %dx,0x256(%rax)
  800420b116:	48 b8 9e d1 20 04 80 	movabs $0x800420d19e,%rax
  800420b11d:	00 00 00 
  800420b120:	48 c1 e8 20          	shr    $0x20,%rax
  800420b124:	89 c2                	mov    %eax,%edx
  800420b126:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b12d:	00 00 00 
  800420b130:	89 90 58 02 00 00    	mov    %edx,0x258(%rax)
  800420b136:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b13d:	00 00 00 
  800420b140:	c7 80 5c 02 00 00 00 	movl   $0x0,0x25c(%rax)
  800420b147:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 6], 0, GD_KT, &Xirq6, 0);
  800420b14a:	48 b8 a8 d1 20 04 80 	movabs $0x800420d1a8,%rax
  800420b151:	00 00 00 
  800420b154:	89 c2                	mov    %eax,%edx
  800420b156:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b15d:	00 00 00 
  800420b160:	66 89 90 60 02 00 00 	mov    %dx,0x260(%rax)
  800420b167:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b16e:	00 00 00 
  800420b171:	66 c7 80 62 02 00 00 	movw   $0x8,0x262(%rax)
  800420b178:	08 00 
  800420b17a:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b181:	00 00 00 
  800420b184:	0f b6 90 64 02 00 00 	movzbl 0x264(%rax),%edx
  800420b18b:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b18e:	88 90 64 02 00 00    	mov    %dl,0x264(%rax)
  800420b194:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b19b:	00 00 00 
  800420b19e:	0f b6 90 64 02 00 00 	movzbl 0x264(%rax),%edx
  800420b1a5:	83 e2 07             	and    $0x7,%edx
  800420b1a8:	88 90 64 02 00 00    	mov    %dl,0x264(%rax)
  800420b1ae:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b1b5:	00 00 00 
  800420b1b8:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420b1bf:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b1c2:	83 ca 0e             	or     $0xe,%edx
  800420b1c5:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420b1cb:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b1d2:	00 00 00 
  800420b1d5:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420b1dc:	83 e2 ef             	and    $0xffffffef,%edx
  800420b1df:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420b1e5:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b1ec:	00 00 00 
  800420b1ef:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420b1f6:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b1f9:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420b1ff:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b206:	00 00 00 
  800420b209:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420b210:	83 ca 80             	or     $0xffffff80,%edx
  800420b213:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420b219:	48 b8 a8 d1 20 04 80 	movabs $0x800420d1a8,%rax
  800420b220:	00 00 00 
  800420b223:	48 c1 e8 10          	shr    $0x10,%rax
  800420b227:	89 c2                	mov    %eax,%edx
  800420b229:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b230:	00 00 00 
  800420b233:	66 89 90 66 02 00 00 	mov    %dx,0x266(%rax)
  800420b23a:	48 b8 a8 d1 20 04 80 	movabs $0x800420d1a8,%rax
  800420b241:	00 00 00 
  800420b244:	48 c1 e8 20          	shr    $0x20,%rax
  800420b248:	89 c2                	mov    %eax,%edx
  800420b24a:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b251:	00 00 00 
  800420b254:	89 90 68 02 00 00    	mov    %edx,0x268(%rax)
  800420b25a:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b261:	00 00 00 
  800420b264:	c7 80 6c 02 00 00 00 	movl   $0x0,0x26c(%rax)
  800420b26b:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 7], 0, GD_KT, &Xirq7, 0);
  800420b26e:	48 b8 b2 d1 20 04 80 	movabs $0x800420d1b2,%rax
  800420b275:	00 00 00 
  800420b278:	89 c2                	mov    %eax,%edx
  800420b27a:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b281:	00 00 00 
  800420b284:	66 89 90 70 02 00 00 	mov    %dx,0x270(%rax)
  800420b28b:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b292:	00 00 00 
  800420b295:	66 c7 80 72 02 00 00 	movw   $0x8,0x272(%rax)
  800420b29c:	08 00 
  800420b29e:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b2a5:	00 00 00 
  800420b2a8:	0f b6 90 74 02 00 00 	movzbl 0x274(%rax),%edx
  800420b2af:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b2b2:	88 90 74 02 00 00    	mov    %dl,0x274(%rax)
  800420b2b8:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b2bf:	00 00 00 
  800420b2c2:	0f b6 90 74 02 00 00 	movzbl 0x274(%rax),%edx
  800420b2c9:	83 e2 07             	and    $0x7,%edx
  800420b2cc:	88 90 74 02 00 00    	mov    %dl,0x274(%rax)
  800420b2d2:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b2d9:	00 00 00 
  800420b2dc:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420b2e3:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b2e6:	83 ca 0e             	or     $0xe,%edx
  800420b2e9:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420b2ef:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b2f6:	00 00 00 
  800420b2f9:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420b300:	83 e2 ef             	and    $0xffffffef,%edx
  800420b303:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420b309:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b310:	00 00 00 
  800420b313:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420b31a:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b31d:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420b323:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b32a:	00 00 00 
  800420b32d:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420b334:	83 ca 80             	or     $0xffffff80,%edx
  800420b337:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420b33d:	48 b8 b2 d1 20 04 80 	movabs $0x800420d1b2,%rax
  800420b344:	00 00 00 
  800420b347:	48 c1 e8 10          	shr    $0x10,%rax
  800420b34b:	89 c2                	mov    %eax,%edx
  800420b34d:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b354:	00 00 00 
  800420b357:	66 89 90 76 02 00 00 	mov    %dx,0x276(%rax)
  800420b35e:	48 b8 b2 d1 20 04 80 	movabs $0x800420d1b2,%rax
  800420b365:	00 00 00 
  800420b368:	48 c1 e8 20          	shr    $0x20,%rax
  800420b36c:	89 c2                	mov    %eax,%edx
  800420b36e:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b375:	00 00 00 
  800420b378:	89 90 78 02 00 00    	mov    %edx,0x278(%rax)
  800420b37e:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b385:	00 00 00 
  800420b388:	c7 80 7c 02 00 00 00 	movl   $0x0,0x27c(%rax)
  800420b38f:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 8], 0, GD_KT, &Xirq8, 0);
  800420b392:	48 b8 bc d1 20 04 80 	movabs $0x800420d1bc,%rax
  800420b399:	00 00 00 
  800420b39c:	89 c2                	mov    %eax,%edx
  800420b39e:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b3a5:	00 00 00 
  800420b3a8:	66 89 90 80 02 00 00 	mov    %dx,0x280(%rax)
  800420b3af:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b3b6:	00 00 00 
  800420b3b9:	66 c7 80 82 02 00 00 	movw   $0x8,0x282(%rax)
  800420b3c0:	08 00 
  800420b3c2:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b3c9:	00 00 00 
  800420b3cc:	0f b6 90 84 02 00 00 	movzbl 0x284(%rax),%edx
  800420b3d3:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b3d6:	88 90 84 02 00 00    	mov    %dl,0x284(%rax)
  800420b3dc:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b3e3:	00 00 00 
  800420b3e6:	0f b6 90 84 02 00 00 	movzbl 0x284(%rax),%edx
  800420b3ed:	83 e2 07             	and    $0x7,%edx
  800420b3f0:	88 90 84 02 00 00    	mov    %dl,0x284(%rax)
  800420b3f6:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b3fd:	00 00 00 
  800420b400:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420b407:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b40a:	83 ca 0e             	or     $0xe,%edx
  800420b40d:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420b413:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b41a:	00 00 00 
  800420b41d:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420b424:	83 e2 ef             	and    $0xffffffef,%edx
  800420b427:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420b42d:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b434:	00 00 00 
  800420b437:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420b43e:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b441:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420b447:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b44e:	00 00 00 
  800420b451:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420b458:	83 ca 80             	or     $0xffffff80,%edx
  800420b45b:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420b461:	48 b8 bc d1 20 04 80 	movabs $0x800420d1bc,%rax
  800420b468:	00 00 00 
  800420b46b:	48 c1 e8 10          	shr    $0x10,%rax
  800420b46f:	89 c2                	mov    %eax,%edx
  800420b471:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b478:	00 00 00 
  800420b47b:	66 89 90 86 02 00 00 	mov    %dx,0x286(%rax)
  800420b482:	48 b8 bc d1 20 04 80 	movabs $0x800420d1bc,%rax
  800420b489:	00 00 00 
  800420b48c:	48 c1 e8 20          	shr    $0x20,%rax
  800420b490:	89 c2                	mov    %eax,%edx
  800420b492:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b499:	00 00 00 
  800420b49c:	89 90 88 02 00 00    	mov    %edx,0x288(%rax)
  800420b4a2:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b4a9:	00 00 00 
  800420b4ac:	c7 80 8c 02 00 00 00 	movl   $0x0,0x28c(%rax)
  800420b4b3:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 9], 0, GD_KT, &Xirq9, 0);
  800420b4b6:	48 b8 c6 d1 20 04 80 	movabs $0x800420d1c6,%rax
  800420b4bd:	00 00 00 
  800420b4c0:	89 c2                	mov    %eax,%edx
  800420b4c2:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b4c9:	00 00 00 
  800420b4cc:	66 89 90 90 02 00 00 	mov    %dx,0x290(%rax)
  800420b4d3:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b4da:	00 00 00 
  800420b4dd:	66 c7 80 92 02 00 00 	movw   $0x8,0x292(%rax)
  800420b4e4:	08 00 
  800420b4e6:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b4ed:	00 00 00 
  800420b4f0:	0f b6 90 94 02 00 00 	movzbl 0x294(%rax),%edx
  800420b4f7:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b4fa:	88 90 94 02 00 00    	mov    %dl,0x294(%rax)
  800420b500:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b507:	00 00 00 
  800420b50a:	0f b6 90 94 02 00 00 	movzbl 0x294(%rax),%edx
  800420b511:	83 e2 07             	and    $0x7,%edx
  800420b514:	88 90 94 02 00 00    	mov    %dl,0x294(%rax)
  800420b51a:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b521:	00 00 00 
  800420b524:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420b52b:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b52e:	83 ca 0e             	or     $0xe,%edx
  800420b531:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420b537:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b53e:	00 00 00 
  800420b541:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420b548:	83 e2 ef             	and    $0xffffffef,%edx
  800420b54b:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420b551:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b558:	00 00 00 
  800420b55b:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420b562:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b565:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420b56b:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b572:	00 00 00 
  800420b575:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420b57c:	83 ca 80             	or     $0xffffff80,%edx
  800420b57f:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420b585:	48 b8 c6 d1 20 04 80 	movabs $0x800420d1c6,%rax
  800420b58c:	00 00 00 
  800420b58f:	48 c1 e8 10          	shr    $0x10,%rax
  800420b593:	89 c2                	mov    %eax,%edx
  800420b595:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b59c:	00 00 00 
  800420b59f:	66 89 90 96 02 00 00 	mov    %dx,0x296(%rax)
  800420b5a6:	48 b8 c6 d1 20 04 80 	movabs $0x800420d1c6,%rax
  800420b5ad:	00 00 00 
  800420b5b0:	48 c1 e8 20          	shr    $0x20,%rax
  800420b5b4:	89 c2                	mov    %eax,%edx
  800420b5b6:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b5bd:	00 00 00 
  800420b5c0:	89 90 98 02 00 00    	mov    %edx,0x298(%rax)
  800420b5c6:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b5cd:	00 00 00 
  800420b5d0:	c7 80 9c 02 00 00 00 	movl   $0x0,0x29c(%rax)
  800420b5d7:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 10], 0, GD_KT, &Xirq10, 0);
  800420b5da:	48 b8 d0 d1 20 04 80 	movabs $0x800420d1d0,%rax
  800420b5e1:	00 00 00 
  800420b5e4:	89 c2                	mov    %eax,%edx
  800420b5e6:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b5ed:	00 00 00 
  800420b5f0:	66 89 90 a0 02 00 00 	mov    %dx,0x2a0(%rax)
  800420b5f7:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b5fe:	00 00 00 
  800420b601:	66 c7 80 a2 02 00 00 	movw   $0x8,0x2a2(%rax)
  800420b608:	08 00 
  800420b60a:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b611:	00 00 00 
  800420b614:	0f b6 90 a4 02 00 00 	movzbl 0x2a4(%rax),%edx
  800420b61b:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b61e:	88 90 a4 02 00 00    	mov    %dl,0x2a4(%rax)
  800420b624:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b62b:	00 00 00 
  800420b62e:	0f b6 90 a4 02 00 00 	movzbl 0x2a4(%rax),%edx
  800420b635:	83 e2 07             	and    $0x7,%edx
  800420b638:	88 90 a4 02 00 00    	mov    %dl,0x2a4(%rax)
  800420b63e:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b645:	00 00 00 
  800420b648:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420b64f:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b652:	83 ca 0e             	or     $0xe,%edx
  800420b655:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420b65b:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b662:	00 00 00 
  800420b665:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420b66c:	83 e2 ef             	and    $0xffffffef,%edx
  800420b66f:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420b675:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b67c:	00 00 00 
  800420b67f:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420b686:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b689:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420b68f:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b696:	00 00 00 
  800420b699:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420b6a0:	83 ca 80             	or     $0xffffff80,%edx
  800420b6a3:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420b6a9:	48 b8 d0 d1 20 04 80 	movabs $0x800420d1d0,%rax
  800420b6b0:	00 00 00 
  800420b6b3:	48 c1 e8 10          	shr    $0x10,%rax
  800420b6b7:	89 c2                	mov    %eax,%edx
  800420b6b9:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b6c0:	00 00 00 
  800420b6c3:	66 89 90 a6 02 00 00 	mov    %dx,0x2a6(%rax)
  800420b6ca:	48 b8 d0 d1 20 04 80 	movabs $0x800420d1d0,%rax
  800420b6d1:	00 00 00 
  800420b6d4:	48 c1 e8 20          	shr    $0x20,%rax
  800420b6d8:	89 c2                	mov    %eax,%edx
  800420b6da:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b6e1:	00 00 00 
  800420b6e4:	89 90 a8 02 00 00    	mov    %edx,0x2a8(%rax)
  800420b6ea:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b6f1:	00 00 00 
  800420b6f4:	c7 80 ac 02 00 00 00 	movl   $0x0,0x2ac(%rax)
  800420b6fb:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 11], 0, GD_KT, &Xirq11, 0);
  800420b6fe:	48 b8 da d1 20 04 80 	movabs $0x800420d1da,%rax
  800420b705:	00 00 00 
  800420b708:	89 c2                	mov    %eax,%edx
  800420b70a:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b711:	00 00 00 
  800420b714:	66 89 90 b0 02 00 00 	mov    %dx,0x2b0(%rax)
  800420b71b:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b722:	00 00 00 
  800420b725:	66 c7 80 b2 02 00 00 	movw   $0x8,0x2b2(%rax)
  800420b72c:	08 00 
  800420b72e:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b735:	00 00 00 
  800420b738:	0f b6 90 b4 02 00 00 	movzbl 0x2b4(%rax),%edx
  800420b73f:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b742:	88 90 b4 02 00 00    	mov    %dl,0x2b4(%rax)
  800420b748:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b74f:	00 00 00 
  800420b752:	0f b6 90 b4 02 00 00 	movzbl 0x2b4(%rax),%edx
  800420b759:	83 e2 07             	and    $0x7,%edx
  800420b75c:	88 90 b4 02 00 00    	mov    %dl,0x2b4(%rax)
  800420b762:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b769:	00 00 00 
  800420b76c:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420b773:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b776:	83 ca 0e             	or     $0xe,%edx
  800420b779:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420b77f:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b786:	00 00 00 
  800420b789:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420b790:	83 e2 ef             	and    $0xffffffef,%edx
  800420b793:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420b799:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b7a0:	00 00 00 
  800420b7a3:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420b7aa:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b7ad:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420b7b3:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b7ba:	00 00 00 
  800420b7bd:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420b7c4:	83 ca 80             	or     $0xffffff80,%edx
  800420b7c7:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420b7cd:	48 b8 da d1 20 04 80 	movabs $0x800420d1da,%rax
  800420b7d4:	00 00 00 
  800420b7d7:	48 c1 e8 10          	shr    $0x10,%rax
  800420b7db:	89 c2                	mov    %eax,%edx
  800420b7dd:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b7e4:	00 00 00 
  800420b7e7:	66 89 90 b6 02 00 00 	mov    %dx,0x2b6(%rax)
  800420b7ee:	48 b8 da d1 20 04 80 	movabs $0x800420d1da,%rax
  800420b7f5:	00 00 00 
  800420b7f8:	48 c1 e8 20          	shr    $0x20,%rax
  800420b7fc:	89 c2                	mov    %eax,%edx
  800420b7fe:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b805:	00 00 00 
  800420b808:	89 90 b8 02 00 00    	mov    %edx,0x2b8(%rax)
  800420b80e:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b815:	00 00 00 
  800420b818:	c7 80 bc 02 00 00 00 	movl   $0x0,0x2bc(%rax)
  800420b81f:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 12], 0, GD_KT, &Xirq12, 0);
  800420b822:	48 b8 e4 d1 20 04 80 	movabs $0x800420d1e4,%rax
  800420b829:	00 00 00 
  800420b82c:	89 c2                	mov    %eax,%edx
  800420b82e:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b835:	00 00 00 
  800420b838:	66 89 90 c0 02 00 00 	mov    %dx,0x2c0(%rax)
  800420b83f:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b846:	00 00 00 
  800420b849:	66 c7 80 c2 02 00 00 	movw   $0x8,0x2c2(%rax)
  800420b850:	08 00 
  800420b852:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b859:	00 00 00 
  800420b85c:	0f b6 90 c4 02 00 00 	movzbl 0x2c4(%rax),%edx
  800420b863:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b866:	88 90 c4 02 00 00    	mov    %dl,0x2c4(%rax)
  800420b86c:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b873:	00 00 00 
  800420b876:	0f b6 90 c4 02 00 00 	movzbl 0x2c4(%rax),%edx
  800420b87d:	83 e2 07             	and    $0x7,%edx
  800420b880:	88 90 c4 02 00 00    	mov    %dl,0x2c4(%rax)
  800420b886:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b88d:	00 00 00 
  800420b890:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420b897:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b89a:	83 ca 0e             	or     $0xe,%edx
  800420b89d:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420b8a3:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b8aa:	00 00 00 
  800420b8ad:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420b8b4:	83 e2 ef             	and    $0xffffffef,%edx
  800420b8b7:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420b8bd:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b8c4:	00 00 00 
  800420b8c7:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420b8ce:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b8d1:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420b8d7:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b8de:	00 00 00 
  800420b8e1:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420b8e8:	83 ca 80             	or     $0xffffff80,%edx
  800420b8eb:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420b8f1:	48 b8 e4 d1 20 04 80 	movabs $0x800420d1e4,%rax
  800420b8f8:	00 00 00 
  800420b8fb:	48 c1 e8 10          	shr    $0x10,%rax
  800420b8ff:	89 c2                	mov    %eax,%edx
  800420b901:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b908:	00 00 00 
  800420b90b:	66 89 90 c6 02 00 00 	mov    %dx,0x2c6(%rax)
  800420b912:	48 b8 e4 d1 20 04 80 	movabs $0x800420d1e4,%rax
  800420b919:	00 00 00 
  800420b91c:	48 c1 e8 20          	shr    $0x20,%rax
  800420b920:	89 c2                	mov    %eax,%edx
  800420b922:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b929:	00 00 00 
  800420b92c:	89 90 c8 02 00 00    	mov    %edx,0x2c8(%rax)
  800420b932:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b939:	00 00 00 
  800420b93c:	c7 80 cc 02 00 00 00 	movl   $0x0,0x2cc(%rax)
  800420b943:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 13], 0, GD_KT, &Xirq13, 0);
  800420b946:	48 b8 ee d1 20 04 80 	movabs $0x800420d1ee,%rax
  800420b94d:	00 00 00 
  800420b950:	89 c2                	mov    %eax,%edx
  800420b952:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b959:	00 00 00 
  800420b95c:	66 89 90 d0 02 00 00 	mov    %dx,0x2d0(%rax)
  800420b963:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b96a:	00 00 00 
  800420b96d:	66 c7 80 d2 02 00 00 	movw   $0x8,0x2d2(%rax)
  800420b974:	08 00 
  800420b976:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b97d:	00 00 00 
  800420b980:	0f b6 90 d4 02 00 00 	movzbl 0x2d4(%rax),%edx
  800420b987:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b98a:	88 90 d4 02 00 00    	mov    %dl,0x2d4(%rax)
  800420b990:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b997:	00 00 00 
  800420b99a:	0f b6 90 d4 02 00 00 	movzbl 0x2d4(%rax),%edx
  800420b9a1:	83 e2 07             	and    $0x7,%edx
  800420b9a4:	88 90 d4 02 00 00    	mov    %dl,0x2d4(%rax)
  800420b9aa:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b9b1:	00 00 00 
  800420b9b4:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420b9bb:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b9be:	83 ca 0e             	or     $0xe,%edx
  800420b9c1:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420b9c7:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b9ce:	00 00 00 
  800420b9d1:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420b9d8:	83 e2 ef             	and    $0xffffffef,%edx
  800420b9db:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420b9e1:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420b9e8:	00 00 00 
  800420b9eb:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420b9f2:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b9f5:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420b9fb:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420ba02:	00 00 00 
  800420ba05:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420ba0c:	83 ca 80             	or     $0xffffff80,%edx
  800420ba0f:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420ba15:	48 b8 ee d1 20 04 80 	movabs $0x800420d1ee,%rax
  800420ba1c:	00 00 00 
  800420ba1f:	48 c1 e8 10          	shr    $0x10,%rax
  800420ba23:	89 c2                	mov    %eax,%edx
  800420ba25:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420ba2c:	00 00 00 
  800420ba2f:	66 89 90 d6 02 00 00 	mov    %dx,0x2d6(%rax)
  800420ba36:	48 b8 ee d1 20 04 80 	movabs $0x800420d1ee,%rax
  800420ba3d:	00 00 00 
  800420ba40:	48 c1 e8 20          	shr    $0x20,%rax
  800420ba44:	89 c2                	mov    %eax,%edx
  800420ba46:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420ba4d:	00 00 00 
  800420ba50:	89 90 d8 02 00 00    	mov    %edx,0x2d8(%rax)
  800420ba56:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420ba5d:	00 00 00 
  800420ba60:	c7 80 dc 02 00 00 00 	movl   $0x0,0x2dc(%rax)
  800420ba67:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 14], 0, GD_KT, &Xirq14, 0);
  800420ba6a:	48 b8 f8 d1 20 04 80 	movabs $0x800420d1f8,%rax
  800420ba71:	00 00 00 
  800420ba74:	89 c2                	mov    %eax,%edx
  800420ba76:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420ba7d:	00 00 00 
  800420ba80:	66 89 90 e0 02 00 00 	mov    %dx,0x2e0(%rax)
  800420ba87:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420ba8e:	00 00 00 
  800420ba91:	66 c7 80 e2 02 00 00 	movw   $0x8,0x2e2(%rax)
  800420ba98:	08 00 
  800420ba9a:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420baa1:	00 00 00 
  800420baa4:	0f b6 90 e4 02 00 00 	movzbl 0x2e4(%rax),%edx
  800420baab:	83 e2 f8             	and    $0xfffffff8,%edx
  800420baae:	88 90 e4 02 00 00    	mov    %dl,0x2e4(%rax)
  800420bab4:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420babb:	00 00 00 
  800420babe:	0f b6 90 e4 02 00 00 	movzbl 0x2e4(%rax),%edx
  800420bac5:	83 e2 07             	and    $0x7,%edx
  800420bac8:	88 90 e4 02 00 00    	mov    %dl,0x2e4(%rax)
  800420bace:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420bad5:	00 00 00 
  800420bad8:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420badf:	83 e2 f0             	and    $0xfffffff0,%edx
  800420bae2:	83 ca 0e             	or     $0xe,%edx
  800420bae5:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420baeb:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420baf2:	00 00 00 
  800420baf5:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420bafc:	83 e2 ef             	and    $0xffffffef,%edx
  800420baff:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420bb05:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420bb0c:	00 00 00 
  800420bb0f:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420bb16:	83 e2 9f             	and    $0xffffff9f,%edx
  800420bb19:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420bb1f:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420bb26:	00 00 00 
  800420bb29:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420bb30:	83 ca 80             	or     $0xffffff80,%edx
  800420bb33:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420bb39:	48 b8 f8 d1 20 04 80 	movabs $0x800420d1f8,%rax
  800420bb40:	00 00 00 
  800420bb43:	48 c1 e8 10          	shr    $0x10,%rax
  800420bb47:	89 c2                	mov    %eax,%edx
  800420bb49:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420bb50:	00 00 00 
  800420bb53:	66 89 90 e6 02 00 00 	mov    %dx,0x2e6(%rax)
  800420bb5a:	48 b8 f8 d1 20 04 80 	movabs $0x800420d1f8,%rax
  800420bb61:	00 00 00 
  800420bb64:	48 c1 e8 20          	shr    $0x20,%rax
  800420bb68:	89 c2                	mov    %eax,%edx
  800420bb6a:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420bb71:	00 00 00 
  800420bb74:	89 90 e8 02 00 00    	mov    %edx,0x2e8(%rax)
  800420bb7a:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420bb81:	00 00 00 
  800420bb84:	c7 80 ec 02 00 00 00 	movl   $0x0,0x2ec(%rax)
  800420bb8b:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 15], 0, GD_KT, &Xirq15, 0);
  800420bb8e:	48 b8 02 d2 20 04 80 	movabs $0x800420d202,%rax
  800420bb95:	00 00 00 
  800420bb98:	89 c2                	mov    %eax,%edx
  800420bb9a:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420bba1:	00 00 00 
  800420bba4:	66 89 90 f0 02 00 00 	mov    %dx,0x2f0(%rax)
  800420bbab:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420bbb2:	00 00 00 
  800420bbb5:	66 c7 80 f2 02 00 00 	movw   $0x8,0x2f2(%rax)
  800420bbbc:	08 00 
  800420bbbe:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420bbc5:	00 00 00 
  800420bbc8:	0f b6 90 f4 02 00 00 	movzbl 0x2f4(%rax),%edx
  800420bbcf:	83 e2 f8             	and    $0xfffffff8,%edx
  800420bbd2:	88 90 f4 02 00 00    	mov    %dl,0x2f4(%rax)
  800420bbd8:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420bbdf:	00 00 00 
  800420bbe2:	0f b6 90 f4 02 00 00 	movzbl 0x2f4(%rax),%edx
  800420bbe9:	83 e2 07             	and    $0x7,%edx
  800420bbec:	88 90 f4 02 00 00    	mov    %dl,0x2f4(%rax)
  800420bbf2:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420bbf9:	00 00 00 
  800420bbfc:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420bc03:	83 e2 f0             	and    $0xfffffff0,%edx
  800420bc06:	83 ca 0e             	or     $0xe,%edx
  800420bc09:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420bc0f:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420bc16:	00 00 00 
  800420bc19:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420bc20:	83 e2 ef             	and    $0xffffffef,%edx
  800420bc23:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420bc29:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420bc30:	00 00 00 
  800420bc33:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420bc3a:	83 e2 9f             	and    $0xffffff9f,%edx
  800420bc3d:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420bc43:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420bc4a:	00 00 00 
  800420bc4d:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420bc54:	83 ca 80             	or     $0xffffff80,%edx
  800420bc57:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420bc5d:	48 b8 02 d2 20 04 80 	movabs $0x800420d202,%rax
  800420bc64:	00 00 00 
  800420bc67:	48 c1 e8 10          	shr    $0x10,%rax
  800420bc6b:	89 c2                	mov    %eax,%edx
  800420bc6d:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420bc74:	00 00 00 
  800420bc77:	66 89 90 f6 02 00 00 	mov    %dx,0x2f6(%rax)
  800420bc7e:	48 b8 02 d2 20 04 80 	movabs $0x800420d202,%rax
  800420bc85:	00 00 00 
  800420bc88:	48 c1 e8 20          	shr    $0x20,%rax
  800420bc8c:	89 c2                	mov    %eax,%edx
  800420bc8e:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420bc95:	00 00 00 
  800420bc98:	89 90 f8 02 00 00    	mov    %edx,0x2f8(%rax)
  800420bc9e:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420bca5:	00 00 00 
  800420bca8:	c7 80 fc 02 00 00 00 	movl   $0x0,0x2fc(%rax)
  800420bcaf:	00 00 00 


	// Use DPL=3 here because system calls are explicitly invoked
	// by the user process (with "int $T_SYSCALL").
	SETGATE(idt[T_SYSCALL], 0, GD_KT, &Xsyscall, 3);
  800420bcb2:	48 b8 0c d2 20 04 80 	movabs $0x800420d20c,%rax
  800420bcb9:	00 00 00 
  800420bcbc:	89 c2                	mov    %eax,%edx
  800420bcbe:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420bcc5:	00 00 00 
  800420bcc8:	66 89 90 00 03 00 00 	mov    %dx,0x300(%rax)
  800420bccf:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420bcd6:	00 00 00 
  800420bcd9:	66 c7 80 02 03 00 00 	movw   $0x8,0x302(%rax)
  800420bce0:	08 00 
  800420bce2:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420bce9:	00 00 00 
  800420bcec:	0f b6 90 04 03 00 00 	movzbl 0x304(%rax),%edx
  800420bcf3:	83 e2 f8             	and    $0xfffffff8,%edx
  800420bcf6:	88 90 04 03 00 00    	mov    %dl,0x304(%rax)
  800420bcfc:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420bd03:	00 00 00 
  800420bd06:	0f b6 90 04 03 00 00 	movzbl 0x304(%rax),%edx
  800420bd0d:	83 e2 07             	and    $0x7,%edx
  800420bd10:	88 90 04 03 00 00    	mov    %dl,0x304(%rax)
  800420bd16:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420bd1d:	00 00 00 
  800420bd20:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420bd27:	83 e2 f0             	and    $0xfffffff0,%edx
  800420bd2a:	83 ca 0e             	or     $0xe,%edx
  800420bd2d:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420bd33:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420bd3a:	00 00 00 
  800420bd3d:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420bd44:	83 e2 ef             	and    $0xffffffef,%edx
  800420bd47:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420bd4d:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420bd54:	00 00 00 
  800420bd57:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420bd5e:	83 ca 60             	or     $0x60,%edx
  800420bd61:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420bd67:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420bd6e:	00 00 00 
  800420bd71:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420bd78:	83 ca 80             	or     $0xffffff80,%edx
  800420bd7b:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420bd81:	48 b8 0c d2 20 04 80 	movabs $0x800420d20c,%rax
  800420bd88:	00 00 00 
  800420bd8b:	48 c1 e8 10          	shr    $0x10,%rax
  800420bd8f:	89 c2                	mov    %eax,%edx
  800420bd91:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420bd98:	00 00 00 
  800420bd9b:	66 89 90 06 03 00 00 	mov    %dx,0x306(%rax)
  800420bda2:	48 b8 0c d2 20 04 80 	movabs $0x800420d20c,%rax
  800420bda9:	00 00 00 
  800420bdac:	48 c1 e8 20          	shr    $0x20,%rax
  800420bdb0:	89 c2                	mov    %eax,%edx
  800420bdb2:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420bdb9:	00 00 00 
  800420bdbc:	89 90 08 03 00 00    	mov    %edx,0x308(%rax)
  800420bdc2:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420bdc9:	00 00 00 
  800420bdcc:	c7 80 0c 03 00 00 00 	movl   $0x0,0x30c(%rax)
  800420bdd3:	00 00 00 

	idt_pd.pd_lim = sizeof(idt)-1;
  800420bdd6:	48 b8 80 e2 49 04 80 	movabs $0x800449e280,%rax
  800420bddd:	00 00 00 
  800420bde0:	66 c7 00 ff 0f       	movw   $0xfff,(%rax)
	idt_pd.pd_base = (uint64_t)idt;
  800420bde5:	48 ba 80 d2 49 04 80 	movabs $0x800449d280,%rdx
  800420bdec:	00 00 00 
  800420bdef:	48 b8 80 e2 49 04 80 	movabs $0x800449e280,%rax
  800420bdf6:	00 00 00 
  800420bdf9:	48 89 50 02          	mov    %rdx,0x2(%rax)
	// Per-CPU setup
	trap_init_percpu();
  800420bdfd:	48 b8 0b be 20 04 80 	movabs $0x800420be0b,%rax
  800420be04:	00 00 00 
  800420be07:	ff d0                	callq  *%rax
}
  800420be09:	c9                   	leaveq 
  800420be0a:	c3                   	retq   

000000800420be0b <trap_init_percpu>:

// Initialize and load the per-CPU TSS and IDT
void
trap_init_percpu(void)
{
  800420be0b:	55                   	push   %rbp
  800420be0c:	48 89 e5             	mov    %rsp,%rbp
  800420be0f:	53                   	push   %rbx
  800420be10:	48 83 ec 18          	sub    $0x18,%rsp
	// wrong, you may not get a fault until you try to return from
	// user space on that CPU.
	//
	// LAB 4: Your code here:

	int gd_tss = (GD_TSS0 >> 3) + cpunum()*2;
  800420be14:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420be1b:	00 00 00 
  800420be1e:	ff d0                	callq  *%rax
  800420be20:	01 c0                	add    %eax,%eax
  800420be22:	83 c0 05             	add    $0x5,%eax
  800420be25:	89 45 ec             	mov    %eax,-0x14(%rbp)

	thiscpu->cpu_ts.ts_esp0 = KSTACKTOP 
  800420be28:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420be2f:	00 00 00 
  800420be32:	ff d0                	callq  *%rax
  800420be34:	89 c3                	mov    %eax,%ebx
		- (KSTKSIZE + KSTKGAP) * cpunum();
  800420be36:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420be3d:	00 00 00 
  800420be40:	ff d0                	callq  *%rax
  800420be42:	89 c2                	mov    %eax,%edx
  800420be44:	89 d0                	mov    %edx,%eax
  800420be46:	01 c0                	add    %eax,%eax
  800420be48:	01 d0                	add    %edx,%eax
  800420be4a:	c1 e0 0f             	shl    $0xf,%eax
  800420be4d:	48 98                	cltq   
  800420be4f:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420be56:	00 00 00 
  800420be59:	48 29 c2             	sub    %rax,%rdx
  800420be5c:	48 89 d0             	mov    %rdx,%rax
	//
	// LAB 4: Your code here:

	int gd_tss = (GD_TSS0 >> 3) + cpunum()*2;

	thiscpu->cpu_ts.ts_esp0 = KSTACKTOP 
  800420be5f:	48 89 c2             	mov    %rax,%rdx
  800420be62:	48 b9 20 e0 69 04 80 	movabs $0x800469e020,%rcx
  800420be69:	00 00 00 
  800420be6c:	48 63 c3             	movslq %ebx,%rax
  800420be6f:	48 c1 e0 03          	shl    $0x3,%rax
  800420be73:	48 89 c6             	mov    %rax,%rsi
  800420be76:	48 c1 e6 04          	shl    $0x4,%rsi
  800420be7a:	48 01 f0             	add    %rsi,%rax
  800420be7d:	48 01 c8             	add    %rcx,%rax
  800420be80:	48 83 c0 10          	add    $0x10,%rax
  800420be84:	48 89 50 04          	mov    %rdx,0x4(%rax)
		- (KSTKSIZE + KSTKGAP) * cpunum();

	SETTSS((struct SystemSegdesc64 *)((gdt_pd>>16)+40+cpunum()*16),STS_T64A, (uint64_t) (&thiscpu->cpu_ts),sizeof(struct Taskstate), 0);
  800420be88:	48 b8 68 c6 22 04 80 	movabs $0x800422c668,%rax
  800420be8f:	00 00 00 
  800420be92:	48 8b 00             	mov    (%rax),%rax
  800420be95:	48 c1 f8 10          	sar    $0x10,%rax
  800420be99:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420be9d:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420bea4:	00 00 00 
  800420bea7:	ff d0                	callq  *%rax
  800420bea9:	c1 e0 04             	shl    $0x4,%eax
  800420beac:	48 98                	cltq   
  800420beae:	48 01 d8             	add    %rbx,%rax
  800420beb1:	66 c7 00 68 00       	movw   $0x68,(%rax)
  800420beb6:	48 b8 68 c6 22 04 80 	movabs $0x800422c668,%rax
  800420bebd:	00 00 00 
  800420bec0:	48 8b 00             	mov    (%rax),%rax
  800420bec3:	48 c1 f8 10          	sar    $0x10,%rax
  800420bec7:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420becb:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420bed2:	00 00 00 
  800420bed5:	ff d0                	callq  *%rax
  800420bed7:	c1 e0 04             	shl    $0x4,%eax
  800420beda:	48 98                	cltq   
  800420bedc:	48 01 d8             	add    %rbx,%rax
  800420bedf:	48 89 c3             	mov    %rax,%rbx
  800420bee2:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420bee9:	00 00 00 
  800420beec:	ff d0                	callq  *%rax
  800420beee:	48 98                	cltq   
  800420bef0:	48 c1 e0 03          	shl    $0x3,%rax
  800420bef4:	48 89 c2             	mov    %rax,%rdx
  800420bef7:	48 c1 e2 04          	shl    $0x4,%rdx
  800420befb:	48 01 d0             	add    %rdx,%rax
  800420befe:	48 8d 50 10          	lea    0x10(%rax),%rdx
  800420bf02:	48 b8 20 e0 69 04 80 	movabs $0x800469e020,%rax
  800420bf09:	00 00 00 
  800420bf0c:	48 01 d0             	add    %rdx,%rax
  800420bf0f:	66 89 43 02          	mov    %ax,0x2(%rbx)
  800420bf13:	48 b8 68 c6 22 04 80 	movabs $0x800422c668,%rax
  800420bf1a:	00 00 00 
  800420bf1d:	48 8b 00             	mov    (%rax),%rax
  800420bf20:	48 c1 f8 10          	sar    $0x10,%rax
  800420bf24:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420bf28:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420bf2f:	00 00 00 
  800420bf32:	ff d0                	callq  *%rax
  800420bf34:	c1 e0 04             	shl    $0x4,%eax
  800420bf37:	48 98                	cltq   
  800420bf39:	48 01 d8             	add    %rbx,%rax
  800420bf3c:	48 89 c3             	mov    %rax,%rbx
  800420bf3f:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420bf46:	00 00 00 
  800420bf49:	ff d0                	callq  *%rax
  800420bf4b:	48 98                	cltq   
  800420bf4d:	48 c1 e0 03          	shl    $0x3,%rax
  800420bf51:	48 89 c2             	mov    %rax,%rdx
  800420bf54:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bf58:	48 01 d0             	add    %rdx,%rax
  800420bf5b:	48 8d 50 10          	lea    0x10(%rax),%rdx
  800420bf5f:	48 b8 20 e0 69 04 80 	movabs $0x800469e020,%rax
  800420bf66:	00 00 00 
  800420bf69:	48 01 d0             	add    %rdx,%rax
  800420bf6c:	48 c1 e8 10          	shr    $0x10,%rax
  800420bf70:	88 43 04             	mov    %al,0x4(%rbx)
  800420bf73:	48 b8 68 c6 22 04 80 	movabs $0x800422c668,%rax
  800420bf7a:	00 00 00 
  800420bf7d:	48 8b 00             	mov    (%rax),%rax
  800420bf80:	48 c1 f8 10          	sar    $0x10,%rax
  800420bf84:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420bf88:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420bf8f:	00 00 00 
  800420bf92:	ff d0                	callq  *%rax
  800420bf94:	c1 e0 04             	shl    $0x4,%eax
  800420bf97:	48 98                	cltq   
  800420bf99:	48 01 d8             	add    %rbx,%rax
  800420bf9c:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420bfa0:	83 e2 f0             	and    $0xfffffff0,%edx
  800420bfa3:	83 ca 09             	or     $0x9,%edx
  800420bfa6:	88 50 05             	mov    %dl,0x5(%rax)
  800420bfa9:	48 b8 68 c6 22 04 80 	movabs $0x800422c668,%rax
  800420bfb0:	00 00 00 
  800420bfb3:	48 8b 00             	mov    (%rax),%rax
  800420bfb6:	48 c1 f8 10          	sar    $0x10,%rax
  800420bfba:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420bfbe:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420bfc5:	00 00 00 
  800420bfc8:	ff d0                	callq  *%rax
  800420bfca:	c1 e0 04             	shl    $0x4,%eax
  800420bfcd:	48 98                	cltq   
  800420bfcf:	48 01 d8             	add    %rbx,%rax
  800420bfd2:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420bfd6:	83 e2 ef             	and    $0xffffffef,%edx
  800420bfd9:	88 50 05             	mov    %dl,0x5(%rax)
  800420bfdc:	48 b8 68 c6 22 04 80 	movabs $0x800422c668,%rax
  800420bfe3:	00 00 00 
  800420bfe6:	48 8b 00             	mov    (%rax),%rax
  800420bfe9:	48 c1 f8 10          	sar    $0x10,%rax
  800420bfed:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420bff1:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420bff8:	00 00 00 
  800420bffb:	ff d0                	callq  *%rax
  800420bffd:	c1 e0 04             	shl    $0x4,%eax
  800420c000:	48 98                	cltq   
  800420c002:	48 01 d8             	add    %rbx,%rax
  800420c005:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420c009:	83 e2 9f             	and    $0xffffff9f,%edx
  800420c00c:	88 50 05             	mov    %dl,0x5(%rax)
  800420c00f:	48 b8 68 c6 22 04 80 	movabs $0x800422c668,%rax
  800420c016:	00 00 00 
  800420c019:	48 8b 00             	mov    (%rax),%rax
  800420c01c:	48 c1 f8 10          	sar    $0x10,%rax
  800420c020:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c024:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420c02b:	00 00 00 
  800420c02e:	ff d0                	callq  *%rax
  800420c030:	c1 e0 04             	shl    $0x4,%eax
  800420c033:	48 98                	cltq   
  800420c035:	48 01 d8             	add    %rbx,%rax
  800420c038:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420c03c:	83 ca 80             	or     $0xffffff80,%edx
  800420c03f:	88 50 05             	mov    %dl,0x5(%rax)
  800420c042:	48 b8 68 c6 22 04 80 	movabs $0x800422c668,%rax
  800420c049:	00 00 00 
  800420c04c:	48 8b 00             	mov    (%rax),%rax
  800420c04f:	48 c1 f8 10          	sar    $0x10,%rax
  800420c053:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c057:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420c05e:	00 00 00 
  800420c061:	ff d0                	callq  *%rax
  800420c063:	c1 e0 04             	shl    $0x4,%eax
  800420c066:	48 98                	cltq   
  800420c068:	48 01 d8             	add    %rbx,%rax
  800420c06b:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420c06f:	83 e2 f0             	and    $0xfffffff0,%edx
  800420c072:	88 50 06             	mov    %dl,0x6(%rax)
  800420c075:	48 b8 68 c6 22 04 80 	movabs $0x800422c668,%rax
  800420c07c:	00 00 00 
  800420c07f:	48 8b 00             	mov    (%rax),%rax
  800420c082:	48 c1 f8 10          	sar    $0x10,%rax
  800420c086:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c08a:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420c091:	00 00 00 
  800420c094:	ff d0                	callq  *%rax
  800420c096:	c1 e0 04             	shl    $0x4,%eax
  800420c099:	48 98                	cltq   
  800420c09b:	48 01 d8             	add    %rbx,%rax
  800420c09e:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420c0a2:	83 e2 ef             	and    $0xffffffef,%edx
  800420c0a5:	88 50 06             	mov    %dl,0x6(%rax)
  800420c0a8:	48 b8 68 c6 22 04 80 	movabs $0x800422c668,%rax
  800420c0af:	00 00 00 
  800420c0b2:	48 8b 00             	mov    (%rax),%rax
  800420c0b5:	48 c1 f8 10          	sar    $0x10,%rax
  800420c0b9:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c0bd:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420c0c4:	00 00 00 
  800420c0c7:	ff d0                	callq  *%rax
  800420c0c9:	c1 e0 04             	shl    $0x4,%eax
  800420c0cc:	48 98                	cltq   
  800420c0ce:	48 01 d8             	add    %rbx,%rax
  800420c0d1:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420c0d5:	83 e2 9f             	and    $0xffffff9f,%edx
  800420c0d8:	88 50 06             	mov    %dl,0x6(%rax)
  800420c0db:	48 b8 68 c6 22 04 80 	movabs $0x800422c668,%rax
  800420c0e2:	00 00 00 
  800420c0e5:	48 8b 00             	mov    (%rax),%rax
  800420c0e8:	48 c1 f8 10          	sar    $0x10,%rax
  800420c0ec:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c0f0:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420c0f7:	00 00 00 
  800420c0fa:	ff d0                	callq  *%rax
  800420c0fc:	c1 e0 04             	shl    $0x4,%eax
  800420c0ff:	48 98                	cltq   
  800420c101:	48 01 d8             	add    %rbx,%rax
  800420c104:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420c108:	83 e2 7f             	and    $0x7f,%edx
  800420c10b:	88 50 06             	mov    %dl,0x6(%rax)
  800420c10e:	48 b8 68 c6 22 04 80 	movabs $0x800422c668,%rax
  800420c115:	00 00 00 
  800420c118:	48 8b 00             	mov    (%rax),%rax
  800420c11b:	48 c1 f8 10          	sar    $0x10,%rax
  800420c11f:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c123:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420c12a:	00 00 00 
  800420c12d:	ff d0                	callq  *%rax
  800420c12f:	c1 e0 04             	shl    $0x4,%eax
  800420c132:	48 98                	cltq   
  800420c134:	48 01 d8             	add    %rbx,%rax
  800420c137:	48 89 c3             	mov    %rax,%rbx
  800420c13a:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420c141:	00 00 00 
  800420c144:	ff d0                	callq  *%rax
  800420c146:	48 98                	cltq   
  800420c148:	48 c1 e0 03          	shl    $0x3,%rax
  800420c14c:	48 89 c2             	mov    %rax,%rdx
  800420c14f:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c153:	48 01 d0             	add    %rdx,%rax
  800420c156:	48 8d 50 10          	lea    0x10(%rax),%rdx
  800420c15a:	48 b8 20 e0 69 04 80 	movabs $0x800469e020,%rax
  800420c161:	00 00 00 
  800420c164:	48 01 d0             	add    %rdx,%rax
  800420c167:	48 c1 e8 18          	shr    $0x18,%rax
  800420c16b:	88 43 07             	mov    %al,0x7(%rbx)
  800420c16e:	48 b8 68 c6 22 04 80 	movabs $0x800422c668,%rax
  800420c175:	00 00 00 
  800420c178:	48 8b 00             	mov    (%rax),%rax
  800420c17b:	48 c1 f8 10          	sar    $0x10,%rax
  800420c17f:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c183:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420c18a:	00 00 00 
  800420c18d:	ff d0                	callq  *%rax
  800420c18f:	c1 e0 04             	shl    $0x4,%eax
  800420c192:	48 98                	cltq   
  800420c194:	48 01 d8             	add    %rbx,%rax
  800420c197:	48 89 c3             	mov    %rax,%rbx
  800420c19a:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420c1a1:	00 00 00 
  800420c1a4:	ff d0                	callq  *%rax
  800420c1a6:	48 98                	cltq   
  800420c1a8:	48 c1 e0 03          	shl    $0x3,%rax
  800420c1ac:	48 89 c2             	mov    %rax,%rdx
  800420c1af:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c1b3:	48 01 d0             	add    %rdx,%rax
  800420c1b6:	48 8d 50 10          	lea    0x10(%rax),%rdx
  800420c1ba:	48 b8 20 e0 69 04 80 	movabs $0x800469e020,%rax
  800420c1c1:	00 00 00 
  800420c1c4:	48 01 d0             	add    %rdx,%rax
  800420c1c7:	48 c1 e8 20          	shr    $0x20,%rax
  800420c1cb:	89 43 08             	mov    %eax,0x8(%rbx)
  800420c1ce:	48 b8 68 c6 22 04 80 	movabs $0x800422c668,%rax
  800420c1d5:	00 00 00 
  800420c1d8:	48 8b 00             	mov    (%rax),%rax
  800420c1db:	48 c1 f8 10          	sar    $0x10,%rax
  800420c1df:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c1e3:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420c1ea:	00 00 00 
  800420c1ed:	ff d0                	callq  *%rax
  800420c1ef:	c1 e0 04             	shl    $0x4,%eax
  800420c1f2:	48 98                	cltq   
  800420c1f4:	48 01 d8             	add    %rbx,%rax
  800420c1f7:	c6 40 0c 00          	movb   $0x0,0xc(%rax)
  800420c1fb:	48 b8 68 c6 22 04 80 	movabs $0x800422c668,%rax
  800420c202:	00 00 00 
  800420c205:	48 8b 00             	mov    (%rax),%rax
  800420c208:	48 c1 f8 10          	sar    $0x10,%rax
  800420c20c:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c210:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420c217:	00 00 00 
  800420c21a:	ff d0                	callq  *%rax
  800420c21c:	c1 e0 04             	shl    $0x4,%eax
  800420c21f:	48 98                	cltq   
  800420c221:	48 01 d8             	add    %rbx,%rax
  800420c224:	c6 40 0d 00          	movb   $0x0,0xd(%rax)
  800420c228:	48 b8 68 c6 22 04 80 	movabs $0x800422c668,%rax
  800420c22f:	00 00 00 
  800420c232:	48 8b 00             	mov    (%rax),%rax
  800420c235:	48 c1 f8 10          	sar    $0x10,%rax
  800420c239:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c23d:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420c244:	00 00 00 
  800420c247:	ff d0                	callq  *%rax
  800420c249:	c1 e0 04             	shl    $0x4,%eax
  800420c24c:	48 98                	cltq   
  800420c24e:	48 01 d8             	add    %rbx,%rax
  800420c251:	66 c7 40 0e 00 00    	movw   $0x0,0xe(%rax)

	// Load the TSS
	ltr(gd_tss << 3);
  800420c257:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c25a:	c1 e0 03             	shl    $0x3,%eax
  800420c25d:	0f b7 c0             	movzwl %ax,%eax
  800420c260:	66 89 45 ea          	mov    %ax,-0x16(%rbp)
	__asm __volatile("lgdt (%0)" : : "r" (p));
}
static __inline void
ltr(uint16_t sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
  800420c264:	0f b7 45 ea          	movzwl -0x16(%rbp),%eax
  800420c268:	0f 00 d8             	ltr    %ax
  800420c26b:	48 b8 80 e2 49 04 80 	movabs $0x800449e280,%rax
  800420c272:	00 00 00 
  800420c275:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
}  

static __inline void
lidt(void *p)
{
	__asm __volatile("lidt (%0)" : : "r" (p));
  800420c279:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c27d:	0f 01 18             	lidt   (%rax)


	// Load the IDT
	lidt(&idt_pd);
}
  800420c280:	48 83 c4 18          	add    $0x18,%rsp
  800420c284:	5b                   	pop    %rbx
  800420c285:	5d                   	pop    %rbp
  800420c286:	c3                   	retq   

000000800420c287 <print_trapframe>:

void
print_trapframe(struct Trapframe *tf)
{
  800420c287:	55                   	push   %rbp
  800420c288:	48 89 e5             	mov    %rsp,%rbp
  800420c28b:	48 83 ec 20          	sub    $0x20,%rsp
  800420c28f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)

	cprintf("TRAP frame at %p from CPU %d\n", tf, cpunum());
  800420c293:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420c29a:	00 00 00 
  800420c29d:	ff d0                	callq  *%rax
  800420c29f:	89 c2                	mov    %eax,%edx
  800420c2a1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c2a5:	48 89 c6             	mov    %rax,%rsi
  800420c2a8:	48 bf 0e a2 21 04 80 	movabs $0x800421a20e,%rdi
  800420c2af:	00 00 00 
  800420c2b2:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c2b7:	48 b9 90 95 20 04 80 	movabs $0x8004209590,%rcx
  800420c2be:	00 00 00 
  800420c2c1:	ff d1                	callq  *%rcx

	print_regs(&tf->tf_regs);
  800420c2c3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c2c7:	48 89 c7             	mov    %rax,%rdi
  800420c2ca:	48 b8 98 c5 20 04 80 	movabs $0x800420c598,%rax
  800420c2d1:	00 00 00 
  800420c2d4:	ff d0                	callq  *%rax
	cprintf("  es   0x----%04x\n", tf->tf_es);
  800420c2d6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c2da:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  800420c2de:	0f b7 c0             	movzwl %ax,%eax
  800420c2e1:	89 c6                	mov    %eax,%esi
  800420c2e3:	48 bf 2c a2 21 04 80 	movabs $0x800421a22c,%rdi
  800420c2ea:	00 00 00 
  800420c2ed:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c2f2:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  800420c2f9:	00 00 00 
  800420c2fc:	ff d2                	callq  *%rdx
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
  800420c2fe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c302:	0f b7 80 80 00 00 00 	movzwl 0x80(%rax),%eax
  800420c309:	0f b7 c0             	movzwl %ax,%eax
  800420c30c:	89 c6                	mov    %eax,%esi
  800420c30e:	48 bf 3f a2 21 04 80 	movabs $0x800421a23f,%rdi
  800420c315:	00 00 00 
  800420c318:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c31d:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  800420c324:	00 00 00 
  800420c327:	ff d2                	callq  *%rdx
	cprintf("  trap 0x%08x %s\n", tf->tf_trapno, trapname(tf->tf_trapno));
  800420c329:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c32d:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c334:	89 c7                	mov    %eax,%edi
  800420c336:	48 b8 a9 96 20 04 80 	movabs $0x80042096a9,%rax
  800420c33d:	00 00 00 
  800420c340:	ff d0                	callq  *%rax
  800420c342:	48 89 c2             	mov    %rax,%rdx
  800420c345:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c349:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c350:	48 89 c6             	mov    %rax,%rsi
  800420c353:	48 bf 52 a2 21 04 80 	movabs $0x800421a252,%rdi
  800420c35a:	00 00 00 
  800420c35d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c362:	48 b9 90 95 20 04 80 	movabs $0x8004209590,%rcx
  800420c369:	00 00 00 
  800420c36c:	ff d1                	callq  *%rcx
	// If this trap was a page fault that just happened
	// (so %cr2 is meaningful), print the faulting linear address.
	if (tf == last_tf && tf->tf_trapno == T_PGFLT)
  800420c36e:	48 b8 90 e2 49 04 80 	movabs $0x800449e290,%rax
  800420c375:	00 00 00 
  800420c378:	48 8b 00             	mov    (%rax),%rax
  800420c37b:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800420c37f:	75 3a                	jne    800420c3bb <print_trapframe+0x134>
  800420c381:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c385:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c38c:	48 83 f8 0e          	cmp    $0xe,%rax
  800420c390:	75 29                	jne    800420c3bb <print_trapframe+0x134>

static __inline uint64_t
rcr2(void)
{
	uint64_t val;
	__asm __volatile("movq %%cr2,%0" : "=r" (val));
  800420c392:	0f 20 d0             	mov    %cr2,%rax
  800420c395:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return val;
  800420c399:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
		cprintf("  cr2  0x%08x\n", rcr2());
  800420c39d:	48 89 c6             	mov    %rax,%rsi
  800420c3a0:	48 bf 64 a2 21 04 80 	movabs $0x800421a264,%rdi
  800420c3a7:	00 00 00 
  800420c3aa:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c3af:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  800420c3b6:	00 00 00 
  800420c3b9:	ff d2                	callq  *%rdx
	cprintf("  err  0x%08x", tf->tf_err);
  800420c3bb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c3bf:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420c3c6:	48 89 c6             	mov    %rax,%rsi
  800420c3c9:	48 bf 73 a2 21 04 80 	movabs $0x800421a273,%rdi
  800420c3d0:	00 00 00 
  800420c3d3:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c3d8:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  800420c3df:	00 00 00 
  800420c3e2:	ff d2                	callq  *%rdx
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
  800420c3e4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c3e8:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c3ef:	48 83 f8 0e          	cmp    $0xe,%rax
  800420c3f3:	0f 85 9c 00 00 00    	jne    800420c495 <print_trapframe+0x20e>
		cprintf(" [%s, %s, %s]\n",
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
			tf->tf_err & 1 ? "protection" : "not-present");
  800420c3f9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c3fd:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420c404:	83 e0 01             	and    $0x1,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420c407:	48 85 c0             	test   %rax,%rax
  800420c40a:	74 0c                	je     800420c418 <print_trapframe+0x191>
  800420c40c:	48 b9 81 a2 21 04 80 	movabs $0x800421a281,%rcx
  800420c413:	00 00 00 
  800420c416:	eb 0a                	jmp    800420c422 <print_trapframe+0x19b>
  800420c418:	48 b9 8c a2 21 04 80 	movabs $0x800421a28c,%rcx
  800420c41f:	00 00 00 
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
  800420c422:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c426:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420c42d:	83 e0 02             	and    $0x2,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420c430:	48 85 c0             	test   %rax,%rax
  800420c433:	74 0c                	je     800420c441 <print_trapframe+0x1ba>
  800420c435:	48 ba 98 a2 21 04 80 	movabs $0x800421a298,%rdx
  800420c43c:	00 00 00 
  800420c43f:	eb 0a                	jmp    800420c44b <print_trapframe+0x1c4>
  800420c441:	48 ba 9e a2 21 04 80 	movabs $0x800421a29e,%rdx
  800420c448:	00 00 00 
			tf->tf_err & 4 ? "user" : "kernel",
  800420c44b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c44f:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420c456:	83 e0 04             	and    $0x4,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420c459:	48 85 c0             	test   %rax,%rax
  800420c45c:	74 0c                	je     800420c46a <print_trapframe+0x1e3>
  800420c45e:	48 b8 a3 a2 21 04 80 	movabs $0x800421a2a3,%rax
  800420c465:	00 00 00 
  800420c468:	eb 0a                	jmp    800420c474 <print_trapframe+0x1ed>
  800420c46a:	48 b8 a8 a2 21 04 80 	movabs $0x800421a2a8,%rax
  800420c471:	00 00 00 
  800420c474:	48 89 c6             	mov    %rax,%rsi
  800420c477:	48 bf af a2 21 04 80 	movabs $0x800421a2af,%rdi
  800420c47e:	00 00 00 
  800420c481:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c486:	49 b8 90 95 20 04 80 	movabs $0x8004209590,%r8
  800420c48d:	00 00 00 
  800420c490:	41 ff d0             	callq  *%r8
  800420c493:	eb 1b                	jmp    800420c4b0 <print_trapframe+0x229>
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
			tf->tf_err & 1 ? "protection" : "not-present");
	else
		cprintf("\n");
  800420c495:	48 bf be a2 21 04 80 	movabs $0x800421a2be,%rdi
  800420c49c:	00 00 00 
  800420c49f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c4a4:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  800420c4ab:	00 00 00 
  800420c4ae:	ff d2                	callq  *%rdx
	cprintf("  rip  0x%08x\n", tf->tf_rip);
  800420c4b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c4b4:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  800420c4bb:	48 89 c6             	mov    %rax,%rsi
  800420c4be:	48 bf c0 a2 21 04 80 	movabs $0x800421a2c0,%rdi
  800420c4c5:	00 00 00 
  800420c4c8:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c4cd:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  800420c4d4:	00 00 00 
  800420c4d7:	ff d2                	callq  *%rdx
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
  800420c4d9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c4dd:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420c4e4:	0f b7 c0             	movzwl %ax,%eax
  800420c4e7:	89 c6                	mov    %eax,%esi
  800420c4e9:	48 bf cf a2 21 04 80 	movabs $0x800421a2cf,%rdi
  800420c4f0:	00 00 00 
  800420c4f3:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c4f8:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  800420c4ff:	00 00 00 
  800420c502:	ff d2                	callq  *%rdx
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
  800420c504:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c508:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  800420c50f:	48 89 c6             	mov    %rax,%rsi
  800420c512:	48 bf e2 a2 21 04 80 	movabs $0x800421a2e2,%rdi
  800420c519:	00 00 00 
  800420c51c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c521:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  800420c528:	00 00 00 
  800420c52b:	ff d2                	callq  *%rdx
	if ((tf->tf_cs & 3) != 0) {
  800420c52d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c531:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420c538:	0f b7 c0             	movzwl %ax,%eax
  800420c53b:	83 e0 03             	and    $0x3,%eax
  800420c53e:	85 c0                	test   %eax,%eax
  800420c540:	74 54                	je     800420c596 <print_trapframe+0x30f>
		cprintf("  rsp  0x%08x\n", tf->tf_rsp);
  800420c542:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c546:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  800420c54d:	48 89 c6             	mov    %rax,%rsi
  800420c550:	48 bf f1 a2 21 04 80 	movabs $0x800421a2f1,%rdi
  800420c557:	00 00 00 
  800420c55a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c55f:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  800420c566:	00 00 00 
  800420c569:	ff d2                	callq  *%rdx
		cprintf("  ss   0x----%04x\n", tf->tf_ss);
  800420c56b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c56f:	0f b7 80 b8 00 00 00 	movzwl 0xb8(%rax),%eax
  800420c576:	0f b7 c0             	movzwl %ax,%eax
  800420c579:	89 c6                	mov    %eax,%esi
  800420c57b:	48 bf 00 a3 21 04 80 	movabs $0x800421a300,%rdi
  800420c582:	00 00 00 
  800420c585:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c58a:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  800420c591:	00 00 00 
  800420c594:	ff d2                	callq  *%rdx
	}
}
  800420c596:	c9                   	leaveq 
  800420c597:	c3                   	retq   

000000800420c598 <print_regs>:

void
print_regs(struct PushRegs *regs)
{
  800420c598:	55                   	push   %rbp
  800420c599:	48 89 e5             	mov    %rsp,%rbp
  800420c59c:	48 83 ec 10          	sub    $0x10,%rsp
  800420c5a0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	cprintf("  r15  0x%08x\n", regs->reg_r15);
  800420c5a4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c5a8:	48 8b 00             	mov    (%rax),%rax
  800420c5ab:	48 89 c6             	mov    %rax,%rsi
  800420c5ae:	48 bf 13 a3 21 04 80 	movabs $0x800421a313,%rdi
  800420c5b5:	00 00 00 
  800420c5b8:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c5bd:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  800420c5c4:	00 00 00 
  800420c5c7:	ff d2                	callq  *%rdx
	cprintf("  r14  0x%08x\n", regs->reg_r14);
  800420c5c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c5cd:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420c5d1:	48 89 c6             	mov    %rax,%rsi
  800420c5d4:	48 bf 22 a3 21 04 80 	movabs $0x800421a322,%rdi
  800420c5db:	00 00 00 
  800420c5de:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c5e3:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  800420c5ea:	00 00 00 
  800420c5ed:	ff d2                	callq  *%rdx
	cprintf("  r13  0x%08x\n", regs->reg_r13);
  800420c5ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c5f3:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420c5f7:	48 89 c6             	mov    %rax,%rsi
  800420c5fa:	48 bf 31 a3 21 04 80 	movabs $0x800421a331,%rdi
  800420c601:	00 00 00 
  800420c604:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c609:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  800420c610:	00 00 00 
  800420c613:	ff d2                	callq  *%rdx
	cprintf("  r12  0x%08x\n", regs->reg_r12);
  800420c615:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c619:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420c61d:	48 89 c6             	mov    %rax,%rsi
  800420c620:	48 bf 40 a3 21 04 80 	movabs $0x800421a340,%rdi
  800420c627:	00 00 00 
  800420c62a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c62f:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  800420c636:	00 00 00 
  800420c639:	ff d2                	callq  *%rdx
	cprintf("  r11  0x%08x\n", regs->reg_r11);
  800420c63b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c63f:	48 8b 40 20          	mov    0x20(%rax),%rax
  800420c643:	48 89 c6             	mov    %rax,%rsi
  800420c646:	48 bf 4f a3 21 04 80 	movabs $0x800421a34f,%rdi
  800420c64d:	00 00 00 
  800420c650:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c655:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  800420c65c:	00 00 00 
  800420c65f:	ff d2                	callq  *%rdx
	cprintf("  r10  0x%08x\n", regs->reg_r10);
  800420c661:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c665:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420c669:	48 89 c6             	mov    %rax,%rsi
  800420c66c:	48 bf 5e a3 21 04 80 	movabs $0x800421a35e,%rdi
  800420c673:	00 00 00 
  800420c676:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c67b:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  800420c682:	00 00 00 
  800420c685:	ff d2                	callq  *%rdx
	cprintf("  r9  0x%08x\n", regs->reg_r9);
  800420c687:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c68b:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420c68f:	48 89 c6             	mov    %rax,%rsi
  800420c692:	48 bf 6d a3 21 04 80 	movabs $0x800421a36d,%rdi
  800420c699:	00 00 00 
  800420c69c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c6a1:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  800420c6a8:	00 00 00 
  800420c6ab:	ff d2                	callq  *%rdx
	cprintf("  r8  0x%08x\n", regs->reg_r8);
  800420c6ad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c6b1:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420c6b5:	48 89 c6             	mov    %rax,%rsi
  800420c6b8:	48 bf 7b a3 21 04 80 	movabs $0x800421a37b,%rdi
  800420c6bf:	00 00 00 
  800420c6c2:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c6c7:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  800420c6ce:	00 00 00 
  800420c6d1:	ff d2                	callq  *%rdx
	cprintf("  rdi  0x%08x\n", regs->reg_rdi);
  800420c6d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c6d7:	48 8b 40 48          	mov    0x48(%rax),%rax
  800420c6db:	48 89 c6             	mov    %rax,%rsi
  800420c6de:	48 bf 89 a3 21 04 80 	movabs $0x800421a389,%rdi
  800420c6e5:	00 00 00 
  800420c6e8:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c6ed:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  800420c6f4:	00 00 00 
  800420c6f7:	ff d2                	callq  *%rdx
	cprintf("  rsi  0x%08x\n", regs->reg_rsi);
  800420c6f9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c6fd:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420c701:	48 89 c6             	mov    %rax,%rsi
  800420c704:	48 bf 98 a3 21 04 80 	movabs $0x800421a398,%rdi
  800420c70b:	00 00 00 
  800420c70e:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c713:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  800420c71a:	00 00 00 
  800420c71d:	ff d2                	callq  *%rdx
	cprintf("  rbp  0x%08x\n", regs->reg_rbp);
  800420c71f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c723:	48 8b 40 50          	mov    0x50(%rax),%rax
  800420c727:	48 89 c6             	mov    %rax,%rsi
  800420c72a:	48 bf a7 a3 21 04 80 	movabs $0x800421a3a7,%rdi
  800420c731:	00 00 00 
  800420c734:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c739:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  800420c740:	00 00 00 
  800420c743:	ff d2                	callq  *%rdx
	cprintf("  rbx  0x%08x\n", regs->reg_rbx);
  800420c745:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c749:	48 8b 40 68          	mov    0x68(%rax),%rax
  800420c74d:	48 89 c6             	mov    %rax,%rsi
  800420c750:	48 bf b6 a3 21 04 80 	movabs $0x800421a3b6,%rdi
  800420c757:	00 00 00 
  800420c75a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c75f:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  800420c766:	00 00 00 
  800420c769:	ff d2                	callq  *%rdx
	cprintf("  rdx  0x%08x\n", regs->reg_rdx);
  800420c76b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c76f:	48 8b 40 58          	mov    0x58(%rax),%rax
  800420c773:	48 89 c6             	mov    %rax,%rsi
  800420c776:	48 bf c5 a3 21 04 80 	movabs $0x800421a3c5,%rdi
  800420c77d:	00 00 00 
  800420c780:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c785:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  800420c78c:	00 00 00 
  800420c78f:	ff d2                	callq  *%rdx
	cprintf("  rcx  0x%08x\n", regs->reg_rcx);
  800420c791:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c795:	48 8b 40 60          	mov    0x60(%rax),%rax
  800420c799:	48 89 c6             	mov    %rax,%rsi
  800420c79c:	48 bf d4 a3 21 04 80 	movabs $0x800421a3d4,%rdi
  800420c7a3:	00 00 00 
  800420c7a6:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c7ab:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  800420c7b2:	00 00 00 
  800420c7b5:	ff d2                	callq  *%rdx
	cprintf("  rax  0x%08x\n", regs->reg_rax);
  800420c7b7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c7bb:	48 8b 40 70          	mov    0x70(%rax),%rax
  800420c7bf:	48 89 c6             	mov    %rax,%rsi
  800420c7c2:	48 bf e3 a3 21 04 80 	movabs $0x800421a3e3,%rdi
  800420c7c9:	00 00 00 
  800420c7cc:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c7d1:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  800420c7d8:	00 00 00 
  800420c7db:	ff d2                	callq  *%rdx
}
  800420c7dd:	c9                   	leaveq 
  800420c7de:	c3                   	retq   

000000800420c7df <trap_dispatch>:

static void
trap_dispatch(struct Trapframe *tf)
{
  800420c7df:	55                   	push   %rbp
  800420c7e0:	48 89 e5             	mov    %rsp,%rbp
  800420c7e3:	48 83 ec 10          	sub    $0x10,%rsp
  800420c7e7:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)

	// Handle processor exceptions.
	// LAB 3: Your code here.

	if (tf->tf_trapno == T_PGFLT) {
  800420c7eb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c7ef:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c7f6:	48 83 f8 0e          	cmp    $0xe,%rax
  800420c7fa:	75 18                	jne    800420c814 <trap_dispatch+0x35>
		page_fault_handler(tf);
  800420c7fc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c800:	48 89 c7             	mov    %rax,%rdi
  800420c803:	48 b8 5d cd 20 04 80 	movabs $0x800420cd5d,%rax
  800420c80a:	00 00 00 
  800420c80d:	ff d0                	callq  *%rax
		return;
  800420c80f:	e9 ea 01 00 00       	jmpq   800420c9fe <trap_dispatch+0x21f>
	}
	if (tf->tf_trapno == T_SYSCALL) {
  800420c814:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c818:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c81f:	48 83 f8 30          	cmp    $0x30,%rax
  800420c823:	75 55                	jne    800420c87a <trap_dispatch+0x9b>
		// handle system call
		tf->tf_regs.reg_rax =
			syscall(tf->tf_regs.reg_rax,
  800420c825:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c829:	4c 8b 40 40          	mov    0x40(%rax),%r8
  800420c82d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c831:	48 8b 78 48          	mov    0x48(%rax),%rdi
  800420c835:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c839:	48 8b 48 68          	mov    0x68(%rax),%rcx
  800420c83d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c841:	48 8b 50 60          	mov    0x60(%rax),%rdx
  800420c845:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c849:	48 8b 70 58          	mov    0x58(%rax),%rsi
  800420c84d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c851:	48 8b 40 70          	mov    0x70(%rax),%rax
  800420c855:	4d 89 c1             	mov    %r8,%r9
  800420c858:	49 89 f8             	mov    %rdi,%r8
  800420c85b:	48 89 c7             	mov    %rax,%rdi
  800420c85e:	48 b8 99 e6 20 04 80 	movabs $0x800420e699,%rax
  800420c865:	00 00 00 
  800420c868:	ff d0                	callq  *%rax
		page_fault_handler(tf);
		return;
	}
	if (tf->tf_trapno == T_SYSCALL) {
		// handle system call
		tf->tf_regs.reg_rax =
  800420c86a:	48 89 c2             	mov    %rax,%rdx
  800420c86d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c871:	48 89 50 70          	mov    %rdx,0x70(%rax)
				tf->tf_regs.reg_rdx,
				tf->tf_regs.reg_rcx,
				tf->tf_regs.reg_rbx,
				tf->tf_regs.reg_rdi,
				tf->tf_regs.reg_rsi);
		return;
  800420c875:	e9 84 01 00 00       	jmpq   800420c9fe <trap_dispatch+0x21f>
	}
	if (tf->tf_trapno == T_BRKPT) {
  800420c87a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c87e:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c885:	48 83 f8 03          	cmp    $0x3,%rax
  800420c889:	75 18                	jne    800420c8a3 <trap_dispatch+0xc4>
		// Invoke the kernel monitor.
		monitor(tf);
  800420c88b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c88f:	48 89 c7             	mov    %rax,%rdi
  800420c892:	48 b8 99 1b 20 04 80 	movabs $0x8004201b99,%rax
  800420c899:	00 00 00 
  800420c89c:	ff d0                	callq  *%rax
		return;
  800420c89e:	e9 5b 01 00 00       	jmpq   800420c9fe <trap_dispatch+0x21f>


	// Handle spurious interrupts
	// The hardware sometimes raises these because of noise on the
	// IRQ line or other reasons. We don't care.
	if (tf->tf_trapno == IRQ_OFFSET + IRQ_SPURIOUS) {
  800420c8a3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c8a7:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c8ae:	48 83 f8 27          	cmp    $0x27,%rax
  800420c8b2:	75 33                	jne    800420c8e7 <trap_dispatch+0x108>
		cprintf("Spurious interrupt on irq 7\n");
  800420c8b4:	48 bf f2 a3 21 04 80 	movabs $0x800421a3f2,%rdi
  800420c8bb:	00 00 00 
  800420c8be:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c8c3:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  800420c8ca:	00 00 00 
  800420c8cd:	ff d2                	callq  *%rdx
		print_trapframe(tf);
  800420c8cf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c8d3:	48 89 c7             	mov    %rax,%rdi
  800420c8d6:	48 b8 87 c2 20 04 80 	movabs $0x800420c287,%rax
  800420c8dd:	00 00 00 
  800420c8e0:	ff d0                	callq  *%rax
		return;
  800420c8e2:	e9 17 01 00 00       	jmpq   800420c9fe <trap_dispatch+0x21f>
	// Add time tick increment to clock interrupts.
	// Be careful! In multiprocessors, clock interrupts are
	// triggered on every CPU.
	// LAB 6: Your code here.

	if (tf->tf_trapno == IRQ_OFFSET + IRQ_TIMER) {
  800420c8e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c8eb:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c8f2:	48 83 f8 20          	cmp    $0x20,%rax
  800420c8f6:	75 34                	jne    800420c92c <trap_dispatch+0x14d>
		// irq 0 -- clock interrupt

		if (cpunum() == 0)
  800420c8f8:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420c8ff:	00 00 00 
  800420c902:	ff d0                	callq  *%rax
  800420c904:	85 c0                	test   %eax,%eax
  800420c906:	75 0c                	jne    800420c914 <trap_dispatch+0x135>
			time_tick();
  800420c908:	48 b8 0e 8c 21 04 80 	movabs $0x8004218c0e,%rax
  800420c90f:	00 00 00 
  800420c912:	ff d0                	callq  *%rax

		lapic_eoi();
  800420c914:	48 b8 07 74 21 04 80 	movabs $0x8004217407,%rax
  800420c91b:	00 00 00 
  800420c91e:	ff d0                	callq  *%rax

		sched_yield();
  800420c920:	48 b8 d5 d2 20 04 80 	movabs $0x800420d2d5,%rax
  800420c927:	00 00 00 
  800420c92a:	ff d0                	callq  *%rax
	}

	// Handle keyboard and serial interrupts.
	// LAB 5: Your code here.

	if (tf->tf_trapno == IRQ_OFFSET + IRQ_KBD) {
  800420c92c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c930:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c937:	48 83 f8 21          	cmp    $0x21,%rax
  800420c93b:	75 11                	jne    800420c94e <trap_dispatch+0x16f>
		kbd_intr();
  800420c93d:	48 b8 13 11 20 04 80 	movabs $0x8004201113,%rax
  800420c944:	00 00 00 
  800420c947:	ff d0                	callq  *%rax
		return;
  800420c949:	e9 b0 00 00 00       	jmpq   800420c9fe <trap_dispatch+0x21f>
	}
	if (tf->tf_trapno == IRQ_OFFSET + IRQ_SERIAL) {
  800420c94e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c952:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c959:	48 83 f8 24          	cmp    $0x24,%rax
  800420c95d:	75 11                	jne    800420c970 <trap_dispatch+0x191>
		serial_intr();
  800420c95f:	48 b8 98 08 20 04 80 	movabs $0x8004200898,%rax
  800420c966:	00 00 00 
  800420c969:	ff d0                	callq  *%rax
		return;
  800420c96b:	e9 8e 00 00 00       	jmpq   800420c9fe <trap_dispatch+0x21f>
	}


	// Unexpected trap: The user process or the kernel has a bug.
	print_trapframe(tf);
  800420c970:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c974:	48 89 c7             	mov    %rax,%rdi
  800420c977:	48 b8 87 c2 20 04 80 	movabs $0x800420c287,%rax
  800420c97e:	00 00 00 
  800420c981:	ff d0                	callq  *%rax
	if (tf->tf_cs == GD_KT)
  800420c983:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c987:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420c98e:	66 83 f8 08          	cmp    $0x8,%ax
  800420c992:	75 2a                	jne    800420c9be <trap_dispatch+0x1df>
		panic("unhandled trap in kernel");
  800420c994:	48 ba 0f a4 21 04 80 	movabs $0x800421a40f,%rdx
  800420c99b:	00 00 00 
  800420c99e:	be 47 01 00 00       	mov    $0x147,%esi
  800420c9a3:	48 bf 28 a4 21 04 80 	movabs $0x800421a428,%rdi
  800420c9aa:	00 00 00 
  800420c9ad:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c9b2:	48 b9 e4 05 20 04 80 	movabs $0x80042005e4,%rcx
  800420c9b9:	00 00 00 
  800420c9bc:	ff d1                	callq  *%rcx
	else {
		env_destroy(curenv);
  800420c9be:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420c9c5:	00 00 00 
  800420c9c8:	ff d0                	callq  *%rax
  800420c9ca:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420c9d1:	00 00 00 
  800420c9d4:	48 98                	cltq   
  800420c9d6:	48 c1 e0 03          	shl    $0x3,%rax
  800420c9da:	48 89 c1             	mov    %rax,%rcx
  800420c9dd:	48 c1 e1 04          	shl    $0x4,%rcx
  800420c9e1:	48 01 c8             	add    %rcx,%rax
  800420c9e4:	48 01 d0             	add    %rdx,%rax
  800420c9e7:	48 83 c0 08          	add    $0x8,%rax
  800420c9eb:	48 8b 00             	mov    (%rax),%rax
  800420c9ee:	48 89 c7             	mov    %rax,%rdi
  800420c9f1:	48 b8 78 8e 20 04 80 	movabs $0x8004208e78,%rax
  800420c9f8:	00 00 00 
  800420c9fb:	ff d0                	callq  *%rax
		return;
  800420c9fd:	90                   	nop
	}
}
  800420c9fe:	c9                   	leaveq 
  800420c9ff:	c3                   	retq   

000000800420ca00 <trap>:

void
trap(struct Trapframe *tf)
{
  800420ca00:	55                   	push   %rbp
  800420ca01:	48 89 e5             	mov    %rsp,%rbp
  800420ca04:	48 83 ec 20          	sub    $0x20,%rsp
  800420ca08:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	//struct Trapframe *tf = &tf_;
	// The environment may have set DF and some versions
	// of GCC rely on DF being clear
	asm volatile("cld" ::: "cc");
  800420ca0c:	fc                   	cld    


	// Halt the CPU if some other CPU has called panic()
	extern char *panicstr;
	if (panicstr)
  800420ca0d:	48 b8 d0 c5 69 04 80 	movabs $0x800469c5d0,%rax
  800420ca14:	00 00 00 
  800420ca17:	48 8b 00             	mov    (%rax),%rax
  800420ca1a:	48 85 c0             	test   %rax,%rax
  800420ca1d:	74 01                	je     800420ca20 <trap+0x20>
		asm volatile("hlt");
  800420ca1f:	f4                   	hlt    

	// Re-acqurie the big kernel lock if we were halted in
	// sched_yield()
	if (xchg(&thiscpu->cpu_status, CPU_STARTED) == CPU_HALTED)
  800420ca20:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420ca27:	00 00 00 
  800420ca2a:	ff d0                	callq  *%rax
  800420ca2c:	48 98                	cltq   
  800420ca2e:	48 c1 e0 03          	shl    $0x3,%rax
  800420ca32:	48 89 c2             	mov    %rax,%rdx
  800420ca35:	48 c1 e2 04          	shl    $0x4,%rdx
  800420ca39:	48 01 d0             	add    %rdx,%rax
  800420ca3c:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420ca43:	00 00 00 
  800420ca46:	48 01 d0             	add    %rdx,%rax
  800420ca49:	48 83 c0 04          	add    $0x4,%rax
  800420ca4d:	be 01 00 00 00       	mov    $0x1,%esi
  800420ca52:	48 89 c7             	mov    %rax,%rdi
  800420ca55:	48 b8 68 96 20 04 80 	movabs $0x8004209668,%rax
  800420ca5c:	00 00 00 
  800420ca5f:	ff d0                	callq  *%rax
  800420ca61:	83 f8 02             	cmp    $0x2,%eax
  800420ca64:	75 0c                	jne    800420ca72 <trap+0x72>
		lock_kernel();
  800420ca66:	48 b8 8d 96 20 04 80 	movabs $0x800420968d,%rax
  800420ca6d:	00 00 00 
  800420ca70:	ff d0                	callq  *%rax

static __inline uint64_t
read_eflags(void)
{
	uint64_t rflags;
	__asm __volatile("pushfq; popq %0" : "=r" (rflags));
  800420ca72:	9c                   	pushfq 
  800420ca73:	58                   	pop    %rax
  800420ca74:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return rflags;
  800420ca78:	48 8b 45 f8          	mov    -0x8(%rbp),%rax

	// Check that interrupts are disabled.  If this assertion
	// fails, DO NOT be tempted to fix it by inserting a "cli" in
	// the interrupt path.
	assert(!(read_eflags() & FL_IF));
  800420ca7c:	25 00 02 00 00       	and    $0x200,%eax
  800420ca81:	48 85 c0             	test   %rax,%rax
  800420ca84:	74 35                	je     800420cabb <trap+0xbb>
  800420ca86:	48 b9 34 a4 21 04 80 	movabs $0x800421a434,%rcx
  800420ca8d:	00 00 00 
  800420ca90:	48 ba 4d a4 21 04 80 	movabs $0x800421a44d,%rdx
  800420ca97:	00 00 00 
  800420ca9a:	be 64 01 00 00       	mov    $0x164,%esi
  800420ca9f:	48 bf 28 a4 21 04 80 	movabs $0x800421a428,%rdi
  800420caa6:	00 00 00 
  800420caa9:	b8 00 00 00 00       	mov    $0x0,%eax
  800420caae:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  800420cab5:	00 00 00 
  800420cab8:	41 ff d0             	callq  *%r8


	if ((tf->tf_cs & 3) == 3) {
  800420cabb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cabf:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420cac6:	0f b7 c0             	movzwl %ax,%eax
  800420cac9:	83 e0 03             	and    $0x3,%eax
  800420cacc:	83 f8 03             	cmp    $0x3,%eax
  800420cacf:	0f 85 a9 01 00 00    	jne    800420cc7e <trap+0x27e>

		// Acquire the big kernel lock before doing any
		// serious kernel work.
		// LAB 4: Your code here.

		lock_kernel();
  800420cad5:	48 b8 8d 96 20 04 80 	movabs $0x800420968d,%rax
  800420cadc:	00 00 00 
  800420cadf:	ff d0                	callq  *%rax

		assert(curenv);
  800420cae1:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420cae8:	00 00 00 
  800420caeb:	ff d0                	callq  *%rax
  800420caed:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420caf4:	00 00 00 
  800420caf7:	48 98                	cltq   
  800420caf9:	48 c1 e0 03          	shl    $0x3,%rax
  800420cafd:	48 89 c1             	mov    %rax,%rcx
  800420cb00:	48 c1 e1 04          	shl    $0x4,%rcx
  800420cb04:	48 01 c8             	add    %rcx,%rax
  800420cb07:	48 01 d0             	add    %rdx,%rax
  800420cb0a:	48 83 c0 08          	add    $0x8,%rax
  800420cb0e:	48 8b 00             	mov    (%rax),%rax
  800420cb11:	48 85 c0             	test   %rax,%rax
  800420cb14:	75 35                	jne    800420cb4b <trap+0x14b>
  800420cb16:	48 b9 62 a4 21 04 80 	movabs $0x800421a462,%rcx
  800420cb1d:	00 00 00 
  800420cb20:	48 ba 4d a4 21 04 80 	movabs $0x800421a44d,%rdx
  800420cb27:	00 00 00 
  800420cb2a:	be 70 01 00 00       	mov    $0x170,%esi
  800420cb2f:	48 bf 28 a4 21 04 80 	movabs $0x800421a428,%rdi
  800420cb36:	00 00 00 
  800420cb39:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cb3e:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  800420cb45:	00 00 00 
  800420cb48:	41 ff d0             	callq  *%r8


		// Garbage collect if current enviroment is a zombie
		if (curenv->env_status == ENV_DYING) {
  800420cb4b:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420cb52:	00 00 00 
  800420cb55:	ff d0                	callq  *%rax
  800420cb57:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420cb5e:	00 00 00 
  800420cb61:	48 98                	cltq   
  800420cb63:	48 c1 e0 03          	shl    $0x3,%rax
  800420cb67:	48 89 c1             	mov    %rax,%rcx
  800420cb6a:	48 c1 e1 04          	shl    $0x4,%rcx
  800420cb6e:	48 01 c8             	add    %rcx,%rax
  800420cb71:	48 01 d0             	add    %rdx,%rax
  800420cb74:	48 83 c0 08          	add    $0x8,%rax
  800420cb78:	48 8b 00             	mov    (%rax),%rax
  800420cb7b:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420cb81:	83 f8 01             	cmp    $0x1,%eax
  800420cb84:	75 7f                	jne    800420cc05 <trap+0x205>
			env_free(curenv);
  800420cb86:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420cb8d:	00 00 00 
  800420cb90:	ff d0                	callq  *%rax
  800420cb92:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420cb99:	00 00 00 
  800420cb9c:	48 98                	cltq   
  800420cb9e:	48 c1 e0 03          	shl    $0x3,%rax
  800420cba2:	48 89 c1             	mov    %rax,%rcx
  800420cba5:	48 c1 e1 04          	shl    $0x4,%rcx
  800420cba9:	48 01 c8             	add    %rcx,%rax
  800420cbac:	48 01 d0             	add    %rdx,%rax
  800420cbaf:	48 83 c0 08          	add    $0x8,%rax
  800420cbb3:	48 8b 00             	mov    (%rax),%rax
  800420cbb6:	48 89 c7             	mov    %rax,%rdi
  800420cbb9:	48 b8 ec 89 20 04 80 	movabs $0x80042089ec,%rax
  800420cbc0:	00 00 00 
  800420cbc3:	ff d0                	callq  *%rax
			curenv = NULL;
  800420cbc5:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420cbcc:	00 00 00 
  800420cbcf:	ff d0                	callq  *%rax
  800420cbd1:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420cbd8:	00 00 00 
  800420cbdb:	48 98                	cltq   
  800420cbdd:	48 c1 e0 03          	shl    $0x3,%rax
  800420cbe1:	48 89 c1             	mov    %rax,%rcx
  800420cbe4:	48 c1 e1 04          	shl    $0x4,%rcx
  800420cbe8:	48 01 c8             	add    %rcx,%rax
  800420cbeb:	48 01 d0             	add    %rdx,%rax
  800420cbee:	48 83 c0 08          	add    $0x8,%rax
  800420cbf2:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			sched_yield();
  800420cbf9:	48 b8 d5 d2 20 04 80 	movabs $0x800420d2d5,%rax
  800420cc00:	00 00 00 
  800420cc03:	ff d0                	callq  *%rax


		// Copy trap frame (which is currently on the stack)
		// into 'curenv->env_tf', so that running the environment
		// will restart at the trap point.
		curenv->env_tf = *tf;
  800420cc05:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420cc0c:	00 00 00 
  800420cc0f:	ff d0                	callq  *%rax
  800420cc11:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420cc18:	00 00 00 
  800420cc1b:	48 98                	cltq   
  800420cc1d:	48 c1 e0 03          	shl    $0x3,%rax
  800420cc21:	48 89 c1             	mov    %rax,%rcx
  800420cc24:	48 c1 e1 04          	shl    $0x4,%rcx
  800420cc28:	48 01 c8             	add    %rcx,%rax
  800420cc2b:	48 01 d0             	add    %rdx,%rax
  800420cc2e:	48 83 c0 08          	add    $0x8,%rax
  800420cc32:	48 8b 10             	mov    (%rax),%rdx
  800420cc35:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cc39:	48 89 c6             	mov    %rax,%rsi
  800420cc3c:	b8 18 00 00 00       	mov    $0x18,%eax
  800420cc41:	48 89 d7             	mov    %rdx,%rdi
  800420cc44:	48 89 c1             	mov    %rax,%rcx
  800420cc47:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
		// The trapframe on the stack should be ignored from here on.
		tf = &curenv->env_tf;
  800420cc4a:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420cc51:	00 00 00 
  800420cc54:	ff d0                	callq  *%rax
  800420cc56:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420cc5d:	00 00 00 
  800420cc60:	48 98                	cltq   
  800420cc62:	48 c1 e0 03          	shl    $0x3,%rax
  800420cc66:	48 89 c1             	mov    %rax,%rcx
  800420cc69:	48 c1 e1 04          	shl    $0x4,%rcx
  800420cc6d:	48 01 c8             	add    %rcx,%rax
  800420cc70:	48 01 d0             	add    %rdx,%rax
  800420cc73:	48 83 c0 08          	add    $0x8,%rax
  800420cc77:	48 8b 00             	mov    (%rax),%rax
  800420cc7a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	}


	// Record that tf is the last real trapframe so
	// print_trapframe can print some additional information.
	last_tf = tf;
  800420cc7e:	48 b8 90 e2 49 04 80 	movabs $0x800449e290,%rax
  800420cc85:	00 00 00 
  800420cc88:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420cc8c:	48 89 10             	mov    %rdx,(%rax)

	// Dispatch based on what type of trap occurred
	trap_dispatch(tf);
  800420cc8f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cc93:	48 89 c7             	mov    %rax,%rdi
  800420cc96:	48 b8 df c7 20 04 80 	movabs $0x800420c7df,%rax
  800420cc9d:	00 00 00 
  800420cca0:	ff d0                	callq  *%rax


	// If we made it to this point, then no other environment was
	// scheduled, so we should return to the current environment
	// if doing so makes sense.
	if (curenv && curenv->env_status == ENV_RUNNING)
  800420cca2:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420cca9:	00 00 00 
  800420ccac:	ff d0                	callq  *%rax
  800420ccae:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420ccb5:	00 00 00 
  800420ccb8:	48 98                	cltq   
  800420ccba:	48 c1 e0 03          	shl    $0x3,%rax
  800420ccbe:	48 89 c1             	mov    %rax,%rcx
  800420ccc1:	48 c1 e1 04          	shl    $0x4,%rcx
  800420ccc5:	48 01 c8             	add    %rcx,%rax
  800420ccc8:	48 01 d0             	add    %rdx,%rax
  800420cccb:	48 83 c0 08          	add    $0x8,%rax
  800420cccf:	48 8b 00             	mov    (%rax),%rax
  800420ccd2:	48 85 c0             	test   %rax,%rax
  800420ccd5:	74 7a                	je     800420cd51 <trap+0x351>
  800420ccd7:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420ccde:	00 00 00 
  800420cce1:	ff d0                	callq  *%rax
  800420cce3:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420ccea:	00 00 00 
  800420cced:	48 98                	cltq   
  800420ccef:	48 c1 e0 03          	shl    $0x3,%rax
  800420ccf3:	48 89 c1             	mov    %rax,%rcx
  800420ccf6:	48 c1 e1 04          	shl    $0x4,%rcx
  800420ccfa:	48 01 c8             	add    %rcx,%rax
  800420ccfd:	48 01 d0             	add    %rdx,%rax
  800420cd00:	48 83 c0 08          	add    $0x8,%rax
  800420cd04:	48 8b 00             	mov    (%rax),%rax
  800420cd07:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420cd0d:	83 f8 03             	cmp    $0x3,%eax
  800420cd10:	75 3f                	jne    800420cd51 <trap+0x351>
		env_run(curenv);
  800420cd12:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420cd19:	00 00 00 
  800420cd1c:	ff d0                	callq  *%rax
  800420cd1e:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420cd25:	00 00 00 
  800420cd28:	48 98                	cltq   
  800420cd2a:	48 c1 e0 03          	shl    $0x3,%rax
  800420cd2e:	48 89 c1             	mov    %rax,%rcx
  800420cd31:	48 c1 e1 04          	shl    $0x4,%rcx
  800420cd35:	48 01 c8             	add    %rcx,%rax
  800420cd38:	48 01 d0             	add    %rdx,%rax
  800420cd3b:	48 83 c0 08          	add    $0x8,%rax
  800420cd3f:	48 8b 00             	mov    (%rax),%rax
  800420cd42:	48 89 c7             	mov    %rax,%rdi
  800420cd45:	48 b8 43 90 20 04 80 	movabs $0x8004209043,%rax
  800420cd4c:	00 00 00 
  800420cd4f:	ff d0                	callq  *%rax
	else
		sched_yield();
  800420cd51:	48 b8 d5 d2 20 04 80 	movabs $0x800420d2d5,%rax
  800420cd58:	00 00 00 
  800420cd5b:	ff d0                	callq  *%rax

000000800420cd5d <page_fault_handler>:
}


void
page_fault_handler(struct Trapframe *tf)
{
  800420cd5d:	55                   	push   %rbp
  800420cd5e:	48 89 e5             	mov    %rsp,%rbp
  800420cd61:	53                   	push   %rbx
  800420cd62:	48 83 ec 38          	sub    $0x38,%rsp
  800420cd66:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)

static __inline uint64_t
rcr2(void)
{
	uint64_t val;
	__asm __volatile("movq %%cr2,%0" : "=r" (val));
  800420cd6a:	0f 20 d0             	mov    %cr2,%rax
  800420cd6d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	return val;
  800420cd71:	48 8b 45 d8          	mov    -0x28(%rbp),%rax

	struct UTrapframe *utf;


	// Read processor's CR2 register to find the faulting address
	fault_va = rcr2();
  800420cd75:	48 89 45 e0          	mov    %rax,-0x20(%rbp)


	if ((tf->tf_cs & 3) == 0) {
  800420cd79:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cd7d:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420cd84:	0f b7 c0             	movzwl %ax,%eax
  800420cd87:	83 e0 03             	and    $0x3,%eax
  800420cd8a:	85 c0                	test   %eax,%eax
  800420cd8c:	75 3d                	jne    800420cdcb <page_fault_handler+0x6e>
		print_trapframe(tf);
  800420cd8e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cd92:	48 89 c7             	mov    %rax,%rdi
  800420cd95:	48 b8 87 c2 20 04 80 	movabs $0x800420c287,%rax
  800420cd9c:	00 00 00 
  800420cd9f:	ff d0                	callq  *%rax
		panic("page fault");
  800420cda1:	48 ba 69 a4 21 04 80 	movabs $0x800421a469,%rdx
  800420cda8:	00 00 00 
  800420cdab:	be a5 01 00 00       	mov    $0x1a5,%esi
  800420cdb0:	48 bf 28 a4 21 04 80 	movabs $0x800421a428,%rdi
  800420cdb7:	00 00 00 
  800420cdba:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cdbf:	48 b9 e4 05 20 04 80 	movabs $0x80042005e4,%rcx
  800420cdc6:	00 00 00 
  800420cdc9:	ff d1                	callq  *%rcx
	}



	// See if the environment has installed a user page fault handler.
	if (curenv->env_pgfault_upcall == 0) {
  800420cdcb:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420cdd2:	00 00 00 
  800420cdd5:	ff d0                	callq  *%rax
  800420cdd7:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420cdde:	00 00 00 
  800420cde1:	48 98                	cltq   
  800420cde3:	48 c1 e0 03          	shl    $0x3,%rax
  800420cde7:	48 89 c1             	mov    %rax,%rcx
  800420cdea:	48 c1 e1 04          	shl    $0x4,%rcx
  800420cdee:	48 01 c8             	add    %rcx,%rax
  800420cdf1:	48 01 d0             	add    %rdx,%rax
  800420cdf4:	48 83 c0 08          	add    $0x8,%rax
  800420cdf8:	48 8b 00             	mov    (%rax),%rax
  800420cdfb:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
  800420ce02:	48 85 c0             	test   %rax,%rax
  800420ce05:	0f 85 b8 00 00 00    	jne    800420cec3 <page_fault_handler+0x166>
		cprintf("[%08x] user fault va %08x ip %08x\n",
  800420ce0b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ce0f:	48 8b 98 98 00 00 00 	mov    0x98(%rax),%rbx
			curenv->env_id, fault_va, tf->tf_rip);
  800420ce16:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420ce1d:	00 00 00 
  800420ce20:	ff d0                	callq  *%rax
  800420ce22:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420ce29:	00 00 00 
  800420ce2c:	48 98                	cltq   
  800420ce2e:	48 c1 e0 03          	shl    $0x3,%rax
  800420ce32:	48 89 c1             	mov    %rax,%rcx
  800420ce35:	48 c1 e1 04          	shl    $0x4,%rcx
  800420ce39:	48 01 c8             	add    %rcx,%rax
  800420ce3c:	48 01 d0             	add    %rdx,%rax
  800420ce3f:	48 83 c0 08          	add    $0x8,%rax
  800420ce43:	48 8b 00             	mov    (%rax),%rax



	// See if the environment has installed a user page fault handler.
	if (curenv->env_pgfault_upcall == 0) {
		cprintf("[%08x] user fault va %08x ip %08x\n",
  800420ce46:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420ce4c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420ce50:	48 89 d9             	mov    %rbx,%rcx
  800420ce53:	89 c6                	mov    %eax,%esi
  800420ce55:	48 bf 78 a4 21 04 80 	movabs $0x800421a478,%rdi
  800420ce5c:	00 00 00 
  800420ce5f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ce64:	49 b8 90 95 20 04 80 	movabs $0x8004209590,%r8
  800420ce6b:	00 00 00 
  800420ce6e:	41 ff d0             	callq  *%r8
			curenv->env_id, fault_va, tf->tf_rip);
		print_trapframe(tf);
  800420ce71:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ce75:	48 89 c7             	mov    %rax,%rdi
  800420ce78:	48 b8 87 c2 20 04 80 	movabs $0x800420c287,%rax
  800420ce7f:	00 00 00 
  800420ce82:	ff d0                	callq  *%rax
		env_destroy(curenv);
  800420ce84:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420ce8b:	00 00 00 
  800420ce8e:	ff d0                	callq  *%rax
  800420ce90:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420ce97:	00 00 00 
  800420ce9a:	48 98                	cltq   
  800420ce9c:	48 c1 e0 03          	shl    $0x3,%rax
  800420cea0:	48 89 c1             	mov    %rax,%rcx
  800420cea3:	48 c1 e1 04          	shl    $0x4,%rcx
  800420cea7:	48 01 c8             	add    %rcx,%rax
  800420ceaa:	48 01 d0             	add    %rdx,%rax
  800420cead:	48 83 c0 08          	add    $0x8,%rax
  800420ceb1:	48 8b 00             	mov    (%rax),%rax
  800420ceb4:	48 89 c7             	mov    %rax,%rdi
  800420ceb7:	48 b8 78 8e 20 04 80 	movabs $0x8004208e78,%rax
  800420cebe:	00 00 00 
  800420cec1:	ff d0                	callq  *%rax
	}

	// Decide where to push our exception stack frame.
	if (tf->tf_rsp >= UXSTACKTOP - PGSIZE && tf->tf_rsp < UXSTACKTOP) {
  800420cec3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cec7:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420cece:	b8 ff ef 7f ef       	mov    $0xef7fefff,%eax
  800420ced3:	48 39 c2             	cmp    %rax,%rdx
  800420ced6:	76 2c                	jbe    800420cf04 <page_fault_handler+0x1a7>
  800420ced8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cedc:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420cee3:	b8 ff ff 7f ef       	mov    $0xef7fffff,%eax
  800420cee8:	48 39 c2             	cmp    %rax,%rdx
  800420ceeb:	77 17                	ja     800420cf04 <page_fault_handler+0x1a7>
		// The user's ESP is ALREADY in the user exception stack area,
		// so push the new frame on the exception stack,
		// preserving the existing exception stack contents.
		utf = (struct UTrapframe*)(tf->tf_rsp
  800420ceed:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cef1:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
					   - sizeof(struct UTrapframe)
					   // Save a spare word for return
					   - 8);
  800420cef8:	48 2d a8 00 00 00    	sub    $0xa8,%rax
	// Decide where to push our exception stack frame.
	if (tf->tf_rsp >= UXSTACKTOP - PGSIZE && tf->tf_rsp < UXSTACKTOP) {
		// The user's ESP is ALREADY in the user exception stack area,
		// so push the new frame on the exception stack,
		// preserving the existing exception stack contents.
		utf = (struct UTrapframe*)(tf->tf_rsp
  800420cefe:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420cf02:	eb 09                	jmp    800420cf0d <page_fault_handler+0x1b0>
		// The user's ESP is NOT in the user exception stack area,
		// so it's presumably pointing to a normal user stack
		// and the user exception stack is not in use.
		// Therefore, switch the user's ESP onto the exception stack
		// and push the new frame at the top of the exception stack.
		utf = (struct UTrapframe*)(UXSTACKTOP
  800420cf04:	b8 60 ff 7f ef       	mov    $0xef7fff60,%eax
  800420cf09:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	}

	// If we can't write to the exception stack,
	// it means the user environment is seriously screwed up,
	// so just terminate it.
	user_mem_assert(curenv, utf, sizeof(struct UTrapframe), PTE_U | PTE_W);
  800420cf0d:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420cf14:	00 00 00 
  800420cf17:	ff d0                	callq  *%rax
  800420cf19:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420cf20:	00 00 00 
  800420cf23:	48 98                	cltq   
  800420cf25:	48 c1 e0 03          	shl    $0x3,%rax
  800420cf29:	48 89 c1             	mov    %rax,%rcx
  800420cf2c:	48 c1 e1 04          	shl    $0x4,%rcx
  800420cf30:	48 01 c8             	add    %rcx,%rax
  800420cf33:	48 01 d0             	add    %rdx,%rax
  800420cf36:	48 83 c0 08          	add    $0x8,%rax
  800420cf3a:	48 8b 00             	mov    (%rax),%rax
  800420cf3d:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  800420cf41:	b9 06 00 00 00       	mov    $0x6,%ecx
  800420cf46:	ba a0 00 00 00       	mov    $0xa0,%edx
  800420cf4b:	48 89 c7             	mov    %rax,%rdi
  800420cf4e:	48 b8 a4 42 20 04 80 	movabs $0x80042042a4,%rax
  800420cf55:	00 00 00 
  800420cf58:	ff d0                	callq  *%rax

	// fill utf
	utf->utf_fault_va = fault_va;
  800420cf5a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cf5e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420cf62:	48 89 10             	mov    %rdx,(%rax)
	utf->utf_err = tf->tf_err;
  800420cf65:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cf69:	48 8b 90 90 00 00 00 	mov    0x90(%rax),%rdx
  800420cf70:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cf74:	48 89 50 08          	mov    %rdx,0x8(%rax)
	utf->utf_regs = tf->tf_regs;
  800420cf78:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cf7c:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420cf80:	48 8b 0a             	mov    (%rdx),%rcx
  800420cf83:	48 89 48 10          	mov    %rcx,0x10(%rax)
  800420cf87:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420cf8b:	48 89 48 18          	mov    %rcx,0x18(%rax)
  800420cf8f:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
  800420cf93:	48 89 48 20          	mov    %rcx,0x20(%rax)
  800420cf97:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
  800420cf9b:	48 89 48 28          	mov    %rcx,0x28(%rax)
  800420cf9f:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
  800420cfa3:	48 89 48 30          	mov    %rcx,0x30(%rax)
  800420cfa7:	48 8b 4a 28          	mov    0x28(%rdx),%rcx
  800420cfab:	48 89 48 38          	mov    %rcx,0x38(%rax)
  800420cfaf:	48 8b 4a 30          	mov    0x30(%rdx),%rcx
  800420cfb3:	48 89 48 40          	mov    %rcx,0x40(%rax)
  800420cfb7:	48 8b 4a 38          	mov    0x38(%rdx),%rcx
  800420cfbb:	48 89 48 48          	mov    %rcx,0x48(%rax)
  800420cfbf:	48 8b 4a 40          	mov    0x40(%rdx),%rcx
  800420cfc3:	48 89 48 50          	mov    %rcx,0x50(%rax)
  800420cfc7:	48 8b 4a 48          	mov    0x48(%rdx),%rcx
  800420cfcb:	48 89 48 58          	mov    %rcx,0x58(%rax)
  800420cfcf:	48 8b 4a 50          	mov    0x50(%rdx),%rcx
  800420cfd3:	48 89 48 60          	mov    %rcx,0x60(%rax)
  800420cfd7:	48 8b 4a 58          	mov    0x58(%rdx),%rcx
  800420cfdb:	48 89 48 68          	mov    %rcx,0x68(%rax)
  800420cfdf:	48 8b 4a 60          	mov    0x60(%rdx),%rcx
  800420cfe3:	48 89 48 70          	mov    %rcx,0x70(%rax)
  800420cfe7:	48 8b 4a 68          	mov    0x68(%rdx),%rcx
  800420cfeb:	48 89 48 78          	mov    %rcx,0x78(%rax)
  800420cfef:	48 8b 52 70          	mov    0x70(%rdx),%rdx
  800420cff3:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
	utf->utf_rip = tf->tf_rip;
  800420cffa:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cffe:	48 8b 90 98 00 00 00 	mov    0x98(%rax),%rdx
  800420d005:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d009:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
	utf->utf_eflags = tf->tf_eflags;
  800420d010:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d014:	48 8b 90 a8 00 00 00 	mov    0xa8(%rax),%rdx
  800420d01b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d01f:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
	utf->utf_rsp = tf->tf_rsp;
  800420d026:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d02a:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420d031:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d035:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)

 	// set user registers so that env_run switches to fault handler
	tf->tf_rsp = (uintptr_t) utf;
  800420d03c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d040:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d044:	48 89 90 b0 00 00 00 	mov    %rdx,0xb0(%rax)
 	tf->tf_rip = (uintptr_t) curenv->env_pgfault_upcall;
  800420d04b:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420d052:	00 00 00 
  800420d055:	ff d0                	callq  *%rax
  800420d057:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420d05e:	00 00 00 
  800420d061:	48 98                	cltq   
  800420d063:	48 c1 e0 03          	shl    $0x3,%rax
  800420d067:	48 89 c1             	mov    %rax,%rcx
  800420d06a:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d06e:	48 01 c8             	add    %rcx,%rax
  800420d071:	48 01 d0             	add    %rdx,%rax
  800420d074:	48 83 c0 08          	add    $0x8,%rax
  800420d078:	48 8b 00             	mov    (%rax),%rax
  800420d07b:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
  800420d082:	48 89 c2             	mov    %rax,%rdx
  800420d085:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d089:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)

	env_run(curenv);
  800420d090:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420d097:	00 00 00 
  800420d09a:	ff d0                	callq  *%rax
  800420d09c:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420d0a3:	00 00 00 
  800420d0a6:	48 98                	cltq   
  800420d0a8:	48 c1 e0 03          	shl    $0x3,%rax
  800420d0ac:	48 89 c1             	mov    %rax,%rcx
  800420d0af:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d0b3:	48 01 c8             	add    %rcx,%rax
  800420d0b6:	48 01 d0             	add    %rdx,%rax
  800420d0b9:	48 83 c0 08          	add    $0x8,%rax
  800420d0bd:	48 8b 00             	mov    (%rax),%rax
  800420d0c0:	48 89 c7             	mov    %rax,%rdi
  800420d0c3:	48 b8 43 90 20 04 80 	movabs $0x8004209043,%rax
  800420d0ca:	00 00 00 
  800420d0cd:	ff d0                	callq  *%rax
  800420d0cf:	90                   	nop

000000800420d0d0 <Xdivide>:

.text


/* CPU traps */
TRAPHANDLER_NOEC(Xdivide, T_DIVIDE)
  800420d0d0:	6a 00                	pushq  $0x0
  800420d0d2:	6a 00                	pushq  $0x0
  800420d0d4:	e9 47 01 00 00       	jmpq   800420d220 <_alltraps>
  800420d0d9:	90                   	nop

000000800420d0da <Xdebug>:
TRAPHANDLER_NOEC(Xdebug,  T_DEBUG)
  800420d0da:	6a 00                	pushq  $0x0
  800420d0dc:	6a 01                	pushq  $0x1
  800420d0de:	e9 3d 01 00 00       	jmpq   800420d220 <_alltraps>
  800420d0e3:	90                   	nop

000000800420d0e4 <Xnmi>:
TRAPHANDLER_NOEC(Xnmi,    T_NMI)
  800420d0e4:	6a 00                	pushq  $0x0
  800420d0e6:	6a 02                	pushq  $0x2
  800420d0e8:	e9 33 01 00 00       	jmpq   800420d220 <_alltraps>
  800420d0ed:	90                   	nop

000000800420d0ee <Xbrkpt>:
TRAPHANDLER_NOEC(Xbrkpt,  T_BRKPT)
  800420d0ee:	6a 00                	pushq  $0x0
  800420d0f0:	6a 03                	pushq  $0x3
  800420d0f2:	e9 29 01 00 00       	jmpq   800420d220 <_alltraps>
  800420d0f7:	90                   	nop

000000800420d0f8 <Xoflow>:
TRAPHANDLER_NOEC(Xoflow,  T_OFLOW)
  800420d0f8:	6a 00                	pushq  $0x0
  800420d0fa:	6a 04                	pushq  $0x4
  800420d0fc:	e9 1f 01 00 00       	jmpq   800420d220 <_alltraps>
  800420d101:	90                   	nop

000000800420d102 <Xbound>:
TRAPHANDLER_NOEC(Xbound,  T_BOUND)
  800420d102:	6a 00                	pushq  $0x0
  800420d104:	6a 05                	pushq  $0x5
  800420d106:	e9 15 01 00 00       	jmpq   800420d220 <_alltraps>
  800420d10b:	90                   	nop

000000800420d10c <Xillop>:
TRAPHANDLER_NOEC(Xillop,  T_ILLOP)
  800420d10c:	6a 00                	pushq  $0x0
  800420d10e:	6a 06                	pushq  $0x6
  800420d110:	e9 0b 01 00 00       	jmpq   800420d220 <_alltraps>
  800420d115:	90                   	nop

000000800420d116 <Xdevice>:
TRAPHANDLER_NOEC(Xdevice, T_DEVICE)
  800420d116:	6a 00                	pushq  $0x0
  800420d118:	6a 07                	pushq  $0x7
  800420d11a:	e9 01 01 00 00       	jmpq   800420d220 <_alltraps>
  800420d11f:	90                   	nop

000000800420d120 <Xdblflt>:
TRAPHANDLER     (Xdblflt, T_DBLFLT)
  800420d120:	6a 08                	pushq  $0x8
  800420d122:	e9 f9 00 00 00       	jmpq   800420d220 <_alltraps>
  800420d127:	90                   	nop

000000800420d128 <Xtss>:
TRAPHANDLER     (Xtss,    T_TSS)
  800420d128:	6a 0a                	pushq  $0xa
  800420d12a:	e9 f1 00 00 00       	jmpq   800420d220 <_alltraps>
  800420d12f:	90                   	nop

000000800420d130 <Xsegnp>:
TRAPHANDLER     (Xsegnp,  T_SEGNP)
  800420d130:	6a 0b                	pushq  $0xb
  800420d132:	e9 e9 00 00 00       	jmpq   800420d220 <_alltraps>
  800420d137:	90                   	nop

000000800420d138 <Xstack>:
TRAPHANDLER     (Xstack,  T_STACK)
  800420d138:	6a 0c                	pushq  $0xc
  800420d13a:	e9 e1 00 00 00       	jmpq   800420d220 <_alltraps>
  800420d13f:	90                   	nop

000000800420d140 <Xgpflt>:
TRAPHANDLER     (Xgpflt,  T_GPFLT)
  800420d140:	6a 0d                	pushq  $0xd
  800420d142:	e9 d9 00 00 00       	jmpq   800420d220 <_alltraps>
  800420d147:	90                   	nop

000000800420d148 <Xpgflt>:
TRAPHANDLER     (Xpgflt,  T_PGFLT)
  800420d148:	6a 0e                	pushq  $0xe
  800420d14a:	e9 d1 00 00 00       	jmpq   800420d220 <_alltraps>
  800420d14f:	90                   	nop

000000800420d150 <Xfperr>:
TRAPHANDLER_NOEC(Xfperr,  T_FPERR)
  800420d150:	6a 00                	pushq  $0x0
  800420d152:	6a 10                	pushq  $0x10
  800420d154:	e9 c7 00 00 00       	jmpq   800420d220 <_alltraps>
  800420d159:	90                   	nop

000000800420d15a <Xalign>:
TRAPHANDLER     (Xalign,  T_ALIGN)
  800420d15a:	6a 11                	pushq  $0x11
  800420d15c:	e9 bf 00 00 00       	jmpq   800420d220 <_alltraps>
  800420d161:	90                   	nop

000000800420d162 <Xmchk>:
TRAPHANDLER_NOEC(Xmchk,   T_MCHK)
  800420d162:	6a 00                	pushq  $0x0
  800420d164:	6a 12                	pushq  $0x12
  800420d166:	e9 b5 00 00 00       	jmpq   800420d220 <_alltraps>
  800420d16b:	90                   	nop

000000800420d16c <Xirq0>:

/* the external device interrupts */
TRAPHANDLER_NOEC(Xirq0,   IRQ_OFFSET+0)
  800420d16c:	6a 00                	pushq  $0x0
  800420d16e:	6a 20                	pushq  $0x20
  800420d170:	e9 ab 00 00 00       	jmpq   800420d220 <_alltraps>
  800420d175:	90                   	nop

000000800420d176 <Xirq1>:
TRAPHANDLER_NOEC(Xirq1,   IRQ_OFFSET+1)
  800420d176:	6a 00                	pushq  $0x0
  800420d178:	6a 21                	pushq  $0x21
  800420d17a:	e9 a1 00 00 00       	jmpq   800420d220 <_alltraps>
  800420d17f:	90                   	nop

000000800420d180 <Xirq2>:
TRAPHANDLER_NOEC(Xirq2,   IRQ_OFFSET+2)
  800420d180:	6a 00                	pushq  $0x0
  800420d182:	6a 22                	pushq  $0x22
  800420d184:	e9 97 00 00 00       	jmpq   800420d220 <_alltraps>
  800420d189:	90                   	nop

000000800420d18a <Xirq3>:
TRAPHANDLER_NOEC(Xirq3,   IRQ_OFFSET+3)
  800420d18a:	6a 00                	pushq  $0x0
  800420d18c:	6a 23                	pushq  $0x23
  800420d18e:	e9 8d 00 00 00       	jmpq   800420d220 <_alltraps>
  800420d193:	90                   	nop

000000800420d194 <Xirq4>:
TRAPHANDLER_NOEC(Xirq4,   IRQ_OFFSET+4)
  800420d194:	6a 00                	pushq  $0x0
  800420d196:	6a 24                	pushq  $0x24
  800420d198:	e9 83 00 00 00       	jmpq   800420d220 <_alltraps>
  800420d19d:	90                   	nop

000000800420d19e <Xirq5>:
TRAPHANDLER_NOEC(Xirq5,   IRQ_OFFSET+5)
  800420d19e:	6a 00                	pushq  $0x0
  800420d1a0:	6a 25                	pushq  $0x25
  800420d1a2:	e9 79 00 00 00       	jmpq   800420d220 <_alltraps>
  800420d1a7:	90                   	nop

000000800420d1a8 <Xirq6>:
TRAPHANDLER_NOEC(Xirq6,   IRQ_OFFSET+6)
  800420d1a8:	6a 00                	pushq  $0x0
  800420d1aa:	6a 26                	pushq  $0x26
  800420d1ac:	e9 6f 00 00 00       	jmpq   800420d220 <_alltraps>
  800420d1b1:	90                   	nop

000000800420d1b2 <Xirq7>:
TRAPHANDLER_NOEC(Xirq7,   IRQ_OFFSET+7)
  800420d1b2:	6a 00                	pushq  $0x0
  800420d1b4:	6a 27                	pushq  $0x27
  800420d1b6:	e9 65 00 00 00       	jmpq   800420d220 <_alltraps>
  800420d1bb:	90                   	nop

000000800420d1bc <Xirq8>:
TRAPHANDLER_NOEC(Xirq8,   IRQ_OFFSET+8)
  800420d1bc:	6a 00                	pushq  $0x0
  800420d1be:	6a 28                	pushq  $0x28
  800420d1c0:	e9 5b 00 00 00       	jmpq   800420d220 <_alltraps>
  800420d1c5:	90                   	nop

000000800420d1c6 <Xirq9>:
TRAPHANDLER_NOEC(Xirq9,   IRQ_OFFSET+9)
  800420d1c6:	6a 00                	pushq  $0x0
  800420d1c8:	6a 29                	pushq  $0x29
  800420d1ca:	e9 51 00 00 00       	jmpq   800420d220 <_alltraps>
  800420d1cf:	90                   	nop

000000800420d1d0 <Xirq10>:
TRAPHANDLER_NOEC(Xirq10,  IRQ_OFFSET+10)
  800420d1d0:	6a 00                	pushq  $0x0
  800420d1d2:	6a 2a                	pushq  $0x2a
  800420d1d4:	e9 47 00 00 00       	jmpq   800420d220 <_alltraps>
  800420d1d9:	90                   	nop

000000800420d1da <Xirq11>:
TRAPHANDLER_NOEC(Xirq11,  IRQ_OFFSET+11)
  800420d1da:	6a 00                	pushq  $0x0
  800420d1dc:	6a 2b                	pushq  $0x2b
  800420d1de:	e9 3d 00 00 00       	jmpq   800420d220 <_alltraps>
  800420d1e3:	90                   	nop

000000800420d1e4 <Xirq12>:
TRAPHANDLER_NOEC(Xirq12,  IRQ_OFFSET+12)
  800420d1e4:	6a 00                	pushq  $0x0
  800420d1e6:	6a 2c                	pushq  $0x2c
  800420d1e8:	e9 33 00 00 00       	jmpq   800420d220 <_alltraps>
  800420d1ed:	90                   	nop

000000800420d1ee <Xirq13>:
TRAPHANDLER_NOEC(Xirq13,  IRQ_OFFSET+13)
  800420d1ee:	6a 00                	pushq  $0x0
  800420d1f0:	6a 2d                	pushq  $0x2d
  800420d1f2:	e9 29 00 00 00       	jmpq   800420d220 <_alltraps>
  800420d1f7:	90                   	nop

000000800420d1f8 <Xirq14>:
TRAPHANDLER_NOEC(Xirq14,  IRQ_OFFSET+14)
  800420d1f8:	6a 00                	pushq  $0x0
  800420d1fa:	6a 2e                	pushq  $0x2e
  800420d1fc:	e9 1f 00 00 00       	jmpq   800420d220 <_alltraps>
  800420d201:	90                   	nop

000000800420d202 <Xirq15>:
TRAPHANDLER_NOEC(Xirq15,  IRQ_OFFSET+15)
  800420d202:	6a 00                	pushq  $0x0
  800420d204:	6a 2f                	pushq  $0x2f
  800420d206:	e9 15 00 00 00       	jmpq   800420d220 <_alltraps>
  800420d20b:	90                   	nop

000000800420d20c <Xsyscall>:

/* system call entry point */
TRAPHANDLER_NOEC(Xsyscall, T_SYSCALL)
  800420d20c:	6a 00                	pushq  $0x0
  800420d20e:	6a 30                	pushq  $0x30
  800420d210:	e9 0b 00 00 00       	jmpq   800420d220 <_alltraps>
  800420d215:	90                   	nop

000000800420d216 <Xdefault>:

/* default handler -- not for any specific trap */
TRAPHANDLER     (Xdefault, T_DEFAULT)
  800420d216:	68 f4 01 00 00       	pushq  $0x1f4
  800420d21b:	e9 00 00 00 00       	jmpq   800420d220 <_alltraps>

000000800420d220 <_alltraps>:

.globl	_alltraps
.type	_alltraps,@function
.p2align 4, 0x90		/* 16-byte alignment, nop filled */
_alltraps:
    subq $16,%rsp
  800420d220:	48 83 ec 10          	sub    $0x10,%rsp
    movw %ds,8(%rsp)
  800420d224:	8c 5c 24 08          	mov    %ds,0x8(%rsp)
    movw %es,0(%rsp)
  800420d228:	8c 04 24             	mov    %es,(%rsp)
    PUSHA
  800420d22b:	48 83 ec 78          	sub    $0x78,%rsp
  800420d22f:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
  800420d234:	48 89 5c 24 68       	mov    %rbx,0x68(%rsp)
  800420d239:	48 89 4c 24 60       	mov    %rcx,0x60(%rsp)
  800420d23e:	48 89 54 24 58       	mov    %rdx,0x58(%rsp)
  800420d243:	48 89 6c 24 50       	mov    %rbp,0x50(%rsp)
  800420d248:	48 89 7c 24 48       	mov    %rdi,0x48(%rsp)
  800420d24d:	48 89 74 24 40       	mov    %rsi,0x40(%rsp)
  800420d252:	4c 89 44 24 38       	mov    %r8,0x38(%rsp)
  800420d257:	4c 89 4c 24 30       	mov    %r9,0x30(%rsp)
  800420d25c:	4c 89 54 24 28       	mov    %r10,0x28(%rsp)
  800420d261:	4c 89 5c 24 20       	mov    %r11,0x20(%rsp)
  800420d266:	4c 89 64 24 18       	mov    %r12,0x18(%rsp)
  800420d26b:	4c 89 6c 24 10       	mov    %r13,0x10(%rsp)
  800420d270:	4c 89 74 24 08       	mov    %r14,0x8(%rsp)
  800420d275:	4c 89 3c 24          	mov    %r15,(%rsp)
    movl $GD_KD, %eax
  800420d279:	b8 10 00 00 00       	mov    $0x10,%eax
    movw %ax, %ds
  800420d27e:	8e d8                	mov    %eax,%ds
    movw %ax, %es
  800420d280:	8e c0                	mov    %eax,%es
    movw %ax, %ss
  800420d282:	8e d0                	mov    %eax,%ss
    movw %ax, %fs
  800420d284:	8e e0                	mov    %eax,%fs
    movw %ax, %gs
  800420d286:	8e e8                	mov    %eax,%gs
    movq %rsp,%rdi
  800420d288:	48 89 e7             	mov    %rsp,%rdi
    call trap   # never returns 
  800420d28b:	e8 70 f7 ff ff       	callq  800420ca00 <trap>

000000800420d290 <spin>:
spin:	jmp spin
  800420d290:	eb fe                	jmp    800420d290 <spin>

000000800420d292 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  800420d292:	55                   	push   %rbp
  800420d293:	48 89 e5             	mov    %rsp,%rbp
  800420d296:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420d29a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420d29e:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  800420d2a1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d2a5:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420d2a8:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420d2ac:	f0 87 02             	lock xchg %eax,(%rdx)
  800420d2af:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  800420d2b2:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420d2b5:	c9                   	leaveq 
  800420d2b6:	c3                   	retq   

000000800420d2b7 <unlock_kernel>:

static inline void
unlock_kernel(void)
{
  800420d2b7:	55                   	push   %rbp
  800420d2b8:	48 89 e5             	mov    %rsp,%rbp
	spin_unlock(&kernel_lock);
  800420d2bb:	48 bf 60 c7 22 04 80 	movabs $0x800422c760,%rdi
  800420d2c2:	00 00 00 
  800420d2c5:	48 b8 34 78 21 04 80 	movabs $0x8004217834,%rax
  800420d2cc:	00 00 00 
  800420d2cf:	ff d0                	callq  *%rax

	// Normally we wouldn't need to do this, but QEMU only runs
	// one CPU at a time and has a long time-slice.  Without the
	// pause, this CPU is likely to reacquire the lock before
	// another CPU has even been given a chance to acquire it.
	asm volatile("pause");
  800420d2d1:	f3 90                	pause  
}
  800420d2d3:	5d                   	pop    %rbp
  800420d2d4:	c3                   	retq   

000000800420d2d5 <sched_yield>:


// Choose a user environment to run and run it.
void
sched_yield(void)
{
  800420d2d5:	55                   	push   %rbp
  800420d2d6:	48 89 e5             	mov    %rsp,%rbp
  800420d2d9:	48 83 ec 10          	sub    $0x10,%rsp
	struct Env *idle;

	int i, j, k;

	// Determine the starting point for the search.
	if (curenv)
  800420d2dd:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420d2e4:	00 00 00 
  800420d2e7:	ff d0                	callq  *%rax
  800420d2e9:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420d2f0:	00 00 00 
  800420d2f3:	48 98                	cltq   
  800420d2f5:	48 c1 e0 03          	shl    $0x3,%rax
  800420d2f9:	48 89 c1             	mov    %rax,%rcx
  800420d2fc:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d300:	48 01 c8             	add    %rcx,%rax
  800420d303:	48 01 d0             	add    %rdx,%rax
  800420d306:	48 83 c0 08          	add    $0x8,%rax
  800420d30a:	48 8b 00             	mov    (%rax),%rax
  800420d30d:	48 85 c0             	test   %rax,%rax
  800420d310:	74 60                	je     800420d372 <sched_yield+0x9d>
		i = curenv-envs;
  800420d312:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420d319:	00 00 00 
  800420d31c:	ff d0                	callq  *%rax
  800420d31e:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420d325:	00 00 00 
  800420d328:	48 98                	cltq   
  800420d32a:	48 c1 e0 03          	shl    $0x3,%rax
  800420d32e:	48 89 c1             	mov    %rax,%rcx
  800420d331:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d335:	48 01 c8             	add    %rcx,%rax
  800420d338:	48 01 d0             	add    %rdx,%rax
  800420d33b:	48 83 c0 08          	add    $0x8,%rax
  800420d33f:	48 8b 00             	mov    (%rax),%rax
  800420d342:	48 89 c2             	mov    %rax,%rdx
  800420d345:	48 b8 58 d2 49 04 80 	movabs $0x800449d258,%rax
  800420d34c:	00 00 00 
  800420d34f:	48 8b 00             	mov    (%rax),%rax
  800420d352:	48 29 c2             	sub    %rax,%rdx
  800420d355:	48 89 d0             	mov    %rdx,%rax
  800420d358:	48 c1 f8 03          	sar    $0x3,%rax
  800420d35c:	48 89 c2             	mov    %rax,%rdx
  800420d35f:	48 b8 a5 4f fa a4 4f 	movabs $0x4fa4fa4fa4fa4fa5,%rax
  800420d366:	fa a4 4f 
  800420d369:	48 0f af c2          	imul   %rdx,%rax
  800420d36d:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420d370:	eb 07                	jmp    800420d379 <sched_yield+0xa4>
	else
		i = NENV-1;
  800420d372:	c7 45 fc ff 03 00 00 	movl   $0x3ff,-0x4(%rbp)
	//cprintf("sched_yield searching from %d\n", i);

	// Loop through all the environments at most once.
	for (j = 1; j <= NENV; j++) {
  800420d379:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%rbp)
  800420d380:	eb 75                	jmp    800420d3f7 <sched_yield+0x122>
		k = (j + i) % NENV;
  800420d382:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d385:	8b 55 f8             	mov    -0x8(%rbp),%edx
  800420d388:	01 c2                	add    %eax,%edx
  800420d38a:	89 d0                	mov    %edx,%eax
  800420d38c:	c1 f8 1f             	sar    $0x1f,%eax
  800420d38f:	c1 e8 16             	shr    $0x16,%eax
  800420d392:	01 c2                	add    %eax,%edx
  800420d394:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
  800420d39a:	29 c2                	sub    %eax,%edx
  800420d39c:	89 d0                	mov    %edx,%eax
  800420d39e:	89 45 f4             	mov    %eax,-0xc(%rbp)
		// If this environment is runnable, run it.
		if (envs[k].env_status == ENV_RUNNABLE) {
  800420d3a1:	48 b8 58 d2 49 04 80 	movabs $0x800449d258,%rax
  800420d3a8:	00 00 00 
  800420d3ab:	48 8b 10             	mov    (%rax),%rdx
  800420d3ae:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420d3b1:	48 98                	cltq   
  800420d3b3:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800420d3ba:	48 01 d0             	add    %rdx,%rax
  800420d3bd:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420d3c3:	83 f8 02             	cmp    $0x2,%eax
  800420d3c6:	75 2b                	jne    800420d3f3 <sched_yield+0x11e>
					continue;
				}
			}
#endif

			env_run(&envs[k]);
  800420d3c8:	48 b8 58 d2 49 04 80 	movabs $0x800449d258,%rax
  800420d3cf:	00 00 00 
  800420d3d2:	48 8b 10             	mov    (%rax),%rdx
  800420d3d5:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420d3d8:	48 98                	cltq   
  800420d3da:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800420d3e1:	48 01 d0             	add    %rdx,%rax
  800420d3e4:	48 89 c7             	mov    %rax,%rdi
  800420d3e7:	48 b8 43 90 20 04 80 	movabs $0x8004209043,%rax
  800420d3ee:	00 00 00 
  800420d3f1:	ff d0                	callq  *%rax
	else
		i = NENV-1;
	//cprintf("sched_yield searching from %d\n", i);

	// Loop through all the environments at most once.
	for (j = 1; j <= NENV; j++) {
  800420d3f3:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  800420d3f7:	81 7d f8 00 04 00 00 	cmpl   $0x400,-0x8(%rbp)
  800420d3fe:	7e 82                	jle    800420d382 <sched_yield+0xad>

			env_run(&envs[k]);
		}
	}

	if (curenv && curenv->env_status == ENV_RUNNING) {
  800420d400:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420d407:	00 00 00 
  800420d40a:	ff d0                	callq  *%rax
  800420d40c:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420d413:	00 00 00 
  800420d416:	48 98                	cltq   
  800420d418:	48 c1 e0 03          	shl    $0x3,%rax
  800420d41c:	48 89 c1             	mov    %rax,%rcx
  800420d41f:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d423:	48 01 c8             	add    %rcx,%rax
  800420d426:	48 01 d0             	add    %rdx,%rax
  800420d429:	48 83 c0 08          	add    $0x8,%rax
  800420d42d:	48 8b 00             	mov    (%rax),%rax
  800420d430:	48 85 c0             	test   %rax,%rax
  800420d433:	74 7a                	je     800420d4af <sched_yield+0x1da>
  800420d435:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420d43c:	00 00 00 
  800420d43f:	ff d0                	callq  *%rax
  800420d441:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420d448:	00 00 00 
  800420d44b:	48 98                	cltq   
  800420d44d:	48 c1 e0 03          	shl    $0x3,%rax
  800420d451:	48 89 c1             	mov    %rax,%rcx
  800420d454:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d458:	48 01 c8             	add    %rcx,%rax
  800420d45b:	48 01 d0             	add    %rdx,%rax
  800420d45e:	48 83 c0 08          	add    $0x8,%rax
  800420d462:	48 8b 00             	mov    (%rax),%rax
  800420d465:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420d46b:	83 f8 03             	cmp    $0x3,%eax
  800420d46e:	75 3f                	jne    800420d4af <sched_yield+0x1da>
			}
		}
		env_run(curenv);
#endif // !VMM_GUEST

		env_run(curenv);
  800420d470:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420d477:	00 00 00 
  800420d47a:	ff d0                	callq  *%rax
  800420d47c:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420d483:	00 00 00 
  800420d486:	48 98                	cltq   
  800420d488:	48 c1 e0 03          	shl    $0x3,%rax
  800420d48c:	48 89 c1             	mov    %rax,%rcx
  800420d48f:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d493:	48 01 c8             	add    %rcx,%rax
  800420d496:	48 01 d0             	add    %rdx,%rax
  800420d499:	48 83 c0 08          	add    $0x8,%rax
  800420d49d:	48 8b 00             	mov    (%rax),%rax
  800420d4a0:	48 89 c7             	mov    %rax,%rdi
  800420d4a3:	48 b8 43 90 20 04 80 	movabs $0x8004209043,%rax
  800420d4aa:	00 00 00 
  800420d4ad:	ff d0                	callq  *%rax
	}


	// sched_halt never returns
	sched_halt();
  800420d4af:	48 b8 bd d4 20 04 80 	movabs $0x800420d4bd,%rax
  800420d4b6:	00 00 00 
  800420d4b9:	ff d0                	callq  *%rax
}
  800420d4bb:	c9                   	leaveq 
  800420d4bc:	c3                   	retq   

000000800420d4bd <sched_halt>:
// Halt this CPU when there is nothing to do. Wait until the
// timer interrupt wakes it up. This function never returns.
//
void
sched_halt(void)
{
  800420d4bd:	55                   	push   %rbp
  800420d4be:	48 89 e5             	mov    %rsp,%rbp
  800420d4c1:	48 83 ec 20          	sub    $0x20,%rsp
	int i;

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
  800420d4c5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420d4cc:	eb 79                	jmp    800420d547 <sched_halt+0x8a>
		if ((envs[i].env_status == ENV_RUNNABLE ||
  800420d4ce:	48 b8 58 d2 49 04 80 	movabs $0x800449d258,%rax
  800420d4d5:	00 00 00 
  800420d4d8:	48 8b 10             	mov    (%rax),%rdx
  800420d4db:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d4de:	48 98                	cltq   
  800420d4e0:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800420d4e7:	48 01 d0             	add    %rdx,%rax
  800420d4ea:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420d4f0:	83 f8 02             	cmp    $0x2,%eax
  800420d4f3:	74 5f                	je     800420d554 <sched_halt+0x97>
		     envs[i].env_status == ENV_RUNNING ||
  800420d4f5:	48 b8 58 d2 49 04 80 	movabs $0x800449d258,%rax
  800420d4fc:	00 00 00 
  800420d4ff:	48 8b 10             	mov    (%rax),%rdx
  800420d502:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d505:	48 98                	cltq   
  800420d507:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800420d50e:	48 01 d0             	add    %rdx,%rax
  800420d511:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
	int i;

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
		if ((envs[i].env_status == ENV_RUNNABLE ||
  800420d517:	83 f8 03             	cmp    $0x3,%eax
  800420d51a:	74 38                	je     800420d554 <sched_halt+0x97>
		     envs[i].env_status == ENV_RUNNING ||
		     envs[i].env_status == ENV_DYING))
  800420d51c:	48 b8 58 d2 49 04 80 	movabs $0x800449d258,%rax
  800420d523:	00 00 00 
  800420d526:	48 8b 10             	mov    (%rax),%rdx
  800420d529:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d52c:	48 98                	cltq   
  800420d52e:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800420d535:	48 01 d0             	add    %rdx,%rax
  800420d538:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
		if ((envs[i].env_status == ENV_RUNNABLE ||
		     envs[i].env_status == ENV_RUNNING ||
  800420d53e:	83 f8 01             	cmp    $0x1,%eax
  800420d541:	74 11                	je     800420d554 <sched_halt+0x97>
{
	int i;

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
  800420d543:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420d547:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  800420d54e:	0f 8e 7a ff ff ff    	jle    800420d4ce <sched_halt+0x11>
		if ((envs[i].env_status == ENV_RUNNABLE ||
		     envs[i].env_status == ENV_RUNNING ||
		     envs[i].env_status == ENV_DYING))
			break;
	}
	if (i == NENV) {
  800420d554:	81 7d fc 00 04 00 00 	cmpl   $0x400,-0x4(%rbp)
  800420d55b:	75 2e                	jne    800420d58b <sched_halt+0xce>
		cprintf("No runnable environments in the system!\n");
  800420d55d:	48 bf 80 a6 21 04 80 	movabs $0x800421a680,%rdi
  800420d564:	00 00 00 
  800420d567:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d56c:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  800420d573:	00 00 00 
  800420d576:	ff d2                	callq  *%rdx
		while (1)
			monitor(NULL);
  800420d578:	bf 00 00 00 00       	mov    $0x0,%edi
  800420d57d:	48 b8 99 1b 20 04 80 	movabs $0x8004201b99,%rax
  800420d584:	00 00 00 
  800420d587:	ff d0                	callq  *%rax
  800420d589:	eb ed                	jmp    800420d578 <sched_halt+0xbb>
	}

	// Mark that no environment is running on this CPU
	curenv = NULL;
  800420d58b:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420d592:	00 00 00 
  800420d595:	ff d0                	callq  *%rax
  800420d597:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420d59e:	00 00 00 
  800420d5a1:	48 98                	cltq   
  800420d5a3:	48 c1 e0 03          	shl    $0x3,%rax
  800420d5a7:	48 89 c1             	mov    %rax,%rcx
  800420d5aa:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d5ae:	48 01 c8             	add    %rcx,%rax
  800420d5b1:	48 01 d0             	add    %rdx,%rax
  800420d5b4:	48 83 c0 08          	add    $0x8,%rax
  800420d5b8:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	lcr3(PADDR(boot_pml4e));
  800420d5bf:	48 b8 e8 c5 69 04 80 	movabs $0x800469c5e8,%rax
  800420d5c6:	00 00 00 
  800420d5c9:	48 8b 00             	mov    (%rax),%rax
  800420d5cc:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420d5d0:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420d5d7:	00 00 00 
  800420d5da:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  800420d5de:	77 32                	ja     800420d612 <sched_halt+0x155>
  800420d5e0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d5e4:	48 89 c1             	mov    %rax,%rcx
  800420d5e7:	48 ba b0 a6 21 04 80 	movabs $0x800421a6b0,%rdx
  800420d5ee:	00 00 00 
  800420d5f1:	be 77 00 00 00       	mov    $0x77,%esi
  800420d5f6:	48 bf d4 a6 21 04 80 	movabs $0x800421a6d4,%rdi
  800420d5fd:	00 00 00 
  800420d600:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d605:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  800420d60c:	00 00 00 
  800420d60f:	41 ff d0             	callq  *%r8
  800420d612:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420d619:	ff ff ff 
  800420d61c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d620:	48 01 d0             	add    %rdx,%rax
  800420d623:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  800420d627:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d62b:	0f 22 d8             	mov    %rax,%cr3

	// Mark that this CPU is in the HALT state, so that when
	// timer interupts come in, we know we should re-acquire the
	// big kernel lock
	xchg(&thiscpu->cpu_status, CPU_HALTED);
  800420d62e:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420d635:	00 00 00 
  800420d638:	ff d0                	callq  *%rax
  800420d63a:	48 98                	cltq   
  800420d63c:	48 c1 e0 03          	shl    $0x3,%rax
  800420d640:	48 89 c2             	mov    %rax,%rdx
  800420d643:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d647:	48 01 d0             	add    %rdx,%rax
  800420d64a:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420d651:	00 00 00 
  800420d654:	48 01 d0             	add    %rdx,%rax
  800420d657:	48 83 c0 04          	add    $0x4,%rax
  800420d65b:	be 02 00 00 00       	mov    $0x2,%esi
  800420d660:	48 89 c7             	mov    %rax,%rdi
  800420d663:	48 b8 92 d2 20 04 80 	movabs $0x800420d292,%rax
  800420d66a:	00 00 00 
  800420d66d:	ff d0                	callq  *%rax

	// Release the big kernel lock as if we were "leaving" the kernel
	unlock_kernel();
  800420d66f:	48 b8 b7 d2 20 04 80 	movabs $0x800420d2b7,%rax
  800420d676:	00 00 00 
  800420d679:	ff d0                	callq  *%rax
		"movq %0, %%rsp\n"
		"pushq $0\n"
		"pushq $0\n"
		"sti\n"
		"hlt\n"
		: : "a" (thiscpu->cpu_ts.ts_esp0));
  800420d67b:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420d682:	00 00 00 
  800420d685:	ff d0                	callq  *%rax
  800420d687:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420d68e:	00 00 00 
  800420d691:	48 98                	cltq   
  800420d693:	48 c1 e0 03          	shl    $0x3,%rax
  800420d697:	48 89 c1             	mov    %rax,%rcx
  800420d69a:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d69e:	48 01 c8             	add    %rcx,%rax
  800420d6a1:	48 01 d0             	add    %rdx,%rax
  800420d6a4:	48 83 c0 10          	add    $0x10,%rax
  800420d6a8:	48 8b 40 04          	mov    0x4(%rax),%rax

	// Release the big kernel lock as if we were "leaving" the kernel
	unlock_kernel();

	// Reset stack pointer, enable interrupts and then halt.
	asm volatile (
  800420d6ac:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp
  800420d6b3:	48 89 c4             	mov    %rax,%rsp
  800420d6b6:	6a 00                	pushq  $0x0
  800420d6b8:	6a 00                	pushq  $0x0
  800420d6ba:	fb                   	sti    
  800420d6bb:	f4                   	hlt    
		"pushq $0\n"
		"pushq $0\n"
		"sti\n"
		"hlt\n"
		: : "a" (thiscpu->cpu_ts.ts_esp0));
}
  800420d6bc:	c9                   	leaveq 
  800420d6bd:	c3                   	retq   

000000800420d6be <pa2page>:
	return page2ppn(pp) << PGSHIFT;
}

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  800420d6be:	55                   	push   %rbp
  800420d6bf:	48 89 e5             	mov    %rsp,%rbp
  800420d6c2:	48 83 ec 10          	sub    $0x10,%rsp
  800420d6c6:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  800420d6ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d6ce:	48 c1 e8 0c          	shr    $0xc,%rax
  800420d6d2:	48 89 c2             	mov    %rax,%rdx
  800420d6d5:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  800420d6dc:	00 00 00 
  800420d6df:	48 8b 00             	mov    (%rax),%rax
  800420d6e2:	48 39 c2             	cmp    %rax,%rdx
  800420d6e5:	72 2a                	jb     800420d711 <pa2page+0x53>
		panic("pa2page called with invalid pa");
  800420d6e7:	48 ba e8 a6 21 04 80 	movabs $0x800421a6e8,%rdx
  800420d6ee:	00 00 00 
  800420d6f1:	be 59 00 00 00       	mov    $0x59,%esi
  800420d6f6:	48 bf 07 a7 21 04 80 	movabs $0x800421a707,%rdi
  800420d6fd:	00 00 00 
  800420d700:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d705:	48 b9 e4 05 20 04 80 	movabs $0x80042005e4,%rcx
  800420d70c:	00 00 00 
  800420d70f:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  800420d711:	48 b8 f8 c5 69 04 80 	movabs $0x800469c5f8,%rax
  800420d718:	00 00 00 
  800420d71b:	48 8b 00             	mov    (%rax),%rax
  800420d71e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420d722:	48 c1 ea 0c          	shr    $0xc,%rdx
  800420d726:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d72a:	48 01 d0             	add    %rdx,%rax
}
  800420d72d:	c9                   	leaveq 
  800420d72e:	c3                   	retq   

000000800420d72f <sys_cputs>:
// Print a string to the system console.
// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void
sys_cputs(const char *s, size_t len)
{
  800420d72f:	55                   	push   %rbp
  800420d730:	48 89 e5             	mov    %rsp,%rbp
  800420d733:	48 83 ec 10          	sub    $0x10,%rsp
  800420d737:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420d73b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	// Check that the user has permission to read memory [s, s+len).
	// Destroy the environment if not.

	// LAB 3: Your code here.

	user_mem_assert(curenv, s, len, PTE_U);
  800420d73f:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420d746:	00 00 00 
  800420d749:	ff d0                	callq  *%rax
  800420d74b:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420d752:	00 00 00 
  800420d755:	48 98                	cltq   
  800420d757:	48 c1 e0 03          	shl    $0x3,%rax
  800420d75b:	48 89 c1             	mov    %rax,%rcx
  800420d75e:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d762:	48 01 c8             	add    %rcx,%rax
  800420d765:	48 01 d0             	add    %rdx,%rax
  800420d768:	48 83 c0 08          	add    $0x8,%rax
  800420d76c:	48 8b 00             	mov    (%rax),%rax
  800420d76f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420d773:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  800420d777:	b9 04 00 00 00       	mov    $0x4,%ecx
  800420d77c:	48 89 c7             	mov    %rax,%rdi
  800420d77f:	48 b8 a4 42 20 04 80 	movabs $0x80042042a4,%rax
  800420d786:	00 00 00 
  800420d789:	ff d0                	callq  *%rax


	// Print the string supplied by the user.
	cprintf("%.*s", len, s);
  800420d78b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420d78f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d793:	48 89 c6             	mov    %rax,%rsi
  800420d796:	48 bf 15 a7 21 04 80 	movabs $0x800421a715,%rdi
  800420d79d:	00 00 00 
  800420d7a0:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d7a5:	48 b9 90 95 20 04 80 	movabs $0x8004209590,%rcx
  800420d7ac:	00 00 00 
  800420d7af:	ff d1                	callq  *%rcx
}
  800420d7b1:	c9                   	leaveq 
  800420d7b2:	c3                   	retq   

000000800420d7b3 <sys_cgetc>:

// Read a character from the system console without blocking.
// Returns the character, or 0 if there is no input waiting.
static int
sys_cgetc(void)
{
  800420d7b3:	55                   	push   %rbp
  800420d7b4:	48 89 e5             	mov    %rsp,%rbp
	return cons_getc();
  800420d7b7:	48 b8 ed 11 20 04 80 	movabs $0x80042011ed,%rax
  800420d7be:	00 00 00 
  800420d7c1:	ff d0                	callq  *%rax
}
  800420d7c3:	5d                   	pop    %rbp
  800420d7c4:	c3                   	retq   

000000800420d7c5 <sys_getenvid>:

// Returns the current environment's envid.
static envid_t
sys_getenvid(void)
{
  800420d7c5:	55                   	push   %rbp
  800420d7c6:	48 89 e5             	mov    %rsp,%rbp
	return curenv->env_id;
  800420d7c9:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420d7d0:	00 00 00 
  800420d7d3:	ff d0                	callq  *%rax
  800420d7d5:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420d7dc:	00 00 00 
  800420d7df:	48 98                	cltq   
  800420d7e1:	48 c1 e0 03          	shl    $0x3,%rax
  800420d7e5:	48 89 c1             	mov    %rax,%rcx
  800420d7e8:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d7ec:	48 01 c8             	add    %rcx,%rax
  800420d7ef:	48 01 d0             	add    %rdx,%rax
  800420d7f2:	48 83 c0 08          	add    $0x8,%rax
  800420d7f6:	48 8b 00             	mov    (%rax),%rax
  800420d7f9:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
}
  800420d7ff:	5d                   	pop    %rbp
  800420d800:	c3                   	retq   

000000800420d801 <sys_env_destroy>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_destroy(envid_t envid)
{
  800420d801:	55                   	push   %rbp
  800420d802:	48 89 e5             	mov    %rsp,%rbp
  800420d805:	48 83 ec 20          	sub    $0x20,%rsp
  800420d809:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int r;
	struct Env *e;

	if ((r = envid2env(envid, &e, 1)) < 0)
  800420d80c:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420d810:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420d813:	ba 01 00 00 00       	mov    $0x1,%edx
  800420d818:	48 89 ce             	mov    %rcx,%rsi
  800420d81b:	89 c7                	mov    %eax,%edi
  800420d81d:	48 b8 46 7f 20 04 80 	movabs $0x8004207f46,%rax
  800420d824:	00 00 00 
  800420d827:	ff d0                	callq  *%rax
  800420d829:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420d82c:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420d830:	79 05                	jns    800420d837 <sys_env_destroy+0x36>
		return r;
  800420d832:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d835:	eb 18                	jmp    800420d84f <sys_env_destroy+0x4e>

	env_destroy(e);
  800420d837:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d83b:	48 89 c7             	mov    %rax,%rdi
  800420d83e:	48 b8 78 8e 20 04 80 	movabs $0x8004208e78,%rax
  800420d845:	00 00 00 
  800420d848:	ff d0                	callq  *%rax
	return 0;
  800420d84a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420d84f:	c9                   	leaveq 
  800420d850:	c3                   	retq   

000000800420d851 <sys_yield>:


// Deschedule current environment and pick a different one to run.
static void
sys_yield(void)
{
  800420d851:	55                   	push   %rbp
  800420d852:	48 89 e5             	mov    %rsp,%rbp
	sched_yield();
  800420d855:	48 b8 d5 d2 20 04 80 	movabs $0x800420d2d5,%rax
  800420d85c:	00 00 00 
  800420d85f:	ff d0                	callq  *%rax

000000800420d861 <sys_exofork>:
// Returns envid of new environment, or < 0 on error.  Errors are:
//	-E_NO_FREE_ENV if no free environment is available.
//	-E_NO_MEM on memory exhaustion.
static envid_t
sys_exofork(void)
{
  800420d861:	55                   	push   %rbp
  800420d862:	48 89 e5             	mov    %rsp,%rbp
  800420d865:	53                   	push   %rbx
  800420d866:	48 83 ec 18          	sub    $0x18,%rsp

	int r;
	struct Env *e;

	if ((r = env_alloc(&e, curenv->env_id)) < 0)
  800420d86a:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420d871:	00 00 00 
  800420d874:	ff d0                	callq  *%rax
  800420d876:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420d87d:	00 00 00 
  800420d880:	48 98                	cltq   
  800420d882:	48 c1 e0 03          	shl    $0x3,%rax
  800420d886:	48 89 c1             	mov    %rax,%rcx
  800420d889:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d88d:	48 01 c8             	add    %rcx,%rax
  800420d890:	48 01 d0             	add    %rdx,%rax
  800420d893:	48 83 c0 08          	add    $0x8,%rax
  800420d897:	48 8b 00             	mov    (%rax),%rax
  800420d89a:	8b 90 c8 00 00 00    	mov    0xc8(%rax),%edx
  800420d8a0:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  800420d8a4:	89 d6                	mov    %edx,%esi
  800420d8a6:	48 89 c7             	mov    %rax,%rdi
  800420d8a9:	48 b8 d5 82 20 04 80 	movabs $0x80042082d5,%rax
  800420d8b0:	00 00 00 
  800420d8b3:	ff d0                	callq  *%rax
  800420d8b5:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420d8b8:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420d8bc:	79 05                	jns    800420d8c3 <sys_exofork+0x62>
		return r;
  800420d8be:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420d8c1:	eb 6c                	jmp    800420d92f <sys_exofork+0xce>
	e->env_status = ENV_NOT_RUNNABLE;
  800420d8c3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d8c7:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  800420d8ce:	00 00 00 
	e->env_tf = curenv->env_tf;
  800420d8d1:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
  800420d8d5:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420d8dc:	00 00 00 
  800420d8df:	ff d0                	callq  *%rax
  800420d8e1:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420d8e8:	00 00 00 
  800420d8eb:	48 98                	cltq   
  800420d8ed:	48 c1 e0 03          	shl    $0x3,%rax
  800420d8f1:	48 89 c1             	mov    %rax,%rcx
  800420d8f4:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d8f8:	48 01 c8             	add    %rcx,%rax
  800420d8fb:	48 01 d0             	add    %rdx,%rax
  800420d8fe:	48 83 c0 08          	add    $0x8,%rax
  800420d902:	48 8b 00             	mov    (%rax),%rax
  800420d905:	48 89 da             	mov    %rbx,%rdx
  800420d908:	48 89 c6             	mov    %rax,%rsi
  800420d90b:	b8 18 00 00 00       	mov    $0x18,%eax
  800420d910:	48 89 d7             	mov    %rdx,%rdi
  800420d913:	48 89 c1             	mov    %rax,%rcx
  800420d916:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
	e->env_tf.tf_regs.reg_rax = 0;
  800420d919:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d91d:	48 c7 40 70 00 00 00 	movq   $0x0,0x70(%rax)
  800420d924:	00 
	return e->env_id;
  800420d925:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d929:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax

}
  800420d92f:	48 83 c4 18          	add    $0x18,%rsp
  800420d933:	5b                   	pop    %rbx
  800420d934:	5d                   	pop    %rbp
  800420d935:	c3                   	retq   

000000800420d936 <sys_env_set_status>:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if status is not a valid status for an environment.
static int
sys_env_set_status(envid_t envid, int status)
{
  800420d936:	55                   	push   %rbp
  800420d937:	48 89 e5             	mov    %rsp,%rbp
  800420d93a:	48 83 ec 20          	sub    $0x20,%rsp
  800420d93e:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420d941:	89 75 e8             	mov    %esi,-0x18(%rbp)

	struct Env *e;
	int r;

	if ((r = envid2env(envid, &e, 1)) < 0)
  800420d944:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420d948:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420d94b:	ba 01 00 00 00       	mov    $0x1,%edx
  800420d950:	48 89 ce             	mov    %rcx,%rsi
  800420d953:	89 c7                	mov    %eax,%edi
  800420d955:	48 b8 46 7f 20 04 80 	movabs $0x8004207f46,%rax
  800420d95c:	00 00 00 
  800420d95f:	ff d0                	callq  *%rax
  800420d961:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420d964:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420d968:	79 05                	jns    800420d96f <sys_env_set_status+0x39>
		return r;
  800420d96a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d96d:	eb 25                	jmp    800420d994 <sys_env_set_status+0x5e>
	if (status != ENV_RUNNABLE && status != ENV_NOT_RUNNABLE)
  800420d96f:	83 7d e8 02          	cmpl   $0x2,-0x18(%rbp)
  800420d973:	74 0d                	je     800420d982 <sys_env_set_status+0x4c>
  800420d975:	83 7d e8 04          	cmpl   $0x4,-0x18(%rbp)
  800420d979:	74 07                	je     800420d982 <sys_env_set_status+0x4c>
		return -E_INVAL;
  800420d97b:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420d980:	eb 12                	jmp    800420d994 <sys_env_set_status+0x5e>
	e->env_status = status;
  800420d982:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d986:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800420d989:	89 90 d4 00 00 00    	mov    %edx,0xd4(%rax)
	return 0;
  800420d98f:	b8 00 00 00 00       	mov    $0x0,%eax

}
  800420d994:	c9                   	leaveq 
  800420d995:	c3                   	retq   

000000800420d996 <sys_env_set_trapframe>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  800420d996:	55                   	push   %rbp
  800420d997:	48 89 e5             	mov    %rsp,%rbp
  800420d99a:	48 81 ec e0 00 00 00 	sub    $0xe0,%rsp
  800420d9a1:	89 bd 2c ff ff ff    	mov    %edi,-0xd4(%rbp)
  800420d9a7:	48 89 b5 20 ff ff ff 	mov    %rsi,-0xe0(%rbp)

	int r;
	struct Env *e;
	struct Trapframe ltf;

	user_mem_assert(curenv, tf, sizeof(struct Trapframe), PTE_U);
  800420d9ae:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420d9b5:	00 00 00 
  800420d9b8:	ff d0                	callq  *%rax
  800420d9ba:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420d9c1:	00 00 00 
  800420d9c4:	48 98                	cltq   
  800420d9c6:	48 c1 e0 03          	shl    $0x3,%rax
  800420d9ca:	48 89 c1             	mov    %rax,%rcx
  800420d9cd:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d9d1:	48 01 c8             	add    %rcx,%rax
  800420d9d4:	48 01 d0             	add    %rdx,%rax
  800420d9d7:	48 83 c0 08          	add    $0x8,%rax
  800420d9db:	48 8b 00             	mov    (%rax),%rax
  800420d9de:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  800420d9e5:	b9 04 00 00 00       	mov    $0x4,%ecx
  800420d9ea:	ba c0 00 00 00       	mov    $0xc0,%edx
  800420d9ef:	48 89 c7             	mov    %rax,%rdi
  800420d9f2:	48 b8 a4 42 20 04 80 	movabs $0x80042042a4,%rax
  800420d9f9:	00 00 00 
  800420d9fc:	ff d0                	callq  *%rax
	ltf = *tf;
  800420d9fe:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  800420da05:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  800420da0c:	48 89 c6             	mov    %rax,%rsi
  800420da0f:	b8 18 00 00 00       	mov    $0x18,%eax
  800420da14:	48 89 d7             	mov    %rdx,%rdi
  800420da17:	48 89 c1             	mov    %rax,%rcx
  800420da1a:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
	ltf.tf_eflags |= FL_IF;
  800420da1d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420da21:	80 cc 02             	or     $0x2,%ah
  800420da24:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	ltf.tf_cs |= 3;
  800420da28:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  800420da2c:	83 c8 03             	or     $0x3,%eax
  800420da2f:	66 89 45 d0          	mov    %ax,-0x30(%rbp)

	if ((r = envid2env(envid, &e, 1)) < 0)
  800420da33:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420da37:	8b 85 2c ff ff ff    	mov    -0xd4(%rbp),%eax
  800420da3d:	ba 01 00 00 00       	mov    $0x1,%edx
  800420da42:	48 89 ce             	mov    %rcx,%rsi
  800420da45:	89 c7                	mov    %eax,%edi
  800420da47:	48 b8 46 7f 20 04 80 	movabs $0x8004207f46,%rax
  800420da4e:	00 00 00 
  800420da51:	ff d0                	callq  *%rax
  800420da53:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420da56:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420da5a:	79 05                	jns    800420da61 <sys_env_set_trapframe+0xcb>
		return r;
  800420da5c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420da5f:	eb 21                	jmp    800420da82 <sys_env_set_trapframe+0xec>
	e->env_tf = ltf;
  800420da61:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420da65:	48 89 c2             	mov    %rax,%rdx
  800420da68:	48 8d b5 30 ff ff ff 	lea    -0xd0(%rbp),%rsi
  800420da6f:	b8 18 00 00 00       	mov    $0x18,%eax
  800420da74:	48 89 d7             	mov    %rdx,%rdi
  800420da77:	48 89 c1             	mov    %rax,%rcx
  800420da7a:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
	return 0;
  800420da7d:	b8 00 00 00 00       	mov    $0x0,%eax

}
  800420da82:	c9                   	leaveq 
  800420da83:	c3                   	retq   

000000800420da84 <sys_env_set_pgfault_upcall>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_set_pgfault_upcall(envid_t envid, void *func)
{
  800420da84:	55                   	push   %rbp
  800420da85:	48 89 e5             	mov    %rsp,%rbp
  800420da88:	48 83 ec 20          	sub    $0x20,%rsp
  800420da8c:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420da8f:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)

	int r;
	struct Env *e;

	if ((r = envid2env(envid, &e, 1)) < 0)
  800420da93:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420da97:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420da9a:	ba 01 00 00 00       	mov    $0x1,%edx
  800420da9f:	48 89 ce             	mov    %rcx,%rsi
  800420daa2:	89 c7                	mov    %eax,%edi
  800420daa4:	48 b8 46 7f 20 04 80 	movabs $0x8004207f46,%rax
  800420daab:	00 00 00 
  800420daae:	ff d0                	callq  *%rax
  800420dab0:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420dab3:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420dab7:	79 05                	jns    800420dabe <sys_env_set_pgfault_upcall+0x3a>
		return r;
  800420dab9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420dabc:	eb 14                	jmp    800420dad2 <sys_env_set_pgfault_upcall+0x4e>
	e->env_pgfault_upcall = func;
  800420dabe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420dac2:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420dac6:	48 89 90 f0 00 00 00 	mov    %rdx,0xf0(%rax)
	return 0;
  800420dacd:	b8 00 00 00 00       	mov    $0x0,%eax

}
  800420dad2:	c9                   	leaveq 
  800420dad3:	c3                   	retq   

000000800420dad4 <sys_page_alloc>:
//	-E_INVAL if perm is inappropriate (see above).
//	-E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  800420dad4:	55                   	push   %rbp
  800420dad5:	48 89 e5             	mov    %rsp,%rbp
  800420dad8:	48 83 ec 30          	sub    $0x30,%rsp
  800420dadc:	89 7d dc             	mov    %edi,-0x24(%rbp)
  800420dadf:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420dae3:	89 55 d8             	mov    %edx,-0x28(%rbp)

	int r;
	struct Env *e;
	struct PageInfo *pp;

	if ((r = envid2env(envid, &e, 1)) < 0)
  800420dae6:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420daea:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420daed:	ba 01 00 00 00       	mov    $0x1,%edx
  800420daf2:	48 89 ce             	mov    %rcx,%rsi
  800420daf5:	89 c7                	mov    %eax,%edi
  800420daf7:	48 b8 46 7f 20 04 80 	movabs $0x8004207f46,%rax
  800420dafe:	00 00 00 
  800420db01:	ff d0                	callq  *%rax
  800420db03:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420db06:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420db0a:	79 08                	jns    800420db14 <sys_page_alloc+0x40>
		return r;
  800420db0c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420db0f:	e9 a7 00 00 00       	jmpq   800420dbbb <sys_page_alloc+0xe7>
	if ((~perm & (PTE_U|PTE_P)) || (perm & ~PTE_SYSCALL))
  800420db14:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420db17:	f7 d0                	not    %eax
  800420db19:	83 e0 05             	and    $0x5,%eax
  800420db1c:	85 c0                	test   %eax,%eax
  800420db1e:	75 0c                	jne    800420db2c <sys_page_alloc+0x58>
  800420db20:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420db23:	25 f8 f1 ff ff       	and    $0xfffff1f8,%eax
  800420db28:	85 c0                	test   %eax,%eax
  800420db2a:	74 0a                	je     800420db36 <sys_page_alloc+0x62>
		return -E_INVAL;
  800420db2c:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420db31:	e9 85 00 00 00       	jmpq   800420dbbb <sys_page_alloc+0xe7>
	if (va >= (void*) UTOP)
  800420db36:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420db3d:	00 00 00 
  800420db40:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  800420db44:	76 07                	jbe    800420db4d <sys_page_alloc+0x79>
		return -E_INVAL;
  800420db46:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420db4b:	eb 6e                	jmp    800420dbbb <sys_page_alloc+0xe7>
	if (!(pp = page_alloc(ALLOC_ZERO)))
  800420db4d:	bf 01 00 00 00       	mov    $0x1,%edi
  800420db52:	48 b8 e0 2f 20 04 80 	movabs $0x8004202fe0,%rax
  800420db59:	00 00 00 
  800420db5c:	ff d0                	callq  *%rax
  800420db5e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420db62:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420db67:	75 07                	jne    800420db70 <sys_page_alloc+0x9c>
		return -E_NO_MEM;
  800420db69:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420db6e:	eb 4b                	jmp    800420dbbb <sys_page_alloc+0xe7>
	if ((r = page_insert(e->env_pml4e, pp, va, perm)) < 0) {
  800420db70:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420db74:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420db7b:	8b 4d d8             	mov    -0x28(%rbp),%ecx
  800420db7e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420db82:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800420db86:	48 89 c7             	mov    %rax,%rdi
  800420db89:	48 b8 52 3b 20 04 80 	movabs $0x8004203b52,%rax
  800420db90:	00 00 00 
  800420db93:	ff d0                	callq  *%rax
  800420db95:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420db98:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420db9c:	79 18                	jns    800420dbb6 <sys_page_alloc+0xe2>
		page_free(pp);
  800420db9e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420dba2:	48 89 c7             	mov    %rax,%rdi
  800420dba5:	48 b8 92 30 20 04 80 	movabs $0x8004203092,%rax
  800420dbac:	00 00 00 
  800420dbaf:	ff d0                	callq  *%rax
		return r;
  800420dbb1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420dbb4:	eb 05                	jmp    800420dbbb <sys_page_alloc+0xe7>
	}
	return 0;
  800420dbb6:	b8 00 00 00 00       	mov    $0x0,%eax

}
  800420dbbb:	c9                   	leaveq 
  800420dbbc:	c3                   	retq   

000000800420dbbd <sys_page_map>:
//		address space.
//	-E_NO_MEM if there's no memory to allocate any necessary page tables.
static int
sys_page_map(envid_t srcenvid, void *srcva,
	     envid_t dstenvid, void *dstva, int perm)
{
  800420dbbd:	55                   	push   %rbp
  800420dbbe:	48 89 e5             	mov    %rsp,%rbp
  800420dbc1:	48 83 ec 60          	sub    $0x60,%rsp
  800420dbc5:	89 7d bc             	mov    %edi,-0x44(%rbp)
  800420dbc8:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  800420dbcc:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420dbcf:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
  800420dbd3:	44 89 45 a4          	mov    %r8d,-0x5c(%rbp)
	int r;
	struct Env *es, *ed;
	struct PageInfo *pp;
	pte_t *ppte;

	if (srcva >= (void*) UTOP || dstva >= (void*) UTOP)
  800420dbd7:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420dbde:	00 00 00 
  800420dbe1:	48 39 45 b0          	cmp    %rax,-0x50(%rbp)
  800420dbe5:	77 10                	ja     800420dbf7 <sys_page_map+0x3a>
  800420dbe7:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420dbee:	00 00 00 
  800420dbf1:	48 39 45 a8          	cmp    %rax,-0x58(%rbp)
  800420dbf5:	76 0a                	jbe    800420dc01 <sys_page_map+0x44>
		return -E_INVAL;
  800420dbf7:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420dbfc:	e9 3f 01 00 00       	jmpq   800420dd40 <sys_page_map+0x183>
	if (srcva != ROUNDDOWN(srcva, PGSIZE) || dstva != ROUNDDOWN(dstva, PGSIZE))
  800420dc01:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420dc05:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420dc09:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420dc0d:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420dc13:	48 3b 45 b0          	cmp    -0x50(%rbp),%rax
  800420dc17:	75 18                	jne    800420dc31 <sys_page_map+0x74>
  800420dc19:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420dc1d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420dc21:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dc25:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420dc2b:	48 3b 45 a8          	cmp    -0x58(%rbp),%rax
  800420dc2f:	74 0a                	je     800420dc3b <sys_page_map+0x7e>
		return -E_INVAL;
  800420dc31:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420dc36:	e9 05 01 00 00       	jmpq   800420dd40 <sys_page_map+0x183>

	if ((r = envid2env(srcenvid, &es, 1)) < 0
  800420dc3b:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  800420dc3f:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800420dc42:	ba 01 00 00 00       	mov    $0x1,%edx
  800420dc47:	48 89 ce             	mov    %rcx,%rsi
  800420dc4a:	89 c7                	mov    %eax,%edi
  800420dc4c:	48 b8 46 7f 20 04 80 	movabs $0x8004207f46,%rax
  800420dc53:	00 00 00 
  800420dc56:	ff d0                	callq  *%rax
  800420dc58:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420dc5b:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420dc5f:	78 26                	js     800420dc87 <sys_page_map+0xca>
            || (r = envid2env(dstenvid, &ed, 1)) < 0)
  800420dc61:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  800420dc65:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420dc68:	ba 01 00 00 00       	mov    $0x1,%edx
  800420dc6d:	48 89 ce             	mov    %rcx,%rsi
  800420dc70:	89 c7                	mov    %eax,%edi
  800420dc72:	48 b8 46 7f 20 04 80 	movabs $0x8004207f46,%rax
  800420dc79:	00 00 00 
  800420dc7c:	ff d0                	callq  *%rax
  800420dc7e:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420dc81:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420dc85:	79 08                	jns    800420dc8f <sys_page_map+0xd2>
		return r;
  800420dc87:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420dc8a:	e9 b1 00 00 00       	jmpq   800420dd40 <sys_page_map+0x183>
	if ((~perm & (PTE_U|PTE_P)) || (perm & ~PTE_SYSCALL))
  800420dc8f:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  800420dc92:	f7 d0                	not    %eax
  800420dc94:	83 e0 05             	and    $0x5,%eax
  800420dc97:	85 c0                	test   %eax,%eax
  800420dc99:	75 0c                	jne    800420dca7 <sys_page_map+0xea>
  800420dc9b:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  800420dc9e:	25 f8 f1 ff ff       	and    $0xfffff1f8,%eax
  800420dca3:	85 c0                	test   %eax,%eax
  800420dca5:	74 0a                	je     800420dcb1 <sys_page_map+0xf4>
		return -E_INVAL;
  800420dca7:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420dcac:	e9 8f 00 00 00       	jmpq   800420dd40 <sys_page_map+0x183>
	if ((pp = page_lookup(es->env_pml4e, srcva, &ppte)) == 0)
  800420dcb1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420dcb5:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420dcbc:	48 8d 55 c8          	lea    -0x38(%rbp),%rdx
  800420dcc0:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  800420dcc4:	48 89 ce             	mov    %rcx,%rsi
  800420dcc7:	48 89 c7             	mov    %rax,%rdi
  800420dcca:	48 b8 c2 3e 20 04 80 	movabs $0x8004203ec2,%rax
  800420dcd1:	00 00 00 
  800420dcd4:	ff d0                	callq  *%rax
  800420dcd6:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420dcda:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420dcdf:	75 07                	jne    800420dce8 <sys_page_map+0x12b>
		return -E_INVAL;
  800420dce1:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420dce6:	eb 58                	jmp    800420dd40 <sys_page_map+0x183>
	if ((perm & PTE_W) && !(*ppte & PTE_W))
  800420dce8:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  800420dceb:	83 e0 02             	and    $0x2,%eax
  800420dcee:	85 c0                	test   %eax,%eax
  800420dcf0:	74 16                	je     800420dd08 <sys_page_map+0x14b>
  800420dcf2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420dcf6:	48 8b 00             	mov    (%rax),%rax
  800420dcf9:	83 e0 02             	and    $0x2,%eax
  800420dcfc:	48 85 c0             	test   %rax,%rax
  800420dcff:	75 07                	jne    800420dd08 <sys_page_map+0x14b>
		return -E_INVAL;
  800420dd01:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420dd06:	eb 38                	jmp    800420dd40 <sys_page_map+0x183>
	if ((r = page_insert(ed->env_pml4e, pp, dstva, perm)) < 0)
  800420dd08:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420dd0c:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420dd13:	8b 4d a4             	mov    -0x5c(%rbp),%ecx
  800420dd16:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800420dd1a:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420dd1e:	48 89 c7             	mov    %rax,%rdi
  800420dd21:	48 b8 52 3b 20 04 80 	movabs $0x8004203b52,%rax
  800420dd28:	00 00 00 
  800420dd2b:	ff d0                	callq  *%rax
  800420dd2d:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420dd30:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420dd34:	79 05                	jns    800420dd3b <sys_page_map+0x17e>
		return r;
  800420dd36:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420dd39:	eb 05                	jmp    800420dd40 <sys_page_map+0x183>
	return 0;
  800420dd3b:	b8 00 00 00 00       	mov    $0x0,%eax

}
  800420dd40:	c9                   	leaveq 
  800420dd41:	c3                   	retq   

000000800420dd42 <sys_page_unmap>:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if va >= UTOP, or va is not page-aligned.
static int
sys_page_unmap(envid_t envid, void *va)
{
  800420dd42:	55                   	push   %rbp
  800420dd43:	48 89 e5             	mov    %rsp,%rbp
  800420dd46:	48 83 ec 20          	sub    $0x20,%rsp
  800420dd4a:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420dd4d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)

	int r;
	struct Env *e;

	if ((r = envid2env(envid, &e, 1)) < 0)
  800420dd51:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420dd55:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420dd58:	ba 01 00 00 00       	mov    $0x1,%edx
  800420dd5d:	48 89 ce             	mov    %rcx,%rsi
  800420dd60:	89 c7                	mov    %eax,%edi
  800420dd62:	48 b8 46 7f 20 04 80 	movabs $0x8004207f46,%rax
  800420dd69:	00 00 00 
  800420dd6c:	ff d0                	callq  *%rax
  800420dd6e:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420dd71:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420dd75:	79 05                	jns    800420dd7c <sys_page_unmap+0x3a>
		return r;
  800420dd77:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420dd7a:	eb 4b                	jmp    800420ddc7 <sys_page_unmap+0x85>
	if (va >= (void*) UTOP || PGOFF(va))
  800420dd7c:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420dd83:	00 00 00 
  800420dd86:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  800420dd8a:	77 0e                	ja     800420dd9a <sys_page_unmap+0x58>
  800420dd8c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420dd90:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420dd95:	48 85 c0             	test   %rax,%rax
  800420dd98:	74 07                	je     800420dda1 <sys_page_unmap+0x5f>
		return -E_INVAL;
  800420dd9a:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420dd9f:	eb 26                	jmp    800420ddc7 <sys_page_unmap+0x85>
	page_remove(e->env_pml4e, va);
  800420dda1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420dda5:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420ddac:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420ddb0:	48 89 d6             	mov    %rdx,%rsi
  800420ddb3:	48 89 c7             	mov    %rax,%rdi
  800420ddb6:	48 b8 4d 3f 20 04 80 	movabs $0x8004203f4d,%rax
  800420ddbd:	00 00 00 
  800420ddc0:	ff d0                	callq  *%rax
	return 0;
  800420ddc2:	b8 00 00 00 00       	mov    $0x0,%eax

}
  800420ddc7:	c9                   	leaveq 
  800420ddc8:	c3                   	retq   

000000800420ddc9 <sys_ipc_try_send>:
//		current environment's address space.
//	-E_NO_MEM if there's not enough memory to map srcva in envid's
//		address space.
static int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)
{
  800420ddc9:	55                   	push   %rbp
  800420ddca:	48 89 e5             	mov    %rsp,%rbp
  800420ddcd:	53                   	push   %rbx
  800420ddce:	48 83 ec 58          	sub    $0x58,%rsp
  800420ddd2:	89 7d bc             	mov    %edi,-0x44(%rbp)
  800420ddd5:	89 75 b8             	mov    %esi,-0x48(%rbp)
  800420ddd8:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
  800420dddc:	89 4d ac             	mov    %ecx,-0x54(%rbp)

	int r;
	struct Env *e;
	struct PageInfo *pp;
	pte_t *ppte;    
	if ((r = envid2env(envid, &e, 0)) < 0)
  800420dddf:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  800420dde3:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800420dde6:	ba 00 00 00 00       	mov    $0x0,%edx
  800420ddeb:	48 89 ce             	mov    %rcx,%rsi
  800420ddee:	89 c7                	mov    %eax,%edi
  800420ddf0:	48 b8 46 7f 20 04 80 	movabs $0x8004207f46,%rax
  800420ddf7:	00 00 00 
  800420ddfa:	ff d0                	callq  *%rax
  800420ddfc:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420ddff:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420de03:	79 08                	jns    800420de0d <sys_ipc_try_send+0x44>
		return r;
  800420de05:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420de08:	e9 58 06 00 00       	jmpq   800420e465 <sys_ipc_try_send+0x69c>
	if (!e->env_ipc_recving) {
  800420de0d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420de11:	0f b6 80 f8 00 00 00 	movzbl 0xf8(%rax),%eax
  800420de18:	83 f0 01             	xor    $0x1,%eax
  800420de1b:	84 c0                	test   %al,%al
  800420de1d:	74 0a                	je     800420de29 <sys_ipc_try_send+0x60>
		//cprintf("[%08x] not recieving!\n", e->env_id);
		return -E_IPC_NOT_RECV;
  800420de1f:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  800420de24:	e9 3c 06 00 00       	jmpq   800420e465 <sys_ipc_try_send+0x69c>
	}

	if(curenv->env_type == ENV_TYPE_GUEST && e->env_ipc_dstva < (void*) UTOP) {
  800420de29:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420de30:	00 00 00 
  800420de33:	ff d0                	callq  *%rax
  800420de35:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420de3c:	00 00 00 
  800420de3f:	48 98                	cltq   
  800420de41:	48 c1 e0 03          	shl    $0x3,%rax
  800420de45:	48 89 c1             	mov    %rax,%rcx
  800420de48:	48 c1 e1 04          	shl    $0x4,%rcx
  800420de4c:	48 01 c8             	add    %rcx,%rax
  800420de4f:	48 01 d0             	add    %rdx,%rax
  800420de52:	48 83 c0 08          	add    $0x8,%rax
  800420de56:	48 8b 00             	mov    (%rax),%rax
  800420de59:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  800420de5f:	83 f8 03             	cmp    $0x3,%eax
  800420de62:	0f 85 7b 01 00 00    	jne    800420dfe3 <sys_ipc_try_send+0x21a>
  800420de68:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420de6c:	48 8b 90 00 01 00 00 	mov    0x100(%rax),%rdx
  800420de73:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420de7a:	00 00 00 
  800420de7d:	48 39 c2             	cmp    %rax,%rdx
  800420de80:	0f 87 5d 01 00 00    	ja     800420dfe3 <sys_ipc_try_send+0x21a>
		// Guest sending a message. srcva is a kernel page.
		//cprintf("Sending message from a guest\n");
		assert(srcva >= (void*)KERNBASE);
  800420de86:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420de8d:	00 00 00 
  800420de90:	48 39 45 b0          	cmp    %rax,-0x50(%rbp)
  800420de94:	77 35                	ja     800420decb <sys_ipc_try_send+0x102>
  800420de96:	48 b9 1a a7 21 04 80 	movabs $0x800421a71a,%rcx
  800420de9d:	00 00 00 
  800420dea0:	48 ba 33 a7 21 04 80 	movabs $0x800421a733,%rdx
  800420dea7:	00 00 00 
  800420deaa:	be 62 01 00 00       	mov    $0x162,%esi
  800420deaf:	48 bf 48 a7 21 04 80 	movabs $0x800421a748,%rdi
  800420deb6:	00 00 00 
  800420deb9:	b8 00 00 00 00       	mov    $0x0,%eax
  800420debe:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  800420dec5:	00 00 00 
  800420dec8:	41 ff d0             	callq  *%r8
		pp = pa2page(PADDR(srcva));
  800420decb:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420decf:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420ded3:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420deda:	00 00 00 
  800420dedd:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  800420dee1:	77 32                	ja     800420df15 <sys_ipc_try_send+0x14c>
  800420dee3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420dee7:	48 89 c1             	mov    %rax,%rcx
  800420deea:	48 ba 58 a7 21 04 80 	movabs $0x800421a758,%rdx
  800420def1:	00 00 00 
  800420def4:	be 63 01 00 00       	mov    $0x163,%esi
  800420def9:	48 bf 48 a7 21 04 80 	movabs $0x800421a748,%rdi
  800420df00:	00 00 00 
  800420df03:	b8 00 00 00 00       	mov    $0x0,%eax
  800420df08:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  800420df0f:	00 00 00 
  800420df12:	41 ff d0             	callq  *%r8
  800420df15:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420df1c:	ff ff ff 
  800420df1f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420df23:	48 01 d0             	add    %rdx,%rax
  800420df26:	48 89 c7             	mov    %rax,%rdi
  800420df29:	48 b8 be d6 20 04 80 	movabs $0x800420d6be,%rax
  800420df30:	00 00 00 
  800420df33:	ff d0                	callq  *%rax
  800420df35:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

		r = page_insert(e->env_pml4e, pp, e->env_ipc_dstva, perm);
  800420df39:	8b 4d ac             	mov    -0x54(%rbp),%ecx
  800420df3c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420df40:	48 8b 90 00 01 00 00 	mov    0x100(%rax),%rdx
  800420df47:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420df4b:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420df52:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  800420df56:	48 89 c7             	mov    %rax,%rdi
  800420df59:	48 b8 52 3b 20 04 80 	movabs $0x8004203b52,%rax
  800420df60:	00 00 00 
  800420df63:	ff d0                	callq  *%rax
  800420df65:	89 45 ec             	mov    %eax,-0x14(%rbp)
		if (r < 0) {
  800420df68:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420df6c:	79 63                	jns    800420dfd1 <sys_ipc_try_send+0x208>
			cprintf("[%08x] page_insert %08x failed in sys_ipc_try_send (%e)\n", curenv->env_id, srcva, r);
  800420df6e:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420df75:	00 00 00 
  800420df78:	ff d0                	callq  *%rax
  800420df7a:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420df81:	00 00 00 
  800420df84:	48 98                	cltq   
  800420df86:	48 c1 e0 03          	shl    $0x3,%rax
  800420df8a:	48 89 c1             	mov    %rax,%rcx
  800420df8d:	48 c1 e1 04          	shl    $0x4,%rcx
  800420df91:	48 01 c8             	add    %rcx,%rax
  800420df94:	48 01 d0             	add    %rdx,%rax
  800420df97:	48 83 c0 08          	add    $0x8,%rax
  800420df9b:	48 8b 00             	mov    (%rax),%rax
  800420df9e:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420dfa4:	8b 4d ec             	mov    -0x14(%rbp),%ecx
  800420dfa7:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420dfab:	89 c6                	mov    %eax,%esi
  800420dfad:	48 bf 80 a7 21 04 80 	movabs $0x800421a780,%rdi
  800420dfb4:	00 00 00 
  800420dfb7:	b8 00 00 00 00       	mov    $0x0,%eax
  800420dfbc:	49 b8 90 95 20 04 80 	movabs $0x8004209590,%r8
  800420dfc3:	00 00 00 
  800420dfc6:	41 ff d0             	callq  *%r8
			return r;
  800420dfc9:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420dfcc:	e9 94 04 00 00       	jmpq   800420e465 <sys_ipc_try_send+0x69c>
		}

		e->env_ipc_perm = perm;
  800420dfd1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420dfd5:	8b 55 ac             	mov    -0x54(%rbp),%edx
  800420dfd8:	89 90 10 01 00 00    	mov    %edx,0x110(%rax)
  800420dfde:	e9 f1 03 00 00       	jmpq   800420e3d4 <sys_ipc_try_send+0x60b>
	} else if(e->env_type == ENV_TYPE_GUEST && srcva < (void*) UTOP) {
  800420dfe3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420dfe7:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  800420dfed:	83 f8 03             	cmp    $0x3,%eax
  800420dff0:	0f 85 4c 01 00 00    	jne    800420e142 <sys_ipc_try_send+0x379>
  800420dff6:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420dffd:	00 00 00 
  800420e000:	48 39 45 b0          	cmp    %rax,-0x50(%rbp)
  800420e004:	0f 87 38 01 00 00    	ja     800420e142 <sys_ipc_try_send+0x379>
		// Sending a message to a VMX guest.
		//cprintf("Sending message to guest\n");
		pp = page_lookup(curenv->env_pml4e, srcva, &ppte);
  800420e00a:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420e011:	00 00 00 
  800420e014:	ff d0                	callq  *%rax
  800420e016:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420e01d:	00 00 00 
  800420e020:	48 98                	cltq   
  800420e022:	48 c1 e0 03          	shl    $0x3,%rax
  800420e026:	48 89 c1             	mov    %rax,%rcx
  800420e029:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e02d:	48 01 c8             	add    %rcx,%rax
  800420e030:	48 01 d0             	add    %rdx,%rax
  800420e033:	48 83 c0 08          	add    $0x8,%rax
  800420e037:	48 8b 00             	mov    (%rax),%rax
  800420e03a:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420e041:	48 8d 55 c8          	lea    -0x38(%rbp),%rdx
  800420e045:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  800420e049:	48 89 ce             	mov    %rcx,%rsi
  800420e04c:	48 89 c7             	mov    %rax,%rdi
  800420e04f:	48 b8 c2 3e 20 04 80 	movabs $0x8004203ec2,%rax
  800420e056:	00 00 00 
  800420e059:	ff d0                	callq  *%rax
  800420e05b:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		if(pp == 0) {
  800420e05f:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420e064:	75 61                	jne    800420e0c7 <sys_ipc_try_send+0x2fe>
			cprintf("[%08x] page_lookup %08x failed in sys_ipc_try_send\n", curenv->env_id, srcva);
  800420e066:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420e06d:	00 00 00 
  800420e070:	ff d0                	callq  *%rax
  800420e072:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420e079:	00 00 00 
  800420e07c:	48 98                	cltq   
  800420e07e:	48 c1 e0 03          	shl    $0x3,%rax
  800420e082:	48 89 c1             	mov    %rax,%rcx
  800420e085:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e089:	48 01 c8             	add    %rcx,%rax
  800420e08c:	48 01 d0             	add    %rdx,%rax
  800420e08f:	48 83 c0 08          	add    $0x8,%rax
  800420e093:	48 8b 00             	mov    (%rax),%rax
  800420e096:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420e09c:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420e0a0:	89 c6                	mov    %eax,%esi
  800420e0a2:	48 bf c0 a7 21 04 80 	movabs $0x800421a7c0,%rdi
  800420e0a9:	00 00 00 
  800420e0ac:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e0b1:	48 b9 90 95 20 04 80 	movabs $0x8004209590,%rcx
  800420e0b8:	00 00 00 
  800420e0bb:	ff d1                	callq  *%rcx
			return -E_INVAL;
  800420e0bd:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e0c2:	e9 9e 03 00 00       	jmpq   800420e465 <sys_ipc_try_send+0x69c>
		}

		if ((perm & PTE_W) && !(*ppte &PTE_W)) {
  800420e0c7:	8b 45 ac             	mov    -0x54(%rbp),%eax
  800420e0ca:	83 e0 02             	and    $0x2,%eax
  800420e0cd:	85 c0                	test   %eax,%eax
  800420e0cf:	74 6c                	je     800420e13d <sys_ipc_try_send+0x374>
  800420e0d1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420e0d5:	48 8b 00             	mov    (%rax),%rax
  800420e0d8:	83 e0 02             	and    $0x2,%eax
  800420e0db:	48 85 c0             	test   %rax,%rax
  800420e0de:	75 5d                	jne    800420e13d <sys_ipc_try_send+0x374>
			cprintf("[%08x] attempt to send read-only page read-write in sys_ipc_try_send\n", curenv->env_id);
  800420e0e0:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420e0e7:	00 00 00 
  800420e0ea:	ff d0                	callq  *%rax
  800420e0ec:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420e0f3:	00 00 00 
  800420e0f6:	48 98                	cltq   
  800420e0f8:	48 c1 e0 03          	shl    $0x3,%rax
  800420e0fc:	48 89 c1             	mov    %rax,%rcx
  800420e0ff:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e103:	48 01 c8             	add    %rcx,%rax
  800420e106:	48 01 d0             	add    %rdx,%rax
  800420e109:	48 83 c0 08          	add    $0x8,%rax
  800420e10d:	48 8b 00             	mov    (%rax),%rax
  800420e110:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420e116:	89 c6                	mov    %eax,%esi
  800420e118:	48 bf f8 a7 21 04 80 	movabs $0x800421a7f8,%rdi
  800420e11f:	00 00 00 
  800420e122:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e127:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  800420e12e:	00 00 00 
  800420e131:	ff d2                	callq  *%rdx
			return -E_INVAL;
  800420e133:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e138:	e9 28 03 00 00       	jmpq   800420e465 <sys_ipc_try_send+0x69c>
		if(pp == 0) {
			cprintf("[%08x] page_lookup %08x failed in sys_ipc_try_send\n", curenv->env_id, srcva);
			return -E_INVAL;
		}

		if ((perm & PTE_W) && !(*ppte &PTE_W)) {
  800420e13d:	e9 92 02 00 00       	jmpq   800420e3d4 <sys_ipc_try_send+0x60b>
		// TODO: Fix permissions.
#ifndef VMM_GUEST
		r = ept_page_insert(e->env_pml4e, pp, e->env_ipc_dstva, __EPTE_FULL);
#endif
    
	} else if (srcva < (void*) UTOP && e->env_ipc_dstva < (void*) UTOP) {
  800420e142:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420e149:	00 00 00 
  800420e14c:	48 39 45 b0          	cmp    %rax,-0x50(%rbp)
  800420e150:	0f 87 70 02 00 00    	ja     800420e3c6 <sys_ipc_try_send+0x5fd>
  800420e156:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e15a:	48 8b 90 00 01 00 00 	mov    0x100(%rax),%rdx
  800420e161:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420e168:	00 00 00 
  800420e16b:	48 39 c2             	cmp    %rax,%rdx
  800420e16e:	0f 87 52 02 00 00    	ja     800420e3c6 <sys_ipc_try_send+0x5fd>

			if ((~perm & (PTE_U|PTE_P)) || (perm & ~PTE_SYSCALL)) {
  800420e174:	8b 45 ac             	mov    -0x54(%rbp),%eax
  800420e177:	f7 d0                	not    %eax
  800420e179:	83 e0 05             	and    $0x5,%eax
  800420e17c:	85 c0                	test   %eax,%eax
  800420e17e:	75 0c                	jne    800420e18c <sys_ipc_try_send+0x3c3>
  800420e180:	8b 45 ac             	mov    -0x54(%rbp),%eax
  800420e183:	25 f8 f1 ff ff       	and    $0xfffff1f8,%eax
  800420e188:	85 c0                	test   %eax,%eax
  800420e18a:	74 60                	je     800420e1ec <sys_ipc_try_send+0x423>
				cprintf("[%08x] bad perm %x in sys_ipc_try_send\n", curenv->env_id, perm);
  800420e18c:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420e193:	00 00 00 
  800420e196:	ff d0                	callq  *%rax
  800420e198:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420e19f:	00 00 00 
  800420e1a2:	48 98                	cltq   
  800420e1a4:	48 c1 e0 03          	shl    $0x3,%rax
  800420e1a8:	48 89 c1             	mov    %rax,%rcx
  800420e1ab:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e1af:	48 01 c8             	add    %rcx,%rax
  800420e1b2:	48 01 d0             	add    %rdx,%rax
  800420e1b5:	48 83 c0 08          	add    $0x8,%rax
  800420e1b9:	48 8b 00             	mov    (%rax),%rax
  800420e1bc:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420e1c2:	8b 55 ac             	mov    -0x54(%rbp),%edx
  800420e1c5:	89 c6                	mov    %eax,%esi
  800420e1c7:	48 bf 40 a8 21 04 80 	movabs $0x800421a840,%rdi
  800420e1ce:	00 00 00 
  800420e1d1:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e1d6:	48 b9 90 95 20 04 80 	movabs $0x8004209590,%rcx
  800420e1dd:	00 00 00 
  800420e1e0:	ff d1                	callq  *%rcx
				return -E_INVAL;
  800420e1e2:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e1e7:	e9 79 02 00 00       	jmpq   800420e465 <sys_ipc_try_send+0x69c>
			}

			pp = page_lookup(curenv->env_pml4e, srcva, &ppte);
  800420e1ec:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420e1f3:	00 00 00 
  800420e1f6:	ff d0                	callq  *%rax
  800420e1f8:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420e1ff:	00 00 00 
  800420e202:	48 98                	cltq   
  800420e204:	48 c1 e0 03          	shl    $0x3,%rax
  800420e208:	48 89 c1             	mov    %rax,%rcx
  800420e20b:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e20f:	48 01 c8             	add    %rcx,%rax
  800420e212:	48 01 d0             	add    %rdx,%rax
  800420e215:	48 83 c0 08          	add    $0x8,%rax
  800420e219:	48 8b 00             	mov    (%rax),%rax
  800420e21c:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420e223:	48 8d 55 c8          	lea    -0x38(%rbp),%rdx
  800420e227:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  800420e22b:	48 89 ce             	mov    %rcx,%rsi
  800420e22e:	48 89 c7             	mov    %rax,%rdi
  800420e231:	48 b8 c2 3e 20 04 80 	movabs $0x8004203ec2,%rax
  800420e238:	00 00 00 
  800420e23b:	ff d0                	callq  *%rax
  800420e23d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
			if (pp == 0) {
  800420e241:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420e246:	75 61                	jne    800420e2a9 <sys_ipc_try_send+0x4e0>
				cprintf("[%08x] page_lookup %08x failed in sys_ipc_try_send\n", curenv->env_id, srcva);
  800420e248:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420e24f:	00 00 00 
  800420e252:	ff d0                	callq  *%rax
  800420e254:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420e25b:	00 00 00 
  800420e25e:	48 98                	cltq   
  800420e260:	48 c1 e0 03          	shl    $0x3,%rax
  800420e264:	48 89 c1             	mov    %rax,%rcx
  800420e267:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e26b:	48 01 c8             	add    %rcx,%rax
  800420e26e:	48 01 d0             	add    %rdx,%rax
  800420e271:	48 83 c0 08          	add    $0x8,%rax
  800420e275:	48 8b 00             	mov    (%rax),%rax
  800420e278:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420e27e:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420e282:	89 c6                	mov    %eax,%esi
  800420e284:	48 bf c0 a7 21 04 80 	movabs $0x800421a7c0,%rdi
  800420e28b:	00 00 00 
  800420e28e:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e293:	48 b9 90 95 20 04 80 	movabs $0x8004209590,%rcx
  800420e29a:	00 00 00 
  800420e29d:	ff d1                	callq  *%rcx
				return -E_INVAL;
  800420e29f:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e2a4:	e9 bc 01 00 00       	jmpq   800420e465 <sys_ipc_try_send+0x69c>
			}

			if ((perm & PTE_W) && !(*ppte & PTE_W)) {
  800420e2a9:	8b 45 ac             	mov    -0x54(%rbp),%eax
  800420e2ac:	83 e0 02             	and    $0x2,%eax
  800420e2af:	85 c0                	test   %eax,%eax
  800420e2b1:	74 6c                	je     800420e31f <sys_ipc_try_send+0x556>
  800420e2b3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420e2b7:	48 8b 00             	mov    (%rax),%rax
  800420e2ba:	83 e0 02             	and    $0x2,%eax
  800420e2bd:	48 85 c0             	test   %rax,%rax
  800420e2c0:	75 5d                	jne    800420e31f <sys_ipc_try_send+0x556>
				cprintf("[%08x] attempt to send read-only page read-write in sys_ipc_try_send\n", curenv->env_id);
  800420e2c2:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420e2c9:	00 00 00 
  800420e2cc:	ff d0                	callq  *%rax
  800420e2ce:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420e2d5:	00 00 00 
  800420e2d8:	48 98                	cltq   
  800420e2da:	48 c1 e0 03          	shl    $0x3,%rax
  800420e2de:	48 89 c1             	mov    %rax,%rcx
  800420e2e1:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e2e5:	48 01 c8             	add    %rcx,%rax
  800420e2e8:	48 01 d0             	add    %rdx,%rax
  800420e2eb:	48 83 c0 08          	add    $0x8,%rax
  800420e2ef:	48 8b 00             	mov    (%rax),%rax
  800420e2f2:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420e2f8:	89 c6                	mov    %eax,%esi
  800420e2fa:	48 bf f8 a7 21 04 80 	movabs $0x800421a7f8,%rdi
  800420e301:	00 00 00 
  800420e304:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e309:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  800420e310:	00 00 00 
  800420e313:	ff d2                	callq  *%rdx
				return -E_INVAL;
  800420e315:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e31a:	e9 46 01 00 00       	jmpq   800420e465 <sys_ipc_try_send+0x69c>
			}

			r = page_insert(e->env_pml4e, pp, e->env_ipc_dstva, perm);
  800420e31f:	8b 4d ac             	mov    -0x54(%rbp),%ecx
  800420e322:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e326:	48 8b 90 00 01 00 00 	mov    0x100(%rax),%rdx
  800420e32d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e331:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420e338:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  800420e33c:	48 89 c7             	mov    %rax,%rdi
  800420e33f:	48 b8 52 3b 20 04 80 	movabs $0x8004203b52,%rax
  800420e346:	00 00 00 
  800420e349:	ff d0                	callq  *%rax
  800420e34b:	89 45 ec             	mov    %eax,-0x14(%rbp)
			if (r < 0) {
  800420e34e:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420e352:	79 63                	jns    800420e3b7 <sys_ipc_try_send+0x5ee>
				cprintf("[%08x] page_insert %08x failed in sys_ipc_try_send (%e)\n", curenv->env_id, srcva, r);
  800420e354:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420e35b:	00 00 00 
  800420e35e:	ff d0                	callq  *%rax
  800420e360:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420e367:	00 00 00 
  800420e36a:	48 98                	cltq   
  800420e36c:	48 c1 e0 03          	shl    $0x3,%rax
  800420e370:	48 89 c1             	mov    %rax,%rcx
  800420e373:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e377:	48 01 c8             	add    %rcx,%rax
  800420e37a:	48 01 d0             	add    %rdx,%rax
  800420e37d:	48 83 c0 08          	add    $0x8,%rax
  800420e381:	48 8b 00             	mov    (%rax),%rax
  800420e384:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420e38a:	8b 4d ec             	mov    -0x14(%rbp),%ecx
  800420e38d:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420e391:	89 c6                	mov    %eax,%esi
  800420e393:	48 bf 80 a7 21 04 80 	movabs $0x800421a780,%rdi
  800420e39a:	00 00 00 
  800420e39d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e3a2:	49 b8 90 95 20 04 80 	movabs $0x8004209590,%r8
  800420e3a9:	00 00 00 
  800420e3ac:	41 ff d0             	callq  *%r8
				return r;
  800420e3af:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420e3b2:	e9 ae 00 00 00       	jmpq   800420e465 <sys_ipc_try_send+0x69c>
			}

			e->env_ipc_perm = perm;
  800420e3b7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e3bb:	8b 55 ac             	mov    -0x54(%rbp),%edx
  800420e3be:	89 90 10 01 00 00    	mov    %edx,0x110(%rax)
  800420e3c4:	eb 0e                	jmp    800420e3d4 <sys_ipc_try_send+0x60b>
		} else {
			e->env_ipc_perm = 0;
  800420e3c6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e3ca:	c7 80 10 01 00 00 00 	movl   $0x0,0x110(%rax)
  800420e3d1:	00 00 00 
		}

		e->env_ipc_recving = 0;
  800420e3d4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e3d8:	c6 80 f8 00 00 00 00 	movb   $0x0,0xf8(%rax)
		e->env_ipc_from = curenv->env_id;
  800420e3df:	48 8b 5d d0          	mov    -0x30(%rbp),%rbx
  800420e3e3:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420e3ea:	00 00 00 
  800420e3ed:	ff d0                	callq  *%rax
  800420e3ef:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420e3f6:	00 00 00 
  800420e3f9:	48 98                	cltq   
  800420e3fb:	48 c1 e0 03          	shl    $0x3,%rax
  800420e3ff:	48 89 c1             	mov    %rax,%rcx
  800420e402:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e406:	48 01 c8             	add    %rcx,%rax
  800420e409:	48 01 d0             	add    %rdx,%rax
  800420e40c:	48 83 c0 08          	add    $0x8,%rax
  800420e410:	48 8b 00             	mov    (%rax),%rax
  800420e413:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420e419:	89 83 0c 01 00 00    	mov    %eax,0x10c(%rbx)
		e->env_ipc_value = value;
  800420e41f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e423:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420e426:	89 90 08 01 00 00    	mov    %edx,0x108(%rax)
		e->env_tf.tf_regs.reg_rax = 0;
  800420e42c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e430:	48 c7 40 70 00 00 00 	movq   $0x0,0x70(%rax)
  800420e437:	00 
		e->env_status = ENV_RUNNABLE;
  800420e438:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e43c:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  800420e443:	00 00 00 

		if(e->env_type == ENV_TYPE_GUEST) {
  800420e446:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e44a:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  800420e450:	83 f8 03             	cmp    $0x3,%eax
  800420e453:	75 0b                	jne    800420e460 <sys_ipc_try_send+0x697>
			e->env_tf.tf_regs.reg_rsi = value;
  800420e455:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e459:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420e45c:	48 89 50 40          	mov    %rdx,0x40(%rax)
		}

		return 0;
  800420e460:	b8 00 00 00 00       	mov    $0x0,%eax

	}
  800420e465:	48 83 c4 58          	add    $0x58,%rsp
  800420e469:	5b                   	pop    %rbx
  800420e46a:	5d                   	pop    %rbp
  800420e46b:	c3                   	retq   

000000800420e46c <sys_ipc_recv>:
// return 0 on success.
// Return < 0 on error.  Errors are:
//	-E_INVAL if dstva < UTOP but dstva is not page-aligned.
static int
sys_ipc_recv(void *dstva)
{
  800420e46c:	55                   	push   %rbp
  800420e46d:	48 89 e5             	mov    %rsp,%rbp
  800420e470:	48 83 ec 10          	sub    $0x10,%rsp
  800420e474:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)

	if (curenv->env_ipc_recving)
  800420e478:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420e47f:	00 00 00 
  800420e482:	ff d0                	callq  *%rax
  800420e484:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420e48b:	00 00 00 
  800420e48e:	48 98                	cltq   
  800420e490:	48 c1 e0 03          	shl    $0x3,%rax
  800420e494:	48 89 c1             	mov    %rax,%rcx
  800420e497:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e49b:	48 01 c8             	add    %rcx,%rax
  800420e49e:	48 01 d0             	add    %rdx,%rax
  800420e4a1:	48 83 c0 08          	add    $0x8,%rax
  800420e4a5:	48 8b 00             	mov    (%rax),%rax
  800420e4a8:	0f b6 80 f8 00 00 00 	movzbl 0xf8(%rax),%eax
  800420e4af:	84 c0                	test   %al,%al
  800420e4b1:	74 2a                	je     800420e4dd <sys_ipc_recv+0x71>
		panic("already recving!");
  800420e4b3:	48 ba 68 a8 21 04 80 	movabs $0x800421a868,%rdx
  800420e4ba:	00 00 00 
  800420e4bd:	be bb 01 00 00       	mov    $0x1bb,%esi
  800420e4c2:	48 bf 48 a7 21 04 80 	movabs $0x800421a748,%rdi
  800420e4c9:	00 00 00 
  800420e4cc:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e4d1:	48 b9 e4 05 20 04 80 	movabs $0x80042005e4,%rcx
  800420e4d8:	00 00 00 
  800420e4db:	ff d1                	callq  *%rcx
	
	curenv->env_ipc_recving = 1;
  800420e4dd:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420e4e4:	00 00 00 
  800420e4e7:	ff d0                	callq  *%rax
  800420e4e9:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420e4f0:	00 00 00 
  800420e4f3:	48 98                	cltq   
  800420e4f5:	48 c1 e0 03          	shl    $0x3,%rax
  800420e4f9:	48 89 c1             	mov    %rax,%rcx
  800420e4fc:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e500:	48 01 c8             	add    %rcx,%rax
  800420e503:	48 01 d0             	add    %rdx,%rax
  800420e506:	48 83 c0 08          	add    $0x8,%rax
  800420e50a:	48 8b 00             	mov    (%rax),%rax
  800420e50d:	c6 80 f8 00 00 00 01 	movb   $0x1,0xf8(%rax)
	curenv->env_ipc_dstva = dstva;
  800420e514:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420e51b:	00 00 00 
  800420e51e:	ff d0                	callq  *%rax
  800420e520:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420e527:	00 00 00 
  800420e52a:	48 98                	cltq   
  800420e52c:	48 c1 e0 03          	shl    $0x3,%rax
  800420e530:	48 89 c1             	mov    %rax,%rcx
  800420e533:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e537:	48 01 c8             	add    %rcx,%rax
  800420e53a:	48 01 d0             	add    %rdx,%rax
  800420e53d:	48 83 c0 08          	add    $0x8,%rax
  800420e541:	48 8b 00             	mov    (%rax),%rax
  800420e544:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420e548:	48 89 90 00 01 00 00 	mov    %rdx,0x100(%rax)
	curenv->env_status = ENV_NOT_RUNNABLE;
  800420e54f:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420e556:	00 00 00 
  800420e559:	ff d0                	callq  *%rax
  800420e55b:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420e562:	00 00 00 
  800420e565:	48 98                	cltq   
  800420e567:	48 c1 e0 03          	shl    $0x3,%rax
  800420e56b:	48 89 c1             	mov    %rax,%rcx
  800420e56e:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e572:	48 01 c8             	add    %rcx,%rax
  800420e575:	48 01 d0             	add    %rdx,%rax
  800420e578:	48 83 c0 08          	add    $0x8,%rax
  800420e57c:	48 8b 00             	mov    (%rax),%rax
  800420e57f:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  800420e586:	00 00 00 
	sched_yield();
  800420e589:	48 b8 d5 d2 20 04 80 	movabs $0x800420d2d5,%rax
  800420e590:	00 00 00 
  800420e593:	ff d0                	callq  *%rax

000000800420e595 <sys_time_msec>:


// Return the current time.
static int
sys_time_msec(void)
{
  800420e595:	55                   	push   %rbp
  800420e596:	48 89 e5             	mov    %rsp,%rbp

	return (int) time_msec();
  800420e599:	48 b8 80 8c 21 04 80 	movabs $0x8004218c80,%rax
  800420e5a0:	00 00 00 
  800420e5a3:	ff d0                	callq  *%rax

}
  800420e5a5:	5d                   	pop    %rbp
  800420e5a6:	c3                   	retq   

000000800420e5a7 <sys_net_transmit>:



static int
sys_net_transmit(const void *data, size_t len)
{
  800420e5a7:	55                   	push   %rbp
  800420e5a8:	48 89 e5             	mov    %rsp,%rbp
  800420e5ab:	48 83 ec 10          	sub    $0x10,%rsp
  800420e5af:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420e5b3:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	user_mem_assert(curenv, data, len, 0);
  800420e5b7:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420e5be:	00 00 00 
  800420e5c1:	ff d0                	callq  *%rax
  800420e5c3:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420e5ca:	00 00 00 
  800420e5cd:	48 98                	cltq   
  800420e5cf:	48 c1 e0 03          	shl    $0x3,%rax
  800420e5d3:	48 89 c1             	mov    %rax,%rcx
  800420e5d6:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e5da:	48 01 c8             	add    %rcx,%rax
  800420e5dd:	48 01 d0             	add    %rdx,%rax
  800420e5e0:	48 83 c0 08          	add    $0x8,%rax
  800420e5e4:	48 8b 00             	mov    (%rax),%rax
  800420e5e7:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420e5eb:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  800420e5ef:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420e5f4:	48 89 c7             	mov    %rax,%rdi
  800420e5f7:	48 b8 a4 42 20 04 80 	movabs $0x80042042a4,%rax
  800420e5fe:	00 00 00 
  800420e601:	ff d0                	callq  *%rax
	return e1000_transmit(data, len);
  800420e603:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e607:	89 c2                	mov    %eax,%edx
  800420e609:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e60d:	89 d6                	mov    %edx,%esi
  800420e60f:	48 89 c7             	mov    %rax,%rdi
  800420e612:	48 b8 09 7e 21 04 80 	movabs $0x8004217e09,%rax
  800420e619:	00 00 00 
  800420e61c:	ff d0                	callq  *%rax
}
  800420e61e:	c9                   	leaveq 
  800420e61f:	c3                   	retq   

000000800420e620 <sys_net_receive>:

static int
sys_net_receive(void *buf, size_t len)
{
  800420e620:	55                   	push   %rbp
  800420e621:	48 89 e5             	mov    %rsp,%rbp
  800420e624:	48 83 ec 10          	sub    $0x10,%rsp
  800420e628:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420e62c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	user_mem_assert(curenv, buf, len, PTE_W);
  800420e630:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420e637:	00 00 00 
  800420e63a:	ff d0                	callq  *%rax
  800420e63c:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420e643:	00 00 00 
  800420e646:	48 98                	cltq   
  800420e648:	48 c1 e0 03          	shl    $0x3,%rax
  800420e64c:	48 89 c1             	mov    %rax,%rcx
  800420e64f:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e653:	48 01 c8             	add    %rcx,%rax
  800420e656:	48 01 d0             	add    %rdx,%rax
  800420e659:	48 83 c0 08          	add    $0x8,%rax
  800420e65d:	48 8b 00             	mov    (%rax),%rax
  800420e660:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420e664:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  800420e668:	b9 02 00 00 00       	mov    $0x2,%ecx
  800420e66d:	48 89 c7             	mov    %rax,%rdi
  800420e670:	48 b8 a4 42 20 04 80 	movabs $0x80042042a4,%rax
  800420e677:	00 00 00 
  800420e67a:	ff d0                	callq  *%rax
	return e1000_receive(buf, len);
  800420e67c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e680:	89 c2                	mov    %eax,%edx
  800420e682:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e686:	89 d6                	mov    %edx,%esi
  800420e688:	48 89 c7             	mov    %rax,%rdi
  800420e68b:	48 b8 78 7f 21 04 80 	movabs $0x8004217f78,%rax
  800420e692:	00 00 00 
  800420e695:	ff d0                	callq  *%rax
}
  800420e697:	c9                   	leaveq 
  800420e698:	c3                   	retq   

000000800420e699 <syscall>:


// Dispatches to the correct kernel function, passing the arguments.
int64_t
syscall(uint64_t syscallno, uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  800420e699:	55                   	push   %rbp
  800420e69a:	48 89 e5             	mov    %rsp,%rbp
  800420e69d:	48 83 ec 30          	sub    $0x30,%rsp
  800420e6a1:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420e6a5:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420e6a9:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420e6ad:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800420e6b1:	4c 89 45 d8          	mov    %r8,-0x28(%rbp)
  800420e6b5:	4c 89 4d d0          	mov    %r9,-0x30(%rbp)


	switch (syscallno) {
  800420e6b9:	48 83 7d f8 10       	cmpq   $0x10,-0x8(%rbp)
  800420e6be:	0f 87 0d 02 00 00    	ja     800420e8d1 <syscall+0x238>
  800420e6c4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e6c8:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420e6cf:	00 
  800420e6d0:	48 b8 80 a8 21 04 80 	movabs $0x800421a880,%rax
  800420e6d7:	00 00 00 
  800420e6da:	48 01 d0             	add    %rdx,%rax
  800420e6dd:	48 8b 00             	mov    (%rax),%rax
  800420e6e0:	ff e0                	jmpq   *%rax

	case SYS_cputs:
		sys_cputs((const char*) a1, a2);
  800420e6e2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e6e6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e6ea:	48 89 d6             	mov    %rdx,%rsi
  800420e6ed:	48 89 c7             	mov    %rax,%rdi
  800420e6f0:	48 b8 2f d7 20 04 80 	movabs $0x800420d72f,%rax
  800420e6f7:	00 00 00 
  800420e6fa:	ff d0                	callq  *%rax
		return 0;
  800420e6fc:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e701:	e9 d2 01 00 00       	jmpq   800420e8d8 <syscall+0x23f>
	case SYS_cgetc:
		return sys_cgetc();
  800420e706:	48 b8 b3 d7 20 04 80 	movabs $0x800420d7b3,%rax
  800420e70d:	00 00 00 
  800420e710:	ff d0                	callq  *%rax
  800420e712:	48 98                	cltq   
  800420e714:	e9 bf 01 00 00       	jmpq   800420e8d8 <syscall+0x23f>
	case SYS_getenvid:
		return sys_getenvid();
  800420e719:	48 b8 c5 d7 20 04 80 	movabs $0x800420d7c5,%rax
  800420e720:	00 00 00 
  800420e723:	ff d0                	callq  *%rax
  800420e725:	48 98                	cltq   
  800420e727:	e9 ac 01 00 00       	jmpq   800420e8d8 <syscall+0x23f>
	case SYS_env_destroy:
		return sys_env_destroy(a1);
  800420e72c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e730:	89 c7                	mov    %eax,%edi
  800420e732:	48 b8 01 d8 20 04 80 	movabs $0x800420d801,%rax
  800420e739:	00 00 00 
  800420e73c:	ff d0                	callq  *%rax
  800420e73e:	48 98                	cltq   
  800420e740:	e9 93 01 00 00       	jmpq   800420e8d8 <syscall+0x23f>

	case SYS_page_alloc:
		return sys_page_alloc(a1, (void*) a2, a3);
  800420e745:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e749:	89 c2                	mov    %eax,%edx
  800420e74b:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420e74f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e753:	48 89 ce             	mov    %rcx,%rsi
  800420e756:	89 c7                	mov    %eax,%edi
  800420e758:	48 b8 d4 da 20 04 80 	movabs $0x800420dad4,%rax
  800420e75f:	00 00 00 
  800420e762:	ff d0                	callq  *%rax
  800420e764:	48 98                	cltq   
  800420e766:	e9 6d 01 00 00       	jmpq   800420e8d8 <syscall+0x23f>
	case SYS_page_map:
		return sys_page_map(a1, (void*) a2, a3, (void*) a4, a5);
  800420e76b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e76f:	89 c7                	mov    %eax,%edi
  800420e771:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420e775:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e779:	89 c2                	mov    %eax,%edx
  800420e77b:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  800420e77f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e783:	41 89 f8             	mov    %edi,%r8d
  800420e786:	89 c7                	mov    %eax,%edi
  800420e788:	48 b8 bd db 20 04 80 	movabs $0x800420dbbd,%rax
  800420e78f:	00 00 00 
  800420e792:	ff d0                	callq  *%rax
  800420e794:	48 98                	cltq   
  800420e796:	e9 3d 01 00 00       	jmpq   800420e8d8 <syscall+0x23f>
	case SYS_page_unmap:
		return sys_page_unmap(a1, (void*) a2);
  800420e79b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e79f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e7a3:	48 89 d6             	mov    %rdx,%rsi
  800420e7a6:	89 c7                	mov    %eax,%edi
  800420e7a8:	48 b8 42 dd 20 04 80 	movabs $0x800420dd42,%rax
  800420e7af:	00 00 00 
  800420e7b2:	ff d0                	callq  *%rax
  800420e7b4:	48 98                	cltq   
  800420e7b6:	e9 1d 01 00 00       	jmpq   800420e8d8 <syscall+0x23f>
	case SYS_exofork:
		return sys_exofork();
  800420e7bb:	48 b8 61 d8 20 04 80 	movabs $0x800420d861,%rax
  800420e7c2:	00 00 00 
  800420e7c5:	ff d0                	callq  *%rax
  800420e7c7:	48 98                	cltq   
  800420e7c9:	e9 0a 01 00 00       	jmpq   800420e8d8 <syscall+0x23f>
	case SYS_env_set_status:
		return sys_env_set_status(a1, a2);
  800420e7ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e7d2:	89 c2                	mov    %eax,%edx
  800420e7d4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e7d8:	89 d6                	mov    %edx,%esi
  800420e7da:	89 c7                	mov    %eax,%edi
  800420e7dc:	48 b8 36 d9 20 04 80 	movabs $0x800420d936,%rax
  800420e7e3:	00 00 00 
  800420e7e6:	ff d0                	callq  *%rax
  800420e7e8:	48 98                	cltq   
  800420e7ea:	e9 e9 00 00 00       	jmpq   800420e8d8 <syscall+0x23f>

	case SYS_env_set_trapframe:
		return sys_env_set_trapframe(a1, (struct Trapframe*) a2);
  800420e7ef:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e7f3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e7f7:	48 89 d6             	mov    %rdx,%rsi
  800420e7fa:	89 c7                	mov    %eax,%edi
  800420e7fc:	48 b8 96 d9 20 04 80 	movabs $0x800420d996,%rax
  800420e803:	00 00 00 
  800420e806:	ff d0                	callq  *%rax
  800420e808:	48 98                	cltq   
  800420e80a:	e9 c9 00 00 00       	jmpq   800420e8d8 <syscall+0x23f>

	case SYS_env_set_pgfault_upcall:
		return sys_env_set_pgfault_upcall(a1, (void*) a2);
  800420e80f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e813:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e817:	48 89 d6             	mov    %rdx,%rsi
  800420e81a:	89 c7                	mov    %eax,%edi
  800420e81c:	48 b8 84 da 20 04 80 	movabs $0x800420da84,%rax
  800420e823:	00 00 00 
  800420e826:	ff d0                	callq  *%rax
  800420e828:	48 98                	cltq   
  800420e82a:	e9 a9 00 00 00       	jmpq   800420e8d8 <syscall+0x23f>
	case SYS_yield:
		sys_yield();
  800420e82f:	48 b8 51 d8 20 04 80 	movabs $0x800420d851,%rax
  800420e836:	00 00 00 
  800420e839:	ff d0                	callq  *%rax
		return 0;
  800420e83b:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e840:	e9 93 00 00 00       	jmpq   800420e8d8 <syscall+0x23f>
	case SYS_ipc_try_send:
		return sys_ipc_try_send(a1, a2, (void*) a3, a4);
  800420e845:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e849:	89 c1                	mov    %eax,%ecx
  800420e84b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420e84f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e853:	89 c6                	mov    %eax,%esi
  800420e855:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e859:	89 c7                	mov    %eax,%edi
  800420e85b:	48 b8 c9 dd 20 04 80 	movabs $0x800420ddc9,%rax
  800420e862:	00 00 00 
  800420e865:	ff d0                	callq  *%rax
  800420e867:	48 98                	cltq   
  800420e869:	eb 6d                	jmp    800420e8d8 <syscall+0x23f>
	case SYS_ipc_recv:
		sys_ipc_recv((void*) a1);
  800420e86b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e86f:	48 89 c7             	mov    %rax,%rdi
  800420e872:	48 b8 6c e4 20 04 80 	movabs $0x800420e46c,%rax
  800420e879:	00 00 00 
  800420e87c:	ff d0                	callq  *%rax
		return 0;
  800420e87e:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e883:	eb 53                	jmp    800420e8d8 <syscall+0x23f>

	case SYS_time_msec:
		return sys_time_msec();
  800420e885:	48 b8 95 e5 20 04 80 	movabs $0x800420e595,%rax
  800420e88c:	00 00 00 
  800420e88f:	ff d0                	callq  *%rax
  800420e891:	48 98                	cltq   
  800420e893:	eb 43                	jmp    800420e8d8 <syscall+0x23f>
	case SYS_net_transmit:
		return sys_net_transmit((const void*)a1, a2);
  800420e895:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e899:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e89d:	48 89 d6             	mov    %rdx,%rsi
  800420e8a0:	48 89 c7             	mov    %rax,%rdi
  800420e8a3:	48 b8 a7 e5 20 04 80 	movabs $0x800420e5a7,%rax
  800420e8aa:	00 00 00 
  800420e8ad:	ff d0                	callq  *%rax
  800420e8af:	48 98                	cltq   
  800420e8b1:	eb 25                	jmp    800420e8d8 <syscall+0x23f>
	case SYS_net_receive:
		return sys_net_receive((void*)a1, a2);
  800420e8b3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e8b7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e8bb:	48 89 d6             	mov    %rdx,%rsi
  800420e8be:	48 89 c7             	mov    %rax,%rdi
  800420e8c1:	48 b8 20 e6 20 04 80 	movabs $0x800420e620,%rax
  800420e8c8:	00 00 00 
  800420e8cb:	ff d0                	callq  *%rax
  800420e8cd:	48 98                	cltq   
  800420e8cf:	eb 07                	jmp    800420e8d8 <syscall+0x23f>
		return 0;
#endif

		
	default:
		return -E_NO_SYS;
  800420e8d1:	48 c7 c0 f9 ff ff ff 	mov    $0xfffffffffffffff9,%rax
	}
}
  800420e8d8:	c9                   	leaveq 
  800420e8d9:	c3                   	retq   

000000800420e8da <list_func_die>:
	const char *stabstr_end;
};


int list_func_die(struct Ripdebuginfo *info, Dwarf_Die *die, uint64_t addr)
{
  800420e8da:	55                   	push   %rbp
  800420e8db:	48 89 e5             	mov    %rsp,%rbp
  800420e8de:	48 81 ec f0 61 00 00 	sub    $0x61f0,%rsp
  800420e8e5:	48 89 bd 58 9e ff ff 	mov    %rdi,-0x61a8(%rbp)
  800420e8ec:	48 89 b5 50 9e ff ff 	mov    %rsi,-0x61b0(%rbp)
  800420e8f3:	48 89 95 48 9e ff ff 	mov    %rdx,-0x61b8(%rbp)
	_Dwarf_Line ln;
	Dwarf_Attribute *low;
	Dwarf_Attribute *high;
	Dwarf_CU *cu = die->cu_header;
  800420e8fa:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420e901:	48 8b 80 60 03 00 00 	mov    0x360(%rax),%rax
  800420e908:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	Dwarf_Die *cudie = die->cu_die; 
  800420e90c:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420e913:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420e91a:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	Dwarf_Die ret, sib=*die; 
  800420e91e:	48 8b 95 50 9e ff ff 	mov    -0x61b0(%rbp),%rdx
  800420e925:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420e92c:	48 89 d1             	mov    %rdx,%rcx
  800420e92f:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420e934:	48 89 ce             	mov    %rcx,%rsi
  800420e937:	48 89 c7             	mov    %rax,%rdi
  800420e93a:	48 b8 76 05 21 04 80 	movabs $0x8004210576,%rax
  800420e941:	00 00 00 
  800420e944:	ff d0                	callq  *%rax
	Dwarf_Attribute *attr;
	uint64_t offset;
	uint64_t ret_val=8;
  800420e946:	48 c7 45 f8 08 00 00 	movq   $0x8,-0x8(%rbp)
  800420e94d:	00 
	uint64_t ret_offset=0;
  800420e94e:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420e955:	00 

	if(die->die_tag != DW_TAG_subprogram)
  800420e956:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420e95d:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420e961:	48 83 f8 2e          	cmp    $0x2e,%rax
  800420e965:	74 0a                	je     800420e971 <list_func_die+0x97>
		return 0;
  800420e967:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e96c:	e9 cd 06 00 00       	jmpq   800420f03e <list_func_die+0x764>

	memset(&ln, 0, sizeof(_Dwarf_Line));
  800420e971:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420e978:	ba 38 00 00 00       	mov    $0x38,%edx
  800420e97d:	be 00 00 00 00       	mov    $0x0,%esi
  800420e982:	48 89 c7             	mov    %rax,%rdi
  800420e985:	48 b8 d4 03 21 04 80 	movabs $0x80042103d4,%rax
  800420e98c:	00 00 00 
  800420e98f:	ff d0                	callq  *%rax

	low  = _dwarf_attr_find(die, DW_AT_low_pc);
  800420e991:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420e998:	be 11 00 00 00       	mov    $0x11,%esi
  800420e99d:	48 89 c7             	mov    %rax,%rdi
  800420e9a0:	48 b8 09 23 21 04 80 	movabs $0x8004212309,%rax
  800420e9a7:	00 00 00 
  800420e9aa:	ff d0                	callq  *%rax
  800420e9ac:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	high = _dwarf_attr_find(die, DW_AT_high_pc);
  800420e9b0:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420e9b7:	be 12 00 00 00       	mov    $0x12,%esi
  800420e9bc:	48 89 c7             	mov    %rax,%rdi
  800420e9bf:	48 b8 09 23 21 04 80 	movabs $0x8004212309,%rax
  800420e9c6:	00 00 00 
  800420e9c9:	ff d0                	callq  *%rax
  800420e9cb:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	if((low && (low->u[0].u64 < addr)) && (high && (high->u[0].u64 > addr)))
  800420e9cf:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420e9d4:	0f 84 5f 06 00 00    	je     800420f039 <list_func_die+0x75f>
  800420e9da:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e9de:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420e9e2:	48 3b 85 48 9e ff ff 	cmp    -0x61b8(%rbp),%rax
  800420e9e9:	0f 83 4a 06 00 00    	jae    800420f039 <list_func_die+0x75f>
  800420e9ef:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420e9f4:	0f 84 3f 06 00 00    	je     800420f039 <list_func_die+0x75f>
  800420e9fa:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420e9fe:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420ea02:	48 3b 85 48 9e ff ff 	cmp    -0x61b8(%rbp),%rax
  800420ea09:	0f 86 2a 06 00 00    	jbe    800420f039 <list_func_die+0x75f>
	{
		info->rip_file = die->cu_die->die_name;
  800420ea0f:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420ea16:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420ea1d:	48 8b 90 50 03 00 00 	mov    0x350(%rax),%rdx
  800420ea24:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420ea2b:	48 89 10             	mov    %rdx,(%rax)

		info->rip_fn_name = die->die_name;
  800420ea2e:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420ea35:	48 8b 90 50 03 00 00 	mov    0x350(%rax),%rdx
  800420ea3c:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420ea43:	48 89 50 10          	mov    %rdx,0x10(%rax)
		info->rip_fn_namelen = strlen(die->die_name);
  800420ea47:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420ea4e:	48 8b 80 50 03 00 00 	mov    0x350(%rax),%rax
  800420ea55:	48 89 c7             	mov    %rax,%rdi
  800420ea58:	48 b8 cf 00 21 04 80 	movabs $0x80042100cf,%rax
  800420ea5f:	00 00 00 
  800420ea62:	ff d0                	callq  *%rax
  800420ea64:	48 8b 95 58 9e ff ff 	mov    -0x61a8(%rbp),%rdx
  800420ea6b:	89 42 18             	mov    %eax,0x18(%rdx)

		info->rip_fn_addr = (uintptr_t)low->u[0].u64;
  800420ea6e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420ea72:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420ea76:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420ea7d:	48 89 50 20          	mov    %rdx,0x20(%rax)

		assert(die->cu_die);	
  800420ea81:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420ea88:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420ea8f:	48 85 c0             	test   %rax,%rax
  800420ea92:	75 35                	jne    800420eac9 <list_func_die+0x1ef>
  800420ea94:	48 b9 40 ac 21 04 80 	movabs $0x800421ac40,%rcx
  800420ea9b:	00 00 00 
  800420ea9e:	48 ba 4c ac 21 04 80 	movabs $0x800421ac4c,%rdx
  800420eaa5:	00 00 00 
  800420eaa8:	be 95 00 00 00       	mov    $0x95,%esi
  800420eaad:	48 bf 61 ac 21 04 80 	movabs $0x800421ac61,%rdi
  800420eab4:	00 00 00 
  800420eab7:	b8 00 00 00 00       	mov    $0x0,%eax
  800420eabc:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  800420eac3:	00 00 00 
  800420eac6:	41 ff d0             	callq  *%r8
		dwarf_srclines(die->cu_die, &ln, addr, NULL); 
  800420eac9:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420ead0:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420ead7:	48 8b 95 48 9e ff ff 	mov    -0x61b8(%rbp),%rdx
  800420eade:	48 8d b5 50 ff ff ff 	lea    -0xb0(%rbp),%rsi
  800420eae5:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420eaea:	48 89 c7             	mov    %rax,%rdi
  800420eaed:	48 b8 30 59 21 04 80 	movabs $0x8004215930,%rax
  800420eaf4:	00 00 00 
  800420eaf7:	ff d0                	callq  *%rax

		info->rip_line = ln.ln_lineno;
  800420eaf9:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420eb00:	89 c2                	mov    %eax,%edx
  800420eb02:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420eb09:	89 50 08             	mov    %edx,0x8(%rax)
		info->rip_fn_narg = 0;
  800420eb0c:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420eb13:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)

		Dwarf_Attribute* attr;

		if(dwarf_child(dbg, cu, &sib, &ret) != DW_DLE_NO_ENTRY)
  800420eb1a:	48 b8 88 c6 22 04 80 	movabs $0x800422c688,%rax
  800420eb21:	00 00 00 
  800420eb24:	48 8b 00             	mov    (%rax),%rax
  800420eb27:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420eb2e:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420eb35:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420eb39:	48 89 c7             	mov    %rax,%rdi
  800420eb3c:	48 b8 e0 25 21 04 80 	movabs $0x80042125e0,%rax
  800420eb43:	00 00 00 
  800420eb46:	ff d0                	callq  *%rax
  800420eb48:	83 f8 04             	cmp    $0x4,%eax
  800420eb4b:	0f 84 e1 04 00 00    	je     800420f032 <list_func_die+0x758>
		{
			if(ret.die_tag != DW_TAG_formal_parameter)
  800420eb51:	48 8b 85 f8 ce ff ff 	mov    -0x3108(%rbp),%rax
  800420eb58:	48 83 f8 05          	cmp    $0x5,%rax
  800420eb5c:	74 05                	je     800420eb63 <list_func_die+0x289>
				goto last;
  800420eb5e:	e9 cf 04 00 00       	jmpq   800420f032 <list_func_die+0x758>

			attr = _dwarf_attr_find(&ret, DW_AT_type);
  800420eb63:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420eb6a:	be 49 00 00 00       	mov    $0x49,%esi
  800420eb6f:	48 89 c7             	mov    %rax,%rdi
  800420eb72:	48 b8 09 23 21 04 80 	movabs $0x8004212309,%rax
  800420eb79:	00 00 00 
  800420eb7c:	ff d0                	callq  *%rax
  800420eb7e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	
		try_again:
			if(attr != NULL)
  800420eb82:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420eb87:	0f 84 d7 00 00 00    	je     800420ec64 <list_func_die+0x38a>
			{
				offset = (uint64_t)cu->cu_offset + attr->u[0].u64;
  800420eb8d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420eb91:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420eb95:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eb99:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420eb9d:	48 01 d0             	add    %rdx,%rax
  800420eba0:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
				dwarf_offdie(dbg, offset, &sib, *cu);
  800420eba4:	48 b8 88 c6 22 04 80 	movabs $0x800422c688,%rax
  800420ebab:	00 00 00 
  800420ebae:	48 8b 08             	mov    (%rax),%rcx
  800420ebb1:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420ebb8:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420ebbc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ebc0:	48 8b 38             	mov    (%rax),%rdi
  800420ebc3:	48 89 3c 24          	mov    %rdi,(%rsp)
  800420ebc7:	48 8b 78 08          	mov    0x8(%rax),%rdi
  800420ebcb:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  800420ebd0:	48 8b 78 10          	mov    0x10(%rax),%rdi
  800420ebd4:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800420ebd9:	48 8b 78 18          	mov    0x18(%rax),%rdi
  800420ebdd:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  800420ebe2:	48 8b 78 20          	mov    0x20(%rax),%rdi
  800420ebe6:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  800420ebeb:	48 8b 78 28          	mov    0x28(%rax),%rdi
  800420ebef:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  800420ebf4:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420ebf8:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800420ebfd:	48 89 cf             	mov    %rcx,%rdi
  800420ec00:	48 b8 06 22 21 04 80 	movabs $0x8004212206,%rax
  800420ec07:	00 00 00 
  800420ec0a:	ff d0                	callq  *%rax
				attr = _dwarf_attr_find(&sib, DW_AT_byte_size);
  800420ec0c:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420ec13:	be 0b 00 00 00       	mov    $0xb,%esi
  800420ec18:	48 89 c7             	mov    %rax,%rdi
  800420ec1b:	48 b8 09 23 21 04 80 	movabs $0x8004212309,%rax
  800420ec22:	00 00 00 
  800420ec25:	ff d0                	callq  *%rax
  800420ec27:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		
				if(attr != NULL)
  800420ec2b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420ec30:	74 0e                	je     800420ec40 <list_func_die+0x366>
				{
					ret_val = attr->u[0].u64;
  800420ec32:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ec36:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420ec3a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420ec3e:	eb 24                	jmp    800420ec64 <list_func_die+0x38a>
				}
				else
				{
					attr = _dwarf_attr_find(&sib, DW_AT_type);
  800420ec40:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420ec47:	be 49 00 00 00       	mov    $0x49,%esi
  800420ec4c:	48 89 c7             	mov    %rax,%rdi
  800420ec4f:	48 b8 09 23 21 04 80 	movabs $0x8004212309,%rax
  800420ec56:	00 00 00 
  800420ec59:	ff d0                	callq  *%rax
  800420ec5b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
					goto try_again;
  800420ec5f:	e9 1e ff ff ff       	jmpq   800420eb82 <list_func_die+0x2a8>
				}
			}

			ret_offset = 0;
  800420ec64:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420ec6b:	00 
			attr = _dwarf_attr_find(&ret, DW_AT_location);
  800420ec6c:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420ec73:	be 02 00 00 00       	mov    $0x2,%esi
  800420ec78:	48 89 c7             	mov    %rax,%rdi
  800420ec7b:	48 b8 09 23 21 04 80 	movabs $0x8004212309,%rax
  800420ec82:	00 00 00 
  800420ec85:	ff d0                	callq  *%rax
  800420ec87:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if (attr != NULL)
  800420ec8b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420ec90:	0f 84 a2 00 00 00    	je     800420ed38 <list_func_die+0x45e>
			{
				Dwarf_Unsigned loc_len = attr->at_block.bl_len;
  800420ec96:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ec9a:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420ec9e:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
				Dwarf_Small *loc_ptr = attr->at_block.bl_data;
  800420eca2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eca6:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420ecaa:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
				Dwarf_Small atom;
				Dwarf_Unsigned op1, op2;

				switch(attr->at_form) {
  800420ecae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ecb2:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420ecb6:	48 83 f8 03          	cmp    $0x3,%rax
  800420ecba:	72 7c                	jb     800420ed38 <list_func_die+0x45e>
  800420ecbc:	48 83 f8 04          	cmp    $0x4,%rax
  800420ecc0:	76 06                	jbe    800420ecc8 <list_func_die+0x3ee>
  800420ecc2:	48 83 f8 0a          	cmp    $0xa,%rax
  800420ecc6:	75 70                	jne    800420ed38 <list_func_die+0x45e>
					case DW_FORM_block1:
					case DW_FORM_block2:
					case DW_FORM_block4:
						offset = 0;
  800420ecc8:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  800420eccf:	00 
						atom = *(loc_ptr++);
  800420ecd0:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420ecd4:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420ecd8:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
  800420ecdc:	0f b6 00             	movzbl (%rax),%eax
  800420ecdf:	88 45 af             	mov    %al,-0x51(%rbp)
						offset++;
  800420ece2:	48 83 45 c0 01       	addq   $0x1,-0x40(%rbp)
						if (atom == DW_OP_fbreg) {
  800420ece7:	80 7d af 91          	cmpb   $0x91,-0x51(%rbp)
  800420eceb:	75 4a                	jne    800420ed37 <list_func_die+0x45d>
							uint8_t *p = loc_ptr;
  800420eced:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420ecf1:	48 89 85 68 9e ff ff 	mov    %rax,-0x6198(%rbp)
							ret_offset = _dwarf_decode_sleb128(&p);
  800420ecf8:	48 8d 85 68 9e ff ff 	lea    -0x6198(%rbp),%rax
  800420ecff:	48 89 c7             	mov    %rax,%rdi
  800420ed02:	48 b8 65 0f 21 04 80 	movabs $0x8004210f65,%rax
  800420ed09:	00 00 00 
  800420ed0c:	ff d0                	callq  *%rax
  800420ed0e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
							offset += p - loc_ptr;
  800420ed12:	48 8b 85 68 9e ff ff 	mov    -0x6198(%rbp),%rax
  800420ed19:	48 89 c2             	mov    %rax,%rdx
  800420ed1c:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420ed20:	48 29 c2             	sub    %rax,%rdx
  800420ed23:	48 89 d0             	mov    %rdx,%rax
  800420ed26:	48 01 45 c0          	add    %rax,-0x40(%rbp)
							loc_ptr = p;
  800420ed2a:	48 8b 85 68 9e ff ff 	mov    -0x6198(%rbp),%rax
  800420ed31:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
						}
						break;
  800420ed35:	eb 00                	jmp    800420ed37 <list_func_die+0x45d>
  800420ed37:	90                   	nop
				}
			}

			info->size_fn_arg[info->rip_fn_narg] = ret_val;
  800420ed38:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420ed3f:	8b 48 28             	mov    0x28(%rax),%ecx
  800420ed42:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ed46:	89 c2                	mov    %eax,%edx
  800420ed48:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420ed4f:	48 63 c9             	movslq %ecx,%rcx
  800420ed52:	48 83 c1 08          	add    $0x8,%rcx
  800420ed56:	89 54 88 0c          	mov    %edx,0xc(%rax,%rcx,4)
			info->offset_fn_arg[info->rip_fn_narg] = ret_offset;
  800420ed5a:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420ed61:	8b 50 28             	mov    0x28(%rax),%edx
  800420ed64:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420ed6b:	48 63 d2             	movslq %edx,%rdx
  800420ed6e:	48 8d 4a 0a          	lea    0xa(%rdx),%rcx
  800420ed72:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420ed76:	48 89 54 c8 08       	mov    %rdx,0x8(%rax,%rcx,8)
			info->rip_fn_narg++;
  800420ed7b:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420ed82:	8b 40 28             	mov    0x28(%rax),%eax
  800420ed85:	8d 50 01             	lea    0x1(%rax),%edx
  800420ed88:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420ed8f:	89 50 28             	mov    %edx,0x28(%rax)
			sib = ret; 
  800420ed92:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420ed99:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420eda0:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420eda5:	48 89 ce             	mov    %rcx,%rsi
  800420eda8:	48 89 c7             	mov    %rax,%rdi
  800420edab:	48 b8 76 05 21 04 80 	movabs $0x8004210576,%rax
  800420edb2:	00 00 00 
  800420edb5:	ff d0                	callq  *%rax

			while(dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
  800420edb7:	e9 40 02 00 00       	jmpq   800420effc <list_func_die+0x722>
			{
				if(ret.die_tag != DW_TAG_formal_parameter)
  800420edbc:	48 8b 85 f8 ce ff ff 	mov    -0x3108(%rbp),%rax
  800420edc3:	48 83 f8 05          	cmp    $0x5,%rax
  800420edc7:	74 05                	je     800420edce <list_func_die+0x4f4>
					break;
  800420edc9:	e9 64 02 00 00       	jmpq   800420f032 <list_func_die+0x758>

				attr = _dwarf_attr_find(&ret, DW_AT_type);
  800420edce:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420edd5:	be 49 00 00 00       	mov    $0x49,%esi
  800420edda:	48 89 c7             	mov    %rax,%rdi
  800420eddd:	48 b8 09 23 21 04 80 	movabs $0x8004212309,%rax
  800420ede4:	00 00 00 
  800420ede7:	ff d0                	callq  *%rax
  800420ede9:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    
				if(attr != NULL)
  800420eded:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420edf2:	0f 84 b1 00 00 00    	je     800420eea9 <list_func_die+0x5cf>
				{	   
					offset = (uint64_t)cu->cu_offset + attr->u[0].u64;
  800420edf8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420edfc:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420ee00:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ee04:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420ee08:	48 01 d0             	add    %rdx,%rax
  800420ee0b:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
					dwarf_offdie(dbg, offset, &sib, *cu);
  800420ee0f:	48 b8 88 c6 22 04 80 	movabs $0x800422c688,%rax
  800420ee16:	00 00 00 
  800420ee19:	48 8b 08             	mov    (%rax),%rcx
  800420ee1c:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420ee23:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420ee27:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ee2b:	48 8b 38             	mov    (%rax),%rdi
  800420ee2e:	48 89 3c 24          	mov    %rdi,(%rsp)
  800420ee32:	48 8b 78 08          	mov    0x8(%rax),%rdi
  800420ee36:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  800420ee3b:	48 8b 78 10          	mov    0x10(%rax),%rdi
  800420ee3f:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800420ee44:	48 8b 78 18          	mov    0x18(%rax),%rdi
  800420ee48:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  800420ee4d:	48 8b 78 20          	mov    0x20(%rax),%rdi
  800420ee51:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  800420ee56:	48 8b 78 28          	mov    0x28(%rax),%rdi
  800420ee5a:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  800420ee5f:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420ee63:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800420ee68:	48 89 cf             	mov    %rcx,%rdi
  800420ee6b:	48 b8 06 22 21 04 80 	movabs $0x8004212206,%rax
  800420ee72:	00 00 00 
  800420ee75:	ff d0                	callq  *%rax
					attr = _dwarf_attr_find(&sib, DW_AT_byte_size);
  800420ee77:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420ee7e:	be 0b 00 00 00       	mov    $0xb,%esi
  800420ee83:	48 89 c7             	mov    %rax,%rdi
  800420ee86:	48 b8 09 23 21 04 80 	movabs $0x8004212309,%rax
  800420ee8d:	00 00 00 
  800420ee90:	ff d0                	callq  *%rax
  800420ee92:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        
					if(attr != NULL)
  800420ee96:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420ee9b:	74 0c                	je     800420eea9 <list_func_die+0x5cf>
					{
						ret_val = attr->u[0].u64;
  800420ee9d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eea1:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420eea5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
					}
				}
	
				ret_offset = 0;
  800420eea9:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420eeb0:	00 
				attr = _dwarf_attr_find(&ret, DW_AT_location);
  800420eeb1:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420eeb8:	be 02 00 00 00       	mov    $0x2,%esi
  800420eebd:	48 89 c7             	mov    %rax,%rdi
  800420eec0:	48 b8 09 23 21 04 80 	movabs $0x8004212309,%rax
  800420eec7:	00 00 00 
  800420eeca:	ff d0                	callq  *%rax
  800420eecc:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				if (attr != NULL)
  800420eed0:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420eed5:	0f 84 a2 00 00 00    	je     800420ef7d <list_func_die+0x6a3>
				{
					Dwarf_Unsigned loc_len = attr->at_block.bl_len;
  800420eedb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eedf:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420eee3:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
					Dwarf_Small *loc_ptr = attr->at_block.bl_data;
  800420eee7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eeeb:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420eeef:	48 89 45 98          	mov    %rax,-0x68(%rbp)
					Dwarf_Small atom;
					Dwarf_Unsigned op1, op2;

					switch(attr->at_form) {
  800420eef3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eef7:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420eefb:	48 83 f8 03          	cmp    $0x3,%rax
  800420eeff:	72 7c                	jb     800420ef7d <list_func_die+0x6a3>
  800420ef01:	48 83 f8 04          	cmp    $0x4,%rax
  800420ef05:	76 06                	jbe    800420ef0d <list_func_die+0x633>
  800420ef07:	48 83 f8 0a          	cmp    $0xa,%rax
  800420ef0b:	75 70                	jne    800420ef7d <list_func_die+0x6a3>
						case DW_FORM_block1:
						case DW_FORM_block2:
						case DW_FORM_block4:
							offset = 0;
  800420ef0d:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  800420ef14:	00 
							atom = *(loc_ptr++);
  800420ef15:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420ef19:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420ef1d:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420ef21:	0f b6 00             	movzbl (%rax),%eax
  800420ef24:	88 45 97             	mov    %al,-0x69(%rbp)
							offset++;
  800420ef27:	48 83 45 c0 01       	addq   $0x1,-0x40(%rbp)
							if (atom == DW_OP_fbreg) {
  800420ef2c:	80 7d 97 91          	cmpb   $0x91,-0x69(%rbp)
  800420ef30:	75 4a                	jne    800420ef7c <list_func_die+0x6a2>
								uint8_t *p = loc_ptr;
  800420ef32:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420ef36:	48 89 85 60 9e ff ff 	mov    %rax,-0x61a0(%rbp)
								ret_offset = _dwarf_decode_sleb128(&p);
  800420ef3d:	48 8d 85 60 9e ff ff 	lea    -0x61a0(%rbp),%rax
  800420ef44:	48 89 c7             	mov    %rax,%rdi
  800420ef47:	48 b8 65 0f 21 04 80 	movabs $0x8004210f65,%rax
  800420ef4e:	00 00 00 
  800420ef51:	ff d0                	callq  *%rax
  800420ef53:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
								offset += p - loc_ptr;
  800420ef57:	48 8b 85 60 9e ff ff 	mov    -0x61a0(%rbp),%rax
  800420ef5e:	48 89 c2             	mov    %rax,%rdx
  800420ef61:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420ef65:	48 29 c2             	sub    %rax,%rdx
  800420ef68:	48 89 d0             	mov    %rdx,%rax
  800420ef6b:	48 01 45 c0          	add    %rax,-0x40(%rbp)
								loc_ptr = p;
  800420ef6f:	48 8b 85 60 9e ff ff 	mov    -0x61a0(%rbp),%rax
  800420ef76:	48 89 45 98          	mov    %rax,-0x68(%rbp)
							}
							break;
  800420ef7a:	eb 00                	jmp    800420ef7c <list_func_die+0x6a2>
  800420ef7c:	90                   	nop
					}
				}

				info->size_fn_arg[info->rip_fn_narg]=ret_val;// _get_arg_size(ret);
  800420ef7d:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420ef84:	8b 48 28             	mov    0x28(%rax),%ecx
  800420ef87:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ef8b:	89 c2                	mov    %eax,%edx
  800420ef8d:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420ef94:	48 63 c9             	movslq %ecx,%rcx
  800420ef97:	48 83 c1 08          	add    $0x8,%rcx
  800420ef9b:	89 54 88 0c          	mov    %edx,0xc(%rax,%rcx,4)
				info->offset_fn_arg[info->rip_fn_narg]=ret_offset;
  800420ef9f:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420efa6:	8b 50 28             	mov    0x28(%rax),%edx
  800420efa9:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420efb0:	48 63 d2             	movslq %edx,%rdx
  800420efb3:	48 8d 4a 0a          	lea    0xa(%rdx),%rcx
  800420efb7:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420efbb:	48 89 54 c8 08       	mov    %rdx,0x8(%rax,%rcx,8)
				info->rip_fn_narg++;
  800420efc0:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420efc7:	8b 40 28             	mov    0x28(%rax),%eax
  800420efca:	8d 50 01             	lea    0x1(%rax),%edx
  800420efcd:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420efd4:	89 50 28             	mov    %edx,0x28(%rax)
				sib = ret; 
  800420efd7:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420efde:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420efe5:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420efea:	48 89 ce             	mov    %rcx,%rsi
  800420efed:	48 89 c7             	mov    %rax,%rdi
  800420eff0:	48 b8 76 05 21 04 80 	movabs $0x8004210576,%rax
  800420eff7:	00 00 00 
  800420effa:	ff d0                	callq  *%rax
			info->size_fn_arg[info->rip_fn_narg] = ret_val;
			info->offset_fn_arg[info->rip_fn_narg] = ret_offset;
			info->rip_fn_narg++;
			sib = ret; 

			while(dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
  800420effc:	48 b8 88 c6 22 04 80 	movabs $0x800422c688,%rax
  800420f003:	00 00 00 
  800420f006:	48 8b 00             	mov    (%rax),%rax
  800420f009:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420f00d:	48 8d 95 e0 ce ff ff 	lea    -0x3120(%rbp),%rdx
  800420f014:	48 8d b5 70 9e ff ff 	lea    -0x6190(%rbp),%rsi
  800420f01b:	48 89 c7             	mov    %rax,%rdi
  800420f01e:	48 b8 9c 23 21 04 80 	movabs $0x800421239c,%rax
  800420f025:	00 00 00 
  800420f028:	ff d0                	callq  *%rax
  800420f02a:	85 c0                	test   %eax,%eax
  800420f02c:	0f 84 8a fd ff ff    	je     800420edbc <list_func_die+0x4e2>
				info->rip_fn_narg++;
				sib = ret; 
			}
		}
	last:	
		return 1;
  800420f032:	b8 01 00 00 00       	mov    $0x1,%eax
  800420f037:	eb 05                	jmp    800420f03e <list_func_die+0x764>
	}

	return 0;
  800420f039:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420f03e:	c9                   	leaveq 
  800420f03f:	c3                   	retq   

000000800420f040 <debuginfo_rip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_rip(uintptr_t addr, struct Ripdebuginfo *info)
{
  800420f040:	55                   	push   %rbp
  800420f041:	48 89 e5             	mov    %rsp,%rbp
  800420f044:	53                   	push   %rbx
  800420f045:	48 81 ec c8 91 00 00 	sub    $0x91c8,%rsp
  800420f04c:	48 89 bd 38 6e ff ff 	mov    %rdi,-0x91c8(%rbp)
  800420f053:	48 89 b5 30 6e ff ff 	mov    %rsi,-0x91d0(%rbp)
	static struct Env* lastenv = NULL;
	void* elf;    
	Dwarf_Section *sect;
	Dwarf_CU cu;
	Dwarf_Die die, cudie, die2;
	Dwarf_Regtable *rt = NULL;
  800420f05a:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  800420f061:	00 
	//Set up initial pc
	uint64_t pc  = (uintptr_t)addr;
  800420f062:	48 8b 85 38 6e ff ff 	mov    -0x91c8(%rbp),%rax
  800420f069:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

    
	// Initialize *info
	info->rip_file = "<unknown>";
  800420f06d:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420f074:	48 bb 6f ac 21 04 80 	movabs $0x800421ac6f,%rbx
  800420f07b:	00 00 00 
  800420f07e:	48 89 18             	mov    %rbx,(%rax)
	info->rip_line = 0;
  800420f081:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420f088:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
	info->rip_fn_name = "<unknown>";
  800420f08f:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420f096:	48 bb 6f ac 21 04 80 	movabs $0x800421ac6f,%rbx
  800420f09d:	00 00 00 
  800420f0a0:	48 89 58 10          	mov    %rbx,0x10(%rax)
	info->rip_fn_namelen = 9;
  800420f0a4:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420f0ab:	c7 40 18 09 00 00 00 	movl   $0x9,0x18(%rax)
	info->rip_fn_addr = addr;
  800420f0b2:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420f0b9:	48 8b 95 38 6e ff ff 	mov    -0x91c8(%rbp),%rdx
  800420f0c0:	48 89 50 20          	mov    %rdx,0x20(%rax)
	info->rip_fn_narg = 0;
  800420f0c4:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420f0cb:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)
    
	// Find the relevant set of stabs
	if (addr >= ULIM) {
  800420f0d2:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  800420f0d9:	00 00 00 
  800420f0dc:	48 39 85 38 6e ff ff 	cmp    %rax,-0x91c8(%rbp)
  800420f0e3:	76 13                	jbe    800420f0f8 <debuginfo_rip+0xb8>
		elf = (void *)0x10000 + KERNBASE;
  800420f0e5:	48 b8 00 00 01 04 80 	movabs $0x8004010000,%rax
  800420f0ec:	00 00 00 
  800420f0ef:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420f0f3:	e9 04 01 00 00       	jmpq   800420f1fc <debuginfo_rip+0x1bc>
	} else {

		if(curenv != lastenv) {
  800420f0f8:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420f0ff:	00 00 00 
  800420f102:	ff d0                	callq  *%rax
  800420f104:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420f10b:	00 00 00 
  800420f10e:	48 98                	cltq   
  800420f110:	48 c1 e0 03          	shl    $0x3,%rax
  800420f114:	48 89 c1             	mov    %rax,%rcx
  800420f117:	48 c1 e1 04          	shl    $0x4,%rcx
  800420f11b:	48 01 c8             	add    %rcx,%rax
  800420f11e:	48 01 d0             	add    %rdx,%rax
  800420f121:	48 83 c0 08          	add    $0x8,%rax
  800420f125:	48 8b 10             	mov    (%rax),%rdx
  800420f128:	48 b8 98 e2 49 04 80 	movabs $0x800449e298,%rax
  800420f12f:	00 00 00 
  800420f132:	48 8b 00             	mov    (%rax),%rax
  800420f135:	48 39 c2             	cmp    %rax,%rdx
  800420f138:	0f 84 83 00 00 00    	je     800420f1c1 <debuginfo_rip+0x181>
			find_debug_sections((uintptr_t)curenv->elf);
  800420f13e:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420f145:	00 00 00 
  800420f148:	ff d0                	callq  *%rax
  800420f14a:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420f151:	00 00 00 
  800420f154:	48 98                	cltq   
  800420f156:	48 c1 e0 03          	shl    $0x3,%rax
  800420f15a:	48 89 c1             	mov    %rax,%rcx
  800420f15d:	48 c1 e1 04          	shl    $0x4,%rcx
  800420f161:	48 01 c8             	add    %rcx,%rax
  800420f164:	48 01 d0             	add    %rdx,%rax
  800420f167:	48 83 c0 08          	add    $0x8,%rax
  800420f16b:	48 8b 00             	mov    (%rax),%rax
  800420f16e:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  800420f175:	48 89 c7             	mov    %rax,%rdi
  800420f178:	48 b8 2b 5b 21 04 80 	movabs $0x8004215b2b,%rax
  800420f17f:	00 00 00 
  800420f182:	ff d0                	callq  *%rax
			lastenv = curenv;
  800420f184:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420f18b:	00 00 00 
  800420f18e:	ff d0                	callq  *%rax
  800420f190:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420f197:	00 00 00 
  800420f19a:	48 98                	cltq   
  800420f19c:	48 c1 e0 03          	shl    $0x3,%rax
  800420f1a0:	48 89 c1             	mov    %rax,%rcx
  800420f1a3:	48 c1 e1 04          	shl    $0x4,%rcx
  800420f1a7:	48 01 c8             	add    %rcx,%rax
  800420f1aa:	48 01 d0             	add    %rdx,%rax
  800420f1ad:	48 83 c0 08          	add    $0x8,%rax
  800420f1b1:	48 8b 10             	mov    (%rax),%rdx
  800420f1b4:	48 b8 98 e2 49 04 80 	movabs $0x800449e298,%rax
  800420f1bb:	00 00 00 
  800420f1be:	48 89 10             	mov    %rdx,(%rax)
		}
		elf = curenv->elf;
  800420f1c1:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  800420f1c8:	00 00 00 
  800420f1cb:	ff d0                	callq  *%rax
  800420f1cd:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800420f1d4:	00 00 00 
  800420f1d7:	48 98                	cltq   
  800420f1d9:	48 c1 e0 03          	shl    $0x3,%rax
  800420f1dd:	48 89 c1             	mov    %rax,%rcx
  800420f1e0:	48 c1 e1 04          	shl    $0x4,%rcx
  800420f1e4:	48 01 c8             	add    %rcx,%rax
  800420f1e7:	48 01 d0             	add    %rdx,%rax
  800420f1ea:	48 83 c0 08          	add    $0x8,%rax
  800420f1ee:	48 8b 00             	mov    (%rax),%rax
  800420f1f1:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  800420f1f8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	}
	_dwarf_init(dbg, elf);
  800420f1fc:	48 b8 88 c6 22 04 80 	movabs $0x800422c688,%rax
  800420f203:	00 00 00 
  800420f206:	48 8b 00             	mov    (%rax),%rax
  800420f209:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f20d:	48 89 d6             	mov    %rdx,%rsi
  800420f210:	48 89 c7             	mov    %rax,%rdi
  800420f213:	48 b8 14 12 21 04 80 	movabs $0x8004211214,%rax
  800420f21a:	00 00 00 
  800420f21d:	ff d0                	callq  *%rax

	sect = _dwarf_find_section(".debug_info");	
  800420f21f:	48 bf 79 ac 21 04 80 	movabs $0x800421ac79,%rdi
  800420f226:	00 00 00 
  800420f229:	48 b8 ab 5a 21 04 80 	movabs $0x8004215aab,%rax
  800420f230:	00 00 00 
  800420f233:	ff d0                	callq  *%rax
  800420f235:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	dbg->dbg_info_offset_elf = (uint64_t)sect->ds_data; 
  800420f239:	48 b8 88 c6 22 04 80 	movabs $0x800422c688,%rax
  800420f240:	00 00 00 
  800420f243:	48 8b 00             	mov    (%rax),%rax
  800420f246:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420f24a:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420f24e:	48 89 50 08          	mov    %rdx,0x8(%rax)
	dbg->dbg_info_size = sect->ds_size;
  800420f252:	48 b8 88 c6 22 04 80 	movabs $0x800422c688,%rax
  800420f259:	00 00 00 
  800420f25c:	48 8b 00             	mov    (%rax),%rax
  800420f25f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420f263:	48 8b 52 18          	mov    0x18(%rdx),%rdx
  800420f267:	48 89 50 10          	mov    %rdx,0x10(%rax)

	assert(dbg->dbg_info_size);
  800420f26b:	48 b8 88 c6 22 04 80 	movabs $0x800422c688,%rax
  800420f272:	00 00 00 
  800420f275:	48 8b 00             	mov    (%rax),%rax
  800420f278:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420f27c:	48 85 c0             	test   %rax,%rax
  800420f27f:	75 35                	jne    800420f2b6 <debuginfo_rip+0x276>
  800420f281:	48 b9 85 ac 21 04 80 	movabs $0x800421ac85,%rcx
  800420f288:	00 00 00 
  800420f28b:	48 ba 4c ac 21 04 80 	movabs $0x800421ac4c,%rdx
  800420f292:	00 00 00 
  800420f295:	be 3d 01 00 00       	mov    $0x13d,%esi
  800420f29a:	48 bf 61 ac 21 04 80 	movabs $0x800421ac61,%rdi
  800420f2a1:	00 00 00 
  800420f2a4:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f2a9:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  800420f2b0:	00 00 00 
  800420f2b3:	41 ff d0             	callq  *%r8
	while(_get_next_cu(dbg, &cu) == 0)
  800420f2b6:	e9 6f 01 00 00       	jmpq   800420f42a <debuginfo_rip+0x3ea>
	{
		if(dwarf_siblingof(dbg, NULL, &cudie, &cu) == DW_DLE_NO_ENTRY)
  800420f2bb:	48 b8 88 c6 22 04 80 	movabs $0x800422c688,%rax
  800420f2c2:	00 00 00 
  800420f2c5:	48 8b 00             	mov    (%rax),%rax
  800420f2c8:	48 8d 4d 90          	lea    -0x70(%rbp),%rcx
  800420f2cc:	48 8d 95 b0 9e ff ff 	lea    -0x6150(%rbp),%rdx
  800420f2d3:	be 00 00 00 00       	mov    $0x0,%esi
  800420f2d8:	48 89 c7             	mov    %rax,%rdi
  800420f2db:	48 b8 9c 23 21 04 80 	movabs $0x800421239c,%rax
  800420f2e2:	00 00 00 
  800420f2e5:	ff d0                	callq  *%rax
  800420f2e7:	83 f8 04             	cmp    $0x4,%eax
  800420f2ea:	75 05                	jne    800420f2f1 <debuginfo_rip+0x2b1>
			continue;
  800420f2ec:	e9 39 01 00 00       	jmpq   800420f42a <debuginfo_rip+0x3ea>

		cudie.cu_header = &cu;
  800420f2f1:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420f2f5:	48 89 85 10 a2 ff ff 	mov    %rax,-0x5df0(%rbp)
		cudie.cu_die = NULL;
  800420f2fc:	48 c7 85 18 a2 ff ff 	movq   $0x0,-0x5de8(%rbp)
  800420f303:	00 00 00 00 

		if(dwarf_child(dbg, &cu, &cudie, &die) == DW_DLE_NO_ENTRY)
  800420f307:	48 b8 88 c6 22 04 80 	movabs $0x800422c688,%rax
  800420f30e:	00 00 00 
  800420f311:	48 8b 00             	mov    (%rax),%rax
  800420f314:	48 8d 8d 20 cf ff ff 	lea    -0x30e0(%rbp),%rcx
  800420f31b:	48 8d 95 b0 9e ff ff 	lea    -0x6150(%rbp),%rdx
  800420f322:	48 8d 75 90          	lea    -0x70(%rbp),%rsi
  800420f326:	48 89 c7             	mov    %rax,%rdi
  800420f329:	48 b8 e0 25 21 04 80 	movabs $0x80042125e0,%rax
  800420f330:	00 00 00 
  800420f333:	ff d0                	callq  *%rax
  800420f335:	83 f8 04             	cmp    $0x4,%eax
  800420f338:	75 05                	jne    800420f33f <debuginfo_rip+0x2ff>
			continue;
  800420f33a:	e9 eb 00 00 00       	jmpq   800420f42a <debuginfo_rip+0x3ea>

		die.cu_header = &cu;
  800420f33f:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420f343:	48 89 85 80 d2 ff ff 	mov    %rax,-0x2d80(%rbp)
		die.cu_die = &cudie;
  800420f34a:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420f351:	48 89 85 88 d2 ff ff 	mov    %rax,-0x2d78(%rbp)
		while(1)
		{
			if(list_func_die(info, &die, addr))
  800420f358:	48 8b 95 38 6e ff ff 	mov    -0x91c8(%rbp),%rdx
  800420f35f:	48 8d 8d 20 cf ff ff 	lea    -0x30e0(%rbp),%rcx
  800420f366:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420f36d:	48 89 ce             	mov    %rcx,%rsi
  800420f370:	48 89 c7             	mov    %rax,%rdi
  800420f373:	48 b8 da e8 20 04 80 	movabs $0x800420e8da,%rax
  800420f37a:	00 00 00 
  800420f37d:	ff d0                	callq  *%rax
  800420f37f:	85 c0                	test   %eax,%eax
  800420f381:	74 30                	je     800420f3b3 <debuginfo_rip+0x373>
				goto find_done;
  800420f383:	90                   	nop

	return -1;

find_done:

	if (dwarf_init_eh_section(dbg, NULL) == DW_DLV_ERROR)
  800420f384:	48 b8 88 c6 22 04 80 	movabs $0x800422c688,%rax
  800420f38b:	00 00 00 
  800420f38e:	48 8b 00             	mov    (%rax),%rax
  800420f391:	be 00 00 00 00       	mov    $0x0,%esi
  800420f396:	48 89 c7             	mov    %rax,%rdi
  800420f399:	48 b8 b8 4c 21 04 80 	movabs $0x8004214cb8,%rax
  800420f3a0:	00 00 00 
  800420f3a3:	ff d0                	callq  *%rax
  800420f3a5:	83 f8 01             	cmp    $0x1,%eax
  800420f3a8:	0f 85 bb 00 00 00    	jne    800420f469 <debuginfo_rip+0x429>
  800420f3ae:	e9 ac 00 00 00       	jmpq   800420f45f <debuginfo_rip+0x41f>
		die.cu_die = &cudie;
		while(1)
		{
			if(list_func_die(info, &die, addr))
				goto find_done;
			if(dwarf_siblingof(dbg, &die, &die2, &cu) < 0)
  800420f3b3:	48 b8 88 c6 22 04 80 	movabs $0x800422c688,%rax
  800420f3ba:	00 00 00 
  800420f3bd:	48 8b 00             	mov    (%rax),%rax
  800420f3c0:	48 8d 4d 90          	lea    -0x70(%rbp),%rcx
  800420f3c4:	48 8d 95 40 6e ff ff 	lea    -0x91c0(%rbp),%rdx
  800420f3cb:	48 8d b5 20 cf ff ff 	lea    -0x30e0(%rbp),%rsi
  800420f3d2:	48 89 c7             	mov    %rax,%rdi
  800420f3d5:	48 b8 9c 23 21 04 80 	movabs $0x800421239c,%rax
  800420f3dc:	00 00 00 
  800420f3df:	ff d0                	callq  *%rax
  800420f3e1:	85 c0                	test   %eax,%eax
  800420f3e3:	79 02                	jns    800420f3e7 <debuginfo_rip+0x3a7>
				break; 
  800420f3e5:	eb 43                	jmp    800420f42a <debuginfo_rip+0x3ea>
			die = die2;
  800420f3e7:	48 8d 85 20 cf ff ff 	lea    -0x30e0(%rbp),%rax
  800420f3ee:	48 8d 8d 40 6e ff ff 	lea    -0x91c0(%rbp),%rcx
  800420f3f5:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420f3fa:	48 89 ce             	mov    %rcx,%rsi
  800420f3fd:	48 89 c7             	mov    %rax,%rdi
  800420f400:	48 b8 76 05 21 04 80 	movabs $0x8004210576,%rax
  800420f407:	00 00 00 
  800420f40a:	ff d0                	callq  *%rax
			die.cu_header = &cu;
  800420f40c:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420f410:	48 89 85 80 d2 ff ff 	mov    %rax,-0x2d80(%rbp)
			die.cu_die = &cudie;
  800420f417:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420f41e:	48 89 85 88 d2 ff ff 	mov    %rax,-0x2d78(%rbp)
		}
  800420f425:	e9 2e ff ff ff       	jmpq   800420f358 <debuginfo_rip+0x318>
	sect = _dwarf_find_section(".debug_info");	
	dbg->dbg_info_offset_elf = (uint64_t)sect->ds_data; 
	dbg->dbg_info_size = sect->ds_size;

	assert(dbg->dbg_info_size);
	while(_get_next_cu(dbg, &cu) == 0)
  800420f42a:	48 b8 88 c6 22 04 80 	movabs $0x800422c688,%rax
  800420f431:	00 00 00 
  800420f434:	48 8b 00             	mov    (%rax),%rax
  800420f437:	48 8d 55 90          	lea    -0x70(%rbp),%rdx
  800420f43b:	48 89 d6             	mov    %rdx,%rsi
  800420f43e:	48 89 c7             	mov    %rax,%rdi
  800420f441:	48 b8 f6 12 21 04 80 	movabs $0x80042112f6,%rax
  800420f448:	00 00 00 
  800420f44b:	ff d0                	callq  *%rax
  800420f44d:	85 c0                	test   %eax,%eax
  800420f44f:	0f 84 66 fe ff ff    	je     800420f2bb <debuginfo_rip+0x27b>
			die.cu_header = &cu;
			die.cu_die = &cudie;
		}
	}

	return -1;
  800420f455:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420f45a:	e9 a0 00 00 00       	jmpq   800420f4ff <debuginfo_rip+0x4bf>

find_done:

	if (dwarf_init_eh_section(dbg, NULL) == DW_DLV_ERROR)
		return -1;
  800420f45f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420f464:	e9 96 00 00 00       	jmpq   800420f4ff <debuginfo_rip+0x4bf>

	if (dwarf_get_fde_at_pc(dbg, addr, fde, cie, NULL) == DW_DLV_OK) {
  800420f469:	48 b8 80 c6 22 04 80 	movabs $0x800422c680,%rax
  800420f470:	00 00 00 
  800420f473:	48 8b 08             	mov    (%rax),%rcx
  800420f476:	48 b8 78 c6 22 04 80 	movabs $0x800422c678,%rax
  800420f47d:	00 00 00 
  800420f480:	48 8b 10             	mov    (%rax),%rdx
  800420f483:	48 b8 88 c6 22 04 80 	movabs $0x800422c688,%rax
  800420f48a:	00 00 00 
  800420f48d:	48 8b 00             	mov    (%rax),%rax
  800420f490:	48 8b b5 38 6e ff ff 	mov    -0x91c8(%rbp),%rsi
  800420f497:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800420f49d:	48 89 c7             	mov    %rax,%rdi
  800420f4a0:	48 b8 21 28 21 04 80 	movabs $0x8004212821,%rax
  800420f4a7:	00 00 00 
  800420f4aa:	ff d0                	callq  *%rax
  800420f4ac:	85 c0                	test   %eax,%eax
  800420f4ae:	75 4a                	jne    800420f4fa <debuginfo_rip+0x4ba>
		dwarf_get_fde_info_for_all_regs(dbg, fde, addr,
  800420f4b0:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420f4b7:	48 8d 88 a8 00 00 00 	lea    0xa8(%rax),%rcx
  800420f4be:	48 b8 78 c6 22 04 80 	movabs $0x800422c678,%rax
  800420f4c5:	00 00 00 
  800420f4c8:	48 8b 30             	mov    (%rax),%rsi
  800420f4cb:	48 b8 88 c6 22 04 80 	movabs $0x800422c688,%rax
  800420f4d2:	00 00 00 
  800420f4d5:	48 8b 00             	mov    (%rax),%rax
  800420f4d8:	48 8b 95 38 6e ff ff 	mov    -0x91c8(%rbp),%rdx
  800420f4df:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  800420f4e5:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800420f4eb:	48 89 c7             	mov    %rax,%rdi
  800420f4ee:	48 b8 2d 3b 21 04 80 	movabs $0x8004213b2d,%rax
  800420f4f5:	00 00 00 
  800420f4f8:	ff d0                	callq  *%rax
					break;
			}
		}
#endif
	}
	return 0;
  800420f4fa:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420f4ff:	48 81 c4 c8 91 00 00 	add    $0x91c8,%rsp
  800420f506:	5b                   	pop    %rbx
  800420f507:	5d                   	pop    %rbp
  800420f508:	c3                   	retq   

000000800420f509 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  800420f509:	55                   	push   %rbp
  800420f50a:	48 89 e5             	mov    %rsp,%rbp
  800420f50d:	53                   	push   %rbx
  800420f50e:	48 83 ec 38          	sub    $0x38,%rsp
  800420f512:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f516:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420f51a:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420f51e:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
  800420f521:	44 89 45 d0          	mov    %r8d,-0x30(%rbp)
  800420f525:	44 89 4d cc          	mov    %r9d,-0x34(%rbp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  800420f529:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800420f52c:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  800420f530:	77 3b                	ja     800420f56d <printnum+0x64>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  800420f532:	8b 45 d0             	mov    -0x30(%rbp),%eax
  800420f535:	44 8d 40 ff          	lea    -0x1(%rax),%r8d
  800420f539:	8b 5d d4             	mov    -0x2c(%rbp),%ebx
  800420f53c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f540:	ba 00 00 00 00       	mov    $0x0,%edx
  800420f545:	48 f7 f3             	div    %rbx
  800420f548:	48 89 c2             	mov    %rax,%rdx
  800420f54b:	8b 7d cc             	mov    -0x34(%rbp),%edi
  800420f54e:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
  800420f551:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420f555:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f559:	41 89 f9             	mov    %edi,%r9d
  800420f55c:	48 89 c7             	mov    %rax,%rdi
  800420f55f:	48 b8 09 f5 20 04 80 	movabs $0x800420f509,%rax
  800420f566:	00 00 00 
  800420f569:	ff d0                	callq  *%rax
  800420f56b:	eb 1e                	jmp    800420f58b <printnum+0x82>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800420f56d:	eb 12                	jmp    800420f581 <printnum+0x78>
			putch(padc, putdat);
  800420f56f:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420f573:	8b 55 cc             	mov    -0x34(%rbp),%edx
  800420f576:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f57a:	48 89 ce             	mov    %rcx,%rsi
  800420f57d:	89 d7                	mov    %edx,%edi
  800420f57f:	ff d0                	callq  *%rax
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800420f581:	83 6d d0 01          	subl   $0x1,-0x30(%rbp)
  800420f585:	83 7d d0 00          	cmpl   $0x0,-0x30(%rbp)
  800420f589:	7f e4                	jg     800420f56f <printnum+0x66>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  800420f58b:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
  800420f58e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f592:	ba 00 00 00 00       	mov    $0x0,%edx
  800420f597:	48 f7 f1             	div    %rcx
  800420f59a:	48 89 d0             	mov    %rdx,%rax
  800420f59d:	48 ba 90 ae 21 04 80 	movabs $0x800421ae90,%rdx
  800420f5a4:	00 00 00 
  800420f5a7:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  800420f5ab:	0f be d0             	movsbl %al,%edx
  800420f5ae:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420f5b2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f5b6:	48 89 ce             	mov    %rcx,%rsi
  800420f5b9:	89 d7                	mov    %edx,%edi
  800420f5bb:	ff d0                	callq  *%rax
}
  800420f5bd:	48 83 c4 38          	add    $0x38,%rsp
  800420f5c1:	5b                   	pop    %rbx
  800420f5c2:	5d                   	pop    %rbp
  800420f5c3:	c3                   	retq   

000000800420f5c4 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  800420f5c4:	55                   	push   %rbp
  800420f5c5:	48 89 e5             	mov    %rsp,%rbp
  800420f5c8:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420f5cc:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f5d0:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	unsigned long long x;    
	if (lflag >= 2)
  800420f5d3:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  800420f5d7:	7e 52                	jle    800420f62b <getuint+0x67>
		x= va_arg(*ap, unsigned long long);
  800420f5d9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f5dd:	8b 00                	mov    (%rax),%eax
  800420f5df:	83 f8 30             	cmp    $0x30,%eax
  800420f5e2:	73 24                	jae    800420f608 <getuint+0x44>
  800420f5e4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f5e8:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420f5ec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f5f0:	8b 00                	mov    (%rax),%eax
  800420f5f2:	89 c0                	mov    %eax,%eax
  800420f5f4:	48 01 d0             	add    %rdx,%rax
  800420f5f7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f5fb:	8b 12                	mov    (%rdx),%edx
  800420f5fd:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420f600:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f604:	89 0a                	mov    %ecx,(%rdx)
  800420f606:	eb 17                	jmp    800420f61f <getuint+0x5b>
  800420f608:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f60c:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420f610:	48 89 d0             	mov    %rdx,%rax
  800420f613:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420f617:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f61b:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420f61f:	48 8b 00             	mov    (%rax),%rax
  800420f622:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420f626:	e9 a3 00 00 00       	jmpq   800420f6ce <getuint+0x10a>
	else if (lflag)
  800420f62b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420f62f:	74 4f                	je     800420f680 <getuint+0xbc>
		x= va_arg(*ap, unsigned long);
  800420f631:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f635:	8b 00                	mov    (%rax),%eax
  800420f637:	83 f8 30             	cmp    $0x30,%eax
  800420f63a:	73 24                	jae    800420f660 <getuint+0x9c>
  800420f63c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f640:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420f644:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f648:	8b 00                	mov    (%rax),%eax
  800420f64a:	89 c0                	mov    %eax,%eax
  800420f64c:	48 01 d0             	add    %rdx,%rax
  800420f64f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f653:	8b 12                	mov    (%rdx),%edx
  800420f655:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420f658:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f65c:	89 0a                	mov    %ecx,(%rdx)
  800420f65e:	eb 17                	jmp    800420f677 <getuint+0xb3>
  800420f660:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f664:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420f668:	48 89 d0             	mov    %rdx,%rax
  800420f66b:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420f66f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f673:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420f677:	48 8b 00             	mov    (%rax),%rax
  800420f67a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420f67e:	eb 4e                	jmp    800420f6ce <getuint+0x10a>
	else
		x= va_arg(*ap, unsigned int);
  800420f680:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f684:	8b 00                	mov    (%rax),%eax
  800420f686:	83 f8 30             	cmp    $0x30,%eax
  800420f689:	73 24                	jae    800420f6af <getuint+0xeb>
  800420f68b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f68f:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420f693:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f697:	8b 00                	mov    (%rax),%eax
  800420f699:	89 c0                	mov    %eax,%eax
  800420f69b:	48 01 d0             	add    %rdx,%rax
  800420f69e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f6a2:	8b 12                	mov    (%rdx),%edx
  800420f6a4:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420f6a7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f6ab:	89 0a                	mov    %ecx,(%rdx)
  800420f6ad:	eb 17                	jmp    800420f6c6 <getuint+0x102>
  800420f6af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f6b3:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420f6b7:	48 89 d0             	mov    %rdx,%rax
  800420f6ba:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420f6be:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f6c2:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420f6c6:	8b 00                	mov    (%rax),%eax
  800420f6c8:	89 c0                	mov    %eax,%eax
  800420f6ca:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  800420f6ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420f6d2:	c9                   	leaveq 
  800420f6d3:	c3                   	retq   

000000800420f6d4 <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
  800420f6d4:	55                   	push   %rbp
  800420f6d5:	48 89 e5             	mov    %rsp,%rbp
  800420f6d8:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420f6dc:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f6e0:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	long long x;
	if (lflag >= 2)
  800420f6e3:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  800420f6e7:	7e 52                	jle    800420f73b <getint+0x67>
		x=va_arg(*ap, long long);
  800420f6e9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f6ed:	8b 00                	mov    (%rax),%eax
  800420f6ef:	83 f8 30             	cmp    $0x30,%eax
  800420f6f2:	73 24                	jae    800420f718 <getint+0x44>
  800420f6f4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f6f8:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420f6fc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f700:	8b 00                	mov    (%rax),%eax
  800420f702:	89 c0                	mov    %eax,%eax
  800420f704:	48 01 d0             	add    %rdx,%rax
  800420f707:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f70b:	8b 12                	mov    (%rdx),%edx
  800420f70d:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420f710:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f714:	89 0a                	mov    %ecx,(%rdx)
  800420f716:	eb 17                	jmp    800420f72f <getint+0x5b>
  800420f718:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f71c:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420f720:	48 89 d0             	mov    %rdx,%rax
  800420f723:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420f727:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f72b:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420f72f:	48 8b 00             	mov    (%rax),%rax
  800420f732:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420f736:	e9 a3 00 00 00       	jmpq   800420f7de <getint+0x10a>
	else if (lflag)
  800420f73b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420f73f:	74 4f                	je     800420f790 <getint+0xbc>
		x=va_arg(*ap, long);
  800420f741:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f745:	8b 00                	mov    (%rax),%eax
  800420f747:	83 f8 30             	cmp    $0x30,%eax
  800420f74a:	73 24                	jae    800420f770 <getint+0x9c>
  800420f74c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f750:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420f754:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f758:	8b 00                	mov    (%rax),%eax
  800420f75a:	89 c0                	mov    %eax,%eax
  800420f75c:	48 01 d0             	add    %rdx,%rax
  800420f75f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f763:	8b 12                	mov    (%rdx),%edx
  800420f765:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420f768:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f76c:	89 0a                	mov    %ecx,(%rdx)
  800420f76e:	eb 17                	jmp    800420f787 <getint+0xb3>
  800420f770:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f774:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420f778:	48 89 d0             	mov    %rdx,%rax
  800420f77b:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420f77f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f783:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420f787:	48 8b 00             	mov    (%rax),%rax
  800420f78a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420f78e:	eb 4e                	jmp    800420f7de <getint+0x10a>
	else
		x=va_arg(*ap, int);
  800420f790:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f794:	8b 00                	mov    (%rax),%eax
  800420f796:	83 f8 30             	cmp    $0x30,%eax
  800420f799:	73 24                	jae    800420f7bf <getint+0xeb>
  800420f79b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f79f:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420f7a3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f7a7:	8b 00                	mov    (%rax),%eax
  800420f7a9:	89 c0                	mov    %eax,%eax
  800420f7ab:	48 01 d0             	add    %rdx,%rax
  800420f7ae:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f7b2:	8b 12                	mov    (%rdx),%edx
  800420f7b4:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420f7b7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f7bb:	89 0a                	mov    %ecx,(%rdx)
  800420f7bd:	eb 17                	jmp    800420f7d6 <getint+0x102>
  800420f7bf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f7c3:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420f7c7:	48 89 d0             	mov    %rdx,%rax
  800420f7ca:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420f7ce:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f7d2:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420f7d6:	8b 00                	mov    (%rax),%eax
  800420f7d8:	48 98                	cltq   
  800420f7da:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  800420f7de:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420f7e2:	c9                   	leaveq 
  800420f7e3:	c3                   	retq   

000000800420f7e4 <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  800420f7e4:	55                   	push   %rbp
  800420f7e5:	48 89 e5             	mov    %rsp,%rbp
  800420f7e8:	41 54                	push   %r12
  800420f7ea:	53                   	push   %rbx
  800420f7eb:	48 83 ec 60          	sub    $0x60,%rsp
  800420f7ef:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  800420f7f3:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  800420f7f7:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420f7fb:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
	register int ch, err;
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
  800420f7ff:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420f803:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  800420f807:	48 8b 0a             	mov    (%rdx),%rcx
  800420f80a:	48 89 08             	mov    %rcx,(%rax)
  800420f80d:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420f811:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420f815:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420f819:	48 89 50 10          	mov    %rdx,0x10(%rax)
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420f81d:	eb 17                	jmp    800420f836 <vprintfmt+0x52>
			if (ch == '\0')
  800420f81f:	85 db                	test   %ebx,%ebx
  800420f821:	0f 84 cc 04 00 00    	je     800420fcf3 <vprintfmt+0x50f>
				return;
			putch(ch, putdat);
  800420f827:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f82b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f82f:	48 89 d6             	mov    %rdx,%rsi
  800420f832:	89 df                	mov    %ebx,%edi
  800420f834:	ff d0                	callq  *%rax
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420f836:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420f83a:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f83e:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420f842:	0f b6 00             	movzbl (%rax),%eax
  800420f845:	0f b6 d8             	movzbl %al,%ebx
  800420f848:	83 fb 25             	cmp    $0x25,%ebx
  800420f84b:	75 d2                	jne    800420f81f <vprintfmt+0x3b>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
  800420f84d:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
		width = -1;
  800420f851:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%rbp)
		precision = -1;
  800420f858:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
		lflag = 0;
  800420f85f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
		altflag = 0;
  800420f866:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  800420f86d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420f871:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f875:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420f879:	0f b6 00             	movzbl (%rax),%eax
  800420f87c:	0f b6 d8             	movzbl %al,%ebx
  800420f87f:	8d 43 dd             	lea    -0x23(%rbx),%eax
  800420f882:	83 f8 55             	cmp    $0x55,%eax
  800420f885:	0f 87 34 04 00 00    	ja     800420fcbf <vprintfmt+0x4db>
  800420f88b:	89 c0                	mov    %eax,%eax
  800420f88d:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420f894:	00 
  800420f895:	48 b8 b8 ae 21 04 80 	movabs $0x800421aeb8,%rax
  800420f89c:	00 00 00 
  800420f89f:	48 01 d0             	add    %rdx,%rax
  800420f8a2:	48 8b 00             	mov    (%rax),%rax
  800420f8a5:	ff e0                	jmpq   *%rax

			// flag to pad on the right
		case '-':
			padc = '-';
  800420f8a7:	c6 45 d3 2d          	movb   $0x2d,-0x2d(%rbp)
			goto reswitch;
  800420f8ab:	eb c0                	jmp    800420f86d <vprintfmt+0x89>

			// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
  800420f8ad:	c6 45 d3 30          	movb   $0x30,-0x2d(%rbp)
			goto reswitch;
  800420f8b1:	eb ba                	jmp    800420f86d <vprintfmt+0x89>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  800420f8b3:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
				precision = precision * 10 + ch - '0';
  800420f8ba:	8b 55 d8             	mov    -0x28(%rbp),%edx
  800420f8bd:	89 d0                	mov    %edx,%eax
  800420f8bf:	c1 e0 02             	shl    $0x2,%eax
  800420f8c2:	01 d0                	add    %edx,%eax
  800420f8c4:	01 c0                	add    %eax,%eax
  800420f8c6:	01 d8                	add    %ebx,%eax
  800420f8c8:	83 e8 30             	sub    $0x30,%eax
  800420f8cb:	89 45 d8             	mov    %eax,-0x28(%rbp)
				ch = *fmt;
  800420f8ce:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420f8d2:	0f b6 00             	movzbl (%rax),%eax
  800420f8d5:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
  800420f8d8:	83 fb 2f             	cmp    $0x2f,%ebx
  800420f8db:	7e 0c                	jle    800420f8e9 <vprintfmt+0x105>
  800420f8dd:	83 fb 39             	cmp    $0x39,%ebx
  800420f8e0:	7f 07                	jg     800420f8e9 <vprintfmt+0x105>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  800420f8e2:	48 83 45 98 01       	addq   $0x1,-0x68(%rbp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
  800420f8e7:	eb d1                	jmp    800420f8ba <vprintfmt+0xd6>
			goto process_precision;
  800420f8e9:	eb 58                	jmp    800420f943 <vprintfmt+0x15f>

		case '*':
			precision = va_arg(aq, int);
  800420f8eb:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f8ee:	83 f8 30             	cmp    $0x30,%eax
  800420f8f1:	73 17                	jae    800420f90a <vprintfmt+0x126>
  800420f8f3:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420f8f7:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f8fa:	89 c0                	mov    %eax,%eax
  800420f8fc:	48 01 d0             	add    %rdx,%rax
  800420f8ff:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420f902:	83 c2 08             	add    $0x8,%edx
  800420f905:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420f908:	eb 0f                	jmp    800420f919 <vprintfmt+0x135>
  800420f90a:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420f90e:	48 89 d0             	mov    %rdx,%rax
  800420f911:	48 83 c2 08          	add    $0x8,%rdx
  800420f915:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420f919:	8b 00                	mov    (%rax),%eax
  800420f91b:	89 45 d8             	mov    %eax,-0x28(%rbp)
			goto process_precision;
  800420f91e:	eb 23                	jmp    800420f943 <vprintfmt+0x15f>

		case '.':
			if (width < 0)
  800420f920:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420f924:	79 0c                	jns    800420f932 <vprintfmt+0x14e>
				width = 0;
  800420f926:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
			goto reswitch;
  800420f92d:	e9 3b ff ff ff       	jmpq   800420f86d <vprintfmt+0x89>
  800420f932:	e9 36 ff ff ff       	jmpq   800420f86d <vprintfmt+0x89>

		case '#':
			altflag = 1;
  800420f937:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%rbp)
			goto reswitch;
  800420f93e:	e9 2a ff ff ff       	jmpq   800420f86d <vprintfmt+0x89>

		process_precision:
			if (width < 0)
  800420f943:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420f947:	79 12                	jns    800420f95b <vprintfmt+0x177>
				width = precision, precision = -1;
  800420f949:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420f94c:	89 45 dc             	mov    %eax,-0x24(%rbp)
  800420f94f:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
			goto reswitch;
  800420f956:	e9 12 ff ff ff       	jmpq   800420f86d <vprintfmt+0x89>
  800420f95b:	e9 0d ff ff ff       	jmpq   800420f86d <vprintfmt+0x89>

			// long flag (doubled for long long)
		case 'l':
			lflag++;
  800420f960:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
			goto reswitch;
  800420f964:	e9 04 ff ff ff       	jmpq   800420f86d <vprintfmt+0x89>

			// character
		case 'c':
			putch(va_arg(aq, int), putdat);
  800420f969:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f96c:	83 f8 30             	cmp    $0x30,%eax
  800420f96f:	73 17                	jae    800420f988 <vprintfmt+0x1a4>
  800420f971:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420f975:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f978:	89 c0                	mov    %eax,%eax
  800420f97a:	48 01 d0             	add    %rdx,%rax
  800420f97d:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420f980:	83 c2 08             	add    $0x8,%edx
  800420f983:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420f986:	eb 0f                	jmp    800420f997 <vprintfmt+0x1b3>
  800420f988:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420f98c:	48 89 d0             	mov    %rdx,%rax
  800420f98f:	48 83 c2 08          	add    $0x8,%rdx
  800420f993:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420f997:	8b 10                	mov    (%rax),%edx
  800420f999:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  800420f99d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f9a1:	48 89 ce             	mov    %rcx,%rsi
  800420f9a4:	89 d7                	mov    %edx,%edi
  800420f9a6:	ff d0                	callq  *%rax
			break;
  800420f9a8:	e9 40 03 00 00       	jmpq   800420fced <vprintfmt+0x509>

			// error message
		case 'e':
			err = va_arg(aq, int);
  800420f9ad:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f9b0:	83 f8 30             	cmp    $0x30,%eax
  800420f9b3:	73 17                	jae    800420f9cc <vprintfmt+0x1e8>
  800420f9b5:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420f9b9:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f9bc:	89 c0                	mov    %eax,%eax
  800420f9be:	48 01 d0             	add    %rdx,%rax
  800420f9c1:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420f9c4:	83 c2 08             	add    $0x8,%edx
  800420f9c7:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420f9ca:	eb 0f                	jmp    800420f9db <vprintfmt+0x1f7>
  800420f9cc:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420f9d0:	48 89 d0             	mov    %rdx,%rax
  800420f9d3:	48 83 c2 08          	add    $0x8,%rdx
  800420f9d7:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420f9db:	8b 18                	mov    (%rax),%ebx
			if (err < 0)
  800420f9dd:	85 db                	test   %ebx,%ebx
  800420f9df:	79 02                	jns    800420f9e3 <vprintfmt+0x1ff>
				err = -err;
  800420f9e1:	f7 db                	neg    %ebx
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  800420f9e3:	83 fb 15             	cmp    $0x15,%ebx
  800420f9e6:	7f 16                	jg     800420f9fe <vprintfmt+0x21a>
  800420f9e8:	48 b8 e0 ad 21 04 80 	movabs $0x800421ade0,%rax
  800420f9ef:	00 00 00 
  800420f9f2:	48 63 d3             	movslq %ebx,%rdx
  800420f9f5:	4c 8b 24 d0          	mov    (%rax,%rdx,8),%r12
  800420f9f9:	4d 85 e4             	test   %r12,%r12
  800420f9fc:	75 2e                	jne    800420fa2c <vprintfmt+0x248>
				printfmt(putch, putdat, "error %d", err);
  800420f9fe:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420fa02:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420fa06:	89 d9                	mov    %ebx,%ecx
  800420fa08:	48 ba a1 ae 21 04 80 	movabs $0x800421aea1,%rdx
  800420fa0f:	00 00 00 
  800420fa12:	48 89 c7             	mov    %rax,%rdi
  800420fa15:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fa1a:	49 b8 fc fc 20 04 80 	movabs $0x800420fcfc,%r8
  800420fa21:	00 00 00 
  800420fa24:	41 ff d0             	callq  *%r8
			else
				printfmt(putch, putdat, "%s", p);
			break;
  800420fa27:	e9 c1 02 00 00       	jmpq   800420fced <vprintfmt+0x509>
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
  800420fa2c:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420fa30:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420fa34:	4c 89 e1             	mov    %r12,%rcx
  800420fa37:	48 ba aa ae 21 04 80 	movabs $0x800421aeaa,%rdx
  800420fa3e:	00 00 00 
  800420fa41:	48 89 c7             	mov    %rax,%rdi
  800420fa44:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fa49:	49 b8 fc fc 20 04 80 	movabs $0x800420fcfc,%r8
  800420fa50:	00 00 00 
  800420fa53:	41 ff d0             	callq  *%r8
			break;
  800420fa56:	e9 92 02 00 00       	jmpq   800420fced <vprintfmt+0x509>

			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
  800420fa5b:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420fa5e:	83 f8 30             	cmp    $0x30,%eax
  800420fa61:	73 17                	jae    800420fa7a <vprintfmt+0x296>
  800420fa63:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420fa67:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420fa6a:	89 c0                	mov    %eax,%eax
  800420fa6c:	48 01 d0             	add    %rdx,%rax
  800420fa6f:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420fa72:	83 c2 08             	add    $0x8,%edx
  800420fa75:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420fa78:	eb 0f                	jmp    800420fa89 <vprintfmt+0x2a5>
  800420fa7a:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420fa7e:	48 89 d0             	mov    %rdx,%rax
  800420fa81:	48 83 c2 08          	add    $0x8,%rdx
  800420fa85:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420fa89:	4c 8b 20             	mov    (%rax),%r12
  800420fa8c:	4d 85 e4             	test   %r12,%r12
  800420fa8f:	75 0a                	jne    800420fa9b <vprintfmt+0x2b7>
				p = "(null)";
  800420fa91:	49 bc ad ae 21 04 80 	movabs $0x800421aead,%r12
  800420fa98:	00 00 00 
			if (width > 0 && padc != '-')
  800420fa9b:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420fa9f:	7e 3f                	jle    800420fae0 <vprintfmt+0x2fc>
  800420faa1:	80 7d d3 2d          	cmpb   $0x2d,-0x2d(%rbp)
  800420faa5:	74 39                	je     800420fae0 <vprintfmt+0x2fc>
				for (width -= strnlen(p, precision); width > 0; width--)
  800420faa7:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420faaa:	48 98                	cltq   
  800420faac:	48 89 c6             	mov    %rax,%rsi
  800420faaf:	4c 89 e7             	mov    %r12,%rdi
  800420fab2:	48 b8 fd 00 21 04 80 	movabs $0x80042100fd,%rax
  800420fab9:	00 00 00 
  800420fabc:	ff d0                	callq  *%rax
  800420fabe:	29 45 dc             	sub    %eax,-0x24(%rbp)
  800420fac1:	eb 17                	jmp    800420fada <vprintfmt+0x2f6>
					putch(padc, putdat);
  800420fac3:	0f be 55 d3          	movsbl -0x2d(%rbp),%edx
  800420fac7:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  800420facb:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420facf:	48 89 ce             	mov    %rcx,%rsi
  800420fad2:	89 d7                	mov    %edx,%edi
  800420fad4:	ff d0                	callq  *%rax
			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  800420fad6:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420fada:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420fade:	7f e3                	jg     800420fac3 <vprintfmt+0x2df>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800420fae0:	eb 37                	jmp    800420fb19 <vprintfmt+0x335>
				if (altflag && (ch < ' ' || ch > '~'))
  800420fae2:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  800420fae6:	74 1e                	je     800420fb06 <vprintfmt+0x322>
  800420fae8:	83 fb 1f             	cmp    $0x1f,%ebx
  800420faeb:	7e 05                	jle    800420faf2 <vprintfmt+0x30e>
  800420faed:	83 fb 7e             	cmp    $0x7e,%ebx
  800420faf0:	7e 14                	jle    800420fb06 <vprintfmt+0x322>
					putch('?', putdat);
  800420faf2:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420faf6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420fafa:	48 89 d6             	mov    %rdx,%rsi
  800420fafd:	bf 3f 00 00 00       	mov    $0x3f,%edi
  800420fb02:	ff d0                	callq  *%rax
  800420fb04:	eb 0f                	jmp    800420fb15 <vprintfmt+0x331>
				else
					putch(ch, putdat);
  800420fb06:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420fb0a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420fb0e:	48 89 d6             	mov    %rdx,%rsi
  800420fb11:	89 df                	mov    %ebx,%edi
  800420fb13:	ff d0                	callq  *%rax
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800420fb15:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420fb19:	4c 89 e0             	mov    %r12,%rax
  800420fb1c:	4c 8d 60 01          	lea    0x1(%rax),%r12
  800420fb20:	0f b6 00             	movzbl (%rax),%eax
  800420fb23:	0f be d8             	movsbl %al,%ebx
  800420fb26:	85 db                	test   %ebx,%ebx
  800420fb28:	74 10                	je     800420fb3a <vprintfmt+0x356>
  800420fb2a:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  800420fb2e:	78 b2                	js     800420fae2 <vprintfmt+0x2fe>
  800420fb30:	83 6d d8 01          	subl   $0x1,-0x28(%rbp)
  800420fb34:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  800420fb38:	79 a8                	jns    800420fae2 <vprintfmt+0x2fe>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800420fb3a:	eb 16                	jmp    800420fb52 <vprintfmt+0x36e>
				putch(' ', putdat);
  800420fb3c:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420fb40:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420fb44:	48 89 d6             	mov    %rdx,%rsi
  800420fb47:	bf 20 00 00 00       	mov    $0x20,%edi
  800420fb4c:	ff d0                	callq  *%rax
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800420fb4e:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420fb52:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420fb56:	7f e4                	jg     800420fb3c <vprintfmt+0x358>
				putch(' ', putdat);
			break;
  800420fb58:	e9 90 01 00 00       	jmpq   800420fced <vprintfmt+0x509>

			// (signed) decimal
		case 'd':
			num = getint(&aq, 3);
  800420fb5d:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420fb61:	be 03 00 00 00       	mov    $0x3,%esi
  800420fb66:	48 89 c7             	mov    %rax,%rdi
  800420fb69:	48 b8 d4 f6 20 04 80 	movabs $0x800420f6d4,%rax
  800420fb70:	00 00 00 
  800420fb73:	ff d0                	callq  *%rax
  800420fb75:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if ((long long) num < 0) {
  800420fb79:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fb7d:	48 85 c0             	test   %rax,%rax
  800420fb80:	79 1d                	jns    800420fb9f <vprintfmt+0x3bb>
				putch('-', putdat);
  800420fb82:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420fb86:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420fb8a:	48 89 d6             	mov    %rdx,%rsi
  800420fb8d:	bf 2d 00 00 00       	mov    $0x2d,%edi
  800420fb92:	ff d0                	callq  *%rax
				num = -(long long) num;
  800420fb94:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fb98:	48 f7 d8             	neg    %rax
  800420fb9b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			}
			base = 10;
  800420fb9f:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  800420fba6:	e9 d5 00 00 00       	jmpq   800420fc80 <vprintfmt+0x49c>

			// unsigned decimal
		case 'u':
			num = getuint(&aq, 3);
  800420fbab:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420fbaf:	be 03 00 00 00       	mov    $0x3,%esi
  800420fbb4:	48 89 c7             	mov    %rax,%rdi
  800420fbb7:	48 b8 c4 f5 20 04 80 	movabs $0x800420f5c4,%rax
  800420fbbe:	00 00 00 
  800420fbc1:	ff d0                	callq  *%rax
  800420fbc3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 10;
  800420fbc7:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  800420fbce:	e9 ad 00 00 00       	jmpq   800420fc80 <vprintfmt+0x49c>

			// (unsigned) octal
		case 'o':

			num = getuint(&aq, 3);
  800420fbd3:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420fbd7:	be 03 00 00 00       	mov    $0x3,%esi
  800420fbdc:	48 89 c7             	mov    %rax,%rdi
  800420fbdf:	48 b8 c4 f5 20 04 80 	movabs $0x800420f5c4,%rax
  800420fbe6:	00 00 00 
  800420fbe9:	ff d0                	callq  *%rax
  800420fbeb:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 8;
  800420fbef:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%rbp)
			goto number;
  800420fbf6:	e9 85 00 00 00       	jmpq   800420fc80 <vprintfmt+0x49c>


			// pointer
		case 'p':
			putch('0', putdat);
  800420fbfb:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420fbff:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420fc03:	48 89 d6             	mov    %rdx,%rsi
  800420fc06:	bf 30 00 00 00       	mov    $0x30,%edi
  800420fc0b:	ff d0                	callq  *%rax
			putch('x', putdat);
  800420fc0d:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420fc11:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420fc15:	48 89 d6             	mov    %rdx,%rsi
  800420fc18:	bf 78 00 00 00       	mov    $0x78,%edi
  800420fc1d:	ff d0                	callq  *%rax
			num = (unsigned long long)
				(uintptr_t) va_arg(aq, void *);
  800420fc1f:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420fc22:	83 f8 30             	cmp    $0x30,%eax
  800420fc25:	73 17                	jae    800420fc3e <vprintfmt+0x45a>
  800420fc27:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420fc2b:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420fc2e:	89 c0                	mov    %eax,%eax
  800420fc30:	48 01 d0             	add    %rdx,%rax
  800420fc33:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420fc36:	83 c2 08             	add    $0x8,%edx
  800420fc39:	89 55 b8             	mov    %edx,-0x48(%rbp)

			// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  800420fc3c:	eb 0f                	jmp    800420fc4d <vprintfmt+0x469>
				(uintptr_t) va_arg(aq, void *);
  800420fc3e:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420fc42:	48 89 d0             	mov    %rdx,%rax
  800420fc45:	48 83 c2 08          	add    $0x8,%rdx
  800420fc49:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420fc4d:	48 8b 00             	mov    (%rax),%rax

			// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  800420fc50:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				(uintptr_t) va_arg(aq, void *);
			base = 16;
  800420fc54:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
			goto number;
  800420fc5b:	eb 23                	jmp    800420fc80 <vprintfmt+0x49c>

			// (unsigned) hexadecimal
		case 'x':
			num = getuint(&aq, 3);
  800420fc5d:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420fc61:	be 03 00 00 00       	mov    $0x3,%esi
  800420fc66:	48 89 c7             	mov    %rax,%rdi
  800420fc69:	48 b8 c4 f5 20 04 80 	movabs $0x800420f5c4,%rax
  800420fc70:	00 00 00 
  800420fc73:	ff d0                	callq  *%rax
  800420fc75:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 16;
  800420fc79:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
		number:
			printnum(putch, putdat, num, base, width, padc);
  800420fc80:	44 0f be 45 d3       	movsbl -0x2d(%rbp),%r8d
  800420fc85:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  800420fc88:	8b 7d dc             	mov    -0x24(%rbp),%edi
  800420fc8b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fc8f:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420fc93:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420fc97:	45 89 c1             	mov    %r8d,%r9d
  800420fc9a:	41 89 f8             	mov    %edi,%r8d
  800420fc9d:	48 89 c7             	mov    %rax,%rdi
  800420fca0:	48 b8 09 f5 20 04 80 	movabs $0x800420f509,%rax
  800420fca7:	00 00 00 
  800420fcaa:	ff d0                	callq  *%rax
			break;
  800420fcac:	eb 3f                	jmp    800420fced <vprintfmt+0x509>

			// escaped '%' character
		case '%':
			putch(ch, putdat);
  800420fcae:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420fcb2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420fcb6:	48 89 d6             	mov    %rdx,%rsi
  800420fcb9:	89 df                	mov    %ebx,%edi
  800420fcbb:	ff d0                	callq  *%rax
			break;
  800420fcbd:	eb 2e                	jmp    800420fced <vprintfmt+0x509>

			// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  800420fcbf:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420fcc3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420fcc7:	48 89 d6             	mov    %rdx,%rsi
  800420fcca:	bf 25 00 00 00       	mov    $0x25,%edi
  800420fccf:	ff d0                	callq  *%rax
			for (fmt--; fmt[-1] != '%'; fmt--)
  800420fcd1:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  800420fcd6:	eb 05                	jmp    800420fcdd <vprintfmt+0x4f9>
  800420fcd8:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  800420fcdd:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420fce1:	48 83 e8 01          	sub    $0x1,%rax
  800420fce5:	0f b6 00             	movzbl (%rax),%eax
  800420fce8:	3c 25                	cmp    $0x25,%al
  800420fcea:	75 ec                	jne    800420fcd8 <vprintfmt+0x4f4>
				/* do nothing */;
			break;
  800420fcec:	90                   	nop
		}
	}
  800420fced:	90                   	nop
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420fcee:	e9 43 fb ff ff       	jmpq   800420f836 <vprintfmt+0x52>
				/* do nothing */;
			break;
		}
	}
	va_end(aq);
}
  800420fcf3:	48 83 c4 60          	add    $0x60,%rsp
  800420fcf7:	5b                   	pop    %rbx
  800420fcf8:	41 5c                	pop    %r12
  800420fcfa:	5d                   	pop    %rbp
  800420fcfb:	c3                   	retq   

000000800420fcfc <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  800420fcfc:	55                   	push   %rbp
  800420fcfd:	48 89 e5             	mov    %rsp,%rbp
  800420fd00:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  800420fd07:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  800420fd0e:	48 89 b5 20 ff ff ff 	mov    %rsi,-0xe0(%rbp)
  800420fd15:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420fd1c:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420fd23:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420fd2a:	84 c0                	test   %al,%al
  800420fd2c:	74 20                	je     800420fd4e <printfmt+0x52>
  800420fd2e:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420fd32:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420fd36:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420fd3a:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420fd3e:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420fd42:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420fd46:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420fd4a:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  800420fd4e:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  800420fd55:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  800420fd5c:	00 00 00 
  800420fd5f:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  800420fd66:	00 00 00 
  800420fd69:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420fd6d:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  800420fd74:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420fd7b:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	vprintfmt(putch, putdat, fmt, ap);
  800420fd82:	48 8d 8d 38 ff ff ff 	lea    -0xc8(%rbp),%rcx
  800420fd89:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  800420fd90:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  800420fd97:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800420fd9e:	48 89 c7             	mov    %rax,%rdi
  800420fda1:	48 b8 e4 f7 20 04 80 	movabs $0x800420f7e4,%rax
  800420fda8:	00 00 00 
  800420fdab:	ff d0                	callq  *%rax
	va_end(ap);
}
  800420fdad:	c9                   	leaveq 
  800420fdae:	c3                   	retq   

000000800420fdaf <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  800420fdaf:	55                   	push   %rbp
  800420fdb0:	48 89 e5             	mov    %rsp,%rbp
  800420fdb3:	48 83 ec 10          	sub    $0x10,%rsp
  800420fdb7:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800420fdba:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	b->cnt++;
  800420fdbe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fdc2:	8b 40 10             	mov    0x10(%rax),%eax
  800420fdc5:	8d 50 01             	lea    0x1(%rax),%edx
  800420fdc8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fdcc:	89 50 10             	mov    %edx,0x10(%rax)
	if (b->buf < b->ebuf)
  800420fdcf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fdd3:	48 8b 10             	mov    (%rax),%rdx
  800420fdd6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fdda:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420fdde:	48 39 c2             	cmp    %rax,%rdx
  800420fde1:	73 17                	jae    800420fdfa <sprintputch+0x4b>
		*b->buf++ = ch;
  800420fde3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fde7:	48 8b 00             	mov    (%rax),%rax
  800420fdea:	48 8d 48 01          	lea    0x1(%rax),%rcx
  800420fdee:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420fdf2:	48 89 0a             	mov    %rcx,(%rdx)
  800420fdf5:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420fdf8:	88 10                	mov    %dl,(%rax)
}
  800420fdfa:	c9                   	leaveq 
  800420fdfb:	c3                   	retq   

000000800420fdfc <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  800420fdfc:	55                   	push   %rbp
  800420fdfd:	48 89 e5             	mov    %rsp,%rbp
  800420fe00:	48 83 ec 50          	sub    $0x50,%rsp
  800420fe04:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800420fe08:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  800420fe0b:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  800420fe0f:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	va_list aq;
	va_copy(aq,ap);
  800420fe13:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  800420fe17:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420fe1b:	48 8b 0a             	mov    (%rdx),%rcx
  800420fe1e:	48 89 08             	mov    %rcx,(%rax)
  800420fe21:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420fe25:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420fe29:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420fe2d:	48 89 50 10          	mov    %rdx,0x10(%rax)
	struct sprintbuf b = {buf, buf+n-1, 0};
  800420fe31:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420fe35:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  800420fe39:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800420fe3c:	48 98                	cltq   
  800420fe3e:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420fe42:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420fe46:	48 01 d0             	add    %rdx,%rax
  800420fe49:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420fe4d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)

	if (buf == NULL || n < 1)
  800420fe54:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420fe59:	74 06                	je     800420fe61 <vsnprintf+0x65>
  800420fe5b:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  800420fe5f:	7f 07                	jg     800420fe68 <vsnprintf+0x6c>
		return -E_INVAL;
  800420fe61:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420fe66:	eb 2f                	jmp    800420fe97 <vsnprintf+0x9b>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, aq);
  800420fe68:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420fe6c:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420fe70:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  800420fe74:	48 89 c6             	mov    %rax,%rsi
  800420fe77:	48 bf af fd 20 04 80 	movabs $0x800420fdaf,%rdi
  800420fe7e:	00 00 00 
  800420fe81:	48 b8 e4 f7 20 04 80 	movabs $0x800420f7e4,%rax
  800420fe88:	00 00 00 
  800420fe8b:	ff d0                	callq  *%rax
	va_end(aq);
	// null terminate the buffer
	*b.buf = '\0';
  800420fe8d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420fe91:	c6 00 00             	movb   $0x0,(%rax)

	return b.cnt;
  800420fe94:	8b 45 e0             	mov    -0x20(%rbp),%eax
}
  800420fe97:	c9                   	leaveq 
  800420fe98:	c3                   	retq   

000000800420fe99 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  800420fe99:	55                   	push   %rbp
  800420fe9a:	48 89 e5             	mov    %rsp,%rbp
  800420fe9d:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  800420fea4:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
  800420feab:	89 b5 04 ff ff ff    	mov    %esi,-0xfc(%rbp)
  800420feb1:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420feb8:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420febf:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420fec6:	84 c0                	test   %al,%al
  800420fec8:	74 20                	je     800420feea <snprintf+0x51>
  800420feca:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420fece:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420fed2:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420fed6:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420feda:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420fede:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420fee2:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420fee6:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  800420feea:	48 89 95 f8 fe ff ff 	mov    %rdx,-0x108(%rbp)
	va_list ap;
	int rc;
	va_list aq;
	va_start(ap, fmt);
  800420fef1:	c7 85 30 ff ff ff 18 	movl   $0x18,-0xd0(%rbp)
  800420fef8:	00 00 00 
  800420fefb:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  800420ff02:	00 00 00 
  800420ff05:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420ff09:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  800420ff10:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420ff17:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_copy(aq,ap);
  800420ff1e:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  800420ff25:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  800420ff2c:	48 8b 0a             	mov    (%rdx),%rcx
  800420ff2f:	48 89 08             	mov    %rcx,(%rax)
  800420ff32:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420ff36:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420ff3a:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420ff3e:	48 89 50 10          	mov    %rdx,0x10(%rax)
	rc = vsnprintf(buf, n, fmt, aq);
  800420ff42:	48 8d 8d 18 ff ff ff 	lea    -0xe8(%rbp),%rcx
  800420ff49:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  800420ff50:	8b b5 04 ff ff ff    	mov    -0xfc(%rbp),%esi
  800420ff56:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  800420ff5d:	48 89 c7             	mov    %rax,%rdi
  800420ff60:	48 b8 fc fd 20 04 80 	movabs $0x800420fdfc,%rax
  800420ff67:	00 00 00 
  800420ff6a:	ff d0                	callq  *%rax
  800420ff6c:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return rc;
  800420ff72:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  800420ff78:	c9                   	leaveq 
  800420ff79:	c3                   	retq   

000000800420ff7a <readline>:
#define BUFLEN 1024
static char buf[BUFLEN];

char *
readline(const char *prompt)
{
  800420ff7a:	55                   	push   %rbp
  800420ff7b:	48 89 e5             	mov    %rsp,%rbp
  800420ff7e:	48 83 ec 20          	sub    $0x20,%rsp
  800420ff82:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int i, c, echoing;


#if JOS_KERNEL
	if (prompt != NULL)
  800420ff86:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420ff8b:	74 22                	je     800420ffaf <readline+0x35>
		cprintf("%s", prompt);
  800420ff8d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ff91:	48 89 c6             	mov    %rax,%rsi
  800420ff94:	48 bf 68 b1 21 04 80 	movabs $0x800421b168,%rdi
  800420ff9b:	00 00 00 
  800420ff9e:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ffa3:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  800420ffaa:	00 00 00 
  800420ffad:	ff d2                	callq  *%rdx
	if (prompt != NULL)
		fprintf(1, "%s", prompt);
#endif


	i = 0;
  800420ffaf:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	echoing = iscons(0);
  800420ffb6:	bf 00 00 00 00       	mov    $0x0,%edi
  800420ffbb:	48 b8 7a 13 20 04 80 	movabs $0x800420137a,%rax
  800420ffc2:	00 00 00 
  800420ffc5:	ff d0                	callq  *%rax
  800420ffc7:	89 45 f8             	mov    %eax,-0x8(%rbp)
	while (1) {
		c = getchar();
  800420ffca:	48 b8 58 13 20 04 80 	movabs $0x8004201358,%rax
  800420ffd1:	00 00 00 
  800420ffd4:	ff d0                	callq  *%rax
  800420ffd6:	89 45 f4             	mov    %eax,-0xc(%rbp)
		if (c < 0) {
  800420ffd9:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  800420ffdd:	79 30                	jns    800421000f <readline+0x95>

			if (c != -E_EOF)
  800420ffdf:	83 7d f4 f7          	cmpl   $0xfffffff7,-0xc(%rbp)
  800420ffe3:	74 20                	je     8004210005 <readline+0x8b>
				cprintf("read error: %e\n", c);
  800420ffe5:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420ffe8:	89 c6                	mov    %eax,%esi
  800420ffea:	48 bf 6b b1 21 04 80 	movabs $0x800421b16b,%rdi
  800420fff1:	00 00 00 
  800420fff4:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fff9:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  8004210000:	00 00 00 
  8004210003:	ff d2                	callq  *%rdx

			return NULL;
  8004210005:	b8 00 00 00 00       	mov    $0x0,%eax
  800421000a:	e9 be 00 00 00       	jmpq   80042100cd <readline+0x153>
		} else if ((c == '\b' || c == '\x7f') && i > 0) {
  800421000f:	83 7d f4 08          	cmpl   $0x8,-0xc(%rbp)
  8004210013:	74 06                	je     800421001b <readline+0xa1>
  8004210015:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%rbp)
  8004210019:	75 26                	jne    8004210041 <readline+0xc7>
  800421001b:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800421001f:	7e 20                	jle    8004210041 <readline+0xc7>
			if (echoing)
  8004210021:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  8004210025:	74 11                	je     8004210038 <readline+0xbe>
				cputchar('\b');
  8004210027:	bf 08 00 00 00       	mov    $0x8,%edi
  800421002c:	48 b8 3a 13 20 04 80 	movabs $0x800420133a,%rax
  8004210033:	00 00 00 
  8004210036:	ff d0                	callq  *%rax
			i--;
  8004210038:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
  800421003c:	e9 87 00 00 00       	jmpq   80042100c8 <readline+0x14e>
		} else if (c >= ' ' && i < BUFLEN-1) {
  8004210041:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  8004210045:	7e 3f                	jle    8004210086 <readline+0x10c>
  8004210047:	81 7d fc fe 03 00 00 	cmpl   $0x3fe,-0x4(%rbp)
  800421004e:	7f 36                	jg     8004210086 <readline+0x10c>
			if (echoing)
  8004210050:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  8004210054:	74 11                	je     8004210067 <readline+0xed>
				cputchar(c);
  8004210056:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210059:	89 c7                	mov    %eax,%edi
  800421005b:	48 b8 3a 13 20 04 80 	movabs $0x800420133a,%rax
  8004210062:	00 00 00 
  8004210065:	ff d0                	callq  *%rax
			buf[i++] = c;
  8004210067:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421006a:	8d 50 01             	lea    0x1(%rax),%edx
  800421006d:	89 55 fc             	mov    %edx,-0x4(%rbp)
  8004210070:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004210073:	89 d1                	mov    %edx,%ecx
  8004210075:	48 ba a0 e2 49 04 80 	movabs $0x800449e2a0,%rdx
  800421007c:	00 00 00 
  800421007f:	48 98                	cltq   
  8004210081:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
  8004210084:	eb 42                	jmp    80042100c8 <readline+0x14e>
		} else if (c == '\n' || c == '\r') {
  8004210086:	83 7d f4 0a          	cmpl   $0xa,-0xc(%rbp)
  800421008a:	74 06                	je     8004210092 <readline+0x118>
  800421008c:	83 7d f4 0d          	cmpl   $0xd,-0xc(%rbp)
  8004210090:	75 36                	jne    80042100c8 <readline+0x14e>
			if (echoing)
  8004210092:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  8004210096:	74 11                	je     80042100a9 <readline+0x12f>
				cputchar('\n');
  8004210098:	bf 0a 00 00 00       	mov    $0xa,%edi
  800421009d:	48 b8 3a 13 20 04 80 	movabs $0x800420133a,%rax
  80042100a4:	00 00 00 
  80042100a7:	ff d0                	callq  *%rax
			buf[i] = 0;
  80042100a9:	48 ba a0 e2 49 04 80 	movabs $0x800449e2a0,%rdx
  80042100b0:	00 00 00 
  80042100b3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042100b6:	48 98                	cltq   
  80042100b8:	c6 04 02 00          	movb   $0x0,(%rdx,%rax,1)
			return buf;
  80042100bc:	48 b8 a0 e2 49 04 80 	movabs $0x800449e2a0,%rax
  80042100c3:	00 00 00 
  80042100c6:	eb 05                	jmp    80042100cd <readline+0x153>
		}
	}
  80042100c8:	e9 fd fe ff ff       	jmpq   800420ffca <readline+0x50>
}
  80042100cd:	c9                   	leaveq 
  80042100ce:	c3                   	retq   

00000080042100cf <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  80042100cf:	55                   	push   %rbp
  80042100d0:	48 89 e5             	mov    %rsp,%rbp
  80042100d3:	48 83 ec 18          	sub    $0x18,%rsp
  80042100d7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int n;

	for (n = 0; *s != '\0'; s++)
  80042100db:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042100e2:	eb 09                	jmp    80042100ed <strlen+0x1e>
		n++;
  80042100e4:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  80042100e8:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  80042100ed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042100f1:	0f b6 00             	movzbl (%rax),%eax
  80042100f4:	84 c0                	test   %al,%al
  80042100f6:	75 ec                	jne    80042100e4 <strlen+0x15>
		n++;
	return n;
  80042100f8:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80042100fb:	c9                   	leaveq 
  80042100fc:	c3                   	retq   

00000080042100fd <strnlen>:

int
strnlen(const char *s, size_t size)
{
  80042100fd:	55                   	push   %rbp
  80042100fe:	48 89 e5             	mov    %rsp,%rbp
  8004210101:	48 83 ec 20          	sub    $0x20,%rsp
  8004210105:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210109:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  800421010d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004210114:	eb 0e                	jmp    8004210124 <strnlen+0x27>
		n++;
  8004210116:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  800421011a:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800421011f:	48 83 6d e0 01       	subq   $0x1,-0x20(%rbp)
  8004210124:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004210129:	74 0b                	je     8004210136 <strnlen+0x39>
  800421012b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421012f:	0f b6 00             	movzbl (%rax),%eax
  8004210132:	84 c0                	test   %al,%al
  8004210134:	75 e0                	jne    8004210116 <strnlen+0x19>
		n++;
	return n;
  8004210136:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004210139:	c9                   	leaveq 
  800421013a:	c3                   	retq   

000000800421013b <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  800421013b:	55                   	push   %rbp
  800421013c:	48 89 e5             	mov    %rsp,%rbp
  800421013f:	48 83 ec 20          	sub    $0x20,%rsp
  8004210143:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210147:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	char *ret;

	ret = dst;
  800421014b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421014f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	while ((*dst++ = *src++) != '\0')
  8004210153:	90                   	nop
  8004210154:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210158:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800421015c:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004210160:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004210164:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  8004210168:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800421016c:	0f b6 12             	movzbl (%rdx),%edx
  800421016f:	88 10                	mov    %dl,(%rax)
  8004210171:	0f b6 00             	movzbl (%rax),%eax
  8004210174:	84 c0                	test   %al,%al
  8004210176:	75 dc                	jne    8004210154 <strcpy+0x19>
		/* do nothing */;
	return ret;
  8004210178:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800421017c:	c9                   	leaveq 
  800421017d:	c3                   	retq   

000000800421017e <strcat>:

char *
strcat(char *dst, const char *src)
{
  800421017e:	55                   	push   %rbp
  800421017f:	48 89 e5             	mov    %rsp,%rbp
  8004210182:	48 83 ec 20          	sub    $0x20,%rsp
  8004210186:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421018a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int len = strlen(dst);
  800421018e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210192:	48 89 c7             	mov    %rax,%rdi
  8004210195:	48 b8 cf 00 21 04 80 	movabs $0x80042100cf,%rax
  800421019c:	00 00 00 
  800421019f:	ff d0                	callq  *%rax
  80042101a1:	89 45 fc             	mov    %eax,-0x4(%rbp)
	strcpy(dst + len, src);
  80042101a4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042101a7:	48 63 d0             	movslq %eax,%rdx
  80042101aa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042101ae:	48 01 c2             	add    %rax,%rdx
  80042101b1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042101b5:	48 89 c6             	mov    %rax,%rsi
  80042101b8:	48 89 d7             	mov    %rdx,%rdi
  80042101bb:	48 b8 3b 01 21 04 80 	movabs $0x800421013b,%rax
  80042101c2:	00 00 00 
  80042101c5:	ff d0                	callq  *%rax
	return dst;
  80042101c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  80042101cb:	c9                   	leaveq 
  80042101cc:	c3                   	retq   

00000080042101cd <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  80042101cd:	55                   	push   %rbp
  80042101ce:	48 89 e5             	mov    %rsp,%rbp
  80042101d1:	48 83 ec 28          	sub    $0x28,%rsp
  80042101d5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042101d9:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042101dd:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	size_t i;
	char *ret;

	ret = dst;
  80042101e1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042101e5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < size; i++) {
  80042101e9:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042101f0:	00 
  80042101f1:	eb 2a                	jmp    800421021d <strncpy+0x50>
		*dst++ = *src;
  80042101f3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042101f7:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042101fb:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80042101ff:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004210203:	0f b6 12             	movzbl (%rdx),%edx
  8004210206:	88 10                	mov    %dl,(%rax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
  8004210208:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421020c:	0f b6 00             	movzbl (%rax),%eax
  800421020f:	84 c0                	test   %al,%al
  8004210211:	74 05                	je     8004210218 <strncpy+0x4b>
			src++;
  8004210213:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  8004210218:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800421021d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210221:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004210225:	72 cc                	jb     80042101f3 <strncpy+0x26>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
  8004210227:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800421022b:	c9                   	leaveq 
  800421022c:	c3                   	retq   

000000800421022d <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  800421022d:	55                   	push   %rbp
  800421022e:	48 89 e5             	mov    %rsp,%rbp
  8004210231:	48 83 ec 28          	sub    $0x28,%rsp
  8004210235:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210239:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800421023d:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *dst_in;

	dst_in = dst;
  8004210241:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210245:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (size > 0) {
  8004210249:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800421024e:	74 3d                	je     800421028d <strlcpy+0x60>
		while (--size > 0 && *src != '\0')
  8004210250:	eb 1d                	jmp    800421026f <strlcpy+0x42>
			*dst++ = *src++;
  8004210252:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210256:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800421025a:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800421025e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004210262:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  8004210266:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800421026a:	0f b6 12             	movzbl (%rdx),%edx
  800421026d:	88 10                	mov    %dl,(%rax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  800421026f:	48 83 6d d8 01       	subq   $0x1,-0x28(%rbp)
  8004210274:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004210279:	74 0b                	je     8004210286 <strlcpy+0x59>
  800421027b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421027f:	0f b6 00             	movzbl (%rax),%eax
  8004210282:	84 c0                	test   %al,%al
  8004210284:	75 cc                	jne    8004210252 <strlcpy+0x25>
			*dst++ = *src++;
		*dst = '\0';
  8004210286:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421028a:	c6 00 00             	movb   $0x0,(%rax)
	}
	return dst - dst_in;
  800421028d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210291:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210295:	48 29 c2             	sub    %rax,%rdx
  8004210298:	48 89 d0             	mov    %rdx,%rax
}
  800421029b:	c9                   	leaveq 
  800421029c:	c3                   	retq   

000000800421029d <strcmp>:

int
strcmp(const char *p, const char *q)
{
  800421029d:	55                   	push   %rbp
  800421029e:	48 89 e5             	mov    %rsp,%rbp
  80042102a1:	48 83 ec 10          	sub    $0x10,%rsp
  80042102a5:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80042102a9:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	while (*p && *p == *q)
  80042102ad:	eb 0a                	jmp    80042102b9 <strcmp+0x1c>
		p++, q++;
  80042102af:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  80042102b4:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  80042102b9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042102bd:	0f b6 00             	movzbl (%rax),%eax
  80042102c0:	84 c0                	test   %al,%al
  80042102c2:	74 12                	je     80042102d6 <strcmp+0x39>
  80042102c4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042102c8:	0f b6 10             	movzbl (%rax),%edx
  80042102cb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042102cf:	0f b6 00             	movzbl (%rax),%eax
  80042102d2:	38 c2                	cmp    %al,%dl
  80042102d4:	74 d9                	je     80042102af <strcmp+0x12>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
  80042102d6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042102da:	0f b6 00             	movzbl (%rax),%eax
  80042102dd:	0f b6 d0             	movzbl %al,%edx
  80042102e0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042102e4:	0f b6 00             	movzbl (%rax),%eax
  80042102e7:	0f b6 c0             	movzbl %al,%eax
  80042102ea:	29 c2                	sub    %eax,%edx
  80042102ec:	89 d0                	mov    %edx,%eax
}
  80042102ee:	c9                   	leaveq 
  80042102ef:	c3                   	retq   

00000080042102f0 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  80042102f0:	55                   	push   %rbp
  80042102f1:	48 89 e5             	mov    %rsp,%rbp
  80042102f4:	48 83 ec 18          	sub    $0x18,%rsp
  80042102f8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80042102fc:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8004210300:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	while (n > 0 && *p && *p == *q)
  8004210304:	eb 0f                	jmp    8004210315 <strncmp+0x25>
		n--, p++, q++;
  8004210306:	48 83 6d e8 01       	subq   $0x1,-0x18(%rbp)
  800421030b:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004210310:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  8004210315:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800421031a:	74 1d                	je     8004210339 <strncmp+0x49>
  800421031c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210320:	0f b6 00             	movzbl (%rax),%eax
  8004210323:	84 c0                	test   %al,%al
  8004210325:	74 12                	je     8004210339 <strncmp+0x49>
  8004210327:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421032b:	0f b6 10             	movzbl (%rax),%edx
  800421032e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210332:	0f b6 00             	movzbl (%rax),%eax
  8004210335:	38 c2                	cmp    %al,%dl
  8004210337:	74 cd                	je     8004210306 <strncmp+0x16>
		n--, p++, q++;
	if (n == 0)
  8004210339:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800421033e:	75 07                	jne    8004210347 <strncmp+0x57>
		return 0;
  8004210340:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210345:	eb 18                	jmp    800421035f <strncmp+0x6f>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  8004210347:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421034b:	0f b6 00             	movzbl (%rax),%eax
  800421034e:	0f b6 d0             	movzbl %al,%edx
  8004210351:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210355:	0f b6 00             	movzbl (%rax),%eax
  8004210358:	0f b6 c0             	movzbl %al,%eax
  800421035b:	29 c2                	sub    %eax,%edx
  800421035d:	89 d0                	mov    %edx,%eax
}
  800421035f:	c9                   	leaveq 
  8004210360:	c3                   	retq   

0000008004210361 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  8004210361:	55                   	push   %rbp
  8004210362:	48 89 e5             	mov    %rsp,%rbp
  8004210365:	48 83 ec 0c          	sub    $0xc,%rsp
  8004210369:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800421036d:	89 f0                	mov    %esi,%eax
  800421036f:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  8004210372:	eb 17                	jmp    800421038b <strchr+0x2a>
		if (*s == c)
  8004210374:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210378:	0f b6 00             	movzbl (%rax),%eax
  800421037b:	3a 45 f4             	cmp    -0xc(%rbp),%al
  800421037e:	75 06                	jne    8004210386 <strchr+0x25>
			return (char *) s;
  8004210380:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210384:	eb 15                	jmp    800421039b <strchr+0x3a>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  8004210386:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800421038b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421038f:	0f b6 00             	movzbl (%rax),%eax
  8004210392:	84 c0                	test   %al,%al
  8004210394:	75 de                	jne    8004210374 <strchr+0x13>
		if (*s == c)
			return (char *) s;
	return 0;
  8004210396:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421039b:	c9                   	leaveq 
  800421039c:	c3                   	retq   

000000800421039d <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  800421039d:	55                   	push   %rbp
  800421039e:	48 89 e5             	mov    %rsp,%rbp
  80042103a1:	48 83 ec 0c          	sub    $0xc,%rsp
  80042103a5:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80042103a9:	89 f0                	mov    %esi,%eax
  80042103ab:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  80042103ae:	eb 13                	jmp    80042103c3 <strfind+0x26>
		if (*s == c)
  80042103b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042103b4:	0f b6 00             	movzbl (%rax),%eax
  80042103b7:	3a 45 f4             	cmp    -0xc(%rbp),%al
  80042103ba:	75 02                	jne    80042103be <strfind+0x21>
			break;
  80042103bc:	eb 10                	jmp    80042103ce <strfind+0x31>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
  80042103be:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  80042103c3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042103c7:	0f b6 00             	movzbl (%rax),%eax
  80042103ca:	84 c0                	test   %al,%al
  80042103cc:	75 e2                	jne    80042103b0 <strfind+0x13>
		if (*s == c)
			break;
	return (char *) s;
  80042103ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80042103d2:	c9                   	leaveq 
  80042103d3:	c3                   	retq   

00000080042103d4 <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  80042103d4:	55                   	push   %rbp
  80042103d5:	48 89 e5             	mov    %rsp,%rbp
  80042103d8:	48 83 ec 18          	sub    $0x18,%rsp
  80042103dc:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80042103e0:	89 75 f4             	mov    %esi,-0xc(%rbp)
  80042103e3:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	char *p;

	if (n == 0)
  80042103e7:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042103ec:	75 06                	jne    80042103f4 <memset+0x20>
		return v;
  80042103ee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042103f2:	eb 69                	jmp    800421045d <memset+0x89>
	if ((int64_t)v%4 == 0 && n%4 == 0) {
  80042103f4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042103f8:	83 e0 03             	and    $0x3,%eax
  80042103fb:	48 85 c0             	test   %rax,%rax
  80042103fe:	75 48                	jne    8004210448 <memset+0x74>
  8004210400:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210404:	83 e0 03             	and    $0x3,%eax
  8004210407:	48 85 c0             	test   %rax,%rax
  800421040a:	75 3c                	jne    8004210448 <memset+0x74>
		c &= 0xFF;
  800421040c:	81 65 f4 ff 00 00 00 	andl   $0xff,-0xc(%rbp)
		c = (c<<24)|(c<<16)|(c<<8)|c;
  8004210413:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210416:	c1 e0 18             	shl    $0x18,%eax
  8004210419:	89 c2                	mov    %eax,%edx
  800421041b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421041e:	c1 e0 10             	shl    $0x10,%eax
  8004210421:	09 c2                	or     %eax,%edx
  8004210423:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210426:	c1 e0 08             	shl    $0x8,%eax
  8004210429:	09 d0                	or     %edx,%eax
  800421042b:	09 45 f4             	or     %eax,-0xc(%rbp)
		asm volatile("cld; rep stosl\n"
			     :: "D" (v), "a" (c), "c" (n/4)
  800421042e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210432:	48 c1 e8 02          	shr    $0x2,%rax
  8004210436:	48 89 c1             	mov    %rax,%rcx
	if (n == 0)
		return v;
	if ((int64_t)v%4 == 0 && n%4 == 0) {
		c &= 0xFF;
		c = (c<<24)|(c<<16)|(c<<8)|c;
		asm volatile("cld; rep stosl\n"
  8004210439:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421043d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210440:	48 89 d7             	mov    %rdx,%rdi
  8004210443:	fc                   	cld    
  8004210444:	f3 ab                	rep stos %eax,%es:(%rdi)
  8004210446:	eb 11                	jmp    8004210459 <memset+0x85>
			     :: "D" (v), "a" (c), "c" (n/4)
			     : "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  8004210448:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421044c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421044f:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004210453:	48 89 d7             	mov    %rdx,%rdi
  8004210456:	fc                   	cld    
  8004210457:	f3 aa                	rep stos %al,%es:(%rdi)
			     :: "D" (v), "a" (c), "c" (n)
			     : "cc", "memory");
	return v;
  8004210459:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800421045d:	c9                   	leaveq 
  800421045e:	c3                   	retq   

000000800421045f <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  800421045f:	55                   	push   %rbp
  8004210460:	48 89 e5             	mov    %rsp,%rbp
  8004210463:	48 83 ec 28          	sub    $0x28,%rsp
  8004210467:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421046b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800421046f:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const char *s;
	char *d;

	s = src;
  8004210473:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210477:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	d = dst;
  800421047b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421047f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (s < d && s + n > d) {
  8004210483:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210487:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  800421048b:	0f 83 88 00 00 00    	jae    8004210519 <memmove+0xba>
  8004210491:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210495:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004210499:	48 01 d0             	add    %rdx,%rax
  800421049c:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  80042104a0:	76 77                	jbe    8004210519 <memmove+0xba>
		s += n;
  80042104a2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042104a6:	48 01 45 f8          	add    %rax,-0x8(%rbp)
		d += n;
  80042104aa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042104ae:	48 01 45 f0          	add    %rax,-0x10(%rbp)
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  80042104b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042104b6:	83 e0 03             	and    $0x3,%eax
  80042104b9:	48 85 c0             	test   %rax,%rax
  80042104bc:	75 3b                	jne    80042104f9 <memmove+0x9a>
  80042104be:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042104c2:	83 e0 03             	and    $0x3,%eax
  80042104c5:	48 85 c0             	test   %rax,%rax
  80042104c8:	75 2f                	jne    80042104f9 <memmove+0x9a>
  80042104ca:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042104ce:	83 e0 03             	and    $0x3,%eax
  80042104d1:	48 85 c0             	test   %rax,%rax
  80042104d4:	75 23                	jne    80042104f9 <memmove+0x9a>
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  80042104d6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042104da:	48 83 e8 04          	sub    $0x4,%rax
  80042104de:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042104e2:	48 83 ea 04          	sub    $0x4,%rdx
  80042104e6:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042104ea:	48 c1 e9 02          	shr    $0x2,%rcx
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
  80042104ee:	48 89 c7             	mov    %rax,%rdi
  80042104f1:	48 89 d6             	mov    %rdx,%rsi
  80042104f4:	fd                   	std    
  80042104f5:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  80042104f7:	eb 1d                	jmp    8004210516 <memmove+0xb7>
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  80042104f9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042104fd:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  8004210501:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210505:	48 8d 70 ff          	lea    -0x1(%rax),%rsi
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  8004210509:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421050d:	48 89 d7             	mov    %rdx,%rdi
  8004210510:	48 89 c1             	mov    %rax,%rcx
  8004210513:	fd                   	std    
  8004210514:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  8004210516:	fc                   	cld    
  8004210517:	eb 57                	jmp    8004210570 <memmove+0x111>
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  8004210519:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421051d:	83 e0 03             	and    $0x3,%eax
  8004210520:	48 85 c0             	test   %rax,%rax
  8004210523:	75 36                	jne    800421055b <memmove+0xfc>
  8004210525:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210529:	83 e0 03             	and    $0x3,%eax
  800421052c:	48 85 c0             	test   %rax,%rax
  800421052f:	75 2a                	jne    800421055b <memmove+0xfc>
  8004210531:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210535:	83 e0 03             	and    $0x3,%eax
  8004210538:	48 85 c0             	test   %rax,%rax
  800421053b:	75 1e                	jne    800421055b <memmove+0xfc>
			asm volatile("cld; rep movsl\n"
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  800421053d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210541:	48 c1 e8 02          	shr    $0x2,%rax
  8004210545:	48 89 c1             	mov    %rax,%rcx
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("cld; rep movsl\n"
  8004210548:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421054c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004210550:	48 89 c7             	mov    %rax,%rdi
  8004210553:	48 89 d6             	mov    %rdx,%rsi
  8004210556:	fc                   	cld    
  8004210557:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  8004210559:	eb 15                	jmp    8004210570 <memmove+0x111>
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  800421055b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421055f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004210563:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004210567:	48 89 c7             	mov    %rax,%rdi
  800421056a:	48 89 d6             	mov    %rdx,%rsi
  800421056d:	fc                   	cld    
  800421056e:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
  8004210570:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  8004210574:	c9                   	leaveq 
  8004210575:	c3                   	retq   

0000008004210576 <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  8004210576:	55                   	push   %rbp
  8004210577:	48 89 e5             	mov    %rsp,%rbp
  800421057a:	48 83 ec 18          	sub    $0x18,%rsp
  800421057e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004210582:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8004210586:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return memmove(dst, src, n);
  800421058a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421058e:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  8004210592:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210596:	48 89 ce             	mov    %rcx,%rsi
  8004210599:	48 89 c7             	mov    %rax,%rdi
  800421059c:	48 b8 5f 04 21 04 80 	movabs $0x800421045f,%rax
  80042105a3:	00 00 00 
  80042105a6:	ff d0                	callq  *%rax
}
  80042105a8:	c9                   	leaveq 
  80042105a9:	c3                   	retq   

00000080042105aa <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  80042105aa:	55                   	push   %rbp
  80042105ab:	48 89 e5             	mov    %rsp,%rbp
  80042105ae:	48 83 ec 28          	sub    $0x28,%rsp
  80042105b2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042105b6:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042105ba:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const uint8_t *s1 = (const uint8_t *) v1;
  80042105be:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042105c2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	const uint8_t *s2 = (const uint8_t *) v2;
  80042105c6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042105ca:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (n-- > 0) {
  80042105ce:	eb 36                	jmp    8004210606 <memcmp+0x5c>
		if (*s1 != *s2)
  80042105d0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042105d4:	0f b6 10             	movzbl (%rax),%edx
  80042105d7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042105db:	0f b6 00             	movzbl (%rax),%eax
  80042105de:	38 c2                	cmp    %al,%dl
  80042105e0:	74 1a                	je     80042105fc <memcmp+0x52>
			return (int) *s1 - (int) *s2;
  80042105e2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042105e6:	0f b6 00             	movzbl (%rax),%eax
  80042105e9:	0f b6 d0             	movzbl %al,%edx
  80042105ec:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042105f0:	0f b6 00             	movzbl (%rax),%eax
  80042105f3:	0f b6 c0             	movzbl %al,%eax
  80042105f6:	29 c2                	sub    %eax,%edx
  80042105f8:	89 d0                	mov    %edx,%eax
  80042105fa:	eb 20                	jmp    800421061c <memcmp+0x72>
		s1++, s2++;
  80042105fc:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004210601:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  8004210606:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421060a:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800421060e:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004210612:	48 85 c0             	test   %rax,%rax
  8004210615:	75 b9                	jne    80042105d0 <memcmp+0x26>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
  8004210617:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421061c:	c9                   	leaveq 
  800421061d:	c3                   	retq   

000000800421061e <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  800421061e:	55                   	push   %rbp
  800421061f:	48 89 e5             	mov    %rsp,%rbp
  8004210622:	48 83 ec 28          	sub    $0x28,%rsp
  8004210626:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421062a:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  800421062d:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const void *ends = (const char *) s + n;
  8004210631:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210635:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210639:	48 01 d0             	add    %rdx,%rax
  800421063c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (; s < ends; s++)
  8004210640:	eb 15                	jmp    8004210657 <memfind+0x39>
		if (*(const unsigned char *) s == (unsigned char) c)
  8004210642:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210646:	0f b6 10             	movzbl (%rax),%edx
  8004210649:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421064c:	38 c2                	cmp    %al,%dl
  800421064e:	75 02                	jne    8004210652 <memfind+0x34>
			break;
  8004210650:	eb 0f                	jmp    8004210661 <memfind+0x43>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  8004210652:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  8004210657:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421065b:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800421065f:	72 e1                	jb     8004210642 <memfind+0x24>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
	return (void *) s;
  8004210661:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  8004210665:	c9                   	leaveq 
  8004210666:	c3                   	retq   

0000008004210667 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  8004210667:	55                   	push   %rbp
  8004210668:	48 89 e5             	mov    %rsp,%rbp
  800421066b:	48 83 ec 34          	sub    $0x34,%rsp
  800421066f:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004210673:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004210677:	89 55 cc             	mov    %edx,-0x34(%rbp)
	int neg = 0;
  800421067a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	long val = 0;
  8004210681:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004210688:	00 

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  8004210689:	eb 05                	jmp    8004210690 <strtol+0x29>
		s++;
  800421068b:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  8004210690:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210694:	0f b6 00             	movzbl (%rax),%eax
  8004210697:	3c 20                	cmp    $0x20,%al
  8004210699:	74 f0                	je     800421068b <strtol+0x24>
  800421069b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421069f:	0f b6 00             	movzbl (%rax),%eax
  80042106a2:	3c 09                	cmp    $0x9,%al
  80042106a4:	74 e5                	je     800421068b <strtol+0x24>
		s++;

	// plus/minus sign
	if (*s == '+')
  80042106a6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042106aa:	0f b6 00             	movzbl (%rax),%eax
  80042106ad:	3c 2b                	cmp    $0x2b,%al
  80042106af:	75 07                	jne    80042106b8 <strtol+0x51>
		s++;
  80042106b1:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  80042106b6:	eb 17                	jmp    80042106cf <strtol+0x68>
	else if (*s == '-')
  80042106b8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042106bc:	0f b6 00             	movzbl (%rax),%eax
  80042106bf:	3c 2d                	cmp    $0x2d,%al
  80042106c1:	75 0c                	jne    80042106cf <strtol+0x68>
		s++, neg = 1;
  80042106c3:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  80042106c8:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80042106cf:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  80042106d3:	74 06                	je     80042106db <strtol+0x74>
  80042106d5:	83 7d cc 10          	cmpl   $0x10,-0x34(%rbp)
  80042106d9:	75 28                	jne    8004210703 <strtol+0x9c>
  80042106db:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042106df:	0f b6 00             	movzbl (%rax),%eax
  80042106e2:	3c 30                	cmp    $0x30,%al
  80042106e4:	75 1d                	jne    8004210703 <strtol+0x9c>
  80042106e6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042106ea:	48 83 c0 01          	add    $0x1,%rax
  80042106ee:	0f b6 00             	movzbl (%rax),%eax
  80042106f1:	3c 78                	cmp    $0x78,%al
  80042106f3:	75 0e                	jne    8004210703 <strtol+0x9c>
		s += 2, base = 16;
  80042106f5:	48 83 45 d8 02       	addq   $0x2,-0x28(%rbp)
  80042106fa:	c7 45 cc 10 00 00 00 	movl   $0x10,-0x34(%rbp)
  8004210701:	eb 2c                	jmp    800421072f <strtol+0xc8>
	else if (base == 0 && s[0] == '0')
  8004210703:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  8004210707:	75 19                	jne    8004210722 <strtol+0xbb>
  8004210709:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421070d:	0f b6 00             	movzbl (%rax),%eax
  8004210710:	3c 30                	cmp    $0x30,%al
  8004210712:	75 0e                	jne    8004210722 <strtol+0xbb>
		s++, base = 8;
  8004210714:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  8004210719:	c7 45 cc 08 00 00 00 	movl   $0x8,-0x34(%rbp)
  8004210720:	eb 0d                	jmp    800421072f <strtol+0xc8>
	else if (base == 0)
  8004210722:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  8004210726:	75 07                	jne    800421072f <strtol+0xc8>
		base = 10;
  8004210728:	c7 45 cc 0a 00 00 00 	movl   $0xa,-0x34(%rbp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  800421072f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210733:	0f b6 00             	movzbl (%rax),%eax
  8004210736:	3c 2f                	cmp    $0x2f,%al
  8004210738:	7e 1d                	jle    8004210757 <strtol+0xf0>
  800421073a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421073e:	0f b6 00             	movzbl (%rax),%eax
  8004210741:	3c 39                	cmp    $0x39,%al
  8004210743:	7f 12                	jg     8004210757 <strtol+0xf0>
			dig = *s - '0';
  8004210745:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210749:	0f b6 00             	movzbl (%rax),%eax
  800421074c:	0f be c0             	movsbl %al,%eax
  800421074f:	83 e8 30             	sub    $0x30,%eax
  8004210752:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004210755:	eb 4e                	jmp    80042107a5 <strtol+0x13e>
		else if (*s >= 'a' && *s <= 'z')
  8004210757:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421075b:	0f b6 00             	movzbl (%rax),%eax
  800421075e:	3c 60                	cmp    $0x60,%al
  8004210760:	7e 1d                	jle    800421077f <strtol+0x118>
  8004210762:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210766:	0f b6 00             	movzbl (%rax),%eax
  8004210769:	3c 7a                	cmp    $0x7a,%al
  800421076b:	7f 12                	jg     800421077f <strtol+0x118>
			dig = *s - 'a' + 10;
  800421076d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210771:	0f b6 00             	movzbl (%rax),%eax
  8004210774:	0f be c0             	movsbl %al,%eax
  8004210777:	83 e8 57             	sub    $0x57,%eax
  800421077a:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800421077d:	eb 26                	jmp    80042107a5 <strtol+0x13e>
		else if (*s >= 'A' && *s <= 'Z')
  800421077f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210783:	0f b6 00             	movzbl (%rax),%eax
  8004210786:	3c 40                	cmp    $0x40,%al
  8004210788:	7e 48                	jle    80042107d2 <strtol+0x16b>
  800421078a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421078e:	0f b6 00             	movzbl (%rax),%eax
  8004210791:	3c 5a                	cmp    $0x5a,%al
  8004210793:	7f 3d                	jg     80042107d2 <strtol+0x16b>
			dig = *s - 'A' + 10;
  8004210795:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210799:	0f b6 00             	movzbl (%rax),%eax
  800421079c:	0f be c0             	movsbl %al,%eax
  800421079f:	83 e8 37             	sub    $0x37,%eax
  80042107a2:	89 45 ec             	mov    %eax,-0x14(%rbp)
		else
			break;
		if (dig >= base)
  80042107a5:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042107a8:	3b 45 cc             	cmp    -0x34(%rbp),%eax
  80042107ab:	7c 02                	jl     80042107af <strtol+0x148>
			break;
  80042107ad:	eb 23                	jmp    80042107d2 <strtol+0x16b>
		s++, val = (val * base) + dig;
  80042107af:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  80042107b4:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80042107b7:	48 98                	cltq   
  80042107b9:	48 0f af 45 f0       	imul   -0x10(%rbp),%rax
  80042107be:	48 89 c2             	mov    %rax,%rdx
  80042107c1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042107c4:	48 98                	cltq   
  80042107c6:	48 01 d0             	add    %rdx,%rax
  80042107c9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		// we don't properly detect overflow!
	}
  80042107cd:	e9 5d ff ff ff       	jmpq   800421072f <strtol+0xc8>

	if (endptr)
  80042107d2:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80042107d7:	74 0b                	je     80042107e4 <strtol+0x17d>
		*endptr = (char *) s;
  80042107d9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042107dd:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042107e1:	48 89 10             	mov    %rdx,(%rax)
	return (neg ? -val : val);
  80042107e4:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042107e8:	74 09                	je     80042107f3 <strtol+0x18c>
  80042107ea:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042107ee:	48 f7 d8             	neg    %rax
  80042107f1:	eb 04                	jmp    80042107f7 <strtol+0x190>
  80042107f3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  80042107f7:	c9                   	leaveq 
  80042107f8:	c3                   	retq   

00000080042107f9 <strstr>:

char * strstr(const char *in, const char *str)
{
  80042107f9:	55                   	push   %rbp
  80042107fa:	48 89 e5             	mov    %rsp,%rbp
  80042107fd:	48 83 ec 30          	sub    $0x30,%rsp
  8004210801:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004210805:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	char c;
	size_t len;

	c = *str++;
  8004210809:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421080d:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210811:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  8004210815:	0f b6 00             	movzbl (%rax),%eax
  8004210818:	88 45 ff             	mov    %al,-0x1(%rbp)
	if (!c)
  800421081b:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  800421081f:	75 06                	jne    8004210827 <strstr+0x2e>
		return (char *) in;	// Trivial empty string case
  8004210821:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210825:	eb 6b                	jmp    8004210892 <strstr+0x99>

	len = strlen(str);
  8004210827:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421082b:	48 89 c7             	mov    %rax,%rdi
  800421082e:	48 b8 cf 00 21 04 80 	movabs $0x80042100cf,%rax
  8004210835:	00 00 00 
  8004210838:	ff d0                	callq  *%rax
  800421083a:	48 98                	cltq   
  800421083c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	do {
		char sc;

		do {
			sc = *in++;
  8004210840:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210844:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210848:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800421084c:	0f b6 00             	movzbl (%rax),%eax
  800421084f:	88 45 ef             	mov    %al,-0x11(%rbp)
			if (!sc)
  8004210852:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  8004210856:	75 07                	jne    800421085f <strstr+0x66>
				return (char *) 0;
  8004210858:	b8 00 00 00 00       	mov    $0x0,%eax
  800421085d:	eb 33                	jmp    8004210892 <strstr+0x99>
		} while (sc != c);
  800421085f:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8004210863:	3a 45 ff             	cmp    -0x1(%rbp),%al
  8004210866:	75 d8                	jne    8004210840 <strstr+0x47>
	} while (strncmp(in, str, len) != 0);
  8004210868:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421086c:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  8004210870:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210874:	48 89 ce             	mov    %rcx,%rsi
  8004210877:	48 89 c7             	mov    %rax,%rdi
  800421087a:	48 b8 f0 02 21 04 80 	movabs $0x80042102f0,%rax
  8004210881:	00 00 00 
  8004210884:	ff d0                	callq  *%rax
  8004210886:	85 c0                	test   %eax,%eax
  8004210888:	75 b6                	jne    8004210840 <strstr+0x47>

	return (char *) (in - 1);
  800421088a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421088e:	48 83 e8 01          	sub    $0x1,%rax
}
  8004210892:	c9                   	leaveq 
  8004210893:	c3                   	retq   

0000008004210894 <_dwarf_read_lsb>:
Dwarf_Section *
_dwarf_find_section(const char *name);

uint64_t
_dwarf_read_lsb(uint8_t *data, uint64_t *offsetp, int bytes_to_read)
{
  8004210894:	55                   	push   %rbp
  8004210895:	48 89 e5             	mov    %rsp,%rbp
  8004210898:	48 83 ec 24          	sub    $0x24,%rsp
  800421089c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042108a0:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042108a4:	89 55 dc             	mov    %edx,-0x24(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = data + *offsetp;
  80042108a7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042108ab:	48 8b 10             	mov    (%rax),%rdx
  80042108ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042108b2:	48 01 d0             	add    %rdx,%rax
  80042108b5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  80042108b9:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042108c0:	00 
	switch (bytes_to_read) {
  80042108c1:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042108c4:	83 f8 02             	cmp    $0x2,%eax
  80042108c7:	0f 84 ab 00 00 00    	je     8004210978 <_dwarf_read_lsb+0xe4>
  80042108cd:	83 f8 02             	cmp    $0x2,%eax
  80042108d0:	7f 0e                	jg     80042108e0 <_dwarf_read_lsb+0x4c>
  80042108d2:	83 f8 01             	cmp    $0x1,%eax
  80042108d5:	0f 84 b3 00 00 00    	je     800421098e <_dwarf_read_lsb+0xfa>
  80042108db:	e9 d9 00 00 00       	jmpq   80042109b9 <_dwarf_read_lsb+0x125>
  80042108e0:	83 f8 04             	cmp    $0x4,%eax
  80042108e3:	74 65                	je     800421094a <_dwarf_read_lsb+0xb6>
  80042108e5:	83 f8 08             	cmp    $0x8,%eax
  80042108e8:	0f 85 cb 00 00 00    	jne    80042109b9 <_dwarf_read_lsb+0x125>
	case 8:
		ret |= ((uint64_t) src[4]) << 32 | ((uint64_t) src[5]) << 40;
  80042108ee:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042108f2:	48 83 c0 04          	add    $0x4,%rax
  80042108f6:	0f b6 00             	movzbl (%rax),%eax
  80042108f9:	0f b6 c0             	movzbl %al,%eax
  80042108fc:	48 c1 e0 20          	shl    $0x20,%rax
  8004210900:	48 89 c2             	mov    %rax,%rdx
  8004210903:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210907:	48 83 c0 05          	add    $0x5,%rax
  800421090b:	0f b6 00             	movzbl (%rax),%eax
  800421090e:	0f b6 c0             	movzbl %al,%eax
  8004210911:	48 c1 e0 28          	shl    $0x28,%rax
  8004210915:	48 09 d0             	or     %rdx,%rax
  8004210918:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[6]) << 48 | ((uint64_t) src[7]) << 56;
  800421091c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210920:	48 83 c0 06          	add    $0x6,%rax
  8004210924:	0f b6 00             	movzbl (%rax),%eax
  8004210927:	0f b6 c0             	movzbl %al,%eax
  800421092a:	48 c1 e0 30          	shl    $0x30,%rax
  800421092e:	48 89 c2             	mov    %rax,%rdx
  8004210931:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210935:	48 83 c0 07          	add    $0x7,%rax
  8004210939:	0f b6 00             	movzbl (%rax),%eax
  800421093c:	0f b6 c0             	movzbl %al,%eax
  800421093f:	48 c1 e0 38          	shl    $0x38,%rax
  8004210943:	48 09 d0             	or     %rdx,%rax
  8004210946:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 4:
		ret |= ((uint64_t) src[2]) << 16 | ((uint64_t) src[3]) << 24;
  800421094a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421094e:	48 83 c0 02          	add    $0x2,%rax
  8004210952:	0f b6 00             	movzbl (%rax),%eax
  8004210955:	0f b6 c0             	movzbl %al,%eax
  8004210958:	48 c1 e0 10          	shl    $0x10,%rax
  800421095c:	48 89 c2             	mov    %rax,%rdx
  800421095f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210963:	48 83 c0 03          	add    $0x3,%rax
  8004210967:	0f b6 00             	movzbl (%rax),%eax
  800421096a:	0f b6 c0             	movzbl %al,%eax
  800421096d:	48 c1 e0 18          	shl    $0x18,%rax
  8004210971:	48 09 d0             	or     %rdx,%rax
  8004210974:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 2:
		ret |= ((uint64_t) src[1]) << 8;
  8004210978:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421097c:	48 83 c0 01          	add    $0x1,%rax
  8004210980:	0f b6 00             	movzbl (%rax),%eax
  8004210983:	0f b6 c0             	movzbl %al,%eax
  8004210986:	48 c1 e0 08          	shl    $0x8,%rax
  800421098a:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 1:
		ret |= src[0];
  800421098e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210992:	0f b6 00             	movzbl (%rax),%eax
  8004210995:	0f b6 c0             	movzbl %al,%eax
  8004210998:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800421099c:	90                   	nop
	default:
		return (0);
	}

	*offsetp += bytes_to_read;
  800421099d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042109a1:	48 8b 10             	mov    (%rax),%rdx
  80042109a4:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042109a7:	48 98                	cltq   
  80042109a9:	48 01 c2             	add    %rax,%rdx
  80042109ac:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042109b0:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  80042109b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042109b7:	eb 05                	jmp    80042109be <_dwarf_read_lsb+0x12a>
		ret |= ((uint64_t) src[1]) << 8;
	case 1:
		ret |= src[0];
		break;
	default:
		return (0);
  80042109b9:	b8 00 00 00 00       	mov    $0x0,%eax
	}

	*offsetp += bytes_to_read;

	return (ret);
}
  80042109be:	c9                   	leaveq 
  80042109bf:	c3                   	retq   

00000080042109c0 <_dwarf_decode_lsb>:

uint64_t
_dwarf_decode_lsb(uint8_t **data, int bytes_to_read)
{
  80042109c0:	55                   	push   %rbp
  80042109c1:	48 89 e5             	mov    %rsp,%rbp
  80042109c4:	48 83 ec 1c          	sub    $0x1c,%rsp
  80042109c8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042109cc:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = *data;
  80042109cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042109d3:	48 8b 00             	mov    (%rax),%rax
  80042109d6:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  80042109da:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042109e1:	00 
	switch (bytes_to_read) {
  80042109e2:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042109e5:	83 f8 02             	cmp    $0x2,%eax
  80042109e8:	0f 84 ab 00 00 00    	je     8004210a99 <_dwarf_decode_lsb+0xd9>
  80042109ee:	83 f8 02             	cmp    $0x2,%eax
  80042109f1:	7f 0e                	jg     8004210a01 <_dwarf_decode_lsb+0x41>
  80042109f3:	83 f8 01             	cmp    $0x1,%eax
  80042109f6:	0f 84 b3 00 00 00    	je     8004210aaf <_dwarf_decode_lsb+0xef>
  80042109fc:	e9 d9 00 00 00       	jmpq   8004210ada <_dwarf_decode_lsb+0x11a>
  8004210a01:	83 f8 04             	cmp    $0x4,%eax
  8004210a04:	74 65                	je     8004210a6b <_dwarf_decode_lsb+0xab>
  8004210a06:	83 f8 08             	cmp    $0x8,%eax
  8004210a09:	0f 85 cb 00 00 00    	jne    8004210ada <_dwarf_decode_lsb+0x11a>
	case 8:
		ret |= ((uint64_t) src[4]) << 32 | ((uint64_t) src[5]) << 40;
  8004210a0f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210a13:	48 83 c0 04          	add    $0x4,%rax
  8004210a17:	0f b6 00             	movzbl (%rax),%eax
  8004210a1a:	0f b6 c0             	movzbl %al,%eax
  8004210a1d:	48 c1 e0 20          	shl    $0x20,%rax
  8004210a21:	48 89 c2             	mov    %rax,%rdx
  8004210a24:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210a28:	48 83 c0 05          	add    $0x5,%rax
  8004210a2c:	0f b6 00             	movzbl (%rax),%eax
  8004210a2f:	0f b6 c0             	movzbl %al,%eax
  8004210a32:	48 c1 e0 28          	shl    $0x28,%rax
  8004210a36:	48 09 d0             	or     %rdx,%rax
  8004210a39:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[6]) << 48 | ((uint64_t) src[7]) << 56;
  8004210a3d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210a41:	48 83 c0 06          	add    $0x6,%rax
  8004210a45:	0f b6 00             	movzbl (%rax),%eax
  8004210a48:	0f b6 c0             	movzbl %al,%eax
  8004210a4b:	48 c1 e0 30          	shl    $0x30,%rax
  8004210a4f:	48 89 c2             	mov    %rax,%rdx
  8004210a52:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210a56:	48 83 c0 07          	add    $0x7,%rax
  8004210a5a:	0f b6 00             	movzbl (%rax),%eax
  8004210a5d:	0f b6 c0             	movzbl %al,%eax
  8004210a60:	48 c1 e0 38          	shl    $0x38,%rax
  8004210a64:	48 09 d0             	or     %rdx,%rax
  8004210a67:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 4:
		ret |= ((uint64_t) src[2]) << 16 | ((uint64_t) src[3]) << 24;
  8004210a6b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210a6f:	48 83 c0 02          	add    $0x2,%rax
  8004210a73:	0f b6 00             	movzbl (%rax),%eax
  8004210a76:	0f b6 c0             	movzbl %al,%eax
  8004210a79:	48 c1 e0 10          	shl    $0x10,%rax
  8004210a7d:	48 89 c2             	mov    %rax,%rdx
  8004210a80:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210a84:	48 83 c0 03          	add    $0x3,%rax
  8004210a88:	0f b6 00             	movzbl (%rax),%eax
  8004210a8b:	0f b6 c0             	movzbl %al,%eax
  8004210a8e:	48 c1 e0 18          	shl    $0x18,%rax
  8004210a92:	48 09 d0             	or     %rdx,%rax
  8004210a95:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 2:
		ret |= ((uint64_t) src[1]) << 8;
  8004210a99:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210a9d:	48 83 c0 01          	add    $0x1,%rax
  8004210aa1:	0f b6 00             	movzbl (%rax),%eax
  8004210aa4:	0f b6 c0             	movzbl %al,%eax
  8004210aa7:	48 c1 e0 08          	shl    $0x8,%rax
  8004210aab:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 1:
		ret |= src[0];
  8004210aaf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210ab3:	0f b6 00             	movzbl (%rax),%eax
  8004210ab6:	0f b6 c0             	movzbl %al,%eax
  8004210ab9:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  8004210abd:	90                   	nop
	default:
		return (0);
	}

	*data += bytes_to_read;
  8004210abe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210ac2:	48 8b 10             	mov    (%rax),%rdx
  8004210ac5:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004210ac8:	48 98                	cltq   
  8004210aca:	48 01 c2             	add    %rax,%rdx
  8004210acd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210ad1:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  8004210ad4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210ad8:	eb 05                	jmp    8004210adf <_dwarf_decode_lsb+0x11f>
		ret |= ((uint64_t) src[1]) << 8;
	case 1:
		ret |= src[0];
		break;
	default:
		return (0);
  8004210ada:	b8 00 00 00 00       	mov    $0x0,%eax
	}

	*data += bytes_to_read;

	return (ret);
}
  8004210adf:	c9                   	leaveq 
  8004210ae0:	c3                   	retq   

0000008004210ae1 <_dwarf_read_msb>:

uint64_t
_dwarf_read_msb(uint8_t *data, uint64_t *offsetp, int bytes_to_read)
{
  8004210ae1:	55                   	push   %rbp
  8004210ae2:	48 89 e5             	mov    %rsp,%rbp
  8004210ae5:	48 83 ec 24          	sub    $0x24,%rsp
  8004210ae9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210aed:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004210af1:	89 55 dc             	mov    %edx,-0x24(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = data + *offsetp;
  8004210af4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210af8:	48 8b 10             	mov    (%rax),%rdx
  8004210afb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210aff:	48 01 d0             	add    %rdx,%rax
  8004210b02:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	switch (bytes_to_read) {
  8004210b06:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004210b09:	83 f8 02             	cmp    $0x2,%eax
  8004210b0c:	74 35                	je     8004210b43 <_dwarf_read_msb+0x62>
  8004210b0e:	83 f8 02             	cmp    $0x2,%eax
  8004210b11:	7f 0a                	jg     8004210b1d <_dwarf_read_msb+0x3c>
  8004210b13:	83 f8 01             	cmp    $0x1,%eax
  8004210b16:	74 18                	je     8004210b30 <_dwarf_read_msb+0x4f>
  8004210b18:	e9 53 01 00 00       	jmpq   8004210c70 <_dwarf_read_msb+0x18f>
  8004210b1d:	83 f8 04             	cmp    $0x4,%eax
  8004210b20:	74 49                	je     8004210b6b <_dwarf_read_msb+0x8a>
  8004210b22:	83 f8 08             	cmp    $0x8,%eax
  8004210b25:	0f 84 96 00 00 00    	je     8004210bc1 <_dwarf_read_msb+0xe0>
  8004210b2b:	e9 40 01 00 00       	jmpq   8004210c70 <_dwarf_read_msb+0x18f>
	case 1:
		ret = src[0];
  8004210b30:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210b34:	0f b6 00             	movzbl (%rax),%eax
  8004210b37:	0f b6 c0             	movzbl %al,%eax
  8004210b3a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  8004210b3e:	e9 34 01 00 00       	jmpq   8004210c77 <_dwarf_read_msb+0x196>
	case 2:
		ret = src[1] | ((uint64_t) src[0]) << 8;
  8004210b43:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210b47:	48 83 c0 01          	add    $0x1,%rax
  8004210b4b:	0f b6 00             	movzbl (%rax),%eax
  8004210b4e:	0f b6 d0             	movzbl %al,%edx
  8004210b51:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210b55:	0f b6 00             	movzbl (%rax),%eax
  8004210b58:	0f b6 c0             	movzbl %al,%eax
  8004210b5b:	48 c1 e0 08          	shl    $0x8,%rax
  8004210b5f:	48 09 d0             	or     %rdx,%rax
  8004210b62:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  8004210b66:	e9 0c 01 00 00       	jmpq   8004210c77 <_dwarf_read_msb+0x196>
	case 4:
		ret = src[3] | ((uint64_t) src[2]) << 8;
  8004210b6b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210b6f:	48 83 c0 03          	add    $0x3,%rax
  8004210b73:	0f b6 00             	movzbl (%rax),%eax
  8004210b76:	0f b6 c0             	movzbl %al,%eax
  8004210b79:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004210b7d:	48 83 c2 02          	add    $0x2,%rdx
  8004210b81:	0f b6 12             	movzbl (%rdx),%edx
  8004210b84:	0f b6 d2             	movzbl %dl,%edx
  8004210b87:	48 c1 e2 08          	shl    $0x8,%rdx
  8004210b8b:	48 09 d0             	or     %rdx,%rax
  8004210b8e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 16 | ((uint64_t) src[0]) << 24;
  8004210b92:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210b96:	48 83 c0 01          	add    $0x1,%rax
  8004210b9a:	0f b6 00             	movzbl (%rax),%eax
  8004210b9d:	0f b6 c0             	movzbl %al,%eax
  8004210ba0:	48 c1 e0 10          	shl    $0x10,%rax
  8004210ba4:	48 89 c2             	mov    %rax,%rdx
  8004210ba7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210bab:	0f b6 00             	movzbl (%rax),%eax
  8004210bae:	0f b6 c0             	movzbl %al,%eax
  8004210bb1:	48 c1 e0 18          	shl    $0x18,%rax
  8004210bb5:	48 09 d0             	or     %rdx,%rax
  8004210bb8:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  8004210bbc:	e9 b6 00 00 00       	jmpq   8004210c77 <_dwarf_read_msb+0x196>
	case 8:
		ret = src[7] | ((uint64_t) src[6]) << 8;
  8004210bc1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210bc5:	48 83 c0 07          	add    $0x7,%rax
  8004210bc9:	0f b6 00             	movzbl (%rax),%eax
  8004210bcc:	0f b6 c0             	movzbl %al,%eax
  8004210bcf:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004210bd3:	48 83 c2 06          	add    $0x6,%rdx
  8004210bd7:	0f b6 12             	movzbl (%rdx),%edx
  8004210bda:	0f b6 d2             	movzbl %dl,%edx
  8004210bdd:	48 c1 e2 08          	shl    $0x8,%rdx
  8004210be1:	48 09 d0             	or     %rdx,%rax
  8004210be4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[5]) << 16 | ((uint64_t) src[4]) << 24;
  8004210be8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210bec:	48 83 c0 05          	add    $0x5,%rax
  8004210bf0:	0f b6 00             	movzbl (%rax),%eax
  8004210bf3:	0f b6 c0             	movzbl %al,%eax
  8004210bf6:	48 c1 e0 10          	shl    $0x10,%rax
  8004210bfa:	48 89 c2             	mov    %rax,%rdx
  8004210bfd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210c01:	48 83 c0 04          	add    $0x4,%rax
  8004210c05:	0f b6 00             	movzbl (%rax),%eax
  8004210c08:	0f b6 c0             	movzbl %al,%eax
  8004210c0b:	48 c1 e0 18          	shl    $0x18,%rax
  8004210c0f:	48 09 d0             	or     %rdx,%rax
  8004210c12:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[3]) << 32 | ((uint64_t) src[2]) << 40;
  8004210c16:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210c1a:	48 83 c0 03          	add    $0x3,%rax
  8004210c1e:	0f b6 00             	movzbl (%rax),%eax
  8004210c21:	0f b6 c0             	movzbl %al,%eax
  8004210c24:	48 c1 e0 20          	shl    $0x20,%rax
  8004210c28:	48 89 c2             	mov    %rax,%rdx
  8004210c2b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210c2f:	48 83 c0 02          	add    $0x2,%rax
  8004210c33:	0f b6 00             	movzbl (%rax),%eax
  8004210c36:	0f b6 c0             	movzbl %al,%eax
  8004210c39:	48 c1 e0 28          	shl    $0x28,%rax
  8004210c3d:	48 09 d0             	or     %rdx,%rax
  8004210c40:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 48 | ((uint64_t) src[0]) << 56;
  8004210c44:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210c48:	48 83 c0 01          	add    $0x1,%rax
  8004210c4c:	0f b6 00             	movzbl (%rax),%eax
  8004210c4f:	0f b6 c0             	movzbl %al,%eax
  8004210c52:	48 c1 e0 30          	shl    $0x30,%rax
  8004210c56:	48 89 c2             	mov    %rax,%rdx
  8004210c59:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210c5d:	0f b6 00             	movzbl (%rax),%eax
  8004210c60:	0f b6 c0             	movzbl %al,%eax
  8004210c63:	48 c1 e0 38          	shl    $0x38,%rax
  8004210c67:	48 09 d0             	or     %rdx,%rax
  8004210c6a:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  8004210c6e:	eb 07                	jmp    8004210c77 <_dwarf_read_msb+0x196>
	default:
		return (0);
  8004210c70:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210c75:	eb 1a                	jmp    8004210c91 <_dwarf_read_msb+0x1b0>
	}

	*offsetp += bytes_to_read;
  8004210c77:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210c7b:	48 8b 10             	mov    (%rax),%rdx
  8004210c7e:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004210c81:	48 98                	cltq   
  8004210c83:	48 01 c2             	add    %rax,%rdx
  8004210c86:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210c8a:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  8004210c8d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004210c91:	c9                   	leaveq 
  8004210c92:	c3                   	retq   

0000008004210c93 <_dwarf_decode_msb>:

uint64_t
_dwarf_decode_msb(uint8_t **data, int bytes_to_read)
{
  8004210c93:	55                   	push   %rbp
  8004210c94:	48 89 e5             	mov    %rsp,%rbp
  8004210c97:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004210c9b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210c9f:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = *data;
  8004210ca2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210ca6:	48 8b 00             	mov    (%rax),%rax
  8004210ca9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  8004210cad:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004210cb4:	00 
	switch (bytes_to_read) {
  8004210cb5:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004210cb8:	83 f8 02             	cmp    $0x2,%eax
  8004210cbb:	74 35                	je     8004210cf2 <_dwarf_decode_msb+0x5f>
  8004210cbd:	83 f8 02             	cmp    $0x2,%eax
  8004210cc0:	7f 0a                	jg     8004210ccc <_dwarf_decode_msb+0x39>
  8004210cc2:	83 f8 01             	cmp    $0x1,%eax
  8004210cc5:	74 18                	je     8004210cdf <_dwarf_decode_msb+0x4c>
  8004210cc7:	e9 53 01 00 00       	jmpq   8004210e1f <_dwarf_decode_msb+0x18c>
  8004210ccc:	83 f8 04             	cmp    $0x4,%eax
  8004210ccf:	74 49                	je     8004210d1a <_dwarf_decode_msb+0x87>
  8004210cd1:	83 f8 08             	cmp    $0x8,%eax
  8004210cd4:	0f 84 96 00 00 00    	je     8004210d70 <_dwarf_decode_msb+0xdd>
  8004210cda:	e9 40 01 00 00       	jmpq   8004210e1f <_dwarf_decode_msb+0x18c>
	case 1:
		ret = src[0];
  8004210cdf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210ce3:	0f b6 00             	movzbl (%rax),%eax
  8004210ce6:	0f b6 c0             	movzbl %al,%eax
  8004210ce9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  8004210ced:	e9 34 01 00 00       	jmpq   8004210e26 <_dwarf_decode_msb+0x193>
	case 2:
		ret = src[1] | ((uint64_t) src[0]) << 8;
  8004210cf2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210cf6:	48 83 c0 01          	add    $0x1,%rax
  8004210cfa:	0f b6 00             	movzbl (%rax),%eax
  8004210cfd:	0f b6 d0             	movzbl %al,%edx
  8004210d00:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210d04:	0f b6 00             	movzbl (%rax),%eax
  8004210d07:	0f b6 c0             	movzbl %al,%eax
  8004210d0a:	48 c1 e0 08          	shl    $0x8,%rax
  8004210d0e:	48 09 d0             	or     %rdx,%rax
  8004210d11:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  8004210d15:	e9 0c 01 00 00       	jmpq   8004210e26 <_dwarf_decode_msb+0x193>
	case 4:
		ret = src[3] | ((uint64_t) src[2]) << 8;
  8004210d1a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210d1e:	48 83 c0 03          	add    $0x3,%rax
  8004210d22:	0f b6 00             	movzbl (%rax),%eax
  8004210d25:	0f b6 c0             	movzbl %al,%eax
  8004210d28:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004210d2c:	48 83 c2 02          	add    $0x2,%rdx
  8004210d30:	0f b6 12             	movzbl (%rdx),%edx
  8004210d33:	0f b6 d2             	movzbl %dl,%edx
  8004210d36:	48 c1 e2 08          	shl    $0x8,%rdx
  8004210d3a:	48 09 d0             	or     %rdx,%rax
  8004210d3d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 16 | ((uint64_t) src[0]) << 24;
  8004210d41:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210d45:	48 83 c0 01          	add    $0x1,%rax
  8004210d49:	0f b6 00             	movzbl (%rax),%eax
  8004210d4c:	0f b6 c0             	movzbl %al,%eax
  8004210d4f:	48 c1 e0 10          	shl    $0x10,%rax
  8004210d53:	48 89 c2             	mov    %rax,%rdx
  8004210d56:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210d5a:	0f b6 00             	movzbl (%rax),%eax
  8004210d5d:	0f b6 c0             	movzbl %al,%eax
  8004210d60:	48 c1 e0 18          	shl    $0x18,%rax
  8004210d64:	48 09 d0             	or     %rdx,%rax
  8004210d67:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  8004210d6b:	e9 b6 00 00 00       	jmpq   8004210e26 <_dwarf_decode_msb+0x193>
	case 8:
		ret = src[7] | ((uint64_t) src[6]) << 8;
  8004210d70:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210d74:	48 83 c0 07          	add    $0x7,%rax
  8004210d78:	0f b6 00             	movzbl (%rax),%eax
  8004210d7b:	0f b6 c0             	movzbl %al,%eax
  8004210d7e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004210d82:	48 83 c2 06          	add    $0x6,%rdx
  8004210d86:	0f b6 12             	movzbl (%rdx),%edx
  8004210d89:	0f b6 d2             	movzbl %dl,%edx
  8004210d8c:	48 c1 e2 08          	shl    $0x8,%rdx
  8004210d90:	48 09 d0             	or     %rdx,%rax
  8004210d93:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[5]) << 16 | ((uint64_t) src[4]) << 24;
  8004210d97:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210d9b:	48 83 c0 05          	add    $0x5,%rax
  8004210d9f:	0f b6 00             	movzbl (%rax),%eax
  8004210da2:	0f b6 c0             	movzbl %al,%eax
  8004210da5:	48 c1 e0 10          	shl    $0x10,%rax
  8004210da9:	48 89 c2             	mov    %rax,%rdx
  8004210dac:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210db0:	48 83 c0 04          	add    $0x4,%rax
  8004210db4:	0f b6 00             	movzbl (%rax),%eax
  8004210db7:	0f b6 c0             	movzbl %al,%eax
  8004210dba:	48 c1 e0 18          	shl    $0x18,%rax
  8004210dbe:	48 09 d0             	or     %rdx,%rax
  8004210dc1:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[3]) << 32 | ((uint64_t) src[2]) << 40;
  8004210dc5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210dc9:	48 83 c0 03          	add    $0x3,%rax
  8004210dcd:	0f b6 00             	movzbl (%rax),%eax
  8004210dd0:	0f b6 c0             	movzbl %al,%eax
  8004210dd3:	48 c1 e0 20          	shl    $0x20,%rax
  8004210dd7:	48 89 c2             	mov    %rax,%rdx
  8004210dda:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210dde:	48 83 c0 02          	add    $0x2,%rax
  8004210de2:	0f b6 00             	movzbl (%rax),%eax
  8004210de5:	0f b6 c0             	movzbl %al,%eax
  8004210de8:	48 c1 e0 28          	shl    $0x28,%rax
  8004210dec:	48 09 d0             	or     %rdx,%rax
  8004210def:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 48 | ((uint64_t) src[0]) << 56;
  8004210df3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210df7:	48 83 c0 01          	add    $0x1,%rax
  8004210dfb:	0f b6 00             	movzbl (%rax),%eax
  8004210dfe:	0f b6 c0             	movzbl %al,%eax
  8004210e01:	48 c1 e0 30          	shl    $0x30,%rax
  8004210e05:	48 89 c2             	mov    %rax,%rdx
  8004210e08:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210e0c:	0f b6 00             	movzbl (%rax),%eax
  8004210e0f:	0f b6 c0             	movzbl %al,%eax
  8004210e12:	48 c1 e0 38          	shl    $0x38,%rax
  8004210e16:	48 09 d0             	or     %rdx,%rax
  8004210e19:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  8004210e1d:	eb 07                	jmp    8004210e26 <_dwarf_decode_msb+0x193>
	default:
		return (0);
  8004210e1f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210e24:	eb 1a                	jmp    8004210e40 <_dwarf_decode_msb+0x1ad>
		break;
	}

	*data += bytes_to_read;
  8004210e26:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210e2a:	48 8b 10             	mov    (%rax),%rdx
  8004210e2d:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004210e30:	48 98                	cltq   
  8004210e32:	48 01 c2             	add    %rax,%rdx
  8004210e35:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210e39:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  8004210e3c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004210e40:	c9                   	leaveq 
  8004210e41:	c3                   	retq   

0000008004210e42 <_dwarf_read_sleb128>:

int64_t
_dwarf_read_sleb128(uint8_t *data, uint64_t *offsetp)
{
  8004210e42:	55                   	push   %rbp
  8004210e43:	48 89 e5             	mov    %rsp,%rbp
  8004210e46:	48 83 ec 30          	sub    $0x30,%rsp
  8004210e4a:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004210e4e:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int64_t ret = 0;
  8004210e52:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004210e59:	00 
	uint8_t b;
	int shift = 0;
  8004210e5a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	uint8_t *src;

	src = data + *offsetp;
  8004210e61:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210e65:	48 8b 10             	mov    (%rax),%rdx
  8004210e68:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210e6c:	48 01 d0             	add    %rdx,%rax
  8004210e6f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  8004210e73:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210e77:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210e7b:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004210e7f:	0f b6 00             	movzbl (%rax),%eax
  8004210e82:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  8004210e85:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004210e89:	83 e0 7f             	and    $0x7f,%eax
  8004210e8c:	89 c2                	mov    %eax,%edx
  8004210e8e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210e91:	89 c1                	mov    %eax,%ecx
  8004210e93:	d3 e2                	shl    %cl,%edx
  8004210e95:	89 d0                	mov    %edx,%eax
  8004210e97:	48 98                	cltq   
  8004210e99:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		(*offsetp)++;
  8004210e9d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210ea1:	48 8b 00             	mov    (%rax),%rax
  8004210ea4:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210ea8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210eac:	48 89 10             	mov    %rdx,(%rax)
		shift += 7;
  8004210eaf:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  8004210eb3:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004210eb7:	84 c0                	test   %al,%al
  8004210eb9:	78 b8                	js     8004210e73 <_dwarf_read_sleb128+0x31>

	if (shift < 32 && (b & 0x40) != 0)
  8004210ebb:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  8004210ebf:	7f 1f                	jg     8004210ee0 <_dwarf_read_sleb128+0x9e>
  8004210ec1:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004210ec5:	83 e0 40             	and    $0x40,%eax
  8004210ec8:	85 c0                	test   %eax,%eax
  8004210eca:	74 14                	je     8004210ee0 <_dwarf_read_sleb128+0x9e>
		ret |= (-1 << shift);
  8004210ecc:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210ecf:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  8004210ed4:	89 c1                	mov    %eax,%ecx
  8004210ed6:	d3 e2                	shl    %cl,%edx
  8004210ed8:	89 d0                	mov    %edx,%eax
  8004210eda:	48 98                	cltq   
  8004210edc:	48 09 45 f8          	or     %rax,-0x8(%rbp)

	return (ret);
  8004210ee0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004210ee4:	c9                   	leaveq 
  8004210ee5:	c3                   	retq   

0000008004210ee6 <_dwarf_read_uleb128>:

uint64_t
_dwarf_read_uleb128(uint8_t *data, uint64_t *offsetp)
{
  8004210ee6:	55                   	push   %rbp
  8004210ee7:	48 89 e5             	mov    %rsp,%rbp
  8004210eea:	48 83 ec 30          	sub    $0x30,%rsp
  8004210eee:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004210ef2:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	uint64_t ret = 0;
  8004210ef6:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004210efd:	00 
	uint8_t b;
	int shift = 0;
  8004210efe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	uint8_t *src;

	src = data + *offsetp;
  8004210f05:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210f09:	48 8b 10             	mov    (%rax),%rdx
  8004210f0c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210f10:	48 01 d0             	add    %rdx,%rax
  8004210f13:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  8004210f17:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210f1b:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210f1f:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004210f23:	0f b6 00             	movzbl (%rax),%eax
  8004210f26:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  8004210f29:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004210f2d:	83 e0 7f             	and    $0x7f,%eax
  8004210f30:	89 c2                	mov    %eax,%edx
  8004210f32:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210f35:	89 c1                	mov    %eax,%ecx
  8004210f37:	d3 e2                	shl    %cl,%edx
  8004210f39:	89 d0                	mov    %edx,%eax
  8004210f3b:	48 98                	cltq   
  8004210f3d:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		(*offsetp)++;
  8004210f41:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210f45:	48 8b 00             	mov    (%rax),%rax
  8004210f48:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210f4c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210f50:	48 89 10             	mov    %rdx,(%rax)
		shift += 7;
  8004210f53:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  8004210f57:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004210f5b:	84 c0                	test   %al,%al
  8004210f5d:	78 b8                	js     8004210f17 <_dwarf_read_uleb128+0x31>

	return (ret);
  8004210f5f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004210f63:	c9                   	leaveq 
  8004210f64:	c3                   	retq   

0000008004210f65 <_dwarf_decode_sleb128>:

int64_t
_dwarf_decode_sleb128(uint8_t **dp)
{
  8004210f65:	55                   	push   %rbp
  8004210f66:	48 89 e5             	mov    %rsp,%rbp
  8004210f69:	48 83 ec 28          	sub    $0x28,%rsp
  8004210f6d:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	int64_t ret = 0;
  8004210f71:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004210f78:	00 
	uint8_t b;
	int shift = 0;
  8004210f79:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

	uint8_t *src = *dp;
  8004210f80:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210f84:	48 8b 00             	mov    (%rax),%rax
  8004210f87:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  8004210f8b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210f8f:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210f93:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004210f97:	0f b6 00             	movzbl (%rax),%eax
  8004210f9a:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  8004210f9d:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004210fa1:	83 e0 7f             	and    $0x7f,%eax
  8004210fa4:	89 c2                	mov    %eax,%edx
  8004210fa6:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210fa9:	89 c1                	mov    %eax,%ecx
  8004210fab:	d3 e2                	shl    %cl,%edx
  8004210fad:	89 d0                	mov    %edx,%eax
  8004210faf:	48 98                	cltq   
  8004210fb1:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		shift += 7;
  8004210fb5:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  8004210fb9:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004210fbd:	84 c0                	test   %al,%al
  8004210fbf:	78 ca                	js     8004210f8b <_dwarf_decode_sleb128+0x26>

	if (shift < 32 && (b & 0x40) != 0)
  8004210fc1:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  8004210fc5:	7f 1f                	jg     8004210fe6 <_dwarf_decode_sleb128+0x81>
  8004210fc7:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004210fcb:	83 e0 40             	and    $0x40,%eax
  8004210fce:	85 c0                	test   %eax,%eax
  8004210fd0:	74 14                	je     8004210fe6 <_dwarf_decode_sleb128+0x81>
		ret |= (-1 << shift);
  8004210fd2:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210fd5:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  8004210fda:	89 c1                	mov    %eax,%ecx
  8004210fdc:	d3 e2                	shl    %cl,%edx
  8004210fde:	89 d0                	mov    %edx,%eax
  8004210fe0:	48 98                	cltq   
  8004210fe2:	48 09 45 f8          	or     %rax,-0x8(%rbp)

	*dp = src;
  8004210fe6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210fea:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210fee:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  8004210ff1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004210ff5:	c9                   	leaveq 
  8004210ff6:	c3                   	retq   

0000008004210ff7 <_dwarf_decode_uleb128>:

uint64_t
_dwarf_decode_uleb128(uint8_t **dp)
{
  8004210ff7:	55                   	push   %rbp
  8004210ff8:	48 89 e5             	mov    %rsp,%rbp
  8004210ffb:	48 83 ec 28          	sub    $0x28,%rsp
  8004210fff:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	uint64_t ret = 0;
  8004211003:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800421100a:	00 
	uint8_t b;
	int shift = 0;
  800421100b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

	uint8_t *src = *dp;
  8004211012:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211016:	48 8b 00             	mov    (%rax),%rax
  8004211019:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  800421101d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211021:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004211025:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004211029:	0f b6 00             	movzbl (%rax),%eax
  800421102c:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  800421102f:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004211033:	83 e0 7f             	and    $0x7f,%eax
  8004211036:	89 c2                	mov    %eax,%edx
  8004211038:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421103b:	89 c1                	mov    %eax,%ecx
  800421103d:	d3 e2                	shl    %cl,%edx
  800421103f:	89 d0                	mov    %edx,%eax
  8004211041:	48 98                	cltq   
  8004211043:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		shift += 7;
  8004211047:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800421104b:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800421104f:	84 c0                	test   %al,%al
  8004211051:	78 ca                	js     800421101d <_dwarf_decode_uleb128+0x26>

	*dp = src;
  8004211053:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211057:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421105b:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800421105e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004211062:	c9                   	leaveq 
  8004211063:	c3                   	retq   

0000008004211064 <_dwarf_read_string>:

#define Dwarf_Unsigned uint64_t

char *
_dwarf_read_string(void *data, Dwarf_Unsigned size, uint64_t *offsetp)
{
  8004211064:	55                   	push   %rbp
  8004211065:	48 89 e5             	mov    %rsp,%rbp
  8004211068:	48 83 ec 28          	sub    $0x28,%rsp
  800421106c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004211070:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004211074:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *ret, *src;

	ret = src = (char *) data + *offsetp;
  8004211078:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421107c:	48 8b 10             	mov    (%rax),%rdx
  800421107f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211083:	48 01 d0             	add    %rdx,%rax
  8004211086:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421108a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421108e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (*src != '\0' && *offsetp < size) {
  8004211092:	eb 17                	jmp    80042110ab <_dwarf_read_string+0x47>
		src++;
  8004211094:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
		(*offsetp)++;
  8004211099:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421109d:	48 8b 00             	mov    (%rax),%rax
  80042110a0:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042110a4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042110a8:	48 89 10             	mov    %rdx,(%rax)
{
	char *ret, *src;

	ret = src = (char *) data + *offsetp;

	while (*src != '\0' && *offsetp < size) {
  80042110ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042110af:	0f b6 00             	movzbl (%rax),%eax
  80042110b2:	84 c0                	test   %al,%al
  80042110b4:	74 0d                	je     80042110c3 <_dwarf_read_string+0x5f>
  80042110b6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042110ba:	48 8b 00             	mov    (%rax),%rax
  80042110bd:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  80042110c1:	72 d1                	jb     8004211094 <_dwarf_read_string+0x30>
		src++;
		(*offsetp)++;
	}

	if (*src == '\0' && *offsetp < size)
  80042110c3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042110c7:	0f b6 00             	movzbl (%rax),%eax
  80042110ca:	84 c0                	test   %al,%al
  80042110cc:	75 1f                	jne    80042110ed <_dwarf_read_string+0x89>
  80042110ce:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042110d2:	48 8b 00             	mov    (%rax),%rax
  80042110d5:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  80042110d9:	73 12                	jae    80042110ed <_dwarf_read_string+0x89>
		(*offsetp)++;
  80042110db:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042110df:	48 8b 00             	mov    (%rax),%rax
  80042110e2:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042110e6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042110ea:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  80042110ed:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  80042110f1:	c9                   	leaveq 
  80042110f2:	c3                   	retq   

00000080042110f3 <_dwarf_read_block>:

uint8_t *
_dwarf_read_block(void *data, uint64_t *offsetp, uint64_t length)
{
  80042110f3:	55                   	push   %rbp
  80042110f4:	48 89 e5             	mov    %rsp,%rbp
  80042110f7:	48 83 ec 28          	sub    $0x28,%rsp
  80042110fb:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042110ff:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004211103:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	uint8_t *ret, *src;

	ret = src = (uint8_t *) data + *offsetp;
  8004211107:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421110b:	48 8b 10             	mov    (%rax),%rdx
  800421110e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211112:	48 01 d0             	add    %rdx,%rax
  8004211115:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004211119:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421111d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	(*offsetp) += length;
  8004211121:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211125:	48 8b 10             	mov    (%rax),%rdx
  8004211128:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421112c:	48 01 c2             	add    %rax,%rdx
  800421112f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211133:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  8004211136:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800421113a:	c9                   	leaveq 
  800421113b:	c3                   	retq   

000000800421113c <_dwarf_elf_get_byte_order>:

Dwarf_Endianness
_dwarf_elf_get_byte_order(void *obj)
{
  800421113c:	55                   	push   %rbp
  800421113d:	48 89 e5             	mov    %rsp,%rbp
  8004211140:	48 83 ec 20          	sub    $0x20,%rsp
  8004211144:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Elf *e;

	e = (Elf *)obj;
  8004211148:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421114c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(e != NULL);
  8004211150:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004211155:	75 35                	jne    800421118c <_dwarf_elf_get_byte_order+0x50>
  8004211157:	48 b9 80 b1 21 04 80 	movabs $0x800421b180,%rcx
  800421115e:	00 00 00 
  8004211161:	48 ba 8a b1 21 04 80 	movabs $0x800421b18a,%rdx
  8004211168:	00 00 00 
  800421116b:	be 29 01 00 00       	mov    $0x129,%esi
  8004211170:	48 bf 9f b1 21 04 80 	movabs $0x800421b19f,%rdi
  8004211177:	00 00 00 
  800421117a:	b8 00 00 00 00       	mov    $0x0,%eax
  800421117f:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004211186:	00 00 00 
  8004211189:	41 ff d0             	callq  *%r8

//TODO: Need to check for 64bit here. Because currently Elf header for
//      64bit doesn't have any memeber e_ident. But need to see what is
//      similar in 64bit.
	switch (e->e_ident[EI_DATA]) {
  800421118c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211190:	0f b6 40 05          	movzbl 0x5(%rax),%eax
  8004211194:	0f b6 c0             	movzbl %al,%eax
  8004211197:	83 f8 02             	cmp    $0x2,%eax
  800421119a:	75 07                	jne    80042111a3 <_dwarf_elf_get_byte_order+0x67>
	case ELFDATA2MSB:
		return (DW_OBJECT_MSB);
  800421119c:	b8 00 00 00 00       	mov    $0x0,%eax
  80042111a1:	eb 05                	jmp    80042111a8 <_dwarf_elf_get_byte_order+0x6c>

	case ELFDATA2LSB:
	case ELFDATANONE:
	default:
		return (DW_OBJECT_LSB);
  80042111a3:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
  80042111a8:	c9                   	leaveq 
  80042111a9:	c3                   	retq   

00000080042111aa <_dwarf_elf_get_pointer_size>:

Dwarf_Small
_dwarf_elf_get_pointer_size(void *obj)
{
  80042111aa:	55                   	push   %rbp
  80042111ab:	48 89 e5             	mov    %rsp,%rbp
  80042111ae:	48 83 ec 20          	sub    $0x20,%rsp
  80042111b2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Elf *e;

	e = (Elf *) obj;
  80042111b6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042111ba:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(e != NULL);
  80042111be:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042111c3:	75 35                	jne    80042111fa <_dwarf_elf_get_pointer_size+0x50>
  80042111c5:	48 b9 80 b1 21 04 80 	movabs $0x800421b180,%rcx
  80042111cc:	00 00 00 
  80042111cf:	48 ba 8a b1 21 04 80 	movabs $0x800421b18a,%rdx
  80042111d6:	00 00 00 
  80042111d9:	be 3f 01 00 00       	mov    $0x13f,%esi
  80042111de:	48 bf 9f b1 21 04 80 	movabs $0x800421b19f,%rdi
  80042111e5:	00 00 00 
  80042111e8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042111ed:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042111f4:	00 00 00 
  80042111f7:	41 ff d0             	callq  *%r8

	if (e->e_ident[4] == ELFCLASS32)
  80042111fa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042111fe:	0f b6 40 04          	movzbl 0x4(%rax),%eax
  8004211202:	3c 01                	cmp    $0x1,%al
  8004211204:	75 07                	jne    800421120d <_dwarf_elf_get_pointer_size+0x63>
		return (4);
  8004211206:	b8 04 00 00 00       	mov    $0x4,%eax
  800421120b:	eb 05                	jmp    8004211212 <_dwarf_elf_get_pointer_size+0x68>
	else
		return (8);
  800421120d:	b8 08 00 00 00       	mov    $0x8,%eax
}
  8004211212:	c9                   	leaveq 
  8004211213:	c3                   	retq   

0000008004211214 <_dwarf_init>:

//Return 0 on success
int _dwarf_init(Dwarf_Debug dbg, void *obj)
{
  8004211214:	55                   	push   %rbp
  8004211215:	48 89 e5             	mov    %rsp,%rbp
  8004211218:	53                   	push   %rbx
  8004211219:	48 83 ec 18          	sub    $0x18,%rsp
  800421121d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004211221:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	memset(dbg, 0, sizeof(struct _Dwarf_Debug));
  8004211225:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211229:	ba 60 00 00 00       	mov    $0x60,%edx
  800421122e:	be 00 00 00 00       	mov    $0x0,%esi
  8004211233:	48 89 c7             	mov    %rax,%rdi
  8004211236:	48 b8 d4 03 21 04 80 	movabs $0x80042103d4,%rax
  800421123d:	00 00 00 
  8004211240:	ff d0                	callq  *%rax
	dbg->curr_off_dbginfo = 0;
  8004211242:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211246:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	dbg->dbg_info_size = 0;
  800421124d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211251:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  8004211258:	00 
	dbg->dbg_pointer_size = _dwarf_elf_get_pointer_size(obj); 
  8004211259:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421125d:	48 89 c7             	mov    %rax,%rdi
  8004211260:	48 b8 aa 11 21 04 80 	movabs $0x80042111aa,%rax
  8004211267:	00 00 00 
  800421126a:	ff d0                	callq  *%rax
  800421126c:	0f b6 d0             	movzbl %al,%edx
  800421126f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211273:	89 50 28             	mov    %edx,0x28(%rax)

	if (_dwarf_elf_get_byte_order(obj) == DW_OBJECT_MSB) {
  8004211276:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421127a:	48 89 c7             	mov    %rax,%rdi
  800421127d:	48 b8 3c 11 21 04 80 	movabs $0x800421113c,%rax
  8004211284:	00 00 00 
  8004211287:	ff d0                	callq  *%rax
  8004211289:	85 c0                	test   %eax,%eax
  800421128b:	75 26                	jne    80042112b3 <_dwarf_init+0x9f>
		dbg->read = _dwarf_read_msb;
  800421128d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211291:	48 b9 e1 0a 21 04 80 	movabs $0x8004210ae1,%rcx
  8004211298:	00 00 00 
  800421129b:	48 89 48 18          	mov    %rcx,0x18(%rax)
		dbg->decode = _dwarf_decode_msb;
  800421129f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042112a3:	48 bb 93 0c 21 04 80 	movabs $0x8004210c93,%rbx
  80042112aa:	00 00 00 
  80042112ad:	48 89 58 20          	mov    %rbx,0x20(%rax)
  80042112b1:	eb 24                	jmp    80042112d7 <_dwarf_init+0xc3>
	} else {
		dbg->read = _dwarf_read_lsb;
  80042112b3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042112b7:	48 b9 94 08 21 04 80 	movabs $0x8004210894,%rcx
  80042112be:	00 00 00 
  80042112c1:	48 89 48 18          	mov    %rcx,0x18(%rax)
		dbg->decode = _dwarf_decode_lsb;
  80042112c5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042112c9:	48 be c0 09 21 04 80 	movabs $0x80042109c0,%rsi
  80042112d0:	00 00 00 
  80042112d3:	48 89 70 20          	mov    %rsi,0x20(%rax)
	}
	_dwarf_frame_params_init(dbg);
  80042112d7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042112db:	48 89 c7             	mov    %rax,%rdi
  80042112de:	48 b8 e1 27 21 04 80 	movabs $0x80042127e1,%rax
  80042112e5:	00 00 00 
  80042112e8:	ff d0                	callq  *%rax
	return 0;
  80042112ea:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042112ef:	48 83 c4 18          	add    $0x18,%rsp
  80042112f3:	5b                   	pop    %rbx
  80042112f4:	5d                   	pop    %rbp
  80042112f5:	c3                   	retq   

00000080042112f6 <_get_next_cu>:

//Return 0 on success
int _get_next_cu(Dwarf_Debug dbg, Dwarf_CU *cu)
{
  80042112f6:	55                   	push   %rbp
  80042112f7:	48 89 e5             	mov    %rsp,%rbp
  80042112fa:	48 83 ec 20          	sub    $0x20,%rsp
  80042112fe:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004211302:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	uint32_t length;
	uint64_t offset;
	uint8_t dwarf_size;

	if(dbg->curr_off_dbginfo > dbg->dbg_info_size)
  8004211306:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421130a:	48 8b 10             	mov    (%rax),%rdx
  800421130d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211311:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004211315:	48 39 c2             	cmp    %rax,%rdx
  8004211318:	76 0a                	jbe    8004211324 <_get_next_cu+0x2e>
		return -1;
  800421131a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800421131f:	e9 6b 01 00 00       	jmpq   800421148f <_get_next_cu+0x199>

	offset = dbg->curr_off_dbginfo;
  8004211324:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211328:	48 8b 00             	mov    (%rax),%rax
  800421132b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	cu->cu_offset = offset;
  800421132f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004211333:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211337:	48 89 50 30          	mov    %rdx,0x30(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset,4);
  800421133b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421133f:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211343:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004211347:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800421134b:	48 89 d1             	mov    %rdx,%rcx
  800421134e:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  8004211352:	ba 04 00 00 00       	mov    $0x4,%edx
  8004211357:	48 89 cf             	mov    %rcx,%rdi
  800421135a:	ff d0                	callq  *%rax
  800421135c:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (length == 0xffffffff) {
  800421135f:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  8004211363:	75 2a                	jne    800421138f <_get_next_cu+0x99>
		length = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 8);
  8004211365:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211369:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421136d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004211371:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8004211375:	48 89 d1             	mov    %rdx,%rcx
  8004211378:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  800421137c:	ba 08 00 00 00       	mov    $0x8,%edx
  8004211381:	48 89 cf             	mov    %rcx,%rdi
  8004211384:	ff d0                	callq  *%rax
  8004211386:	89 45 fc             	mov    %eax,-0x4(%rbp)
		dwarf_size = 8;
  8004211389:	c6 45 fb 08          	movb   $0x8,-0x5(%rbp)
  800421138d:	eb 04                	jmp    8004211393 <_get_next_cu+0x9d>
	} else {
		dwarf_size = 4;
  800421138f:	c6 45 fb 04          	movb   $0x4,-0x5(%rbp)
	}

	cu->cu_dwarf_size = dwarf_size;
  8004211393:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211397:	0f b6 55 fb          	movzbl -0x5(%rbp),%edx
  800421139b:	88 50 19             	mov    %dl,0x19(%rax)
	 if (length > ds->ds_size - offset) {
	 return (DW_DLE_CU_LENGTH_ERROR);
	 }*/

	/* Compute the offset to the next compilation unit: */
	dbg->curr_off_dbginfo = offset + length;
  800421139e:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042113a1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042113a5:	48 01 c2             	add    %rax,%rdx
  80042113a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042113ac:	48 89 10             	mov    %rdx,(%rax)
	cu->cu_next_offset   = dbg->curr_off_dbginfo;
  80042113af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042113b3:	48 8b 10             	mov    (%rax),%rdx
  80042113b6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042113ba:	48 89 50 20          	mov    %rdx,0x20(%rax)

	/* Initialise the compilation unit. */
	cu->cu_length = (uint64_t)length;
  80042113be:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042113c1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042113c5:	48 89 10             	mov    %rdx,(%rax)

	cu->cu_length_size   = (dwarf_size == 4 ? 4 : 12);
  80042113c8:	80 7d fb 04          	cmpb   $0x4,-0x5(%rbp)
  80042113cc:	75 07                	jne    80042113d5 <_get_next_cu+0xdf>
  80042113ce:	b8 04 00 00 00       	mov    $0x4,%eax
  80042113d3:	eb 05                	jmp    80042113da <_get_next_cu+0xe4>
  80042113d5:	b8 0c 00 00 00       	mov    $0xc,%eax
  80042113da:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042113de:	88 42 18             	mov    %al,0x18(%rdx)
	cu->version              = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 2);
  80042113e1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042113e5:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042113e9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042113ed:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  80042113f1:	48 89 d1             	mov    %rdx,%rcx
  80042113f4:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  80042113f8:	ba 02 00 00 00       	mov    $0x2,%edx
  80042113fd:	48 89 cf             	mov    %rcx,%rdi
  8004211400:	ff d0                	callq  *%rax
  8004211402:	89 c2                	mov    %eax,%edx
  8004211404:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211408:	66 89 50 08          	mov    %dx,0x8(%rax)
	cu->debug_abbrev_offset  = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, dwarf_size);
  800421140c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211410:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211414:	0f b6 55 fb          	movzbl -0x5(%rbp),%edx
  8004211418:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421141c:	48 8b 49 08          	mov    0x8(%rcx),%rcx
  8004211420:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  8004211424:	48 89 cf             	mov    %rcx,%rdi
  8004211427:	ff d0                	callq  *%rax
  8004211429:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421142d:	48 89 42 10          	mov    %rax,0x10(%rdx)
	//cu->cu_abbrev_offset_cur = cu->cu_abbrev_offset;
	cu->addr_size  = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 1);
  8004211431:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211435:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211439:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421143d:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8004211441:	48 89 d1             	mov    %rdx,%rcx
  8004211444:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  8004211448:	ba 01 00 00 00       	mov    $0x1,%edx
  800421144d:	48 89 cf             	mov    %rcx,%rdi
  8004211450:	ff d0                	callq  *%rax
  8004211452:	89 c2                	mov    %eax,%edx
  8004211454:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211458:	88 50 0a             	mov    %dl,0xa(%rax)

	if (cu->version < 2 || cu->version > 4) {
  800421145b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421145f:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004211463:	66 83 f8 01          	cmp    $0x1,%ax
  8004211467:	76 0e                	jbe    8004211477 <_get_next_cu+0x181>
  8004211469:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421146d:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004211471:	66 83 f8 04          	cmp    $0x4,%ax
  8004211475:	76 07                	jbe    800421147e <_get_next_cu+0x188>
		return -1;
  8004211477:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800421147c:	eb 11                	jmp    800421148f <_get_next_cu+0x199>
	}

	cu->cu_die_offset = offset;
  800421147e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004211482:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211486:	48 89 50 28          	mov    %rdx,0x28(%rax)

	return 0;
  800421148a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421148f:	c9                   	leaveq 
  8004211490:	c3                   	retq   

0000008004211491 <print_cu>:

void print_cu(Dwarf_CU cu)
{
  8004211491:	55                   	push   %rbp
  8004211492:	48 89 e5             	mov    %rsp,%rbp
	cprintf("%ld---%du--%d\n",cu.cu_length,cu.version,cu.addr_size);
  8004211495:	0f b6 45 1a          	movzbl 0x1a(%rbp),%eax
  8004211499:	0f b6 c8             	movzbl %al,%ecx
  800421149c:	0f b7 45 18          	movzwl 0x18(%rbp),%eax
  80042114a0:	0f b7 d0             	movzwl %ax,%edx
  80042114a3:	48 8b 45 10          	mov    0x10(%rbp),%rax
  80042114a7:	48 89 c6             	mov    %rax,%rsi
  80042114aa:	48 bf b2 b1 21 04 80 	movabs $0x800421b1b2,%rdi
  80042114b1:	00 00 00 
  80042114b4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042114b9:	49 b8 90 95 20 04 80 	movabs $0x8004209590,%r8
  80042114c0:	00 00 00 
  80042114c3:	41 ff d0             	callq  *%r8
}
  80042114c6:	5d                   	pop    %rbp
  80042114c7:	c3                   	retq   

00000080042114c8 <_dwarf_abbrev_parse>:

//Return 0 on success
int
_dwarf_abbrev_parse(Dwarf_Debug dbg, Dwarf_CU cu, Dwarf_Unsigned *offset,
		    Dwarf_Abbrev *abp, Dwarf_Section *ds)
{
  80042114c8:	55                   	push   %rbp
  80042114c9:	48 89 e5             	mov    %rsp,%rbp
  80042114cc:	48 83 ec 60          	sub    $0x60,%rsp
  80042114d0:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  80042114d4:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  80042114d8:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  80042114dc:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
	uint64_t tag;
	uint8_t children;
	uint64_t abbr_addr;
	int ret;

	assert(abp != NULL);
  80042114e0:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  80042114e5:	75 35                	jne    800421151c <_dwarf_abbrev_parse+0x54>
  80042114e7:	48 b9 c1 b1 21 04 80 	movabs $0x800421b1c1,%rcx
  80042114ee:	00 00 00 
  80042114f1:	48 ba 8a b1 21 04 80 	movabs $0x800421b18a,%rdx
  80042114f8:	00 00 00 
  80042114fb:	be a4 01 00 00       	mov    $0x1a4,%esi
  8004211500:	48 bf 9f b1 21 04 80 	movabs $0x800421b19f,%rdi
  8004211507:	00 00 00 
  800421150a:	b8 00 00 00 00       	mov    $0x0,%eax
  800421150f:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004211516:	00 00 00 
  8004211519:	41 ff d0             	callq  *%r8
	assert(ds != NULL);
  800421151c:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  8004211521:	75 35                	jne    8004211558 <_dwarf_abbrev_parse+0x90>
  8004211523:	48 b9 cd b1 21 04 80 	movabs $0x800421b1cd,%rcx
  800421152a:	00 00 00 
  800421152d:	48 ba 8a b1 21 04 80 	movabs $0x800421b18a,%rdx
  8004211534:	00 00 00 
  8004211537:	be a5 01 00 00       	mov    $0x1a5,%esi
  800421153c:	48 bf 9f b1 21 04 80 	movabs $0x800421b19f,%rdi
  8004211543:	00 00 00 
  8004211546:	b8 00 00 00 00       	mov    $0x0,%eax
  800421154b:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004211552:	00 00 00 
  8004211555:	41 ff d0             	callq  *%r8

	if (*offset >= ds->ds_size)
  8004211558:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421155c:	48 8b 10             	mov    (%rax),%rdx
  800421155f:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004211563:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211567:	48 39 c2             	cmp    %rax,%rdx
  800421156a:	72 0a                	jb     8004211576 <_dwarf_abbrev_parse+0xae>
        	return (DW_DLE_NO_ENTRY);
  800421156c:	b8 04 00 00 00       	mov    $0x4,%eax
  8004211571:	e9 d3 01 00 00       	jmpq   8004211749 <_dwarf_abbrev_parse+0x281>

	aboff = *offset;
  8004211576:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421157a:	48 8b 00             	mov    (%rax),%rax
  800421157d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	abbr_addr = (uint64_t)ds->ds_data; //(uint64_t)((uint8_t *)elf_base_ptr + ds->sh_offset);
  8004211581:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004211585:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004211589:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	entry = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  800421158d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211591:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004211595:	48 89 d6             	mov    %rdx,%rsi
  8004211598:	48 89 c7             	mov    %rax,%rdi
  800421159b:	48 b8 e6 0e 21 04 80 	movabs $0x8004210ee6,%rax
  80042115a2:	00 00 00 
  80042115a5:	ff d0                	callq  *%rax
  80042115a7:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	if (entry == 0) {
  80042115ab:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042115b0:	75 15                	jne    80042115c7 <_dwarf_abbrev_parse+0xff>
		/* Last entry. */
		//Need to make connection from below function
		abp->ab_entry = 0;
  80042115b2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042115b6:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return DW_DLE_NONE;
  80042115bd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042115c2:	e9 82 01 00 00       	jmpq   8004211749 <_dwarf_abbrev_parse+0x281>
	}

	tag = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  80042115c7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042115cb:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  80042115cf:	48 89 d6             	mov    %rdx,%rsi
  80042115d2:	48 89 c7             	mov    %rax,%rdi
  80042115d5:	48 b8 e6 0e 21 04 80 	movabs $0x8004210ee6,%rax
  80042115dc:	00 00 00 
  80042115df:	ff d0                	callq  *%rax
  80042115e1:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	children = dbg->read((uint8_t *)abbr_addr, offset, 1);
  80042115e5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042115e9:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042115ed:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  80042115f1:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  80042115f5:	ba 01 00 00 00       	mov    $0x1,%edx
  80042115fa:	48 89 cf             	mov    %rcx,%rdi
  80042115fd:	ff d0                	callq  *%rax
  80042115ff:	88 45 df             	mov    %al,-0x21(%rbp)

	abp->ab_entry    = entry;
  8004211602:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004211606:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421160a:	48 89 10             	mov    %rdx,(%rax)
	abp->ab_tag      = tag;
  800421160d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004211611:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004211615:	48 89 50 08          	mov    %rdx,0x8(%rax)
	abp->ab_children = children;
  8004211619:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421161d:	0f b6 55 df          	movzbl -0x21(%rbp),%edx
  8004211621:	88 50 10             	mov    %dl,0x10(%rax)
	abp->ab_offset   = aboff;
  8004211624:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004211628:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421162c:	48 89 50 18          	mov    %rdx,0x18(%rax)
	abp->ab_length   = 0;    /* fill in later. */
  8004211630:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004211634:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  800421163b:	00 
	abp->ab_atnum    = 0;
  800421163c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004211640:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  8004211647:	00 

	/* Parse attribute definitions. */
	do {
		adoff = *offset;
  8004211648:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421164c:	48 8b 00             	mov    (%rax),%rax
  800421164f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		attr = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  8004211653:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211657:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800421165b:	48 89 d6             	mov    %rdx,%rsi
  800421165e:	48 89 c7             	mov    %rax,%rdi
  8004211661:	48 b8 e6 0e 21 04 80 	movabs $0x8004210ee6,%rax
  8004211668:	00 00 00 
  800421166b:	ff d0                	callq  *%rax
  800421166d:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
		form = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  8004211671:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211675:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004211679:	48 89 d6             	mov    %rdx,%rsi
  800421167c:	48 89 c7             	mov    %rax,%rdi
  800421167f:	48 b8 e6 0e 21 04 80 	movabs $0x8004210ee6,%rax
  8004211686:	00 00 00 
  8004211689:	ff d0                	callq  *%rax
  800421168b:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		if (attr != 0)
  800421168f:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004211694:	0f 84 89 00 00 00    	je     8004211723 <_dwarf_abbrev_parse+0x25b>
		{
			/* Initialise the attribute definition structure. */
			abp->ab_attrdef[abp->ab_atnum].ad_attrib = attr;
  800421169a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421169e:	48 8b 50 28          	mov    0x28(%rax),%rdx
  80042116a2:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  80042116a6:	48 89 d0             	mov    %rdx,%rax
  80042116a9:	48 01 c0             	add    %rax,%rax
  80042116ac:	48 01 d0             	add    %rdx,%rax
  80042116af:	48 c1 e0 03          	shl    $0x3,%rax
  80042116b3:	48 01 c8             	add    %rcx,%rax
  80042116b6:	48 8d 50 30          	lea    0x30(%rax),%rdx
  80042116ba:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042116be:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_attrdef[abp->ab_atnum].ad_form   = form;
  80042116c1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042116c5:	48 8b 50 28          	mov    0x28(%rax),%rdx
  80042116c9:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  80042116cd:	48 89 d0             	mov    %rdx,%rax
  80042116d0:	48 01 c0             	add    %rax,%rax
  80042116d3:	48 01 d0             	add    %rdx,%rax
  80042116d6:	48 c1 e0 03          	shl    $0x3,%rax
  80042116da:	48 01 c8             	add    %rcx,%rax
  80042116dd:	48 8d 50 38          	lea    0x38(%rax),%rdx
  80042116e1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042116e5:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_attrdef[abp->ab_atnum].ad_offset = adoff;
  80042116e8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042116ec:	48 8b 50 28          	mov    0x28(%rax),%rdx
  80042116f0:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  80042116f4:	48 89 d0             	mov    %rdx,%rax
  80042116f7:	48 01 c0             	add    %rax,%rax
  80042116fa:	48 01 d0             	add    %rdx,%rax
  80042116fd:	48 c1 e0 03          	shl    $0x3,%rax
  8004211701:	48 01 c8             	add    %rcx,%rax
  8004211704:	48 8d 50 40          	lea    0x40(%rax),%rdx
  8004211708:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421170c:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_atnum++;
  800421170f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004211713:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004211717:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800421171b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421171f:	48 89 50 28          	mov    %rdx,0x28(%rax)
		}
	} while (attr != 0);
  8004211723:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004211728:	0f 85 1a ff ff ff    	jne    8004211648 <_dwarf_abbrev_parse+0x180>

	//(*abp)->ab_length = *offset - aboff;
	abp->ab_length = (uint64_t)(*offset - aboff);
  800421172e:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004211732:	48 8b 00             	mov    (%rax),%rax
  8004211735:	48 2b 45 f8          	sub    -0x8(%rbp),%rax
  8004211739:	48 89 c2             	mov    %rax,%rdx
  800421173c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004211740:	48 89 50 20          	mov    %rdx,0x20(%rax)

	return DW_DLV_OK;
  8004211744:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004211749:	c9                   	leaveq 
  800421174a:	c3                   	retq   

000000800421174b <_dwarf_abbrev_find>:

//Return 0 on success
int
_dwarf_abbrev_find(Dwarf_Debug dbg, Dwarf_CU cu, uint64_t entry, Dwarf_Abbrev *abp)
{
  800421174b:	55                   	push   %rbp
  800421174c:	48 89 e5             	mov    %rsp,%rbp
  800421174f:	48 83 ec 70          	sub    $0x70,%rsp
  8004211753:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004211757:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800421175b:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	Dwarf_Section *ds;
	uint64_t offset;
	int ret;

	if (entry == 0)
  800421175f:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004211764:	75 0a                	jne    8004211770 <_dwarf_abbrev_find+0x25>
	{
		return (DW_DLE_NO_ENTRY);
  8004211766:	b8 04 00 00 00       	mov    $0x4,%eax
  800421176b:	e9 0a 01 00 00       	jmpq   800421187a <_dwarf_abbrev_find+0x12f>
	}

	/* Load and search the abbrev table. */
	ds = _dwarf_find_section(".debug_abbrev");
  8004211770:	48 bf d8 b1 21 04 80 	movabs $0x800421b1d8,%rdi
  8004211777:	00 00 00 
  800421177a:	48 b8 ab 5a 21 04 80 	movabs $0x8004215aab,%rax
  8004211781:	00 00 00 
  8004211784:	ff d0                	callq  *%rax
  8004211786:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(ds != NULL);
  800421178a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800421178f:	75 35                	jne    80042117c6 <_dwarf_abbrev_find+0x7b>
  8004211791:	48 b9 cd b1 21 04 80 	movabs $0x800421b1cd,%rcx
  8004211798:	00 00 00 
  800421179b:	48 ba 8a b1 21 04 80 	movabs $0x800421b18a,%rdx
  80042117a2:	00 00 00 
  80042117a5:	be e5 01 00 00       	mov    $0x1e5,%esi
  80042117aa:	48 bf 9f b1 21 04 80 	movabs $0x800421b19f,%rdi
  80042117b1:	00 00 00 
  80042117b4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042117b9:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042117c0:	00 00 00 
  80042117c3:	41 ff d0             	callq  *%r8

	//TODO: We are starting offset from 0, however libdwarf logic
	//      is keeping a counter for current offset. Ok. let use
	//      that. I relent, but this will be done in Phase 2. :)
	//offset = 0; //cu->cu_abbrev_offset_cur;
	offset = cu.debug_abbrev_offset; //cu->cu_abbrev_offset_cur;
  80042117c6:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042117ca:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	while (offset < ds->ds_size) {
  80042117ce:	e9 8d 00 00 00       	jmpq   8004211860 <_dwarf_abbrev_find+0x115>
		ret = _dwarf_abbrev_parse(dbg, cu, &offset, abp, ds);
  80042117d3:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80042117d7:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042117db:	48 8d 75 e8          	lea    -0x18(%rbp),%rsi
  80042117df:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042117e3:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  80042117e7:	48 89 3c 24          	mov    %rdi,(%rsp)
  80042117eb:	48 8b 7d 18          	mov    0x18(%rbp),%rdi
  80042117ef:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  80042117f4:	48 8b 7d 20          	mov    0x20(%rbp),%rdi
  80042117f8:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  80042117fd:	48 8b 7d 28          	mov    0x28(%rbp),%rdi
  8004211801:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  8004211806:	48 8b 7d 30          	mov    0x30(%rbp),%rdi
  800421180a:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  800421180f:	48 8b 7d 38          	mov    0x38(%rbp),%rdi
  8004211813:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  8004211818:	48 8b 7d 40          	mov    0x40(%rbp),%rdi
  800421181c:	48 89 7c 24 30       	mov    %rdi,0x30(%rsp)
  8004211821:	48 89 c7             	mov    %rax,%rdi
  8004211824:	48 b8 c8 14 21 04 80 	movabs $0x80042114c8,%rax
  800421182b:	00 00 00 
  800421182e:	ff d0                	callq  *%rax
  8004211830:	89 45 f4             	mov    %eax,-0xc(%rbp)
		if (ret != DW_DLE_NONE)
  8004211833:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  8004211837:	74 05                	je     800421183e <_dwarf_abbrev_find+0xf3>
			return (ret);
  8004211839:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421183c:	eb 3c                	jmp    800421187a <_dwarf_abbrev_find+0x12f>
		if (abp->ab_entry == entry) {
  800421183e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211842:	48 8b 00             	mov    (%rax),%rax
  8004211845:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004211849:	75 07                	jne    8004211852 <_dwarf_abbrev_find+0x107>
			//cu->cu_abbrev_offset_cur = offset;
			return DW_DLE_NONE;
  800421184b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211850:	eb 28                	jmp    800421187a <_dwarf_abbrev_find+0x12f>
		}
		if (abp->ab_entry == 0) {
  8004211852:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211856:	48 8b 00             	mov    (%rax),%rax
  8004211859:	48 85 c0             	test   %rax,%rax
  800421185c:	75 02                	jne    8004211860 <_dwarf_abbrev_find+0x115>
			//cu->cu_abbrev_offset_cur = offset;
			//cu->cu_abbrev_loaded = 1;
			break;
  800421185e:	eb 15                	jmp    8004211875 <_dwarf_abbrev_find+0x12a>
	//TODO: We are starting offset from 0, however libdwarf logic
	//      is keeping a counter for current offset. Ok. let use
	//      that. I relent, but this will be done in Phase 2. :)
	//offset = 0; //cu->cu_abbrev_offset_cur;
	offset = cu.debug_abbrev_offset; //cu->cu_abbrev_offset_cur;
	while (offset < ds->ds_size) {
  8004211860:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211864:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004211868:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421186c:	48 39 c2             	cmp    %rax,%rdx
  800421186f:	0f 87 5e ff ff ff    	ja     80042117d3 <_dwarf_abbrev_find+0x88>
			//cu->cu_abbrev_loaded = 1;
			break;
		}
	}

	return DW_DLE_NO_ENTRY;
  8004211875:	b8 04 00 00 00       	mov    $0x4,%eax
}
  800421187a:	c9                   	leaveq 
  800421187b:	c3                   	retq   

000000800421187c <_dwarf_attr_init>:

//Return 0 on success
int
_dwarf_attr_init(Dwarf_Debug dbg, uint64_t *offsetp, Dwarf_CU *cu, Dwarf_Die *ret_die, Dwarf_AttrDef *ad,
		 uint64_t form, int indirect)
{
  800421187c:	55                   	push   %rbp
  800421187d:	48 89 e5             	mov    %rsp,%rbp
  8004211880:	48 81 ec d0 00 00 00 	sub    $0xd0,%rsp
  8004211887:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  800421188e:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  8004211895:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
  800421189c:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
  80042118a3:	4c 89 85 48 ff ff ff 	mov    %r8,-0xb8(%rbp)
  80042118aa:	4c 89 8d 40 ff ff ff 	mov    %r9,-0xc0(%rbp)
	struct _Dwarf_Attribute atref;
	Dwarf_Section *str;
	int ret;
	Dwarf_Section *ds = _dwarf_find_section(".debug_info");
  80042118b1:	48 bf e6 b1 21 04 80 	movabs $0x800421b1e6,%rdi
  80042118b8:	00 00 00 
  80042118bb:	48 b8 ab 5a 21 04 80 	movabs $0x8004215aab,%rax
  80042118c2:	00 00 00 
  80042118c5:	ff d0                	callq  *%rax
  80042118c7:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	uint8_t *ds_data = (uint8_t *)ds->ds_data; //(uint8_t *)dbg->dbg_info_offset_elf;
  80042118cb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042118cf:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042118d3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uint8_t dwarf_size = cu->cu_dwarf_size;
  80042118d7:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042118de:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  80042118e2:	88 45 e7             	mov    %al,-0x19(%rbp)

	ret = DW_DLE_NONE;
  80042118e5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	memset(&atref, 0, sizeof(atref));
  80042118ec:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  80042118f3:	ba 60 00 00 00       	mov    $0x60,%edx
  80042118f8:	be 00 00 00 00       	mov    $0x0,%esi
  80042118fd:	48 89 c7             	mov    %rax,%rdi
  8004211900:	48 b8 d4 03 21 04 80 	movabs $0x80042103d4,%rax
  8004211907:	00 00 00 
  800421190a:	ff d0                	callq  *%rax
	atref.at_die = ret_die;
  800421190c:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004211913:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
	atref.at_attrib = ad->ad_attrib;
  800421191a:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004211921:	48 8b 00             	mov    (%rax),%rax
  8004211924:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	atref.at_form = ad->ad_form;
  8004211928:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  800421192f:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004211933:	48 89 45 88          	mov    %rax,-0x78(%rbp)
	atref.at_indirect = indirect;
  8004211937:	8b 45 10             	mov    0x10(%rbp),%eax
  800421193a:	89 45 90             	mov    %eax,-0x70(%rbp)
	atref.at_ld = NULL;
  800421193d:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  8004211944:	00 

	switch (form) {
  8004211945:	48 83 bd 40 ff ff ff 	cmpq   $0x20,-0xc0(%rbp)
  800421194c:	20 
  800421194d:	0f 87 82 04 00 00    	ja     8004211dd5 <_dwarf_attr_init+0x559>
  8004211953:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  800421195a:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004211961:	00 
  8004211962:	48 b8 10 b2 21 04 80 	movabs $0x800421b210,%rax
  8004211969:	00 00 00 
  800421196c:	48 01 d0             	add    %rdx,%rax
  800421196f:	48 8b 00             	mov    (%rax),%rax
  8004211972:	ff e0                	jmpq   *%rax
	case DW_FORM_addr:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
  8004211974:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421197b:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421197f:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  8004211986:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  800421198a:	0f b6 d2             	movzbl %dl,%edx
  800421198d:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004211994:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004211998:	48 89 cf             	mov    %rcx,%rdi
  800421199b:	ff d0                	callq  *%rax
  800421199d:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  80042119a1:	e9 37 04 00 00       	jmpq   8004211ddd <_dwarf_attr_init+0x561>
	case DW_FORM_block:
	case DW_FORM_exprloc:
		atref.u[0].u64 = _dwarf_read_uleb128(ds_data, offsetp);
  80042119a6:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  80042119ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042119b1:	48 89 d6             	mov    %rdx,%rsi
  80042119b4:	48 89 c7             	mov    %rax,%rdi
  80042119b7:	48 b8 e6 0e 21 04 80 	movabs $0x8004210ee6,%rax
  80042119be:	00 00 00 
  80042119c1:	ff d0                	callq  *%rax
  80042119c3:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  80042119c7:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  80042119cb:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  80042119d2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042119d6:	48 89 ce             	mov    %rcx,%rsi
  80042119d9:	48 89 c7             	mov    %rax,%rdi
  80042119dc:	48 b8 f3 10 21 04 80 	movabs $0x80042110f3,%rax
  80042119e3:	00 00 00 
  80042119e6:	ff d0                	callq  *%rax
  80042119e8:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  80042119ec:	e9 ec 03 00 00       	jmpq   8004211ddd <_dwarf_attr_init+0x561>
	case DW_FORM_block1:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 1);
  80042119f1:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042119f8:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042119fc:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004211a03:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004211a07:	ba 01 00 00 00       	mov    $0x1,%edx
  8004211a0c:	48 89 cf             	mov    %rcx,%rdi
  8004211a0f:	ff d0                	callq  *%rax
  8004211a11:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  8004211a15:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004211a19:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004211a20:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211a24:	48 89 ce             	mov    %rcx,%rsi
  8004211a27:	48 89 c7             	mov    %rax,%rdi
  8004211a2a:	48 b8 f3 10 21 04 80 	movabs $0x80042110f3,%rax
  8004211a31:	00 00 00 
  8004211a34:	ff d0                	callq  *%rax
  8004211a36:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  8004211a3a:	e9 9e 03 00 00       	jmpq   8004211ddd <_dwarf_attr_init+0x561>
	case DW_FORM_block2:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 2);
  8004211a3f:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211a46:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211a4a:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004211a51:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004211a55:	ba 02 00 00 00       	mov    $0x2,%edx
  8004211a5a:	48 89 cf             	mov    %rcx,%rdi
  8004211a5d:	ff d0                	callq  *%rax
  8004211a5f:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  8004211a63:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004211a67:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004211a6e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211a72:	48 89 ce             	mov    %rcx,%rsi
  8004211a75:	48 89 c7             	mov    %rax,%rdi
  8004211a78:	48 b8 f3 10 21 04 80 	movabs $0x80042110f3,%rax
  8004211a7f:	00 00 00 
  8004211a82:	ff d0                	callq  *%rax
  8004211a84:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  8004211a88:	e9 50 03 00 00       	jmpq   8004211ddd <_dwarf_attr_init+0x561>
	case DW_FORM_block4:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 4);
  8004211a8d:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211a94:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211a98:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004211a9f:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004211aa3:	ba 04 00 00 00       	mov    $0x4,%edx
  8004211aa8:	48 89 cf             	mov    %rcx,%rdi
  8004211aab:	ff d0                	callq  *%rax
  8004211aad:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  8004211ab1:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004211ab5:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004211abc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211ac0:	48 89 ce             	mov    %rcx,%rsi
  8004211ac3:	48 89 c7             	mov    %rax,%rdi
  8004211ac6:	48 b8 f3 10 21 04 80 	movabs $0x80042110f3,%rax
  8004211acd:	00 00 00 
  8004211ad0:	ff d0                	callq  *%rax
  8004211ad2:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  8004211ad6:	e9 02 03 00 00       	jmpq   8004211ddd <_dwarf_attr_init+0x561>
	case DW_FORM_data1:
	case DW_FORM_flag:
	case DW_FORM_ref1:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 1);
  8004211adb:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211ae2:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211ae6:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004211aed:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004211af1:	ba 01 00 00 00       	mov    $0x1,%edx
  8004211af6:	48 89 cf             	mov    %rcx,%rdi
  8004211af9:	ff d0                	callq  *%rax
  8004211afb:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004211aff:	e9 d9 02 00 00       	jmpq   8004211ddd <_dwarf_attr_init+0x561>
	case DW_FORM_data2:
	case DW_FORM_ref2:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 2);
  8004211b04:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211b0b:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211b0f:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004211b16:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004211b1a:	ba 02 00 00 00       	mov    $0x2,%edx
  8004211b1f:	48 89 cf             	mov    %rcx,%rdi
  8004211b22:	ff d0                	callq  *%rax
  8004211b24:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004211b28:	e9 b0 02 00 00       	jmpq   8004211ddd <_dwarf_attr_init+0x561>
	case DW_FORM_data4:
	case DW_FORM_ref4:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 4);
  8004211b2d:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211b34:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211b38:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004211b3f:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004211b43:	ba 04 00 00 00       	mov    $0x4,%edx
  8004211b48:	48 89 cf             	mov    %rcx,%rdi
  8004211b4b:	ff d0                	callq  *%rax
  8004211b4d:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004211b51:	e9 87 02 00 00       	jmpq   8004211ddd <_dwarf_attr_init+0x561>
	case DW_FORM_data8:
	case DW_FORM_ref8:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 8);
  8004211b56:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211b5d:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211b61:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004211b68:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004211b6c:	ba 08 00 00 00       	mov    $0x8,%edx
  8004211b71:	48 89 cf             	mov    %rcx,%rdi
  8004211b74:	ff d0                	callq  *%rax
  8004211b76:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004211b7a:	e9 5e 02 00 00       	jmpq   8004211ddd <_dwarf_attr_init+0x561>
	case DW_FORM_indirect:
		form = _dwarf_read_uleb128(ds_data, offsetp);
  8004211b7f:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004211b86:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211b8a:	48 89 d6             	mov    %rdx,%rsi
  8004211b8d:	48 89 c7             	mov    %rax,%rdi
  8004211b90:	48 b8 e6 0e 21 04 80 	movabs $0x8004210ee6,%rax
  8004211b97:	00 00 00 
  8004211b9a:	ff d0                	callq  *%rax
  8004211b9c:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
		return (_dwarf_attr_init(dbg, offsetp, cu, ret_die, ad, form, 1));
  8004211ba3:	4c 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%r8
  8004211baa:	48 8b bd 48 ff ff ff 	mov    -0xb8(%rbp),%rdi
  8004211bb1:	48 8b 8d 50 ff ff ff 	mov    -0xb0(%rbp),%rcx
  8004211bb8:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  8004211bbf:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004211bc6:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211bcd:	c7 04 24 01 00 00 00 	movl   $0x1,(%rsp)
  8004211bd4:	4d 89 c1             	mov    %r8,%r9
  8004211bd7:	49 89 f8             	mov    %rdi,%r8
  8004211bda:	48 89 c7             	mov    %rax,%rdi
  8004211bdd:	48 b8 7c 18 21 04 80 	movabs $0x800421187c,%rax
  8004211be4:	00 00 00 
  8004211be7:	ff d0                	callq  *%rax
  8004211be9:	e9 1d 03 00 00       	jmpq   8004211f0b <_dwarf_attr_init+0x68f>
	case DW_FORM_ref_addr:
		if (cu->version == 2)
  8004211bee:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004211bf5:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004211bf9:	66 83 f8 02          	cmp    $0x2,%ax
  8004211bfd:	75 2f                	jne    8004211c2e <_dwarf_attr_init+0x3b2>
			atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
  8004211bff:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211c06:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211c0a:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  8004211c11:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  8004211c15:	0f b6 d2             	movzbl %dl,%edx
  8004211c18:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004211c1f:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004211c23:	48 89 cf             	mov    %rcx,%rdi
  8004211c26:	ff d0                	callq  *%rax
  8004211c28:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  8004211c2c:	eb 39                	jmp    8004211c67 <_dwarf_attr_init+0x3eb>
		else if (cu->version == 3)
  8004211c2e:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004211c35:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004211c39:	66 83 f8 03          	cmp    $0x3,%ax
  8004211c3d:	75 28                	jne    8004211c67 <_dwarf_attr_init+0x3eb>
			atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  8004211c3f:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211c46:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211c4a:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  8004211c4e:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004211c55:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004211c59:	48 89 cf             	mov    %rcx,%rdi
  8004211c5c:	ff d0                	callq  *%rax
  8004211c5e:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004211c62:	e9 76 01 00 00       	jmpq   8004211ddd <_dwarf_attr_init+0x561>
  8004211c67:	e9 71 01 00 00       	jmpq   8004211ddd <_dwarf_attr_init+0x561>
	case DW_FORM_ref_udata:
	case DW_FORM_udata:
		atref.u[0].u64 = _dwarf_read_uleb128(ds_data, offsetp);
  8004211c6c:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004211c73:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211c77:	48 89 d6             	mov    %rdx,%rsi
  8004211c7a:	48 89 c7             	mov    %rax,%rdi
  8004211c7d:	48 b8 e6 0e 21 04 80 	movabs $0x8004210ee6,%rax
  8004211c84:	00 00 00 
  8004211c87:	ff d0                	callq  *%rax
  8004211c89:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004211c8d:	e9 4b 01 00 00       	jmpq   8004211ddd <_dwarf_attr_init+0x561>
	case DW_FORM_sdata:
		atref.u[0].s64 = _dwarf_read_sleb128(ds_data, offsetp);
  8004211c92:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004211c99:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211c9d:	48 89 d6             	mov    %rdx,%rsi
  8004211ca0:	48 89 c7             	mov    %rax,%rdi
  8004211ca3:	48 b8 42 0e 21 04 80 	movabs $0x8004210e42,%rax
  8004211caa:	00 00 00 
  8004211cad:	ff d0                	callq  *%rax
  8004211caf:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004211cb3:	e9 25 01 00 00       	jmpq   8004211ddd <_dwarf_attr_init+0x561>
	case DW_FORM_sec_offset:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  8004211cb8:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211cbf:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211cc3:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  8004211cc7:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004211cce:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004211cd2:	48 89 cf             	mov    %rcx,%rdi
  8004211cd5:	ff d0                	callq  *%rax
  8004211cd7:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004211cdb:	e9 fd 00 00 00       	jmpq   8004211ddd <_dwarf_attr_init+0x561>
	case DW_FORM_string:
		atref.u[0].s =(char*) _dwarf_read_string(ds_data, (uint64_t)ds->ds_size, offsetp);
  8004211ce0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211ce4:	48 8b 48 18          	mov    0x18(%rax),%rcx
  8004211ce8:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004211cef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211cf3:	48 89 ce             	mov    %rcx,%rsi
  8004211cf6:	48 89 c7             	mov    %rax,%rdi
  8004211cf9:	48 b8 64 10 21 04 80 	movabs $0x8004211064,%rax
  8004211d00:	00 00 00 
  8004211d03:	ff d0                	callq  *%rax
  8004211d05:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004211d09:	e9 cf 00 00 00       	jmpq   8004211ddd <_dwarf_attr_init+0x561>
	case DW_FORM_strp:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  8004211d0e:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211d15:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211d19:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  8004211d1d:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004211d24:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004211d28:	48 89 cf             	mov    %rcx,%rdi
  8004211d2b:	ff d0                	callq  *%rax
  8004211d2d:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		str = _dwarf_find_section(".debug_str");
  8004211d31:	48 bf f2 b1 21 04 80 	movabs $0x800421b1f2,%rdi
  8004211d38:	00 00 00 
  8004211d3b:	48 b8 ab 5a 21 04 80 	movabs $0x8004215aab,%rax
  8004211d42:	00 00 00 
  8004211d45:	ff d0                	callq  *%rax
  8004211d47:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		assert(str != NULL);
  8004211d4b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004211d50:	75 35                	jne    8004211d87 <_dwarf_attr_init+0x50b>
  8004211d52:	48 b9 fd b1 21 04 80 	movabs $0x800421b1fd,%rcx
  8004211d59:	00 00 00 
  8004211d5c:	48 ba 8a b1 21 04 80 	movabs $0x800421b18a,%rdx
  8004211d63:	00 00 00 
  8004211d66:	be 51 02 00 00       	mov    $0x251,%esi
  8004211d6b:	48 bf 9f b1 21 04 80 	movabs $0x800421b19f,%rdi
  8004211d72:	00 00 00 
  8004211d75:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211d7a:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004211d81:	00 00 00 
  8004211d84:	41 ff d0             	callq  *%r8
		//atref.u[1].s = (char *)(elf_base_ptr + str->sh_offset) + atref.u[0].u64;
		atref.u[1].s = (char *)str->ds_data + atref.u[0].u64;
  8004211d87:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211d8b:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004211d8f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211d93:	48 01 d0             	add    %rdx,%rax
  8004211d96:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  8004211d9a:	eb 41                	jmp    8004211ddd <_dwarf_attr_init+0x561>
	case DW_FORM_ref_sig8:
		atref.u[0].u64 = 8;
  8004211d9c:	48 c7 45 98 08 00 00 	movq   $0x8,-0x68(%rbp)
  8004211da3:	00 
		atref.u[1].u8p = (uint8_t*)(_dwarf_read_block(ds_data, offsetp, atref.u[0].u64));
  8004211da4:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004211da8:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004211daf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211db3:	48 89 ce             	mov    %rcx,%rsi
  8004211db6:	48 89 c7             	mov    %rax,%rdi
  8004211db9:	48 b8 f3 10 21 04 80 	movabs $0x80042110f3,%rax
  8004211dc0:	00 00 00 
  8004211dc3:	ff d0                	callq  *%rax
  8004211dc5:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  8004211dc9:	eb 12                	jmp    8004211ddd <_dwarf_attr_init+0x561>
	case DW_FORM_flag_present:
		/* This form has no value encoded in the DIE. */
		atref.u[0].u64 = 1;
  8004211dcb:	48 c7 45 98 01 00 00 	movq   $0x1,-0x68(%rbp)
  8004211dd2:	00 
		break;
  8004211dd3:	eb 08                	jmp    8004211ddd <_dwarf_attr_init+0x561>
	default:
		//DWARF_SET_ERROR(dbg, error, DW_DLE_ATTR_FORM_BAD);
		ret = DW_DLE_ATTR_FORM_BAD;
  8004211dd5:	c7 45 fc 0e 00 00 00 	movl   $0xe,-0x4(%rbp)
		break;
  8004211ddc:	90                   	nop
	}

	if (ret == DW_DLE_NONE) {
  8004211ddd:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004211de1:	0f 85 21 01 00 00    	jne    8004211f08 <_dwarf_attr_init+0x68c>
		if (form == DW_FORM_block || form == DW_FORM_block1 ||
  8004211de7:	48 83 bd 40 ff ff ff 	cmpq   $0x9,-0xc0(%rbp)
  8004211dee:	09 
  8004211def:	74 1e                	je     8004211e0f <_dwarf_attr_init+0x593>
  8004211df1:	48 83 bd 40 ff ff ff 	cmpq   $0xa,-0xc0(%rbp)
  8004211df8:	0a 
  8004211df9:	74 14                	je     8004211e0f <_dwarf_attr_init+0x593>
  8004211dfb:	48 83 bd 40 ff ff ff 	cmpq   $0x3,-0xc0(%rbp)
  8004211e02:	03 
  8004211e03:	74 0a                	je     8004211e0f <_dwarf_attr_init+0x593>
		    form == DW_FORM_block2 || form == DW_FORM_block4) {
  8004211e05:	48 83 bd 40 ff ff ff 	cmpq   $0x4,-0xc0(%rbp)
  8004211e0c:	04 
  8004211e0d:	75 10                	jne    8004211e1f <_dwarf_attr_init+0x5a3>
			atref.at_block.bl_len = atref.u[0].u64;
  8004211e0f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211e13:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			atref.at_block.bl_data = atref.u[1].u8p;
  8004211e17:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004211e1b:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
		}
		//ret = _dwarf_attr_add(die, &atref, NULL, error);
		if (atref.at_attrib == DW_AT_name) {
  8004211e1f:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004211e23:	48 83 f8 03          	cmp    $0x3,%rax
  8004211e27:	75 39                	jne    8004211e62 <_dwarf_attr_init+0x5e6>
			switch (atref.at_form) {
  8004211e29:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004211e2d:	48 83 f8 08          	cmp    $0x8,%rax
  8004211e31:	74 1c                	je     8004211e4f <_dwarf_attr_init+0x5d3>
  8004211e33:	48 83 f8 0e          	cmp    $0xe,%rax
  8004211e37:	74 02                	je     8004211e3b <_dwarf_attr_init+0x5bf>
				break;
			case DW_FORM_string:
				ret_die->die_name = atref.u[0].s;
				break;
			default:
				break;
  8004211e39:	eb 27                	jmp    8004211e62 <_dwarf_attr_init+0x5e6>
		}
		//ret = _dwarf_attr_add(die, &atref, NULL, error);
		if (atref.at_attrib == DW_AT_name) {
			switch (atref.at_form) {
			case DW_FORM_strp:
				ret_die->die_name = atref.u[1].s;
  8004211e3b:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004211e3f:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004211e46:	48 89 90 50 03 00 00 	mov    %rdx,0x350(%rax)
				break;
  8004211e4d:	eb 13                	jmp    8004211e62 <_dwarf_attr_init+0x5e6>
			case DW_FORM_string:
				ret_die->die_name = atref.u[0].s;
  8004211e4f:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004211e53:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004211e5a:	48 89 90 50 03 00 00 	mov    %rdx,0x350(%rax)
				break;
  8004211e61:	90                   	nop
			default:
				break;
			}
		}
		ret_die->die_attr[ret_die->die_attr_count++] = atref;
  8004211e62:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004211e69:	0f b6 80 58 03 00 00 	movzbl 0x358(%rax),%eax
  8004211e70:	8d 48 01             	lea    0x1(%rax),%ecx
  8004211e73:	48 8b 95 50 ff ff ff 	mov    -0xb0(%rbp),%rdx
  8004211e7a:	88 8a 58 03 00 00    	mov    %cl,0x358(%rdx)
  8004211e80:	0f b6 c0             	movzbl %al,%eax
  8004211e83:	48 8b 8d 50 ff ff ff 	mov    -0xb0(%rbp),%rcx
  8004211e8a:	48 63 d0             	movslq %eax,%rdx
  8004211e8d:	48 89 d0             	mov    %rdx,%rax
  8004211e90:	48 01 c0             	add    %rax,%rax
  8004211e93:	48 01 d0             	add    %rdx,%rax
  8004211e96:	48 c1 e0 05          	shl    $0x5,%rax
  8004211e9a:	48 01 c8             	add    %rcx,%rax
  8004211e9d:	48 05 70 03 00 00    	add    $0x370,%rax
  8004211ea3:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004211eaa:	48 89 10             	mov    %rdx,(%rax)
  8004211ead:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  8004211eb4:	48 89 50 08          	mov    %rdx,0x8(%rax)
  8004211eb8:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004211ebc:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004211ec0:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  8004211ec4:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004211ec8:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8004211ecc:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004211ed0:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004211ed4:	48 89 50 28          	mov    %rdx,0x28(%rax)
  8004211ed8:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004211edc:	48 89 50 30          	mov    %rdx,0x30(%rax)
  8004211ee0:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004211ee4:	48 89 50 38          	mov    %rdx,0x38(%rax)
  8004211ee8:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004211eec:	48 89 50 40          	mov    %rdx,0x40(%rax)
  8004211ef0:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004211ef4:	48 89 50 48          	mov    %rdx,0x48(%rax)
  8004211ef8:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004211efc:	48 89 50 50          	mov    %rdx,0x50(%rax)
  8004211f00:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211f04:	48 89 50 58          	mov    %rdx,0x58(%rax)
	}

	return (ret);
  8004211f08:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004211f0b:	c9                   	leaveq 
  8004211f0c:	c3                   	retq   

0000008004211f0d <dwarf_search_die_within_cu>:

int
dwarf_search_die_within_cu(Dwarf_Debug dbg, Dwarf_CU cu, uint64_t offset, Dwarf_Die *ret_die, int search_sibling)
{
  8004211f0d:	55                   	push   %rbp
  8004211f0e:	48 89 e5             	mov    %rsp,%rbp
  8004211f11:	48 81 ec d0 03 00 00 	sub    $0x3d0,%rsp
  8004211f18:	48 89 bd 88 fc ff ff 	mov    %rdi,-0x378(%rbp)
  8004211f1f:	48 89 b5 80 fc ff ff 	mov    %rsi,-0x380(%rbp)
  8004211f26:	48 89 95 78 fc ff ff 	mov    %rdx,-0x388(%rbp)
  8004211f2d:	89 8d 74 fc ff ff    	mov    %ecx,-0x38c(%rbp)
	uint64_t abnum;
	uint64_t die_offset;
	int ret, level;
	int i;

	assert(dbg);
  8004211f33:	48 83 bd 88 fc ff ff 	cmpq   $0x0,-0x378(%rbp)
  8004211f3a:	00 
  8004211f3b:	75 35                	jne    8004211f72 <dwarf_search_die_within_cu+0x65>
  8004211f3d:	48 b9 18 b3 21 04 80 	movabs $0x800421b318,%rcx
  8004211f44:	00 00 00 
  8004211f47:	48 ba 8a b1 21 04 80 	movabs $0x800421b18a,%rdx
  8004211f4e:	00 00 00 
  8004211f51:	be 86 02 00 00       	mov    $0x286,%esi
  8004211f56:	48 bf 9f b1 21 04 80 	movabs $0x800421b19f,%rdi
  8004211f5d:	00 00 00 
  8004211f60:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211f65:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004211f6c:	00 00 00 
  8004211f6f:	41 ff d0             	callq  *%r8
	//assert(cu);
	assert(ret_die);
  8004211f72:	48 83 bd 78 fc ff ff 	cmpq   $0x0,-0x388(%rbp)
  8004211f79:	00 
  8004211f7a:	75 35                	jne    8004211fb1 <dwarf_search_die_within_cu+0xa4>
  8004211f7c:	48 b9 1c b3 21 04 80 	movabs $0x800421b31c,%rcx
  8004211f83:	00 00 00 
  8004211f86:	48 ba 8a b1 21 04 80 	movabs $0x800421b18a,%rdx
  8004211f8d:	00 00 00 
  8004211f90:	be 88 02 00 00       	mov    $0x288,%esi
  8004211f95:	48 bf 9f b1 21 04 80 	movabs $0x800421b19f,%rdi
  8004211f9c:	00 00 00 
  8004211f9f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211fa4:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004211fab:	00 00 00 
  8004211fae:	41 ff d0             	callq  *%r8

	level = 1;
  8004211fb1:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	while (offset < cu.cu_next_offset && offset < dbg->dbg_info_size) {
  8004211fb8:	e9 17 02 00 00       	jmpq   80042121d4 <dwarf_search_die_within_cu+0x2c7>

		die_offset = offset;
  8004211fbd:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  8004211fc4:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

		abnum = _dwarf_read_uleb128((uint8_t *)dbg->dbg_info_offset_elf, &offset);
  8004211fc8:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  8004211fcf:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004211fd3:	48 8d 95 80 fc ff ff 	lea    -0x380(%rbp),%rdx
  8004211fda:	48 89 d6             	mov    %rdx,%rsi
  8004211fdd:	48 89 c7             	mov    %rax,%rdi
  8004211fe0:	48 b8 e6 0e 21 04 80 	movabs $0x8004210ee6,%rax
  8004211fe7:	00 00 00 
  8004211fea:	ff d0                	callq  *%rax
  8004211fec:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

		if (abnum == 0) {
  8004211ff0:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004211ff5:	75 22                	jne    8004212019 <dwarf_search_die_within_cu+0x10c>
			if (level == 0 || !search_sibling) {
  8004211ff7:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004211ffb:	74 09                	je     8004212006 <dwarf_search_die_within_cu+0xf9>
  8004211ffd:	83 bd 74 fc ff ff 00 	cmpl   $0x0,-0x38c(%rbp)
  8004212004:	75 0a                	jne    8004212010 <dwarf_search_die_within_cu+0x103>
				//No more entry
				return (DW_DLE_NO_ENTRY);
  8004212006:	b8 04 00 00 00       	mov    $0x4,%eax
  800421200b:	e9 f4 01 00 00       	jmpq   8004212204 <dwarf_search_die_within_cu+0x2f7>
			}
			/*
			 * Return to previous DIE level.
			 */
			level--;
  8004212010:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
			continue;
  8004212014:	e9 bb 01 00 00       	jmpq   80042121d4 <dwarf_search_die_within_cu+0x2c7>
		}

		if ((ret = _dwarf_abbrev_find(dbg, cu, abnum, &ab)) != DW_DLE_NONE)
  8004212019:	48 8d 95 b0 fc ff ff 	lea    -0x350(%rbp),%rdx
  8004212020:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004212024:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  800421202b:	48 8b 75 10          	mov    0x10(%rbp),%rsi
  800421202f:	48 89 34 24          	mov    %rsi,(%rsp)
  8004212033:	48 8b 75 18          	mov    0x18(%rbp),%rsi
  8004212037:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
  800421203c:	48 8b 75 20          	mov    0x20(%rbp),%rsi
  8004212040:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
  8004212045:	48 8b 75 28          	mov    0x28(%rbp),%rsi
  8004212049:	48 89 74 24 18       	mov    %rsi,0x18(%rsp)
  800421204e:	48 8b 75 30          	mov    0x30(%rbp),%rsi
  8004212052:	48 89 74 24 20       	mov    %rsi,0x20(%rsp)
  8004212057:	48 8b 75 38          	mov    0x38(%rbp),%rsi
  800421205b:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
  8004212060:	48 8b 75 40          	mov    0x40(%rbp),%rsi
  8004212064:	48 89 74 24 30       	mov    %rsi,0x30(%rsp)
  8004212069:	48 89 ce             	mov    %rcx,%rsi
  800421206c:	48 89 c7             	mov    %rax,%rdi
  800421206f:	48 b8 4b 17 21 04 80 	movabs $0x800421174b,%rax
  8004212076:	00 00 00 
  8004212079:	ff d0                	callq  *%rax
  800421207b:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  800421207e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004212082:	74 08                	je     800421208c <dwarf_search_die_within_cu+0x17f>
			return (ret);
  8004212084:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004212087:	e9 78 01 00 00       	jmpq   8004212204 <dwarf_search_die_within_cu+0x2f7>
		ret_die->die_offset = die_offset;
  800421208c:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004212093:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004212097:	48 89 10             	mov    %rdx,(%rax)
		ret_die->die_abnum  = abnum;
  800421209a:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  80042120a1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042120a5:	48 89 50 10          	mov    %rdx,0x10(%rax)
		ret_die->die_ab  = ab;
  80042120a9:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  80042120b0:	48 8d 78 20          	lea    0x20(%rax),%rdi
  80042120b4:	48 8d 95 b0 fc ff ff 	lea    -0x350(%rbp),%rdx
  80042120bb:	b8 66 00 00 00       	mov    $0x66,%eax
  80042120c0:	48 89 d6             	mov    %rdx,%rsi
  80042120c3:	48 89 c1             	mov    %rax,%rcx
  80042120c6:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
		ret_die->die_attr_count = 0;
  80042120c9:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  80042120d0:	c6 80 58 03 00 00 00 	movb   $0x0,0x358(%rax)
		ret_die->die_tag = ab.ab_tag;
  80042120d7:	48 8b 95 b8 fc ff ff 	mov    -0x348(%rbp),%rdx
  80042120de:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  80042120e5:	48 89 50 18          	mov    %rdx,0x18(%rax)
		//ret_die->die_cu  = cu;
		//ret_die->die_dbg = cu->cu_dbg;

		for(i=0; i < ab.ab_atnum; i++)
  80042120e9:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  80042120f0:	e9 8e 00 00 00       	jmpq   8004212183 <dwarf_search_die_within_cu+0x276>
		{
			if ((ret = _dwarf_attr_init(dbg, &offset, &cu, ret_die, &ab.ab_attrdef[i], ab.ab_attrdef[i].ad_form, 0)) != DW_DLE_NONE)
  80042120f5:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042120f8:	48 63 d0             	movslq %eax,%rdx
  80042120fb:	48 89 d0             	mov    %rdx,%rax
  80042120fe:	48 01 c0             	add    %rax,%rax
  8004212101:	48 01 d0             	add    %rdx,%rax
  8004212104:	48 c1 e0 03          	shl    $0x3,%rax
  8004212108:	48 01 e8             	add    %rbp,%rax
  800421210b:	48 2d 18 03 00 00    	sub    $0x318,%rax
  8004212111:	48 8b 08             	mov    (%rax),%rcx
  8004212114:	48 8d b5 b0 fc ff ff 	lea    -0x350(%rbp),%rsi
  800421211b:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421211e:	48 63 d0             	movslq %eax,%rdx
  8004212121:	48 89 d0             	mov    %rdx,%rax
  8004212124:	48 01 c0             	add    %rax,%rax
  8004212127:	48 01 d0             	add    %rdx,%rax
  800421212a:	48 c1 e0 03          	shl    $0x3,%rax
  800421212e:	48 83 c0 30          	add    $0x30,%rax
  8004212132:	48 8d 3c 06          	lea    (%rsi,%rax,1),%rdi
  8004212136:	48 8b 95 78 fc ff ff 	mov    -0x388(%rbp),%rdx
  800421213d:	48 8d b5 80 fc ff ff 	lea    -0x380(%rbp),%rsi
  8004212144:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  800421214b:	c7 04 24 00 00 00 00 	movl   $0x0,(%rsp)
  8004212152:	49 89 c9             	mov    %rcx,%r9
  8004212155:	49 89 f8             	mov    %rdi,%r8
  8004212158:	48 89 d1             	mov    %rdx,%rcx
  800421215b:	48 8d 55 10          	lea    0x10(%rbp),%rdx
  800421215f:	48 89 c7             	mov    %rax,%rdi
  8004212162:	48 b8 7c 18 21 04 80 	movabs $0x800421187c,%rax
  8004212169:	00 00 00 
  800421216c:	ff d0                	callq  *%rax
  800421216e:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004212171:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004212175:	74 08                	je     800421217f <dwarf_search_die_within_cu+0x272>
				return (ret);
  8004212177:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421217a:	e9 85 00 00 00       	jmpq   8004212204 <dwarf_search_die_within_cu+0x2f7>
		ret_die->die_attr_count = 0;
		ret_die->die_tag = ab.ab_tag;
		//ret_die->die_cu  = cu;
		//ret_die->die_dbg = cu->cu_dbg;

		for(i=0; i < ab.ab_atnum; i++)
  800421217f:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  8004212183:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004212186:	48 63 d0             	movslq %eax,%rdx
  8004212189:	48 8b 85 d8 fc ff ff 	mov    -0x328(%rbp),%rax
  8004212190:	48 39 c2             	cmp    %rax,%rdx
  8004212193:	0f 82 5c ff ff ff    	jb     80042120f5 <dwarf_search_die_within_cu+0x1e8>
		{
			if ((ret = _dwarf_attr_init(dbg, &offset, &cu, ret_die, &ab.ab_attrdef[i], ab.ab_attrdef[i].ad_form, 0)) != DW_DLE_NONE)
				return (ret);
		}

		ret_die->die_next_off = offset;
  8004212199:	48 8b 95 80 fc ff ff 	mov    -0x380(%rbp),%rdx
  80042121a0:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  80042121a7:	48 89 50 08          	mov    %rdx,0x8(%rax)
		if (search_sibling && level > 0) {
  80042121ab:	83 bd 74 fc ff ff 00 	cmpl   $0x0,-0x38c(%rbp)
  80042121b2:	74 19                	je     80042121cd <dwarf_search_die_within_cu+0x2c0>
  80042121b4:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042121b8:	7e 13                	jle    80042121cd <dwarf_search_die_within_cu+0x2c0>
			//dwarf_dealloc(dbg, die, DW_DLA_DIE);
			if (ab.ab_children == DW_CHILDREN_yes) {
  80042121ba:	0f b6 85 c0 fc ff ff 	movzbl -0x340(%rbp),%eax
  80042121c1:	3c 01                	cmp    $0x1,%al
  80042121c3:	75 06                	jne    80042121cb <dwarf_search_die_within_cu+0x2be>
				/* Advance to next DIE level. */
				level++;
  80042121c5:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
		}

		ret_die->die_next_off = offset;
		if (search_sibling && level > 0) {
			//dwarf_dealloc(dbg, die, DW_DLA_DIE);
			if (ab.ab_children == DW_CHILDREN_yes) {
  80042121c9:	eb 09                	jmp    80042121d4 <dwarf_search_die_within_cu+0x2c7>
  80042121cb:	eb 07                	jmp    80042121d4 <dwarf_search_die_within_cu+0x2c7>
				/* Advance to next DIE level. */
				level++;
			}
		} else {
			//*ret_die = die;
			return (DW_DLE_NONE);
  80042121cd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042121d2:	eb 30                	jmp    8004212204 <dwarf_search_die_within_cu+0x2f7>
	//assert(cu);
	assert(ret_die);

	level = 1;

	while (offset < cu.cu_next_offset && offset < dbg->dbg_info_size) {
  80042121d4:	48 8b 55 30          	mov    0x30(%rbp),%rdx
  80042121d8:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  80042121df:	48 39 c2             	cmp    %rax,%rdx
  80042121e2:	76 1b                	jbe    80042121ff <dwarf_search_die_within_cu+0x2f2>
  80042121e4:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  80042121eb:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042121ef:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  80042121f6:	48 39 c2             	cmp    %rax,%rdx
  80042121f9:	0f 87 be fd ff ff    	ja     8004211fbd <dwarf_search_die_within_cu+0xb0>
			//*ret_die = die;
			return (DW_DLE_NONE);
		}
	}

	return (DW_DLE_NO_ENTRY);
  80042121ff:	b8 04 00 00 00       	mov    $0x4,%eax
}
  8004212204:	c9                   	leaveq 
  8004212205:	c3                   	retq   

0000008004212206 <dwarf_offdie>:

//Return 0 on success
int
dwarf_offdie(Dwarf_Debug dbg, uint64_t offset, Dwarf_Die *ret_die, Dwarf_CU cu)
{
  8004212206:	55                   	push   %rbp
  8004212207:	48 89 e5             	mov    %rsp,%rbp
  800421220a:	48 83 ec 60          	sub    $0x60,%rsp
  800421220e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004212212:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004212216:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int ret;

	assert(dbg);
  800421221a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800421221f:	75 35                	jne    8004212256 <dwarf_offdie+0x50>
  8004212221:	48 b9 18 b3 21 04 80 	movabs $0x800421b318,%rcx
  8004212228:	00 00 00 
  800421222b:	48 ba 8a b1 21 04 80 	movabs $0x800421b18a,%rdx
  8004212232:	00 00 00 
  8004212235:	be c4 02 00 00       	mov    $0x2c4,%esi
  800421223a:	48 bf 9f b1 21 04 80 	movabs $0x800421b19f,%rdi
  8004212241:	00 00 00 
  8004212244:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212249:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004212250:	00 00 00 
  8004212253:	41 ff d0             	callq  *%r8
	assert(ret_die);
  8004212256:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800421225b:	75 35                	jne    8004212292 <dwarf_offdie+0x8c>
  800421225d:	48 b9 1c b3 21 04 80 	movabs $0x800421b31c,%rcx
  8004212264:	00 00 00 
  8004212267:	48 ba 8a b1 21 04 80 	movabs $0x800421b18a,%rdx
  800421226e:	00 00 00 
  8004212271:	be c5 02 00 00       	mov    $0x2c5,%esi
  8004212276:	48 bf 9f b1 21 04 80 	movabs $0x800421b19f,%rdi
  800421227d:	00 00 00 
  8004212280:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212285:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  800421228c:	00 00 00 
  800421228f:	41 ff d0             	callq  *%r8

	/* First search the current CU. */
	if (offset < cu.cu_next_offset) {
  8004212292:	48 8b 45 30          	mov    0x30(%rbp),%rax
  8004212296:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800421229a:	76 66                	jbe    8004212302 <dwarf_offdie+0xfc>
		ret = dwarf_search_die_within_cu(dbg, cu, offset, ret_die, 0);
  800421229c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042122a0:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  80042122a4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042122a8:	48 8b 4d 10          	mov    0x10(%rbp),%rcx
  80042122ac:	48 89 0c 24          	mov    %rcx,(%rsp)
  80042122b0:	48 8b 4d 18          	mov    0x18(%rbp),%rcx
  80042122b4:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
  80042122b9:	48 8b 4d 20          	mov    0x20(%rbp),%rcx
  80042122bd:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
  80042122c2:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  80042122c6:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
  80042122cb:	48 8b 4d 30          	mov    0x30(%rbp),%rcx
  80042122cf:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
  80042122d4:	48 8b 4d 38          	mov    0x38(%rbp),%rcx
  80042122d8:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
  80042122dd:	48 8b 4d 40          	mov    0x40(%rbp),%rcx
  80042122e1:	48 89 4c 24 30       	mov    %rcx,0x30(%rsp)
  80042122e6:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042122eb:	48 89 c7             	mov    %rax,%rdi
  80042122ee:	48 b8 0d 1f 21 04 80 	movabs $0x8004211f0d,%rax
  80042122f5:	00 00 00 
  80042122f8:	ff d0                	callq  *%rax
  80042122fa:	89 45 fc             	mov    %eax,-0x4(%rbp)
		return ret;
  80042122fd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004212300:	eb 05                	jmp    8004212307 <dwarf_offdie+0x101>
	}

	/*TODO: Search other CU*/
	return DW_DLV_OK;
  8004212302:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004212307:	c9                   	leaveq 
  8004212308:	c3                   	retq   

0000008004212309 <_dwarf_attr_find>:

Dwarf_Attribute*
_dwarf_attr_find(Dwarf_Die *die, uint16_t attr)
{
  8004212309:	55                   	push   %rbp
  800421230a:	48 89 e5             	mov    %rsp,%rbp
  800421230d:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004212311:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004212315:	89 f0                	mov    %esi,%eax
  8004212317:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
	Dwarf_Attribute *myat = NULL;
  800421231b:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004212322:	00 
	int i;
    
	for(i=0; i < die->die_attr_count; i++)
  8004212323:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  800421232a:	eb 57                	jmp    8004212383 <_dwarf_attr_find+0x7a>
	{
		if (die->die_attr[i].at_attrib == attr)
  800421232c:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004212330:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004212333:	48 63 d0             	movslq %eax,%rdx
  8004212336:	48 89 d0             	mov    %rdx,%rax
  8004212339:	48 01 c0             	add    %rax,%rax
  800421233c:	48 01 d0             	add    %rdx,%rax
  800421233f:	48 c1 e0 05          	shl    $0x5,%rax
  8004212343:	48 01 c8             	add    %rcx,%rax
  8004212346:	48 05 80 03 00 00    	add    $0x380,%rax
  800421234c:	48 8b 10             	mov    (%rax),%rdx
  800421234f:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  8004212353:	48 39 c2             	cmp    %rax,%rdx
  8004212356:	75 27                	jne    800421237f <_dwarf_attr_find+0x76>
		{
			myat = &(die->die_attr[i]);
  8004212358:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421235b:	48 63 d0             	movslq %eax,%rdx
  800421235e:	48 89 d0             	mov    %rdx,%rax
  8004212361:	48 01 c0             	add    %rax,%rax
  8004212364:	48 01 d0             	add    %rdx,%rax
  8004212367:	48 c1 e0 05          	shl    $0x5,%rax
  800421236b:	48 8d 90 70 03 00 00 	lea    0x370(%rax),%rdx
  8004212372:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212376:	48 01 d0             	add    %rdx,%rax
  8004212379:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  800421237d:	eb 17                	jmp    8004212396 <_dwarf_attr_find+0x8d>
_dwarf_attr_find(Dwarf_Die *die, uint16_t attr)
{
	Dwarf_Attribute *myat = NULL;
	int i;
    
	for(i=0; i < die->die_attr_count; i++)
  800421237f:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004212383:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212387:	0f b6 80 58 03 00 00 	movzbl 0x358(%rax),%eax
  800421238e:	0f b6 c0             	movzbl %al,%eax
  8004212391:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  8004212394:	7f 96                	jg     800421232c <_dwarf_attr_find+0x23>
			myat = &(die->die_attr[i]);
			break;
		}
	}

	return myat;
  8004212396:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800421239a:	c9                   	leaveq 
  800421239b:	c3                   	retq   

000000800421239c <dwarf_siblingof>:

//Return 0 on success
int
dwarf_siblingof(Dwarf_Debug dbg, Dwarf_Die *die, Dwarf_Die *ret_die,
		Dwarf_CU *cu)
{
  800421239c:	55                   	push   %rbp
  800421239d:	48 89 e5             	mov    %rsp,%rbp
  80042123a0:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  80042123a4:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042123a8:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80042123ac:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  80042123b0:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
	Dwarf_Attribute *at;
	uint64_t offset;
	int ret, search_sibling;

	assert(dbg);
  80042123b4:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042123b9:	75 35                	jne    80042123f0 <dwarf_siblingof+0x54>
  80042123bb:	48 b9 18 b3 21 04 80 	movabs $0x800421b318,%rcx
  80042123c2:	00 00 00 
  80042123c5:	48 ba 8a b1 21 04 80 	movabs $0x800421b18a,%rdx
  80042123cc:	00 00 00 
  80042123cf:	be ec 02 00 00       	mov    $0x2ec,%esi
  80042123d4:	48 bf 9f b1 21 04 80 	movabs $0x800421b19f,%rdi
  80042123db:	00 00 00 
  80042123de:	b8 00 00 00 00       	mov    $0x0,%eax
  80042123e3:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042123ea:	00 00 00 
  80042123ed:	41 ff d0             	callq  *%r8
	assert(ret_die);
  80042123f0:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  80042123f5:	75 35                	jne    800421242c <dwarf_siblingof+0x90>
  80042123f7:	48 b9 1c b3 21 04 80 	movabs $0x800421b31c,%rcx
  80042123fe:	00 00 00 
  8004212401:	48 ba 8a b1 21 04 80 	movabs $0x800421b18a,%rdx
  8004212408:	00 00 00 
  800421240b:	be ed 02 00 00       	mov    $0x2ed,%esi
  8004212410:	48 bf 9f b1 21 04 80 	movabs $0x800421b19f,%rdi
  8004212417:	00 00 00 
  800421241a:	b8 00 00 00 00       	mov    $0x0,%eax
  800421241f:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004212426:	00 00 00 
  8004212429:	41 ff d0             	callq  *%r8
	assert(cu);
  800421242c:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004212431:	75 35                	jne    8004212468 <dwarf_siblingof+0xcc>
  8004212433:	48 b9 24 b3 21 04 80 	movabs $0x800421b324,%rcx
  800421243a:	00 00 00 
  800421243d:	48 ba 8a b1 21 04 80 	movabs $0x800421b18a,%rdx
  8004212444:	00 00 00 
  8004212447:	be ee 02 00 00       	mov    $0x2ee,%esi
  800421244c:	48 bf 9f b1 21 04 80 	movabs $0x800421b19f,%rdi
  8004212453:	00 00 00 
  8004212456:	b8 00 00 00 00       	mov    $0x0,%eax
  800421245b:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004212462:	00 00 00 
  8004212465:	41 ff d0             	callq  *%r8

	/* Application requests the first DIE in this CU. */
	if (die == NULL)
  8004212468:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800421246d:	75 65                	jne    80042124d4 <dwarf_siblingof+0x138>
		return (dwarf_offdie(dbg, cu->cu_die_offset, ret_die, *cu));
  800421246f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212473:	48 8b 70 28          	mov    0x28(%rax),%rsi
  8004212477:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421247b:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800421247f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212483:	48 8b 38             	mov    (%rax),%rdi
  8004212486:	48 89 3c 24          	mov    %rdi,(%rsp)
  800421248a:	48 8b 78 08          	mov    0x8(%rax),%rdi
  800421248e:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  8004212493:	48 8b 78 10          	mov    0x10(%rax),%rdi
  8004212497:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800421249c:	48 8b 78 18          	mov    0x18(%rax),%rdi
  80042124a0:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  80042124a5:	48 8b 78 20          	mov    0x20(%rax),%rdi
  80042124a9:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  80042124ae:	48 8b 78 28          	mov    0x28(%rax),%rdi
  80042124b2:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  80042124b7:	48 8b 40 30          	mov    0x30(%rax),%rax
  80042124bb:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  80042124c0:	48 89 cf             	mov    %rcx,%rdi
  80042124c3:	48 b8 06 22 21 04 80 	movabs $0x8004212206,%rax
  80042124ca:	00 00 00 
  80042124cd:	ff d0                	callq  *%rax
  80042124cf:	e9 0a 01 00 00       	jmpq   80042125de <dwarf_siblingof+0x242>

	/*
	 * If the DIE doesn't have any children, its sibling sits next
	 * right to it.
	 */
	search_sibling = 0;
  80042124d4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	if (die->die_ab.ab_children == DW_CHILDREN_no)
  80042124db:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042124df:	0f b6 40 30          	movzbl 0x30(%rax),%eax
  80042124e3:	84 c0                	test   %al,%al
  80042124e5:	75 0e                	jne    80042124f5 <dwarf_siblingof+0x159>
		offset = die->die_next_off;
  80042124e7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042124eb:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042124ef:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042124f3:	eb 6b                	jmp    8004212560 <dwarf_siblingof+0x1c4>
	else {
		/*
		 * Look for DW_AT_sibling attribute for the offset of
		 * its sibling.
		 */
		if ((at = _dwarf_attr_find(die, DW_AT_sibling)) != NULL) {
  80042124f5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042124f9:	be 01 00 00 00       	mov    $0x1,%esi
  80042124fe:	48 89 c7             	mov    %rax,%rdi
  8004212501:	48 b8 09 23 21 04 80 	movabs $0x8004212309,%rax
  8004212508:	00 00 00 
  800421250b:	ff d0                	callq  *%rax
  800421250d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004212511:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004212516:	74 35                	je     800421254d <dwarf_siblingof+0x1b1>
			if (at->at_form != DW_FORM_ref_addr)
  8004212518:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421251c:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212520:	48 83 f8 10          	cmp    $0x10,%rax
  8004212524:	74 19                	je     800421253f <dwarf_siblingof+0x1a3>
				offset = at->u[0].u64 + cu->cu_offset;
  8004212526:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421252a:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800421252e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212532:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004212536:	48 01 d0             	add    %rdx,%rax
  8004212539:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421253d:	eb 21                	jmp    8004212560 <dwarf_siblingof+0x1c4>
			else
				offset = at->u[0].u64;
  800421253f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212543:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004212547:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421254b:	eb 13                	jmp    8004212560 <dwarf_siblingof+0x1c4>
		} else {
			offset = die->die_next_off;
  800421254d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212551:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212555:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			search_sibling = 1;
  8004212559:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)
		}
	}

	ret = dwarf_search_die_within_cu(dbg, *cu, offset, ret_die, search_sibling);
  8004212560:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  8004212563:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212567:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  800421256b:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
  800421256f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212573:	4c 8b 00             	mov    (%rax),%r8
  8004212576:	4c 89 04 24          	mov    %r8,(%rsp)
  800421257a:	4c 8b 40 08          	mov    0x8(%rax),%r8
  800421257e:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  8004212583:	4c 8b 40 10          	mov    0x10(%rax),%r8
  8004212587:	4c 89 44 24 10       	mov    %r8,0x10(%rsp)
  800421258c:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004212590:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
  8004212595:	4c 8b 40 20          	mov    0x20(%rax),%r8
  8004212599:	4c 89 44 24 20       	mov    %r8,0x20(%rsp)
  800421259e:	4c 8b 40 28          	mov    0x28(%rax),%r8
  80042125a2:	4c 89 44 24 28       	mov    %r8,0x28(%rsp)
  80042125a7:	48 8b 40 30          	mov    0x30(%rax),%rax
  80042125ab:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  80042125b0:	48 b8 0d 1f 21 04 80 	movabs $0x8004211f0d,%rax
  80042125b7:	00 00 00 
  80042125ba:	ff d0                	callq  *%rax
  80042125bc:	89 45 e4             	mov    %eax,-0x1c(%rbp)


	if (ret == DW_DLE_NO_ENTRY) {
  80042125bf:	83 7d e4 04          	cmpl   $0x4,-0x1c(%rbp)
  80042125c3:	75 07                	jne    80042125cc <dwarf_siblingof+0x230>
		return (DW_DLV_NO_ENTRY);
  80042125c5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042125ca:	eb 12                	jmp    80042125de <dwarf_siblingof+0x242>
	} else if (ret != DW_DLE_NONE)
  80042125cc:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  80042125d0:	74 07                	je     80042125d9 <dwarf_siblingof+0x23d>
		return (DW_DLV_ERROR);
  80042125d2:	b8 01 00 00 00       	mov    $0x1,%eax
  80042125d7:	eb 05                	jmp    80042125de <dwarf_siblingof+0x242>


	return (DW_DLV_OK);
  80042125d9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042125de:	c9                   	leaveq 
  80042125df:	c3                   	retq   

00000080042125e0 <dwarf_child>:

int
dwarf_child(Dwarf_Debug dbg, Dwarf_CU *cu, Dwarf_Die *die, Dwarf_Die *ret_die)
{
  80042125e0:	55                   	push   %rbp
  80042125e1:	48 89 e5             	mov    %rsp,%rbp
  80042125e4:	48 83 ec 70          	sub    $0x70,%rsp
  80042125e8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042125ec:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042125f0:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  80042125f4:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
	int ret;

	assert(die);
  80042125f8:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042125fd:	75 35                	jne    8004212634 <dwarf_child+0x54>
  80042125ff:	48 b9 27 b3 21 04 80 	movabs $0x800421b327,%rcx
  8004212606:	00 00 00 
  8004212609:	48 ba 8a b1 21 04 80 	movabs $0x800421b18a,%rdx
  8004212610:	00 00 00 
  8004212613:	be 1c 03 00 00       	mov    $0x31c,%esi
  8004212618:	48 bf 9f b1 21 04 80 	movabs $0x800421b19f,%rdi
  800421261f:	00 00 00 
  8004212622:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212627:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  800421262e:	00 00 00 
  8004212631:	41 ff d0             	callq  *%r8
	assert(ret_die);
  8004212634:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004212639:	75 35                	jne    8004212670 <dwarf_child+0x90>
  800421263b:	48 b9 1c b3 21 04 80 	movabs $0x800421b31c,%rcx
  8004212642:	00 00 00 
  8004212645:	48 ba 8a b1 21 04 80 	movabs $0x800421b18a,%rdx
  800421264c:	00 00 00 
  800421264f:	be 1d 03 00 00       	mov    $0x31d,%esi
  8004212654:	48 bf 9f b1 21 04 80 	movabs $0x800421b19f,%rdi
  800421265b:	00 00 00 
  800421265e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212663:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  800421266a:	00 00 00 
  800421266d:	41 ff d0             	callq  *%r8
	assert(dbg);
  8004212670:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004212675:	75 35                	jne    80042126ac <dwarf_child+0xcc>
  8004212677:	48 b9 18 b3 21 04 80 	movabs $0x800421b318,%rcx
  800421267e:	00 00 00 
  8004212681:	48 ba 8a b1 21 04 80 	movabs $0x800421b18a,%rdx
  8004212688:	00 00 00 
  800421268b:	be 1e 03 00 00       	mov    $0x31e,%esi
  8004212690:	48 bf 9f b1 21 04 80 	movabs $0x800421b19f,%rdi
  8004212697:	00 00 00 
  800421269a:	b8 00 00 00 00       	mov    $0x0,%eax
  800421269f:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042126a6:	00 00 00 
  80042126a9:	41 ff d0             	callq  *%r8
	assert(cu);
  80042126ac:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042126b1:	75 35                	jne    80042126e8 <dwarf_child+0x108>
  80042126b3:	48 b9 24 b3 21 04 80 	movabs $0x800421b324,%rcx
  80042126ba:	00 00 00 
  80042126bd:	48 ba 8a b1 21 04 80 	movabs $0x800421b18a,%rdx
  80042126c4:	00 00 00 
  80042126c7:	be 1f 03 00 00       	mov    $0x31f,%esi
  80042126cc:	48 bf 9f b1 21 04 80 	movabs $0x800421b19f,%rdi
  80042126d3:	00 00 00 
  80042126d6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042126db:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042126e2:	00 00 00 
  80042126e5:	41 ff d0             	callq  *%r8

	if (die->die_ab.ab_children == DW_CHILDREN_no)
  80042126e8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042126ec:	0f b6 40 30          	movzbl 0x30(%rax),%eax
  80042126f0:	84 c0                	test   %al,%al
  80042126f2:	75 0a                	jne    80042126fe <dwarf_child+0x11e>
		return (DW_DLE_NO_ENTRY);
  80042126f4:	b8 04 00 00 00       	mov    $0x4,%eax
  80042126f9:	e9 84 00 00 00       	jmpq   8004212782 <dwarf_child+0x1a2>

	ret = dwarf_search_die_within_cu(dbg, *cu, die->die_next_off, ret_die, 0);
  80042126fe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004212702:	48 8b 70 08          	mov    0x8(%rax),%rsi
  8004212706:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421270a:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  800421270e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212712:	48 8b 08             	mov    (%rax),%rcx
  8004212715:	48 89 0c 24          	mov    %rcx,(%rsp)
  8004212719:	48 8b 48 08          	mov    0x8(%rax),%rcx
  800421271d:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
  8004212722:	48 8b 48 10          	mov    0x10(%rax),%rcx
  8004212726:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
  800421272b:	48 8b 48 18          	mov    0x18(%rax),%rcx
  800421272f:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
  8004212734:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212738:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
  800421273d:	48 8b 48 28          	mov    0x28(%rax),%rcx
  8004212741:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
  8004212746:	48 8b 40 30          	mov    0x30(%rax),%rax
  800421274a:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800421274f:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004212754:	48 b8 0d 1f 21 04 80 	movabs $0x8004211f0d,%rax
  800421275b:	00 00 00 
  800421275e:	ff d0                	callq  *%rax
  8004212760:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if (ret == DW_DLE_NO_ENTRY) {
  8004212763:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  8004212767:	75 07                	jne    8004212770 <dwarf_child+0x190>
		DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
		return (DW_DLV_NO_ENTRY);
  8004212769:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800421276e:	eb 12                	jmp    8004212782 <dwarf_child+0x1a2>
	} else if (ret != DW_DLE_NONE)
  8004212770:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004212774:	74 07                	je     800421277d <dwarf_child+0x19d>
		return (DW_DLV_ERROR);
  8004212776:	b8 01 00 00 00       	mov    $0x1,%eax
  800421277b:	eb 05                	jmp    8004212782 <dwarf_child+0x1a2>

	return (DW_DLV_OK);
  800421277d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004212782:	c9                   	leaveq 
  8004212783:	c3                   	retq   

0000008004212784 <_dwarf_find_section_enhanced>:


int  _dwarf_find_section_enhanced(Dwarf_Section *ds)
{
  8004212784:	55                   	push   %rbp
  8004212785:	48 89 e5             	mov    %rsp,%rbp
  8004212788:	48 83 ec 20          	sub    $0x20,%rsp
  800421278c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Dwarf_Section *secthdr = _dwarf_find_section(ds->ds_name);
  8004212790:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212794:	48 8b 00             	mov    (%rax),%rax
  8004212797:	48 89 c7             	mov    %rax,%rdi
  800421279a:	48 b8 ab 5a 21 04 80 	movabs $0x8004215aab,%rax
  80042127a1:	00 00 00 
  80042127a4:	ff d0                	callq  *%rax
  80042127a6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	ds->ds_data = secthdr->ds_data;//(Dwarf_Small*)((uint8_t *)elf_base_ptr + secthdr->sh_offset);
  80042127aa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042127ae:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80042127b2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042127b6:	48 89 50 08          	mov    %rdx,0x8(%rax)
	ds->ds_addr = secthdr->ds_addr;
  80042127ba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042127be:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042127c2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042127c6:	48 89 50 10          	mov    %rdx,0x10(%rax)
	ds->ds_size = secthdr->ds_size;
  80042127ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042127ce:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042127d2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042127d6:	48 89 50 18          	mov    %rdx,0x18(%rax)
	return 0;
  80042127da:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042127df:	c9                   	leaveq 
  80042127e0:	c3                   	retq   

00000080042127e1 <_dwarf_frame_params_init>:

extern int  _dwarf_find_section_enhanced(Dwarf_Section *ds);

void
_dwarf_frame_params_init(Dwarf_Debug dbg)
{
  80042127e1:	55                   	push   %rbp
  80042127e2:	48 89 e5             	mov    %rsp,%rbp
  80042127e5:	48 83 ec 08          	sub    $0x8,%rsp
  80042127e9:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	/* Initialise call frame related parameters. */
	dbg->dbg_frame_rule_table_size = DW_FRAME_LAST_REG_NUM;
  80042127ed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042127f1:	66 c7 40 48 42 00    	movw   $0x42,0x48(%rax)
	dbg->dbg_frame_rule_initial_value = DW_FRAME_REG_INITIAL_VALUE;
  80042127f7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042127fb:	66 c7 40 4a 0b 04    	movw   $0x40b,0x4a(%rax)
	dbg->dbg_frame_cfa_value = DW_FRAME_CFA_COL3;
  8004212801:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212805:	66 c7 40 4c 9c 05    	movw   $0x59c,0x4c(%rax)
	dbg->dbg_frame_same_value = DW_FRAME_SAME_VAL;
  800421280b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421280f:	66 c7 40 4e 0b 04    	movw   $0x40b,0x4e(%rax)
	dbg->dbg_frame_undefined_value = DW_FRAME_UNDEFINED_VAL;
  8004212815:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212819:	66 c7 40 50 0a 04    	movw   $0x40a,0x50(%rax)
}
  800421281f:	c9                   	leaveq 
  8004212820:	c3                   	retq   

0000008004212821 <dwarf_get_fde_at_pc>:

int
dwarf_get_fde_at_pc(Dwarf_Debug dbg, Dwarf_Addr pc,
		    struct _Dwarf_Fde *ret_fde, Dwarf_Cie cie,
		    Dwarf_Error *error)
{
  8004212821:	55                   	push   %rbp
  8004212822:	48 89 e5             	mov    %rsp,%rbp
  8004212825:	48 83 ec 40          	sub    $0x40,%rsp
  8004212829:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421282d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004212831:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004212835:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  8004212839:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
	Dwarf_Fde fde = ret_fde;
  800421283d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004212841:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	memset(fde, 0, sizeof(struct _Dwarf_Fde));
  8004212845:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212849:	ba 80 00 00 00       	mov    $0x80,%edx
  800421284e:	be 00 00 00 00       	mov    $0x0,%esi
  8004212853:	48 89 c7             	mov    %rax,%rdi
  8004212856:	48 b8 d4 03 21 04 80 	movabs $0x80042103d4,%rax
  800421285d:	00 00 00 
  8004212860:	ff d0                	callq  *%rax
	fde->fde_cie = cie;
  8004212862:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212866:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421286a:	48 89 50 08          	mov    %rdx,0x8(%rax)
	
	if (ret_fde == NULL)
  800421286e:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004212873:	75 07                	jne    800421287c <dwarf_get_fde_at_pc+0x5b>
		return (DW_DLV_ERROR);
  8004212875:	b8 01 00 00 00       	mov    $0x1,%eax
  800421287a:	eb 75                	jmp    80042128f1 <dwarf_get_fde_at_pc+0xd0>

	while(dbg->curr_off_eh < dbg->dbg_eh_size) {
  800421287c:	eb 59                	jmp    80042128d7 <dwarf_get_fde_at_pc+0xb6>
		if (_dwarf_get_next_fde(dbg, true, error, fde) < 0)
  800421287e:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  8004212882:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212886:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421288a:	be 01 00 00 00       	mov    $0x1,%esi
  800421288f:	48 89 c7             	mov    %rax,%rdi
  8004212892:	48 b8 36 4a 21 04 80 	movabs $0x8004214a36,%rax
  8004212899:	00 00 00 
  800421289c:	ff d0                	callq  *%rax
  800421289e:	85 c0                	test   %eax,%eax
  80042128a0:	79 07                	jns    80042128a9 <dwarf_get_fde_at_pc+0x88>
		{
			return DW_DLV_NO_ENTRY;
  80042128a2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042128a7:	eb 48                	jmp    80042128f1 <dwarf_get_fde_at_pc+0xd0>
		}
		if (pc >= fde->fde_initloc && pc < fde->fde_initloc +
  80042128a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042128ad:	48 8b 40 30          	mov    0x30(%rax),%rax
  80042128b1:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  80042128b5:	77 20                	ja     80042128d7 <dwarf_get_fde_at_pc+0xb6>
  80042128b7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042128bb:	48 8b 50 30          	mov    0x30(%rax),%rdx
		    fde->fde_adrange)
  80042128bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042128c3:	48 8b 40 38          	mov    0x38(%rax),%rax
	while(dbg->curr_off_eh < dbg->dbg_eh_size) {
		if (_dwarf_get_next_fde(dbg, true, error, fde) < 0)
		{
			return DW_DLV_NO_ENTRY;
		}
		if (pc >= fde->fde_initloc && pc < fde->fde_initloc +
  80042128c7:	48 01 d0             	add    %rdx,%rax
  80042128ca:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  80042128ce:	76 07                	jbe    80042128d7 <dwarf_get_fde_at_pc+0xb6>
		    fde->fde_adrange)
			return (DW_DLV_OK);
  80042128d0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042128d5:	eb 1a                	jmp    80042128f1 <dwarf_get_fde_at_pc+0xd0>
	fde->fde_cie = cie;
	
	if (ret_fde == NULL)
		return (DW_DLV_ERROR);

	while(dbg->curr_off_eh < dbg->dbg_eh_size) {
  80042128d7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042128db:	48 8b 50 30          	mov    0x30(%rax),%rdx
  80042128df:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042128e3:	48 8b 40 40          	mov    0x40(%rax),%rax
  80042128e7:	48 39 c2             	cmp    %rax,%rdx
  80042128ea:	72 92                	jb     800421287e <dwarf_get_fde_at_pc+0x5d>
		    fde->fde_adrange)
			return (DW_DLV_OK);
	}

	DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
	return (DW_DLV_NO_ENTRY);
  80042128ec:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  80042128f1:	c9                   	leaveq 
  80042128f2:	c3                   	retq   

00000080042128f3 <_dwarf_frame_regtable_copy>:

int
_dwarf_frame_regtable_copy(Dwarf_Debug dbg, Dwarf_Regtable3 **dest,
			   Dwarf_Regtable3 *src, Dwarf_Error *error)
{
  80042128f3:	55                   	push   %rbp
  80042128f4:	48 89 e5             	mov    %rsp,%rbp
  80042128f7:	53                   	push   %rbx
  80042128f8:	48 83 ec 38          	sub    $0x38,%rsp
  80042128fc:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004212900:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004212904:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004212908:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
	int i;

	assert(dest != NULL);
  800421290c:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004212911:	75 35                	jne    8004212948 <_dwarf_frame_regtable_copy+0x55>
  8004212913:	48 b9 3a b3 21 04 80 	movabs $0x800421b33a,%rcx
  800421291a:	00 00 00 
  800421291d:	48 ba 47 b3 21 04 80 	movabs $0x800421b347,%rdx
  8004212924:	00 00 00 
  8004212927:	be 57 00 00 00       	mov    $0x57,%esi
  800421292c:	48 bf 5c b3 21 04 80 	movabs $0x800421b35c,%rdi
  8004212933:	00 00 00 
  8004212936:	b8 00 00 00 00       	mov    $0x0,%eax
  800421293b:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004212942:	00 00 00 
  8004212945:	41 ff d0             	callq  *%r8
	assert(src != NULL);
  8004212948:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800421294d:	75 35                	jne    8004212984 <_dwarf_frame_regtable_copy+0x91>
  800421294f:	48 b9 72 b3 21 04 80 	movabs $0x800421b372,%rcx
  8004212956:	00 00 00 
  8004212959:	48 ba 47 b3 21 04 80 	movabs $0x800421b347,%rdx
  8004212960:	00 00 00 
  8004212963:	be 58 00 00 00       	mov    $0x58,%esi
  8004212968:	48 bf 5c b3 21 04 80 	movabs $0x800421b35c,%rdi
  800421296f:	00 00 00 
  8004212972:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212977:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  800421297e:	00 00 00 
  8004212981:	41 ff d0             	callq  *%r8

	if (*dest == NULL) {
  8004212984:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212988:	48 8b 00             	mov    (%rax),%rax
  800421298b:	48 85 c0             	test   %rax,%rax
  800421298e:	75 39                	jne    80042129c9 <_dwarf_frame_regtable_copy+0xd6>
		*dest = &global_rt_table_shadow;
  8004212990:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212994:	48 bb e0 e6 49 04 80 	movabs $0x800449e6e0,%rbx
  800421299b:	00 00 00 
  800421299e:	48 89 18             	mov    %rbx,(%rax)
		(*dest)->rt3_reg_table_size = src->rt3_reg_table_size;
  80042129a1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042129a5:	48 8b 00             	mov    (%rax),%rax
  80042129a8:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042129ac:	0f b7 52 18          	movzwl 0x18(%rdx),%edx
  80042129b0:	66 89 50 18          	mov    %dx,0x18(%rax)
		(*dest)->rt3_rules = global_rules_shadow;
  80042129b4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042129b8:	48 8b 00             	mov    (%rax),%rax
  80042129bb:	48 bb e0 c7 69 04 80 	movabs $0x800469c7e0,%rbx
  80042129c2:	00 00 00 
  80042129c5:	48 89 58 20          	mov    %rbx,0x20(%rax)
	}

	memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
  80042129c9:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  80042129cd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042129d1:	48 8b 00             	mov    (%rax),%rax
  80042129d4:	ba 18 00 00 00       	mov    $0x18,%edx
  80042129d9:	48 89 ce             	mov    %rcx,%rsi
  80042129dc:	48 89 c7             	mov    %rax,%rdi
  80042129df:	48 b8 76 05 21 04 80 	movabs $0x8004210576,%rax
  80042129e6:	00 00 00 
  80042129e9:	ff d0                	callq  *%rax
	       sizeof(Dwarf_Regtable_Entry3));

	for (i = 0; i < (*dest)->rt3_reg_table_size &&
  80042129eb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  80042129f2:	eb 5a                	jmp    8004212a4e <_dwarf_frame_regtable_copy+0x15b>
		     i < src->rt3_reg_table_size; i++)
		memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
  80042129f4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042129f8:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042129fc:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042129ff:	48 63 d0             	movslq %eax,%rdx
  8004212a02:	48 89 d0             	mov    %rdx,%rax
  8004212a05:	48 01 c0             	add    %rax,%rax
  8004212a08:	48 01 d0             	add    %rdx,%rax
  8004212a0b:	48 c1 e0 03          	shl    $0x3,%rax
  8004212a0f:	48 01 c1             	add    %rax,%rcx
  8004212a12:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212a16:	48 8b 00             	mov    (%rax),%rax
  8004212a19:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004212a1d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004212a20:	48 63 d0             	movslq %eax,%rdx
  8004212a23:	48 89 d0             	mov    %rdx,%rax
  8004212a26:	48 01 c0             	add    %rax,%rax
  8004212a29:	48 01 d0             	add    %rdx,%rax
  8004212a2c:	48 c1 e0 03          	shl    $0x3,%rax
  8004212a30:	48 01 f0             	add    %rsi,%rax
  8004212a33:	ba 18 00 00 00       	mov    $0x18,%edx
  8004212a38:	48 89 ce             	mov    %rcx,%rsi
  8004212a3b:	48 89 c7             	mov    %rax,%rdi
  8004212a3e:	48 b8 76 05 21 04 80 	movabs $0x8004210576,%rax
  8004212a45:	00 00 00 
  8004212a48:	ff d0                	callq  *%rax

	memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

	for (i = 0; i < (*dest)->rt3_reg_table_size &&
		     i < src->rt3_reg_table_size; i++)
  8004212a4a:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
	}

	memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

	for (i = 0; i < (*dest)->rt3_reg_table_size &&
  8004212a4e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212a52:	48 8b 00             	mov    (%rax),%rax
  8004212a55:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212a59:	0f b7 c0             	movzwl %ax,%eax
  8004212a5c:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004212a5f:	7e 10                	jle    8004212a71 <_dwarf_frame_regtable_copy+0x17e>
		     i < src->rt3_reg_table_size; i++)
  8004212a61:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212a65:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212a69:	0f b7 c0             	movzwl %ax,%eax
	}

	memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

	for (i = 0; i < (*dest)->rt3_reg_table_size &&
  8004212a6c:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004212a6f:	7f 83                	jg     80042129f4 <_dwarf_frame_regtable_copy+0x101>
		     i < src->rt3_reg_table_size; i++)
		memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

	for (; i < (*dest)->rt3_reg_table_size; i++)
  8004212a71:	eb 32                	jmp    8004212aa5 <_dwarf_frame_regtable_copy+0x1b2>
		(*dest)->rt3_rules[i].dw_regnum =
  8004212a73:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212a77:	48 8b 00             	mov    (%rax),%rax
  8004212a7a:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212a7e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004212a81:	48 63 d0             	movslq %eax,%rdx
  8004212a84:	48 89 d0             	mov    %rdx,%rax
  8004212a87:	48 01 c0             	add    %rax,%rax
  8004212a8a:	48 01 d0             	add    %rdx,%rax
  8004212a8d:	48 c1 e0 03          	shl    $0x3,%rax
  8004212a91:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
			dbg->dbg_frame_undefined_value;
  8004212a95:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004212a99:	0f b7 40 50          	movzwl 0x50(%rax),%eax
		     i < src->rt3_reg_table_size; i++)
		memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

	for (; i < (*dest)->rt3_reg_table_size; i++)
		(*dest)->rt3_rules[i].dw_regnum =
  8004212a9d:	66 89 42 02          	mov    %ax,0x2(%rdx)
	for (i = 0; i < (*dest)->rt3_reg_table_size &&
		     i < src->rt3_reg_table_size; i++)
		memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

	for (; i < (*dest)->rt3_reg_table_size; i++)
  8004212aa1:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004212aa5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212aa9:	48 8b 00             	mov    (%rax),%rax
  8004212aac:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212ab0:	0f b7 c0             	movzwl %ax,%eax
  8004212ab3:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004212ab6:	7f bb                	jg     8004212a73 <_dwarf_frame_regtable_copy+0x180>
		(*dest)->rt3_rules[i].dw_regnum =
			dbg->dbg_frame_undefined_value;

	return (DW_DLE_NONE);
  8004212ab8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004212abd:	48 83 c4 38          	add    $0x38,%rsp
  8004212ac1:	5b                   	pop    %rbx
  8004212ac2:	5d                   	pop    %rbp
  8004212ac3:	c3                   	retq   

0000008004212ac4 <_dwarf_frame_run_inst>:

static int
_dwarf_frame_run_inst(Dwarf_Debug dbg, Dwarf_Regtable3 *rt, uint8_t *insts,
		      Dwarf_Unsigned len, Dwarf_Unsigned caf, Dwarf_Signed daf, Dwarf_Addr pc,
		      Dwarf_Addr pc_req, Dwarf_Addr *row_pc, Dwarf_Error *error)
{
  8004212ac4:	55                   	push   %rbp
  8004212ac5:	48 89 e5             	mov    %rsp,%rbp
  8004212ac8:	53                   	push   %rbx
  8004212ac9:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
  8004212ad0:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  8004212ad4:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
  8004212ad8:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
  8004212adc:	48 89 4d 80          	mov    %rcx,-0x80(%rbp)
  8004212ae0:	4c 89 85 78 ff ff ff 	mov    %r8,-0x88(%rbp)
  8004212ae7:	4c 89 8d 70 ff ff ff 	mov    %r9,-0x90(%rbp)
			ret = DW_DLE_DF_REG_NUM_TOO_HIGH;               \
			goto program_done;                              \
		}                                                       \
	} while(0)

	ret = DW_DLE_NONE;
  8004212aee:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
	init_rt = saved_rt = NULL;
  8004212af5:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  8004212afc:	00 
  8004212afd:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004212b01:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	*row_pc = pc;
  8004212b05:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212b09:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212b0d:	48 89 10             	mov    %rdx,(%rax)

	/* Save a copy of the table as initial state. */
	_dwarf_frame_regtable_copy(dbg, &init_rt, rt, error);
  8004212b10:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8004212b14:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  8004212b18:	48 8d 75 b0          	lea    -0x50(%rbp),%rsi
  8004212b1c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212b20:	48 89 c7             	mov    %rax,%rdi
  8004212b23:	48 b8 f3 28 21 04 80 	movabs $0x80042128f3,%rax
  8004212b2a:	00 00 00 
  8004212b2d:	ff d0                	callq  *%rax
	p = insts;
  8004212b2f:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004212b33:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
	pe = p + len;
  8004212b37:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004212b3b:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004212b3f:	48 01 d0             	add    %rdx,%rax
  8004212b42:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	while (p < pe) {
  8004212b46:	e9 3a 0d 00 00       	jmpq   8004213885 <_dwarf_frame_run_inst+0xdc1>
		if (*p == DW_CFA_nop) {
  8004212b4b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212b4f:	0f b6 00             	movzbl (%rax),%eax
  8004212b52:	84 c0                	test   %al,%al
  8004212b54:	75 11                	jne    8004212b67 <_dwarf_frame_run_inst+0xa3>
			p++;
  8004212b56:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212b5a:	48 83 c0 01          	add    $0x1,%rax
  8004212b5e:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			continue;
  8004212b62:	e9 1e 0d 00 00       	jmpq   8004213885 <_dwarf_frame_run_inst+0xdc1>
		}

		high2 = *p & 0xc0;
  8004212b67:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212b6b:	0f b6 00             	movzbl (%rax),%eax
  8004212b6e:	83 e0 c0             	and    $0xffffffc0,%eax
  8004212b71:	88 45 df             	mov    %al,-0x21(%rbp)
		low6 = *p & 0x3f;
  8004212b74:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212b78:	0f b6 00             	movzbl (%rax),%eax
  8004212b7b:	83 e0 3f             	and    $0x3f,%eax
  8004212b7e:	88 45 de             	mov    %al,-0x22(%rbp)
		p++;
  8004212b81:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212b85:	48 83 c0 01          	add    $0x1,%rax
  8004212b89:	48 89 45 a0          	mov    %rax,-0x60(%rbp)

		if (high2 > 0) {
  8004212b8d:	80 7d df 00          	cmpb   $0x0,-0x21(%rbp)
  8004212b91:	0f 84 a1 01 00 00    	je     8004212d38 <_dwarf_frame_run_inst+0x274>
			switch (high2) {
  8004212b97:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004212b9b:	3d 80 00 00 00       	cmp    $0x80,%eax
  8004212ba0:	74 38                	je     8004212bda <_dwarf_frame_run_inst+0x116>
  8004212ba2:	3d c0 00 00 00       	cmp    $0xc0,%eax
  8004212ba7:	0f 84 01 01 00 00    	je     8004212cae <_dwarf_frame_run_inst+0x1ea>
  8004212bad:	83 f8 40             	cmp    $0x40,%eax
  8004212bb0:	0f 85 71 01 00 00    	jne    8004212d27 <_dwarf_frame_run_inst+0x263>
			case DW_CFA_advance_loc:
			        pc += low6 * caf;
  8004212bb6:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
  8004212bba:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  8004212bc1:	ff 
  8004212bc2:	48 01 45 10          	add    %rax,0x10(%rbp)
			        if (pc_req < pc)
  8004212bc6:	48 8b 45 18          	mov    0x18(%rbp),%rax
  8004212bca:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  8004212bce:	73 05                	jae    8004212bd5 <_dwarf_frame_run_inst+0x111>
			                goto program_done;
  8004212bd0:	e9 be 0c 00 00       	jmpq   8004213893 <_dwarf_frame_run_inst+0xdcf>
			        break;
  8004212bd5:	e9 59 01 00 00       	jmpq   8004212d33 <_dwarf_frame_run_inst+0x26f>
			case DW_CFA_offset:
			        *row_pc = pc;
  8004212bda:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212bde:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212be2:	48 89 10             	mov    %rdx,(%rax)
			        CHECK_TABLE_SIZE(low6);
  8004212be5:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004212be9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212bed:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212bf1:	66 39 c2             	cmp    %ax,%dx
  8004212bf4:	72 0c                	jb     8004212c02 <_dwarf_frame_run_inst+0x13e>
  8004212bf6:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212bfd:	e9 91 0c 00 00       	jmpq   8004213893 <_dwarf_frame_run_inst+0xdcf>
			        RL[low6].dw_offset_relevant = 1;
  8004212c02:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212c06:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212c0a:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004212c0e:	48 89 d0             	mov    %rdx,%rax
  8004212c11:	48 01 c0             	add    %rax,%rax
  8004212c14:	48 01 d0             	add    %rdx,%rax
  8004212c17:	48 c1 e0 03          	shl    $0x3,%rax
  8004212c1b:	48 01 c8             	add    %rcx,%rax
  8004212c1e:	c6 00 01             	movb   $0x1,(%rax)
			        RL[low6].dw_value_type = DW_EXPR_OFFSET;
  8004212c21:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212c25:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212c29:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004212c2d:	48 89 d0             	mov    %rdx,%rax
  8004212c30:	48 01 c0             	add    %rax,%rax
  8004212c33:	48 01 d0             	add    %rdx,%rax
  8004212c36:	48 c1 e0 03          	shl    $0x3,%rax
  8004212c3a:	48 01 c8             	add    %rcx,%rax
  8004212c3d:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			        RL[low6].dw_regnum = dbg->dbg_frame_cfa_value;
  8004212c41:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212c45:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212c49:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004212c4d:	48 89 d0             	mov    %rdx,%rax
  8004212c50:	48 01 c0             	add    %rax,%rax
  8004212c53:	48 01 d0             	add    %rdx,%rax
  8004212c56:	48 c1 e0 03          	shl    $0x3,%rax
  8004212c5a:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212c5e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212c62:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004212c66:	66 89 42 02          	mov    %ax,0x2(%rdx)
			        RL[low6].dw_offset_or_block_len =
  8004212c6a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212c6e:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212c72:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004212c76:	48 89 d0             	mov    %rdx,%rax
  8004212c79:	48 01 c0             	add    %rax,%rax
  8004212c7c:	48 01 d0             	add    %rdx,%rax
  8004212c7f:	48 c1 e0 03          	shl    $0x3,%rax
  8004212c83:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
					_dwarf_decode_uleb128(&p) * daf;
  8004212c87:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212c8b:	48 89 c7             	mov    %rax,%rdi
  8004212c8e:	48 b8 f7 0f 21 04 80 	movabs $0x8004210ff7,%rax
  8004212c95:	00 00 00 
  8004212c98:	ff d0                	callq  *%rax
  8004212c9a:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004212ca1:	48 0f af c2          	imul   %rdx,%rax
			        *row_pc = pc;
			        CHECK_TABLE_SIZE(low6);
			        RL[low6].dw_offset_relevant = 1;
			        RL[low6].dw_value_type = DW_EXPR_OFFSET;
			        RL[low6].dw_regnum = dbg->dbg_frame_cfa_value;
			        RL[low6].dw_offset_or_block_len =
  8004212ca5:	48 89 43 08          	mov    %rax,0x8(%rbx)
					_dwarf_decode_uleb128(&p) * daf;
			        break;
  8004212ca9:	e9 85 00 00 00       	jmpq   8004212d33 <_dwarf_frame_run_inst+0x26f>
			case DW_CFA_restore:
			        *row_pc = pc;
  8004212cae:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212cb2:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212cb6:	48 89 10             	mov    %rdx,(%rax)
			        CHECK_TABLE_SIZE(low6);
  8004212cb9:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004212cbd:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212cc1:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212cc5:	66 39 c2             	cmp    %ax,%dx
  8004212cc8:	72 0c                	jb     8004212cd6 <_dwarf_frame_run_inst+0x212>
  8004212cca:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212cd1:	e9 bd 0b 00 00       	jmpq   8004213893 <_dwarf_frame_run_inst+0xdcf>
			        memcpy(&RL[low6], &INITRL[low6],
  8004212cd6:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212cda:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212cde:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004212ce2:	48 89 d0             	mov    %rdx,%rax
  8004212ce5:	48 01 c0             	add    %rax,%rax
  8004212ce8:	48 01 d0             	add    %rdx,%rax
  8004212ceb:	48 c1 e0 03          	shl    $0x3,%rax
  8004212cef:	48 01 c1             	add    %rax,%rcx
  8004212cf2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212cf6:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004212cfa:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004212cfe:	48 89 d0             	mov    %rdx,%rax
  8004212d01:	48 01 c0             	add    %rax,%rax
  8004212d04:	48 01 d0             	add    %rdx,%rax
  8004212d07:	48 c1 e0 03          	shl    $0x3,%rax
  8004212d0b:	48 01 f0             	add    %rsi,%rax
  8004212d0e:	ba 18 00 00 00       	mov    $0x18,%edx
  8004212d13:	48 89 ce             	mov    %rcx,%rsi
  8004212d16:	48 89 c7             	mov    %rax,%rdi
  8004212d19:	48 b8 76 05 21 04 80 	movabs $0x8004210576,%rax
  8004212d20:	00 00 00 
  8004212d23:	ff d0                	callq  *%rax
				       sizeof(Dwarf_Regtable_Entry3));
			        break;
  8004212d25:	eb 0c                	jmp    8004212d33 <_dwarf_frame_run_inst+0x26f>
			default:
			        DWARF_SET_ERROR(dbg, error,
						DW_DLE_FRAME_INSTR_EXEC_ERROR);
			        ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
  8004212d27:	c7 45 ec 15 00 00 00 	movl   $0x15,-0x14(%rbp)
			        goto program_done;
  8004212d2e:	e9 60 0b 00 00       	jmpq   8004213893 <_dwarf_frame_run_inst+0xdcf>
			}

			continue;
  8004212d33:	e9 4d 0b 00 00       	jmpq   8004213885 <_dwarf_frame_run_inst+0xdc1>
		}

		switch (low6) {
  8004212d38:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
  8004212d3c:	83 f8 16             	cmp    $0x16,%eax
  8004212d3f:	0f 87 37 0b 00 00    	ja     800421387c <_dwarf_frame_run_inst+0xdb8>
  8004212d45:	89 c0                	mov    %eax,%eax
  8004212d47:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004212d4e:	00 
  8004212d4f:	48 b8 80 b3 21 04 80 	movabs $0x800421b380,%rax
  8004212d56:	00 00 00 
  8004212d59:	48 01 d0             	add    %rdx,%rax
  8004212d5c:	48 8b 00             	mov    (%rax),%rax
  8004212d5f:	ff e0                	jmpq   *%rax
		case DW_CFA_set_loc:
			pc = dbg->decode(&p, dbg->dbg_pointer_size);
  8004212d61:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212d65:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004212d69:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004212d6d:	8b 4a 28             	mov    0x28(%rdx),%ecx
  8004212d70:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  8004212d74:	89 ce                	mov    %ecx,%esi
  8004212d76:	48 89 d7             	mov    %rdx,%rdi
  8004212d79:	ff d0                	callq  *%rax
  8004212d7b:	48 89 45 10          	mov    %rax,0x10(%rbp)
			if (pc_req < pc)
  8004212d7f:	48 8b 45 18          	mov    0x18(%rbp),%rax
  8004212d83:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  8004212d87:	73 05                	jae    8004212d8e <_dwarf_frame_run_inst+0x2ca>
			        goto program_done;
  8004212d89:	e9 05 0b 00 00       	jmpq   8004213893 <_dwarf_frame_run_inst+0xdcf>
			break;
  8004212d8e:	e9 f2 0a 00 00       	jmpq   8004213885 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_advance_loc1:
			pc += dbg->decode(&p, 1) * caf;
  8004212d93:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212d97:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004212d9b:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  8004212d9f:	be 01 00 00 00       	mov    $0x1,%esi
  8004212da4:	48 89 d7             	mov    %rdx,%rdi
  8004212da7:	ff d0                	callq  *%rax
  8004212da9:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  8004212db0:	ff 
  8004212db1:	48 01 45 10          	add    %rax,0x10(%rbp)
			if (pc_req < pc)
  8004212db5:	48 8b 45 18          	mov    0x18(%rbp),%rax
  8004212db9:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  8004212dbd:	73 05                	jae    8004212dc4 <_dwarf_frame_run_inst+0x300>
			        goto program_done;
  8004212dbf:	e9 cf 0a 00 00       	jmpq   8004213893 <_dwarf_frame_run_inst+0xdcf>
			break;
  8004212dc4:	e9 bc 0a 00 00       	jmpq   8004213885 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_advance_loc2:
			pc += dbg->decode(&p, 2) * caf;
  8004212dc9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212dcd:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004212dd1:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  8004212dd5:	be 02 00 00 00       	mov    $0x2,%esi
  8004212dda:	48 89 d7             	mov    %rdx,%rdi
  8004212ddd:	ff d0                	callq  *%rax
  8004212ddf:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  8004212de6:	ff 
  8004212de7:	48 01 45 10          	add    %rax,0x10(%rbp)
			if (pc_req < pc)
  8004212deb:	48 8b 45 18          	mov    0x18(%rbp),%rax
  8004212def:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  8004212df3:	73 05                	jae    8004212dfa <_dwarf_frame_run_inst+0x336>
			        goto program_done;
  8004212df5:	e9 99 0a 00 00       	jmpq   8004213893 <_dwarf_frame_run_inst+0xdcf>
			break;
  8004212dfa:	e9 86 0a 00 00       	jmpq   8004213885 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_advance_loc4:
			pc += dbg->decode(&p, 4) * caf;
  8004212dff:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212e03:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004212e07:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  8004212e0b:	be 04 00 00 00       	mov    $0x4,%esi
  8004212e10:	48 89 d7             	mov    %rdx,%rdi
  8004212e13:	ff d0                	callq  *%rax
  8004212e15:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  8004212e1c:	ff 
  8004212e1d:	48 01 45 10          	add    %rax,0x10(%rbp)
			if (pc_req < pc)
  8004212e21:	48 8b 45 18          	mov    0x18(%rbp),%rax
  8004212e25:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  8004212e29:	73 05                	jae    8004212e30 <_dwarf_frame_run_inst+0x36c>
			        goto program_done;
  8004212e2b:	e9 63 0a 00 00       	jmpq   8004213893 <_dwarf_frame_run_inst+0xdcf>
			break;
  8004212e30:	e9 50 0a 00 00       	jmpq   8004213885 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_offset_extended:
			*row_pc = pc;
  8004212e35:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212e39:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212e3d:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004212e40:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212e44:	48 89 c7             	mov    %rax,%rdi
  8004212e47:	48 b8 f7 0f 21 04 80 	movabs $0x8004210ff7,%rax
  8004212e4e:	00 00 00 
  8004212e51:	ff d0                	callq  *%rax
  8004212e53:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			uoff = _dwarf_decode_uleb128(&p);
  8004212e57:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212e5b:	48 89 c7             	mov    %rax,%rdi
  8004212e5e:	48 b8 f7 0f 21 04 80 	movabs $0x8004210ff7,%rax
  8004212e65:	00 00 00 
  8004212e68:	ff d0                	callq  *%rax
  8004212e6a:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004212e6e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212e72:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212e76:	0f b7 c0             	movzwl %ax,%eax
  8004212e79:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004212e7d:	77 0c                	ja     8004212e8b <_dwarf_frame_run_inst+0x3c7>
  8004212e7f:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212e86:	e9 08 0a 00 00       	jmpq   8004213893 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 1;
  8004212e8b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212e8f:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212e93:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212e97:	48 89 d0             	mov    %rdx,%rax
  8004212e9a:	48 01 c0             	add    %rax,%rax
  8004212e9d:	48 01 d0             	add    %rdx,%rax
  8004212ea0:	48 c1 e0 03          	shl    $0x3,%rax
  8004212ea4:	48 01 c8             	add    %rcx,%rax
  8004212ea7:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_OFFSET;
  8004212eaa:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212eae:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212eb2:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212eb6:	48 89 d0             	mov    %rdx,%rax
  8004212eb9:	48 01 c0             	add    %rax,%rax
  8004212ebc:	48 01 d0             	add    %rdx,%rax
  8004212ebf:	48 c1 e0 03          	shl    $0x3,%rax
  8004212ec3:	48 01 c8             	add    %rcx,%rax
  8004212ec6:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004212eca:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212ece:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212ed2:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212ed6:	48 89 d0             	mov    %rdx,%rax
  8004212ed9:	48 01 c0             	add    %rax,%rax
  8004212edc:	48 01 d0             	add    %rdx,%rax
  8004212edf:	48 c1 e0 03          	shl    $0x3,%rax
  8004212ee3:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212ee7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212eeb:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004212eef:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = uoff * daf;
  8004212ef3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212ef7:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212efb:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212eff:	48 89 d0             	mov    %rdx,%rax
  8004212f02:	48 01 c0             	add    %rax,%rax
  8004212f05:	48 01 d0             	add    %rdx,%rax
  8004212f08:	48 c1 e0 03          	shl    $0x3,%rax
  8004212f0c:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212f10:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004212f17:	48 0f af 45 c8       	imul   -0x38(%rbp),%rax
  8004212f1c:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  8004212f20:	e9 60 09 00 00       	jmpq   8004213885 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_restore_extended:
			*row_pc = pc;
  8004212f25:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212f29:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212f2d:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004212f30:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212f34:	48 89 c7             	mov    %rax,%rdi
  8004212f37:	48 b8 f7 0f 21 04 80 	movabs $0x8004210ff7,%rax
  8004212f3e:	00 00 00 
  8004212f41:	ff d0                	callq  *%rax
  8004212f43:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004212f47:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212f4b:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212f4f:	0f b7 c0             	movzwl %ax,%eax
  8004212f52:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004212f56:	77 0c                	ja     8004212f64 <_dwarf_frame_run_inst+0x4a0>
  8004212f58:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212f5f:	e9 2f 09 00 00       	jmpq   8004213893 <_dwarf_frame_run_inst+0xdcf>
			memcpy(&RL[reg], &INITRL[reg],
  8004212f64:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212f68:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212f6c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212f70:	48 89 d0             	mov    %rdx,%rax
  8004212f73:	48 01 c0             	add    %rax,%rax
  8004212f76:	48 01 d0             	add    %rdx,%rax
  8004212f79:	48 c1 e0 03          	shl    $0x3,%rax
  8004212f7d:	48 01 c1             	add    %rax,%rcx
  8004212f80:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212f84:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004212f88:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212f8c:	48 89 d0             	mov    %rdx,%rax
  8004212f8f:	48 01 c0             	add    %rax,%rax
  8004212f92:	48 01 d0             	add    %rdx,%rax
  8004212f95:	48 c1 e0 03          	shl    $0x3,%rax
  8004212f99:	48 01 f0             	add    %rsi,%rax
  8004212f9c:	ba 18 00 00 00       	mov    $0x18,%edx
  8004212fa1:	48 89 ce             	mov    %rcx,%rsi
  8004212fa4:	48 89 c7             	mov    %rax,%rdi
  8004212fa7:	48 b8 76 05 21 04 80 	movabs $0x8004210576,%rax
  8004212fae:	00 00 00 
  8004212fb1:	ff d0                	callq  *%rax
			       sizeof(Dwarf_Regtable_Entry3));
			break;
  8004212fb3:	e9 cd 08 00 00       	jmpq   8004213885 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_undefined:
			*row_pc = pc;
  8004212fb8:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212fbc:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212fc0:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004212fc3:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212fc7:	48 89 c7             	mov    %rax,%rdi
  8004212fca:	48 b8 f7 0f 21 04 80 	movabs $0x8004210ff7,%rax
  8004212fd1:	00 00 00 
  8004212fd4:	ff d0                	callq  *%rax
  8004212fd6:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004212fda:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212fde:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212fe2:	0f b7 c0             	movzwl %ax,%eax
  8004212fe5:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004212fe9:	77 0c                	ja     8004212ff7 <_dwarf_frame_run_inst+0x533>
  8004212feb:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212ff2:	e9 9c 08 00 00       	jmpq   8004213893 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 0;
  8004212ff7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212ffb:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212fff:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213003:	48 89 d0             	mov    %rdx,%rax
  8004213006:	48 01 c0             	add    %rax,%rax
  8004213009:	48 01 d0             	add    %rdx,%rax
  800421300c:	48 c1 e0 03          	shl    $0x3,%rax
  8004213010:	48 01 c8             	add    %rcx,%rax
  8004213013:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_undefined_value;
  8004213016:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421301a:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421301e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213022:	48 89 d0             	mov    %rdx,%rax
  8004213025:	48 01 c0             	add    %rax,%rax
  8004213028:	48 01 d0             	add    %rdx,%rax
  800421302b:	48 c1 e0 03          	shl    $0x3,%rax
  800421302f:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004213033:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004213037:	0f b7 40 50          	movzwl 0x50(%rax),%eax
  800421303b:	66 89 42 02          	mov    %ax,0x2(%rdx)
			break;
  800421303f:	e9 41 08 00 00       	jmpq   8004213885 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_same_value:
			reg = _dwarf_decode_uleb128(&p);
  8004213044:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213048:	48 89 c7             	mov    %rax,%rdi
  800421304b:	48 b8 f7 0f 21 04 80 	movabs $0x8004210ff7,%rax
  8004213052:	00 00 00 
  8004213055:	ff d0                	callq  *%rax
  8004213057:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  800421305b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421305f:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004213063:	0f b7 c0             	movzwl %ax,%eax
  8004213066:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800421306a:	77 0c                	ja     8004213078 <_dwarf_frame_run_inst+0x5b4>
  800421306c:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004213073:	e9 1b 08 00 00       	jmpq   8004213893 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 0;
  8004213078:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421307c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213080:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213084:	48 89 d0             	mov    %rdx,%rax
  8004213087:	48 01 c0             	add    %rax,%rax
  800421308a:	48 01 d0             	add    %rdx,%rax
  800421308d:	48 c1 e0 03          	shl    $0x3,%rax
  8004213091:	48 01 c8             	add    %rcx,%rax
  8004213094:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_same_value;
  8004213097:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421309b:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421309f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042130a3:	48 89 d0             	mov    %rdx,%rax
  80042130a6:	48 01 c0             	add    %rax,%rax
  80042130a9:	48 01 d0             	add    %rdx,%rax
  80042130ac:	48 c1 e0 03          	shl    $0x3,%rax
  80042130b0:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042130b4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042130b8:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  80042130bc:	66 89 42 02          	mov    %ax,0x2(%rdx)
			break;
  80042130c0:	e9 c0 07 00 00       	jmpq   8004213885 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_register:
			*row_pc = pc;
  80042130c5:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042130c9:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042130cd:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  80042130d0:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042130d4:	48 89 c7             	mov    %rax,%rdi
  80042130d7:	48 b8 f7 0f 21 04 80 	movabs $0x8004210ff7,%rax
  80042130de:	00 00 00 
  80042130e1:	ff d0                	callq  *%rax
  80042130e3:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			reg2 = _dwarf_decode_uleb128(&p);
  80042130e7:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042130eb:	48 89 c7             	mov    %rax,%rdi
  80042130ee:	48 b8 f7 0f 21 04 80 	movabs $0x8004210ff7,%rax
  80042130f5:	00 00 00 
  80042130f8:	ff d0                	callq  *%rax
  80042130fa:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
			CHECK_TABLE_SIZE(reg);
  80042130fe:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213102:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004213106:	0f b7 c0             	movzwl %ax,%eax
  8004213109:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800421310d:	77 0c                	ja     800421311b <_dwarf_frame_run_inst+0x657>
  800421310f:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004213116:	e9 78 07 00 00       	jmpq   8004213893 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 0;
  800421311b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421311f:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213123:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213127:	48 89 d0             	mov    %rdx,%rax
  800421312a:	48 01 c0             	add    %rax,%rax
  800421312d:	48 01 d0             	add    %rdx,%rax
  8004213130:	48 c1 e0 03          	shl    $0x3,%rax
  8004213134:	48 01 c8             	add    %rcx,%rax
  8004213137:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_regnum = reg2;
  800421313a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421313e:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213142:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213146:	48 89 d0             	mov    %rdx,%rax
  8004213149:	48 01 c0             	add    %rax,%rax
  800421314c:	48 01 d0             	add    %rdx,%rax
  800421314f:	48 c1 e0 03          	shl    $0x3,%rax
  8004213153:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004213157:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421315b:	66 89 42 02          	mov    %ax,0x2(%rdx)
			break;
  800421315f:	e9 21 07 00 00       	jmpq   8004213885 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_remember_state:
			_dwarf_frame_regtable_copy(dbg, &saved_rt, rt, error);
  8004213164:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8004213168:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  800421316c:	48 8d 75 a8          	lea    -0x58(%rbp),%rsi
  8004213170:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004213174:	48 89 c7             	mov    %rax,%rdi
  8004213177:	48 b8 f3 28 21 04 80 	movabs $0x80042128f3,%rax
  800421317e:	00 00 00 
  8004213181:	ff d0                	callq  *%rax
			break;
  8004213183:	e9 fd 06 00 00       	jmpq   8004213885 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_restore_state:
			*row_pc = pc;
  8004213188:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421318c:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213190:	48 89 10             	mov    %rdx,(%rax)
			_dwarf_frame_regtable_copy(dbg, &rt, saved_rt, error);
  8004213193:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004213197:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  800421319b:	48 8d 75 90          	lea    -0x70(%rbp),%rsi
  800421319f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042131a3:	48 89 c7             	mov    %rax,%rdi
  80042131a6:	48 b8 f3 28 21 04 80 	movabs $0x80042128f3,%rax
  80042131ad:	00 00 00 
  80042131b0:	ff d0                	callq  *%rax
			break;
  80042131b2:	e9 ce 06 00 00       	jmpq   8004213885 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa:
			*row_pc = pc;
  80042131b7:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042131bb:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042131bf:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  80042131c2:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042131c6:	48 89 c7             	mov    %rax,%rdi
  80042131c9:	48 b8 f7 0f 21 04 80 	movabs $0x8004210ff7,%rax
  80042131d0:	00 00 00 
  80042131d3:	ff d0                	callq  *%rax
  80042131d5:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			uoff = _dwarf_decode_uleb128(&p);
  80042131d9:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042131dd:	48 89 c7             	mov    %rax,%rdi
  80042131e0:	48 b8 f7 0f 21 04 80 	movabs $0x8004210ff7,%rax
  80042131e7:	00 00 00 
  80042131ea:	ff d0                	callq  *%rax
  80042131ec:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CFA.dw_offset_relevant = 1;
  80042131f0:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042131f4:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  80042131f7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042131fb:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_regnum = reg;
  80042131ff:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213203:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213207:	66 89 50 02          	mov    %dx,0x2(%rax)
			CFA.dw_offset_or_block_len = uoff;
  800421320b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421320f:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213213:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  8004213217:	e9 69 06 00 00       	jmpq   8004213885 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa_register:
			*row_pc = pc;
  800421321c:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213220:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213224:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004213227:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421322b:	48 89 c7             	mov    %rax,%rdi
  800421322e:	48 b8 f7 0f 21 04 80 	movabs $0x8004210ff7,%rax
  8004213235:	00 00 00 
  8004213238:	ff d0                	callq  *%rax
  800421323a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CFA.dw_regnum = reg;
  800421323e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213242:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213246:	66 89 50 02          	mov    %dx,0x2(%rax)
			 * Note that DW_CFA_def_cfa_register change the CFA
			 * rule register while keep the old offset. So we
			 * should not touch the CFA.dw_offset_relevant flag
			 * here.
			 */
			break;
  800421324a:	e9 36 06 00 00       	jmpq   8004213885 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa_offset:
			*row_pc = pc;
  800421324f:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213253:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213257:	48 89 10             	mov    %rdx,(%rax)
			uoff = _dwarf_decode_uleb128(&p);
  800421325a:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421325e:	48 89 c7             	mov    %rax,%rdi
  8004213261:	48 b8 f7 0f 21 04 80 	movabs $0x8004210ff7,%rax
  8004213268:	00 00 00 
  800421326b:	ff d0                	callq  *%rax
  800421326d:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CFA.dw_offset_relevant = 1;
  8004213271:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213275:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  8004213278:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421327c:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_offset_or_block_len = uoff;
  8004213280:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213284:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213288:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  800421328c:	e9 f4 05 00 00       	jmpq   8004213885 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa_expression:
			*row_pc = pc;
  8004213291:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213295:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213299:	48 89 10             	mov    %rdx,(%rax)
			CFA.dw_offset_relevant = 0;
  800421329c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042132a0:	c6 00 00             	movb   $0x0,(%rax)
			CFA.dw_value_type = DW_EXPR_EXPRESSION;
  80042132a3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042132a7:	c6 40 01 02          	movb   $0x2,0x1(%rax)
			CFA.dw_offset_or_block_len = _dwarf_decode_uleb128(&p);
  80042132ab:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx
  80042132af:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042132b3:	48 89 c7             	mov    %rax,%rdi
  80042132b6:	48 b8 f7 0f 21 04 80 	movabs $0x8004210ff7,%rax
  80042132bd:	00 00 00 
  80042132c0:	ff d0                	callq  *%rax
  80042132c2:	48 89 43 08          	mov    %rax,0x8(%rbx)
			CFA.dw_block_ptr = p;
  80042132c6:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042132ca:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042132ce:	48 89 50 10          	mov    %rdx,0x10(%rax)
			p += CFA.dw_offset_or_block_len;
  80042132d2:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042132d6:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042132da:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042132de:	48 01 d0             	add    %rdx,%rax
  80042132e1:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			break;
  80042132e5:	e9 9b 05 00 00       	jmpq   8004213885 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_expression:
			*row_pc = pc;
  80042132ea:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042132ee:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042132f2:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  80042132f5:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042132f9:	48 89 c7             	mov    %rax,%rdi
  80042132fc:	48 b8 f7 0f 21 04 80 	movabs $0x8004210ff7,%rax
  8004213303:	00 00 00 
  8004213306:	ff d0                	callq  *%rax
  8004213308:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  800421330c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213310:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004213314:	0f b7 c0             	movzwl %ax,%eax
  8004213317:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800421331b:	77 0c                	ja     8004213329 <_dwarf_frame_run_inst+0x865>
  800421331d:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004213324:	e9 6a 05 00 00       	jmpq   8004213893 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 0;
  8004213329:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421332d:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213331:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213335:	48 89 d0             	mov    %rdx,%rax
  8004213338:	48 01 c0             	add    %rax,%rax
  800421333b:	48 01 d0             	add    %rdx,%rax
  800421333e:	48 c1 e0 03          	shl    $0x3,%rax
  8004213342:	48 01 c8             	add    %rcx,%rax
  8004213345:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_value_type = DW_EXPR_EXPRESSION;
  8004213348:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421334c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213350:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213354:	48 89 d0             	mov    %rdx,%rax
  8004213357:	48 01 c0             	add    %rax,%rax
  800421335a:	48 01 d0             	add    %rdx,%rax
  800421335d:	48 c1 e0 03          	shl    $0x3,%rax
  8004213361:	48 01 c8             	add    %rcx,%rax
  8004213364:	c6 40 01 02          	movb   $0x2,0x1(%rax)
			RL[reg].dw_offset_or_block_len =
  8004213368:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421336c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213370:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213374:	48 89 d0             	mov    %rdx,%rax
  8004213377:	48 01 c0             	add    %rax,%rax
  800421337a:	48 01 d0             	add    %rdx,%rax
  800421337d:	48 c1 e0 03          	shl    $0x3,%rax
  8004213381:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
				_dwarf_decode_uleb128(&p);
  8004213385:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213389:	48 89 c7             	mov    %rax,%rdi
  800421338c:	48 b8 f7 0f 21 04 80 	movabs $0x8004210ff7,%rax
  8004213393:	00 00 00 
  8004213396:	ff d0                	callq  *%rax
			*row_pc = pc;
			reg = _dwarf_decode_uleb128(&p);
			CHECK_TABLE_SIZE(reg);
			RL[reg].dw_offset_relevant = 0;
			RL[reg].dw_value_type = DW_EXPR_EXPRESSION;
			RL[reg].dw_offset_or_block_len =
  8004213398:	48 89 43 08          	mov    %rax,0x8(%rbx)
				_dwarf_decode_uleb128(&p);
			RL[reg].dw_block_ptr = p;
  800421339c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042133a0:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042133a4:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042133a8:	48 89 d0             	mov    %rdx,%rax
  80042133ab:	48 01 c0             	add    %rax,%rax
  80042133ae:	48 01 d0             	add    %rdx,%rax
  80042133b1:	48 c1 e0 03          	shl    $0x3,%rax
  80042133b5:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042133b9:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042133bd:	48 89 42 10          	mov    %rax,0x10(%rdx)
			p += RL[reg].dw_offset_or_block_len;
  80042133c1:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  80042133c5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042133c9:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80042133cd:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042133d1:	48 89 d0             	mov    %rdx,%rax
  80042133d4:	48 01 c0             	add    %rax,%rax
  80042133d7:	48 01 d0             	add    %rdx,%rax
  80042133da:	48 c1 e0 03          	shl    $0x3,%rax
  80042133de:	48 01 f0             	add    %rsi,%rax
  80042133e1:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042133e5:	48 01 c8             	add    %rcx,%rax
  80042133e8:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			break;
  80042133ec:	e9 94 04 00 00       	jmpq   8004213885 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_offset_extended_sf:
			*row_pc = pc;
  80042133f1:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042133f5:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042133f9:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  80042133fc:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213400:	48 89 c7             	mov    %rax,%rdi
  8004213403:	48 b8 f7 0f 21 04 80 	movabs $0x8004210ff7,%rax
  800421340a:	00 00 00 
  800421340d:	ff d0                	callq  *%rax
  800421340f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			soff = _dwarf_decode_sleb128(&p);
  8004213413:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213417:	48 89 c7             	mov    %rax,%rdi
  800421341a:	48 b8 65 0f 21 04 80 	movabs $0x8004210f65,%rax
  8004213421:	00 00 00 
  8004213424:	ff d0                	callq  *%rax
  8004213426:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CHECK_TABLE_SIZE(reg);
  800421342a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421342e:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004213432:	0f b7 c0             	movzwl %ax,%eax
  8004213435:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004213439:	77 0c                	ja     8004213447 <_dwarf_frame_run_inst+0x983>
  800421343b:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004213442:	e9 4c 04 00 00       	jmpq   8004213893 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 1;
  8004213447:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421344b:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421344f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213453:	48 89 d0             	mov    %rdx,%rax
  8004213456:	48 01 c0             	add    %rax,%rax
  8004213459:	48 01 d0             	add    %rdx,%rax
  800421345c:	48 c1 e0 03          	shl    $0x3,%rax
  8004213460:	48 01 c8             	add    %rcx,%rax
  8004213463:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_OFFSET;
  8004213466:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421346a:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421346e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213472:	48 89 d0             	mov    %rdx,%rax
  8004213475:	48 01 c0             	add    %rax,%rax
  8004213478:	48 01 d0             	add    %rdx,%rax
  800421347b:	48 c1 e0 03          	shl    $0x3,%rax
  800421347f:	48 01 c8             	add    %rcx,%rax
  8004213482:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004213486:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421348a:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421348e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213492:	48 89 d0             	mov    %rdx,%rax
  8004213495:	48 01 c0             	add    %rax,%rax
  8004213498:	48 01 d0             	add    %rdx,%rax
  800421349b:	48 c1 e0 03          	shl    $0x3,%rax
  800421349f:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042134a3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042134a7:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  80042134ab:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = soff * daf;
  80042134af:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042134b3:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042134b7:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042134bb:	48 89 d0             	mov    %rdx,%rax
  80042134be:	48 01 c0             	add    %rax,%rax
  80042134c1:	48 01 d0             	add    %rdx,%rax
  80042134c4:	48 c1 e0 03          	shl    $0x3,%rax
  80042134c8:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042134cc:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80042134d3:	48 0f af 45 b8       	imul   -0x48(%rbp),%rax
  80042134d8:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  80042134dc:	e9 a4 03 00 00       	jmpq   8004213885 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa_sf:
			*row_pc = pc;
  80042134e1:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042134e5:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042134e9:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  80042134ec:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042134f0:	48 89 c7             	mov    %rax,%rdi
  80042134f3:	48 b8 f7 0f 21 04 80 	movabs $0x8004210ff7,%rax
  80042134fa:	00 00 00 
  80042134fd:	ff d0                	callq  *%rax
  80042134ff:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			soff = _dwarf_decode_sleb128(&p);
  8004213503:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213507:	48 89 c7             	mov    %rax,%rdi
  800421350a:	48 b8 65 0f 21 04 80 	movabs $0x8004210f65,%rax
  8004213511:	00 00 00 
  8004213514:	ff d0                	callq  *%rax
  8004213516:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CFA.dw_offset_relevant = 1;
  800421351a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421351e:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  8004213521:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213525:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_regnum = reg;
  8004213529:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421352d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213531:	66 89 50 02          	mov    %dx,0x2(%rax)
			CFA.dw_offset_or_block_len = soff * daf;
  8004213535:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213539:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004213540:	48 0f af 55 b8       	imul   -0x48(%rbp),%rdx
  8004213545:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  8004213549:	e9 37 03 00 00       	jmpq   8004213885 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa_offset_sf:
			*row_pc = pc;
  800421354e:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213552:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213556:	48 89 10             	mov    %rdx,(%rax)
			soff = _dwarf_decode_sleb128(&p);
  8004213559:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421355d:	48 89 c7             	mov    %rax,%rdi
  8004213560:	48 b8 65 0f 21 04 80 	movabs $0x8004210f65,%rax
  8004213567:	00 00 00 
  800421356a:	ff d0                	callq  *%rax
  800421356c:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CFA.dw_offset_relevant = 1;
  8004213570:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213574:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  8004213577:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421357b:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_offset_or_block_len = soff * daf;
  800421357f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213583:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  800421358a:	48 0f af 55 b8       	imul   -0x48(%rbp),%rdx
  800421358f:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  8004213593:	e9 ed 02 00 00       	jmpq   8004213885 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_val_offset:
			*row_pc = pc;
  8004213598:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421359c:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042135a0:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  80042135a3:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042135a7:	48 89 c7             	mov    %rax,%rdi
  80042135aa:	48 b8 f7 0f 21 04 80 	movabs $0x8004210ff7,%rax
  80042135b1:	00 00 00 
  80042135b4:	ff d0                	callq  *%rax
  80042135b6:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			uoff = _dwarf_decode_uleb128(&p);
  80042135ba:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042135be:	48 89 c7             	mov    %rax,%rdi
  80042135c1:	48 b8 f7 0f 21 04 80 	movabs $0x8004210ff7,%rax
  80042135c8:	00 00 00 
  80042135cb:	ff d0                	callq  *%rax
  80042135cd:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CHECK_TABLE_SIZE(reg);
  80042135d1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042135d5:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042135d9:	0f b7 c0             	movzwl %ax,%eax
  80042135dc:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042135e0:	77 0c                	ja     80042135ee <_dwarf_frame_run_inst+0xb2a>
  80042135e2:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042135e9:	e9 a5 02 00 00       	jmpq   8004213893 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 1;
  80042135ee:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042135f2:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042135f6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042135fa:	48 89 d0             	mov    %rdx,%rax
  80042135fd:	48 01 c0             	add    %rax,%rax
  8004213600:	48 01 d0             	add    %rdx,%rax
  8004213603:	48 c1 e0 03          	shl    $0x3,%rax
  8004213607:	48 01 c8             	add    %rcx,%rax
  800421360a:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_VAL_OFFSET;
  800421360d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213611:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213615:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213619:	48 89 d0             	mov    %rdx,%rax
  800421361c:	48 01 c0             	add    %rax,%rax
  800421361f:	48 01 d0             	add    %rdx,%rax
  8004213622:	48 c1 e0 03          	shl    $0x3,%rax
  8004213626:	48 01 c8             	add    %rcx,%rax
  8004213629:	c6 40 01 01          	movb   $0x1,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  800421362d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213631:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213635:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213639:	48 89 d0             	mov    %rdx,%rax
  800421363c:	48 01 c0             	add    %rax,%rax
  800421363f:	48 01 d0             	add    %rdx,%rax
  8004213642:	48 c1 e0 03          	shl    $0x3,%rax
  8004213646:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800421364a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421364e:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004213652:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = uoff * daf;
  8004213656:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421365a:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421365e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213662:	48 89 d0             	mov    %rdx,%rax
  8004213665:	48 01 c0             	add    %rax,%rax
  8004213668:	48 01 d0             	add    %rdx,%rax
  800421366b:	48 c1 e0 03          	shl    $0x3,%rax
  800421366f:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004213673:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  800421367a:	48 0f af 45 c8       	imul   -0x38(%rbp),%rax
  800421367f:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  8004213683:	e9 fd 01 00 00       	jmpq   8004213885 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_val_offset_sf:
			*row_pc = pc;
  8004213688:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421368c:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213690:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004213693:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213697:	48 89 c7             	mov    %rax,%rdi
  800421369a:	48 b8 f7 0f 21 04 80 	movabs $0x8004210ff7,%rax
  80042136a1:	00 00 00 
  80042136a4:	ff d0                	callq  *%rax
  80042136a6:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			soff = _dwarf_decode_sleb128(&p);
  80042136aa:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042136ae:	48 89 c7             	mov    %rax,%rdi
  80042136b1:	48 b8 65 0f 21 04 80 	movabs $0x8004210f65,%rax
  80042136b8:	00 00 00 
  80042136bb:	ff d0                	callq  *%rax
  80042136bd:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CHECK_TABLE_SIZE(reg);
  80042136c1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042136c5:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042136c9:	0f b7 c0             	movzwl %ax,%eax
  80042136cc:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042136d0:	77 0c                	ja     80042136de <_dwarf_frame_run_inst+0xc1a>
  80042136d2:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042136d9:	e9 b5 01 00 00       	jmpq   8004213893 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 1;
  80042136de:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042136e2:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042136e6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042136ea:	48 89 d0             	mov    %rdx,%rax
  80042136ed:	48 01 c0             	add    %rax,%rax
  80042136f0:	48 01 d0             	add    %rdx,%rax
  80042136f3:	48 c1 e0 03          	shl    $0x3,%rax
  80042136f7:	48 01 c8             	add    %rcx,%rax
  80042136fa:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_VAL_OFFSET;
  80042136fd:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213701:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213705:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213709:	48 89 d0             	mov    %rdx,%rax
  800421370c:	48 01 c0             	add    %rax,%rax
  800421370f:	48 01 d0             	add    %rdx,%rax
  8004213712:	48 c1 e0 03          	shl    $0x3,%rax
  8004213716:	48 01 c8             	add    %rcx,%rax
  8004213719:	c6 40 01 01          	movb   $0x1,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  800421371d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213721:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213725:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213729:	48 89 d0             	mov    %rdx,%rax
  800421372c:	48 01 c0             	add    %rax,%rax
  800421372f:	48 01 d0             	add    %rdx,%rax
  8004213732:	48 c1 e0 03          	shl    $0x3,%rax
  8004213736:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800421373a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421373e:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004213742:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = soff * daf;
  8004213746:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421374a:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421374e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213752:	48 89 d0             	mov    %rdx,%rax
  8004213755:	48 01 c0             	add    %rax,%rax
  8004213758:	48 01 d0             	add    %rdx,%rax
  800421375b:	48 c1 e0 03          	shl    $0x3,%rax
  800421375f:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004213763:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  800421376a:	48 0f af 45 b8       	imul   -0x48(%rbp),%rax
  800421376f:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  8004213773:	e9 0d 01 00 00       	jmpq   8004213885 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_val_expression:
			*row_pc = pc;
  8004213778:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421377c:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213780:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004213783:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213787:	48 89 c7             	mov    %rax,%rdi
  800421378a:	48 b8 f7 0f 21 04 80 	movabs $0x8004210ff7,%rax
  8004213791:	00 00 00 
  8004213794:	ff d0                	callq  *%rax
  8004213796:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  800421379a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421379e:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042137a2:	0f b7 c0             	movzwl %ax,%eax
  80042137a5:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042137a9:	77 0c                	ja     80042137b7 <_dwarf_frame_run_inst+0xcf3>
  80042137ab:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042137b2:	e9 dc 00 00 00       	jmpq   8004213893 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 0;
  80042137b7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042137bb:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042137bf:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042137c3:	48 89 d0             	mov    %rdx,%rax
  80042137c6:	48 01 c0             	add    %rax,%rax
  80042137c9:	48 01 d0             	add    %rdx,%rax
  80042137cc:	48 c1 e0 03          	shl    $0x3,%rax
  80042137d0:	48 01 c8             	add    %rcx,%rax
  80042137d3:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_value_type = DW_EXPR_VAL_EXPRESSION;
  80042137d6:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042137da:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042137de:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042137e2:	48 89 d0             	mov    %rdx,%rax
  80042137e5:	48 01 c0             	add    %rax,%rax
  80042137e8:	48 01 d0             	add    %rdx,%rax
  80042137eb:	48 c1 e0 03          	shl    $0x3,%rax
  80042137ef:	48 01 c8             	add    %rcx,%rax
  80042137f2:	c6 40 01 03          	movb   $0x3,0x1(%rax)
			RL[reg].dw_offset_or_block_len =
  80042137f6:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042137fa:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042137fe:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213802:	48 89 d0             	mov    %rdx,%rax
  8004213805:	48 01 c0             	add    %rax,%rax
  8004213808:	48 01 d0             	add    %rdx,%rax
  800421380b:	48 c1 e0 03          	shl    $0x3,%rax
  800421380f:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
				_dwarf_decode_uleb128(&p);
  8004213813:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213817:	48 89 c7             	mov    %rax,%rdi
  800421381a:	48 b8 f7 0f 21 04 80 	movabs $0x8004210ff7,%rax
  8004213821:	00 00 00 
  8004213824:	ff d0                	callq  *%rax
			*row_pc = pc;
			reg = _dwarf_decode_uleb128(&p);
			CHECK_TABLE_SIZE(reg);
			RL[reg].dw_offset_relevant = 0;
			RL[reg].dw_value_type = DW_EXPR_VAL_EXPRESSION;
			RL[reg].dw_offset_or_block_len =
  8004213826:	48 89 43 08          	mov    %rax,0x8(%rbx)
				_dwarf_decode_uleb128(&p);
			RL[reg].dw_block_ptr = p;
  800421382a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421382e:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213832:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213836:	48 89 d0             	mov    %rdx,%rax
  8004213839:	48 01 c0             	add    %rax,%rax
  800421383c:	48 01 d0             	add    %rdx,%rax
  800421383f:	48 c1 e0 03          	shl    $0x3,%rax
  8004213843:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004213847:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421384b:	48 89 42 10          	mov    %rax,0x10(%rdx)
			p += RL[reg].dw_offset_or_block_len;
  800421384f:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004213853:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213857:	48 8b 70 20          	mov    0x20(%rax),%rsi
  800421385b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421385f:	48 89 d0             	mov    %rdx,%rax
  8004213862:	48 01 c0             	add    %rax,%rax
  8004213865:	48 01 d0             	add    %rdx,%rax
  8004213868:	48 c1 e0 03          	shl    $0x3,%rax
  800421386c:	48 01 f0             	add    %rsi,%rax
  800421386f:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004213873:	48 01 c8             	add    %rcx,%rax
  8004213876:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			break;
  800421387a:	eb 09                	jmp    8004213885 <_dwarf_frame_run_inst+0xdc1>
		default:
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_FRAME_INSTR_EXEC_ERROR);
			ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
  800421387c:	c7 45 ec 15 00 00 00 	movl   $0x15,-0x14(%rbp)
			goto program_done;
  8004213883:	eb 0e                	jmp    8004213893 <_dwarf_frame_run_inst+0xdcf>
	/* Save a copy of the table as initial state. */
	_dwarf_frame_regtable_copy(dbg, &init_rt, rt, error);
	p = insts;
	pe = p + len;

	while (p < pe) {
  8004213885:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004213889:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800421388d:	0f 82 b8 f2 ff ff    	jb     8004212b4b <_dwarf_frame_run_inst+0x87>
			goto program_done;
		}
	}

program_done:
	return (ret);
  8004213893:	8b 45 ec             	mov    -0x14(%rbp),%eax
#undef  CFA
#undef  INITCFA
#undef  RL
#undef  INITRL
#undef  CHECK_TABLE_SIZE
}
  8004213896:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
  800421389d:	5b                   	pop    %rbx
  800421389e:	5d                   	pop    %rbp
  800421389f:	c3                   	retq   

00000080042138a0 <_dwarf_frame_get_internal_table>:
int
_dwarf_frame_get_internal_table(Dwarf_Debug dbg, Dwarf_Fde fde,
				Dwarf_Addr pc_req, Dwarf_Regtable3 **ret_rt,
				Dwarf_Addr *ret_row_pc,
				Dwarf_Error *error)
{
  80042138a0:	55                   	push   %rbp
  80042138a1:	48 89 e5             	mov    %rsp,%rbp
  80042138a4:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  80042138a8:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80042138ac:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  80042138b0:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  80042138b4:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  80042138b8:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
  80042138bc:	4c 89 4d a0          	mov    %r9,-0x60(%rbp)
	Dwarf_Cie cie;
	Dwarf_Regtable3 *rt;
	Dwarf_Addr row_pc;
	int i, ret;

	assert(ret_rt != NULL);
  80042138c0:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  80042138c5:	75 35                	jne    80042138fc <_dwarf_frame_get_internal_table+0x5c>
  80042138c7:	48 b9 38 b4 21 04 80 	movabs $0x800421b438,%rcx
  80042138ce:	00 00 00 
  80042138d1:	48 ba 47 b3 21 04 80 	movabs $0x800421b347,%rdx
  80042138d8:	00 00 00 
  80042138db:	be 83 01 00 00       	mov    $0x183,%esi
  80042138e0:	48 bf 5c b3 21 04 80 	movabs $0x800421b35c,%rdi
  80042138e7:	00 00 00 
  80042138ea:	b8 00 00 00 00       	mov    $0x0,%eax
  80042138ef:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042138f6:	00 00 00 
  80042138f9:	41 ff d0             	callq  *%r8

	//dbg = fde->fde_dbg;
	assert(dbg != NULL);
  80042138fc:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004213901:	75 35                	jne    8004213938 <_dwarf_frame_get_internal_table+0x98>
  8004213903:	48 b9 47 b4 21 04 80 	movabs $0x800421b447,%rcx
  800421390a:	00 00 00 
  800421390d:	48 ba 47 b3 21 04 80 	movabs $0x800421b347,%rdx
  8004213914:	00 00 00 
  8004213917:	be 86 01 00 00       	mov    $0x186,%esi
  800421391c:	48 bf 5c b3 21 04 80 	movabs $0x800421b35c,%rdi
  8004213923:	00 00 00 
  8004213926:	b8 00 00 00 00       	mov    $0x0,%eax
  800421392b:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004213932:	00 00 00 
  8004213935:	41 ff d0             	callq  *%r8

	rt = dbg->dbg_internal_reg_table;
  8004213938:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421393c:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004213940:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	/* Clear the content of regtable from previous run. */
	memset(&rt->rt3_cfa_rule, 0, sizeof(Dwarf_Regtable_Entry3));
  8004213944:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004213948:	ba 18 00 00 00       	mov    $0x18,%edx
  800421394d:	be 00 00 00 00       	mov    $0x0,%esi
  8004213952:	48 89 c7             	mov    %rax,%rdi
  8004213955:	48 b8 d4 03 21 04 80 	movabs $0x80042103d4,%rax
  800421395c:	00 00 00 
  800421395f:	ff d0                	callq  *%rax
	memset(rt->rt3_rules, 0, rt->rt3_reg_table_size *
  8004213961:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004213965:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004213969:	0f b7 d0             	movzwl %ax,%edx
  800421396c:	48 89 d0             	mov    %rdx,%rax
  800421396f:	48 01 c0             	add    %rax,%rax
  8004213972:	48 01 d0             	add    %rdx,%rax
  8004213975:	48 c1 e0 03          	shl    $0x3,%rax
  8004213979:	48 89 c2             	mov    %rax,%rdx
  800421397c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004213980:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004213984:	be 00 00 00 00       	mov    $0x0,%esi
  8004213989:	48 89 c7             	mov    %rax,%rdi
  800421398c:	48 b8 d4 03 21 04 80 	movabs $0x80042103d4,%rax
  8004213993:	00 00 00 
  8004213996:	ff d0                	callq  *%rax
	       sizeof(Dwarf_Regtable_Entry3));

	/* Set rules to initial values. */
	for (i = 0; i < rt->rt3_reg_table_size; i++)
  8004213998:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800421399f:	eb 2f                	jmp    80042139d0 <_dwarf_frame_get_internal_table+0x130>
		rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;
  80042139a1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042139a5:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042139a9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042139ac:	48 63 d0             	movslq %eax,%rdx
  80042139af:	48 89 d0             	mov    %rdx,%rax
  80042139b2:	48 01 c0             	add    %rax,%rax
  80042139b5:	48 01 d0             	add    %rdx,%rax
  80042139b8:	48 c1 e0 03          	shl    $0x3,%rax
  80042139bc:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042139c0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042139c4:	0f b7 40 4a          	movzwl 0x4a(%rax),%eax
  80042139c8:	66 89 42 02          	mov    %ax,0x2(%rdx)
	memset(&rt->rt3_cfa_rule, 0, sizeof(Dwarf_Regtable_Entry3));
	memset(rt->rt3_rules, 0, rt->rt3_reg_table_size *
	       sizeof(Dwarf_Regtable_Entry3));

	/* Set rules to initial values. */
	for (i = 0; i < rt->rt3_reg_table_size; i++)
  80042139cc:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042139d0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042139d4:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042139d8:	0f b7 c0             	movzwl %ax,%eax
  80042139db:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80042139de:	7f c1                	jg     80042139a1 <_dwarf_frame_get_internal_table+0x101>
		rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;

	/* Run initial instructions in CIE. */
	cie = fde->fde_cie;
  80042139e0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042139e4:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042139e8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	assert(cie != NULL);
  80042139ec:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042139f1:	75 35                	jne    8004213a28 <_dwarf_frame_get_internal_table+0x188>
  80042139f3:	48 b9 53 b4 21 04 80 	movabs $0x800421b453,%rcx
  80042139fa:	00 00 00 
  80042139fd:	48 ba 47 b3 21 04 80 	movabs $0x800421b347,%rdx
  8004213a04:	00 00 00 
  8004213a07:	be 95 01 00 00       	mov    $0x195,%esi
  8004213a0c:	48 bf 5c b3 21 04 80 	movabs $0x800421b35c,%rdi
  8004213a13:	00 00 00 
  8004213a16:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213a1b:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004213a22:	00 00 00 
  8004213a25:	41 ff d0             	callq  *%r8
	ret = _dwarf_frame_run_inst(dbg, rt, cie->cie_initinst,
  8004213a28:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213a2c:	4c 8b 48 40          	mov    0x40(%rax),%r9
  8004213a30:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213a34:	4c 8b 40 38          	mov    0x38(%rax),%r8
  8004213a38:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213a3c:	48 8b 48 70          	mov    0x70(%rax),%rcx
  8004213a40:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213a44:	48 8b 50 68          	mov    0x68(%rax),%rdx
  8004213a48:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8004213a4c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213a50:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
  8004213a54:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  8004213a59:	48 8d 7d d8          	lea    -0x28(%rbp),%rdi
  8004213a5d:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  8004213a62:	48 c7 44 24 08 ff ff 	movq   $0xffffffffffffffff,0x8(%rsp)
  8004213a69:	ff ff 
  8004213a6b:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  8004213a72:	00 
  8004213a73:	48 89 c7             	mov    %rax,%rdi
  8004213a76:	48 b8 c4 2a 21 04 80 	movabs $0x8004212ac4,%rax
  8004213a7d:	00 00 00 
  8004213a80:	ff d0                	callq  *%rax
  8004213a82:	89 45 e4             	mov    %eax,-0x1c(%rbp)
				    cie->cie_instlen, cie->cie_caf,
				    cie->cie_daf, 0, ~0ULL,
				    &row_pc, error);
	if (ret != DW_DLE_NONE)
  8004213a85:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004213a89:	74 08                	je     8004213a93 <_dwarf_frame_get_internal_table+0x1f3>
		return (ret);
  8004213a8b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004213a8e:	e9 98 00 00 00       	jmpq   8004213b2b <_dwarf_frame_get_internal_table+0x28b>
	/* Run instructions in FDE. */
	if (pc_req >= fde->fde_initloc) {
  8004213a93:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213a97:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004213a9b:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004213a9f:	77 6f                	ja     8004213b10 <_dwarf_frame_get_internal_table+0x270>
		ret = _dwarf_frame_run_inst(dbg, rt, fde->fde_inst,
  8004213aa1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213aa5:	48 8b 78 30          	mov    0x30(%rax),%rdi
  8004213aa9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213aad:	4c 8b 48 40          	mov    0x40(%rax),%r9
  8004213ab1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213ab5:	4c 8b 50 38          	mov    0x38(%rax),%r10
  8004213ab9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213abd:	48 8b 48 58          	mov    0x58(%rax),%rcx
  8004213ac1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213ac5:	48 8b 50 50          	mov    0x50(%rax),%rdx
  8004213ac9:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8004213acd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213ad1:	4c 8b 45 a0          	mov    -0x60(%rbp),%r8
  8004213ad5:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
  8004213ada:	4c 8d 45 d8          	lea    -0x28(%rbp),%r8
  8004213ade:	4c 89 44 24 10       	mov    %r8,0x10(%rsp)
  8004213ae3:	4c 8b 45 b8          	mov    -0x48(%rbp),%r8
  8004213ae7:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  8004213aec:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004213af0:	4d 89 d0             	mov    %r10,%r8
  8004213af3:	48 89 c7             	mov    %rax,%rdi
  8004213af6:	48 b8 c4 2a 21 04 80 	movabs $0x8004212ac4,%rax
  8004213afd:	00 00 00 
  8004213b00:	ff d0                	callq  *%rax
  8004213b02:	89 45 e4             	mov    %eax,-0x1c(%rbp)
					    fde->fde_instlen, cie->cie_caf,
					    cie->cie_daf,
					    fde->fde_initloc, pc_req,
					    &row_pc, error);
		if (ret != DW_DLE_NONE)
  8004213b05:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004213b09:	74 05                	je     8004213b10 <_dwarf_frame_get_internal_table+0x270>
			return (ret);
  8004213b0b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004213b0e:	eb 1b                	jmp    8004213b2b <_dwarf_frame_get_internal_table+0x28b>
	}

	*ret_rt = rt;
  8004213b10:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213b14:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004213b18:	48 89 10             	mov    %rdx,(%rax)
	*ret_row_pc = row_pc;
  8004213b1b:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004213b1f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004213b23:	48 89 10             	mov    %rdx,(%rax)

	return (DW_DLE_NONE);
  8004213b26:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004213b2b:	c9                   	leaveq 
  8004213b2c:	c3                   	retq   

0000008004213b2d <dwarf_get_fde_info_for_all_regs>:
int
dwarf_get_fde_info_for_all_regs(Dwarf_Debug dbg, Dwarf_Fde fde,
				Dwarf_Addr pc_requested,
				Dwarf_Regtable *reg_table, Dwarf_Addr *row_pc,
				Dwarf_Error *error)
{
  8004213b2d:	55                   	push   %rbp
  8004213b2e:	48 89 e5             	mov    %rsp,%rbp
  8004213b31:	48 83 ec 50          	sub    $0x50,%rsp
  8004213b35:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004213b39:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004213b3d:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004213b41:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  8004213b45:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
  8004213b49:	4c 89 4d b0          	mov    %r9,-0x50(%rbp)
	Dwarf_Regtable3 *rt;
	Dwarf_Addr pc;
	Dwarf_Half cfa;
	int i, ret;

	if (fde == NULL || reg_table == NULL) {
  8004213b4d:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004213b52:	74 07                	je     8004213b5b <dwarf_get_fde_info_for_all_regs+0x2e>
  8004213b54:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004213b59:	75 0a                	jne    8004213b65 <dwarf_get_fde_info_for_all_regs+0x38>
		DWARF_SET_ERROR(dbg, error, DW_DLE_ARGUMENT);
		return (DW_DLV_ERROR);
  8004213b5b:	b8 01 00 00 00       	mov    $0x1,%eax
  8004213b60:	e9 eb 02 00 00       	jmpq   8004213e50 <dwarf_get_fde_info_for_all_regs+0x323>
	}

	assert(dbg != NULL);
  8004213b65:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004213b6a:	75 35                	jne    8004213ba1 <dwarf_get_fde_info_for_all_regs+0x74>
  8004213b6c:	48 b9 47 b4 21 04 80 	movabs $0x800421b447,%rcx
  8004213b73:	00 00 00 
  8004213b76:	48 ba 47 b3 21 04 80 	movabs $0x800421b347,%rdx
  8004213b7d:	00 00 00 
  8004213b80:	be bf 01 00 00       	mov    $0x1bf,%esi
  8004213b85:	48 bf 5c b3 21 04 80 	movabs $0x800421b35c,%rdi
  8004213b8c:	00 00 00 
  8004213b8f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213b94:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004213b9b:	00 00 00 
  8004213b9e:	41 ff d0             	callq  *%r8

	if (pc_requested < fde->fde_initloc ||
  8004213ba1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213ba5:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004213ba9:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004213bad:	77 19                	ja     8004213bc8 <dwarf_get_fde_info_for_all_regs+0x9b>
	    pc_requested >= fde->fde_initloc + fde->fde_adrange) {
  8004213baf:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213bb3:	48 8b 50 30          	mov    0x30(%rax),%rdx
  8004213bb7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213bbb:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213bbf:	48 01 d0             	add    %rdx,%rax
		return (DW_DLV_ERROR);
	}

	assert(dbg != NULL);

	if (pc_requested < fde->fde_initloc ||
  8004213bc2:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004213bc6:	77 0a                	ja     8004213bd2 <dwarf_get_fde_info_for_all_regs+0xa5>
	    pc_requested >= fde->fde_initloc + fde->fde_adrange) {
		DWARF_SET_ERROR(dbg, error, DW_DLE_PC_NOT_IN_FDE_RANGE);
		return (DW_DLV_ERROR);
  8004213bc8:	b8 01 00 00 00       	mov    $0x1,%eax
  8004213bcd:	e9 7e 02 00 00       	jmpq   8004213e50 <dwarf_get_fde_info_for_all_regs+0x323>
	}

	ret = _dwarf_frame_get_internal_table(dbg, fde, pc_requested, &rt, &pc,
  8004213bd2:	4c 8b 45 b0          	mov    -0x50(%rbp),%r8
  8004213bd6:	48 8d 7d e0          	lea    -0x20(%rbp),%rdi
  8004213bda:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  8004213bde:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213be2:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004213be6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213bea:	4d 89 c1             	mov    %r8,%r9
  8004213bed:	49 89 f8             	mov    %rdi,%r8
  8004213bf0:	48 89 c7             	mov    %rax,%rdi
  8004213bf3:	48 b8 a0 38 21 04 80 	movabs $0x80042138a0,%rax
  8004213bfa:	00 00 00 
  8004213bfd:	ff d0                	callq  *%rax
  8004213bff:	89 45 f8             	mov    %eax,-0x8(%rbp)
					      error);
	if (ret != DW_DLE_NONE)
  8004213c02:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  8004213c06:	74 0a                	je     8004213c12 <dwarf_get_fde_info_for_all_regs+0xe5>
		return (DW_DLV_ERROR);
  8004213c08:	b8 01 00 00 00       	mov    $0x1,%eax
  8004213c0d:	e9 3e 02 00 00       	jmpq   8004213e50 <dwarf_get_fde_info_for_all_regs+0x323>
	/*
	 * Copy the CFA rule to the column intended for holding the CFA,
	 * if it's within the range of regtable.
	 */
#define CFA rt->rt3_cfa_rule
	cfa = dbg->dbg_frame_cfa_value;
  8004213c12:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213c16:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004213c1a:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
	if (cfa < DW_REG_TABLE_SIZE) {
  8004213c1e:	66 83 7d f6 41       	cmpw   $0x41,-0xa(%rbp)
  8004213c23:	0f 87 b1 00 00 00    	ja     8004213cda <dwarf_get_fde_info_for_all_regs+0x1ad>
		reg_table->rules[cfa].dw_offset_relevant =
  8004213c29:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
			CFA.dw_offset_relevant;
  8004213c2d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213c31:	0f b6 00             	movzbl (%rax),%eax
	 * if it's within the range of regtable.
	 */
#define CFA rt->rt3_cfa_rule
	cfa = dbg->dbg_frame_cfa_value;
	if (cfa < DW_REG_TABLE_SIZE) {
		reg_table->rules[cfa].dw_offset_relevant =
  8004213c34:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004213c38:	48 63 c9             	movslq %ecx,%rcx
  8004213c3b:	48 83 c1 01          	add    $0x1,%rcx
  8004213c3f:	48 c1 e1 04          	shl    $0x4,%rcx
  8004213c43:	48 01 ca             	add    %rcx,%rdx
  8004213c46:	88 02                	mov    %al,(%rdx)
			CFA.dw_offset_relevant;
		reg_table->rules[cfa].dw_value_type = CFA.dw_value_type;
  8004213c48:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  8004213c4c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213c50:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8004213c54:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004213c58:	48 63 c9             	movslq %ecx,%rcx
  8004213c5b:	48 83 c1 01          	add    $0x1,%rcx
  8004213c5f:	48 c1 e1 04          	shl    $0x4,%rcx
  8004213c63:	48 01 ca             	add    %rcx,%rdx
  8004213c66:	88 42 01             	mov    %al,0x1(%rdx)
		reg_table->rules[cfa].dw_regnum = CFA.dw_regnum;
  8004213c69:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  8004213c6d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213c71:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  8004213c75:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004213c79:	48 63 c9             	movslq %ecx,%rcx
  8004213c7c:	48 83 c1 01          	add    $0x1,%rcx
  8004213c80:	48 c1 e1 04          	shl    $0x4,%rcx
  8004213c84:	48 01 ca             	add    %rcx,%rdx
  8004213c87:	66 89 42 02          	mov    %ax,0x2(%rdx)
		reg_table->rules[cfa].dw_offset = CFA.dw_offset_or_block_len;
  8004213c8b:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  8004213c8f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213c93:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004213c97:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004213c9b:	48 63 c9             	movslq %ecx,%rcx
  8004213c9e:	48 83 c1 01          	add    $0x1,%rcx
  8004213ca2:	48 c1 e1 04          	shl    $0x4,%rcx
  8004213ca6:	48 01 ca             	add    %rcx,%rdx
  8004213ca9:	48 83 c2 08          	add    $0x8,%rdx
  8004213cad:	48 89 02             	mov    %rax,(%rdx)
		reg_table->cfa_rule = reg_table->rules[cfa];
  8004213cb0:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  8004213cb4:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004213cb8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213cbc:	48 63 d2             	movslq %edx,%rdx
  8004213cbf:	48 83 c2 01          	add    $0x1,%rdx
  8004213cc3:	48 c1 e2 04          	shl    $0x4,%rdx
  8004213cc7:	48 01 d0             	add    %rdx,%rax
  8004213cca:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004213cce:	48 8b 00             	mov    (%rax),%rax
  8004213cd1:	48 89 01             	mov    %rax,(%rcx)
  8004213cd4:	48 89 51 08          	mov    %rdx,0x8(%rcx)
  8004213cd8:	eb 3c                	jmp    8004213d16 <dwarf_get_fde_info_for_all_regs+0x1e9>
	} else {
		reg_table->cfa_rule.dw_offset_relevant =
		    CFA.dw_offset_relevant;
  8004213cda:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213cde:	0f b6 10             	movzbl (%rax),%edx
		reg_table->rules[cfa].dw_value_type = CFA.dw_value_type;
		reg_table->rules[cfa].dw_regnum = CFA.dw_regnum;
		reg_table->rules[cfa].dw_offset = CFA.dw_offset_or_block_len;
		reg_table->cfa_rule = reg_table->rules[cfa];
	} else {
		reg_table->cfa_rule.dw_offset_relevant =
  8004213ce1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213ce5:	88 10                	mov    %dl,(%rax)
		    CFA.dw_offset_relevant;
		reg_table->cfa_rule.dw_value_type = CFA.dw_value_type;
  8004213ce7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213ceb:	0f b6 50 01          	movzbl 0x1(%rax),%edx
  8004213cef:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213cf3:	88 50 01             	mov    %dl,0x1(%rax)
		reg_table->cfa_rule.dw_regnum = CFA.dw_regnum;
  8004213cf6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213cfa:	0f b7 50 02          	movzwl 0x2(%rax),%edx
  8004213cfe:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213d02:	66 89 50 02          	mov    %dx,0x2(%rax)
		reg_table->cfa_rule.dw_offset = CFA.dw_offset_or_block_len;
  8004213d06:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213d0a:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004213d0e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213d12:	48 89 50 08          	mov    %rdx,0x8(%rax)
	}

	/*
	 * Copy other columns.
	 */
	for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
  8004213d16:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004213d1d:	e9 fd 00 00 00       	jmpq   8004213e1f <dwarf_get_fde_info_for_all_regs+0x2f2>
	     i++) {

		/* Do not overwrite CFA column */
		if (i == cfa)
  8004213d22:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  8004213d26:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8004213d29:	75 05                	jne    8004213d30 <dwarf_get_fde_info_for_all_regs+0x203>
			continue;
  8004213d2b:	e9 eb 00 00 00       	jmpq   8004213e1b <dwarf_get_fde_info_for_all_regs+0x2ee>

		reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
  8004213d30:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213d34:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213d38:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004213d3b:	48 63 d0             	movslq %eax,%rdx
  8004213d3e:	48 89 d0             	mov    %rdx,%rax
  8004213d41:	48 01 c0             	add    %rax,%rax
  8004213d44:	48 01 d0             	add    %rdx,%rax
  8004213d47:	48 c1 e0 03          	shl    $0x3,%rax
  8004213d4b:	48 01 c8             	add    %rcx,%rax
  8004213d4e:	0f b6 00             	movzbl (%rax),%eax

		/* Do not overwrite CFA column */
		if (i == cfa)
			continue;

		reg_table->rules[i].dw_offset_relevant =
  8004213d51:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004213d55:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004213d58:	48 63 c9             	movslq %ecx,%rcx
  8004213d5b:	48 83 c1 01          	add    $0x1,%rcx
  8004213d5f:	48 c1 e1 04          	shl    $0x4,%rcx
  8004213d63:	48 01 ca             	add    %rcx,%rdx
  8004213d66:	88 02                	mov    %al,(%rdx)
			rt->rt3_rules[i].dw_offset_relevant;
		reg_table->rules[i].dw_value_type =
			rt->rt3_rules[i].dw_value_type;
  8004213d68:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213d6c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213d70:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004213d73:	48 63 d0             	movslq %eax,%rdx
  8004213d76:	48 89 d0             	mov    %rdx,%rax
  8004213d79:	48 01 c0             	add    %rax,%rax
  8004213d7c:	48 01 d0             	add    %rdx,%rax
  8004213d7f:	48 c1 e0 03          	shl    $0x3,%rax
  8004213d83:	48 01 c8             	add    %rcx,%rax
  8004213d86:	0f b6 40 01          	movzbl 0x1(%rax),%eax
		if (i == cfa)
			continue;

		reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
		reg_table->rules[i].dw_value_type =
  8004213d8a:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004213d8e:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004213d91:	48 63 c9             	movslq %ecx,%rcx
  8004213d94:	48 83 c1 01          	add    $0x1,%rcx
  8004213d98:	48 c1 e1 04          	shl    $0x4,%rcx
  8004213d9c:	48 01 ca             	add    %rcx,%rdx
  8004213d9f:	88 42 01             	mov    %al,0x1(%rdx)
			rt->rt3_rules[i].dw_value_type;
		reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
  8004213da2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213da6:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213daa:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004213dad:	48 63 d0             	movslq %eax,%rdx
  8004213db0:	48 89 d0             	mov    %rdx,%rax
  8004213db3:	48 01 c0             	add    %rax,%rax
  8004213db6:	48 01 d0             	add    %rdx,%rax
  8004213db9:	48 c1 e0 03          	shl    $0x3,%rax
  8004213dbd:	48 01 c8             	add    %rcx,%rax
  8004213dc0:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  8004213dc4:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004213dc8:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004213dcb:	48 63 c9             	movslq %ecx,%rcx
  8004213dce:	48 83 c1 01          	add    $0x1,%rcx
  8004213dd2:	48 c1 e1 04          	shl    $0x4,%rcx
  8004213dd6:	48 01 ca             	add    %rcx,%rdx
  8004213dd9:	66 89 42 02          	mov    %ax,0x2(%rdx)
		reg_table->rules[i].dw_offset =
			rt->rt3_rules[i].dw_offset_or_block_len;
  8004213ddd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213de1:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213de5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004213de8:	48 63 d0             	movslq %eax,%rdx
  8004213deb:	48 89 d0             	mov    %rdx,%rax
  8004213dee:	48 01 c0             	add    %rax,%rax
  8004213df1:	48 01 d0             	add    %rdx,%rax
  8004213df4:	48 c1 e0 03          	shl    $0x3,%rax
  8004213df8:	48 01 c8             	add    %rcx,%rax
  8004213dfb:	48 8b 40 08          	mov    0x8(%rax),%rax
		reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
		reg_table->rules[i].dw_value_type =
			rt->rt3_rules[i].dw_value_type;
		reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
		reg_table->rules[i].dw_offset =
  8004213dff:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004213e03:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004213e06:	48 63 c9             	movslq %ecx,%rcx
  8004213e09:	48 83 c1 01          	add    $0x1,%rcx
  8004213e0d:	48 c1 e1 04          	shl    $0x4,%rcx
  8004213e11:	48 01 ca             	add    %rcx,%rdx
  8004213e14:	48 83 c2 08          	add    $0x8,%rdx
  8004213e18:	48 89 02             	mov    %rax,(%rdx)

	/*
	 * Copy other columns.
	 */
	for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
	     i++) {
  8004213e1b:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
	}

	/*
	 * Copy other columns.
	 */
	for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
  8004213e1f:	83 7d fc 41          	cmpl   $0x41,-0x4(%rbp)
  8004213e23:	7f 14                	jg     8004213e39 <dwarf_get_fde_info_for_all_regs+0x30c>
  8004213e25:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213e29:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  8004213e2d:	0f b7 c0             	movzwl %ax,%eax
  8004213e30:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8004213e33:	0f 8f e9 fe ff ff    	jg     8004213d22 <dwarf_get_fde_info_for_all_regs+0x1f5>
		reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
		reg_table->rules[i].dw_offset =
			rt->rt3_rules[i].dw_offset_or_block_len;
	}

	if (row_pc) *row_pc = pc;
  8004213e39:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004213e3e:	74 0b                	je     8004213e4b <dwarf_get_fde_info_for_all_regs+0x31e>
  8004213e40:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213e44:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213e48:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLV_OK);
  8004213e4b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004213e50:	c9                   	leaveq 
  8004213e51:	c3                   	retq   

0000008004213e52 <_dwarf_frame_read_lsb_encoded>:

static int
_dwarf_frame_read_lsb_encoded(Dwarf_Debug dbg, uint64_t *val, uint8_t *data,
			      uint64_t *offsetp, uint8_t encode, Dwarf_Addr pc, Dwarf_Error *error)
{
  8004213e52:	55                   	push   %rbp
  8004213e53:	48 89 e5             	mov    %rsp,%rbp
  8004213e56:	48 83 ec 40          	sub    $0x40,%rsp
  8004213e5a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004213e5e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004213e62:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004213e66:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  8004213e6a:	44 89 c0             	mov    %r8d,%eax
  8004213e6d:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
  8004213e71:	88 45 cc             	mov    %al,-0x34(%rbp)
	uint8_t application;

	if (encode == DW_EH_PE_omit)
  8004213e74:	80 7d cc ff          	cmpb   $0xff,-0x34(%rbp)
  8004213e78:	75 0a                	jne    8004213e84 <_dwarf_frame_read_lsb_encoded+0x32>
		return (DW_DLE_NONE);
  8004213e7a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213e7f:	e9 e6 01 00 00       	jmpq   800421406a <_dwarf_frame_read_lsb_encoded+0x218>

	application = encode & 0xf0;
  8004213e84:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004213e88:	83 e0 f0             	and    $0xfffffff0,%eax
  8004213e8b:	88 45 ff             	mov    %al,-0x1(%rbp)
	encode &= 0x0f;
  8004213e8e:	80 65 cc 0f          	andb   $0xf,-0x34(%rbp)

	switch (encode) {
  8004213e92:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004213e96:	83 f8 0c             	cmp    $0xc,%eax
  8004213e99:	0f 87 72 01 00 00    	ja     8004214011 <_dwarf_frame_read_lsb_encoded+0x1bf>
  8004213e9f:	89 c0                	mov    %eax,%eax
  8004213ea1:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004213ea8:	00 
  8004213ea9:	48 b8 60 b4 21 04 80 	movabs $0x800421b460,%rax
  8004213eb0:	00 00 00 
  8004213eb3:	48 01 d0             	add    %rdx,%rax
  8004213eb6:	48 8b 00             	mov    (%rax),%rax
  8004213eb9:	ff e0                	jmpq   *%rax
	case DW_EH_PE_absptr:
		*val = dbg->read(data, offsetp, dbg->dbg_pointer_size);
  8004213ebb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213ebf:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213ec3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213ec7:	8b 52 28             	mov    0x28(%rdx),%edx
  8004213eca:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004213ece:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004213ed2:	48 89 cf             	mov    %rcx,%rdi
  8004213ed5:	ff d0                	callq  *%rax
  8004213ed7:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213edb:	48 89 02             	mov    %rax,(%rdx)
		break;
  8004213ede:	e9 35 01 00 00       	jmpq   8004214018 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_uleb128:
		*val = _dwarf_read_uleb128(data, offsetp);
  8004213ee3:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213ee7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213eeb:	48 89 d6             	mov    %rdx,%rsi
  8004213eee:	48 89 c7             	mov    %rax,%rdi
  8004213ef1:	48 b8 e6 0e 21 04 80 	movabs $0x8004210ee6,%rax
  8004213ef8:	00 00 00 
  8004213efb:	ff d0                	callq  *%rax
  8004213efd:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213f01:	48 89 02             	mov    %rax,(%rdx)
		break;
  8004213f04:	e9 0f 01 00 00       	jmpq   8004214018 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_udata2:
		*val = dbg->read(data, offsetp, 2);
  8004213f09:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213f0d:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213f11:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004213f15:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004213f19:	ba 02 00 00 00       	mov    $0x2,%edx
  8004213f1e:	48 89 cf             	mov    %rcx,%rdi
  8004213f21:	ff d0                	callq  *%rax
  8004213f23:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213f27:	48 89 02             	mov    %rax,(%rdx)
		break;
  8004213f2a:	e9 e9 00 00 00       	jmpq   8004214018 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_udata4:
		*val = dbg->read(data, offsetp, 4);
  8004213f2f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213f33:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213f37:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004213f3b:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004213f3f:	ba 04 00 00 00       	mov    $0x4,%edx
  8004213f44:	48 89 cf             	mov    %rcx,%rdi
  8004213f47:	ff d0                	callq  *%rax
  8004213f49:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213f4d:	48 89 02             	mov    %rax,(%rdx)
		break;
  8004213f50:	e9 c3 00 00 00       	jmpq   8004214018 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_udata8:
		*val = dbg->read(data, offsetp, 8);
  8004213f55:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213f59:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213f5d:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004213f61:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004213f65:	ba 08 00 00 00       	mov    $0x8,%edx
  8004213f6a:	48 89 cf             	mov    %rcx,%rdi
  8004213f6d:	ff d0                	callq  *%rax
  8004213f6f:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213f73:	48 89 02             	mov    %rax,(%rdx)
		break;
  8004213f76:	e9 9d 00 00 00       	jmpq   8004214018 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sleb128:
		*val = _dwarf_read_sleb128(data, offsetp);
  8004213f7b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213f7f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213f83:	48 89 d6             	mov    %rdx,%rsi
  8004213f86:	48 89 c7             	mov    %rax,%rdi
  8004213f89:	48 b8 42 0e 21 04 80 	movabs $0x8004210e42,%rax
  8004213f90:	00 00 00 
  8004213f93:	ff d0                	callq  *%rax
  8004213f95:	48 89 c2             	mov    %rax,%rdx
  8004213f98:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004213f9c:	48 89 10             	mov    %rdx,(%rax)
		break;
  8004213f9f:	eb 77                	jmp    8004214018 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sdata2:
		*val = (int16_t) dbg->read(data, offsetp, 2);
  8004213fa1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213fa5:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213fa9:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004213fad:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004213fb1:	ba 02 00 00 00       	mov    $0x2,%edx
  8004213fb6:	48 89 cf             	mov    %rcx,%rdi
  8004213fb9:	ff d0                	callq  *%rax
  8004213fbb:	48 0f bf d0          	movswq %ax,%rdx
  8004213fbf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004213fc3:	48 89 10             	mov    %rdx,(%rax)
		break;
  8004213fc6:	eb 50                	jmp    8004214018 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sdata4:
		*val = (int32_t) dbg->read(data, offsetp, 4);
  8004213fc8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213fcc:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213fd0:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004213fd4:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004213fd8:	ba 04 00 00 00       	mov    $0x4,%edx
  8004213fdd:	48 89 cf             	mov    %rcx,%rdi
  8004213fe0:	ff d0                	callq  *%rax
  8004213fe2:	48 63 d0             	movslq %eax,%rdx
  8004213fe5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004213fe9:	48 89 10             	mov    %rdx,(%rax)
		break;
  8004213fec:	eb 2a                	jmp    8004214018 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sdata8:
		*val = dbg->read(data, offsetp, 8);
  8004213fee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213ff2:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213ff6:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004213ffa:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004213ffe:	ba 08 00 00 00       	mov    $0x8,%edx
  8004214003:	48 89 cf             	mov    %rcx,%rdi
  8004214006:	ff d0                	callq  *%rax
  8004214008:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421400c:	48 89 02             	mov    %rax,(%rdx)
		break;
  800421400f:	eb 07                	jmp    8004214018 <_dwarf_frame_read_lsb_encoded+0x1c6>
	default:
		DWARF_SET_ERROR(dbg, error, DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
		return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
  8004214011:	b8 14 00 00 00       	mov    $0x14,%eax
  8004214016:	eb 52                	jmp    800421406a <_dwarf_frame_read_lsb_encoded+0x218>
	}

	if (application == DW_EH_PE_pcrel) {
  8004214018:	80 7d ff 10          	cmpb   $0x10,-0x1(%rbp)
  800421401c:	75 47                	jne    8004214065 <_dwarf_frame_read_lsb_encoded+0x213>
		/*
		 * Value is relative to .eh_frame section virtual addr.
		 */
		switch (encode) {
  800421401e:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004214022:	83 f8 01             	cmp    $0x1,%eax
  8004214025:	7c 3d                	jl     8004214064 <_dwarf_frame_read_lsb_encoded+0x212>
  8004214027:	83 f8 04             	cmp    $0x4,%eax
  800421402a:	7e 0a                	jle    8004214036 <_dwarf_frame_read_lsb_encoded+0x1e4>
  800421402c:	83 e8 09             	sub    $0x9,%eax
  800421402f:	83 f8 03             	cmp    $0x3,%eax
  8004214032:	77 30                	ja     8004214064 <_dwarf_frame_read_lsb_encoded+0x212>
  8004214034:	eb 17                	jmp    800421404d <_dwarf_frame_read_lsb_encoded+0x1fb>
		case DW_EH_PE_uleb128:
		case DW_EH_PE_udata2:
		case DW_EH_PE_udata4:
		case DW_EH_PE_udata8:
			*val += pc;
  8004214036:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421403a:	48 8b 10             	mov    (%rax),%rdx
  800421403d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214041:	48 01 c2             	add    %rax,%rdx
  8004214044:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214048:	48 89 10             	mov    %rdx,(%rax)
			break;
  800421404b:	eb 18                	jmp    8004214065 <_dwarf_frame_read_lsb_encoded+0x213>
		case DW_EH_PE_sleb128:
		case DW_EH_PE_sdata2:
		case DW_EH_PE_sdata4:
		case DW_EH_PE_sdata8:
			*val = pc + (int64_t) *val;
  800421404d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214051:	48 8b 10             	mov    (%rax),%rdx
  8004214054:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214058:	48 01 c2             	add    %rax,%rdx
  800421405b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421405f:	48 89 10             	mov    %rdx,(%rax)
			break;
  8004214062:	eb 01                	jmp    8004214065 <_dwarf_frame_read_lsb_encoded+0x213>
		default:
			/* DW_EH_PE_absptr is absolute value. */
			break;
  8004214064:	90                   	nop
		}
	}

	/* XXX Applications other than DW_EH_PE_pcrel are not handled. */

	return (DW_DLE_NONE);
  8004214065:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421406a:	c9                   	leaveq 
  800421406b:	c3                   	retq   

000000800421406c <_dwarf_frame_parse_lsb_cie_augment>:

static int
_dwarf_frame_parse_lsb_cie_augment(Dwarf_Debug dbg, Dwarf_Cie cie,
				   Dwarf_Error *error)
{
  800421406c:	55                   	push   %rbp
  800421406d:	48 89 e5             	mov    %rsp,%rbp
  8004214070:	48 83 ec 50          	sub    $0x50,%rsp
  8004214074:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004214078:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800421407c:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
	uint8_t *aug_p, *augdata_p;
	uint64_t val, offset;
	uint8_t encode;
	int ret;

	assert(cie->cie_augment != NULL && *cie->cie_augment == 'z');
  8004214080:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214084:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004214088:	48 85 c0             	test   %rax,%rax
  800421408b:	74 0f                	je     800421409c <_dwarf_frame_parse_lsb_cie_augment+0x30>
  800421408d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214091:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004214095:	0f b6 00             	movzbl (%rax),%eax
  8004214098:	3c 7a                	cmp    $0x7a,%al
  800421409a:	74 35                	je     80042140d1 <_dwarf_frame_parse_lsb_cie_augment+0x65>
  800421409c:	48 b9 c8 b4 21 04 80 	movabs $0x800421b4c8,%rcx
  80042140a3:	00 00 00 
  80042140a6:	48 ba 47 b3 21 04 80 	movabs $0x800421b347,%rdx
  80042140ad:	00 00 00 
  80042140b0:	be 4a 02 00 00       	mov    $0x24a,%esi
  80042140b5:	48 bf 5c b3 21 04 80 	movabs $0x800421b35c,%rdi
  80042140bc:	00 00 00 
  80042140bf:	b8 00 00 00 00       	mov    $0x0,%eax
  80042140c4:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042140cb:	00 00 00 
  80042140ce:	41 ff d0             	callq  *%r8
	/*
	 * Here we're only interested in the presence of augment 'R'
	 * and associated CIE augment data, which describes the
	 * encoding scheme of FDE PC begin and range.
	 */
	aug_p = &cie->cie_augment[1];
  80042140d1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042140d5:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042140d9:	48 83 c0 01          	add    $0x1,%rax
  80042140dd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	augdata_p = cie->cie_augdata;
  80042140e1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042140e5:	48 8b 40 58          	mov    0x58(%rax),%rax
  80042140e9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	while (*aug_p != '\0') {
  80042140ed:	e9 af 00 00 00       	jmpq   80042141a1 <_dwarf_frame_parse_lsb_cie_augment+0x135>
		switch (*aug_p) {
  80042140f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042140f6:	0f b6 00             	movzbl (%rax),%eax
  80042140f9:	0f b6 c0             	movzbl %al,%eax
  80042140fc:	83 f8 50             	cmp    $0x50,%eax
  80042140ff:	74 18                	je     8004214119 <_dwarf_frame_parse_lsb_cie_augment+0xad>
  8004214101:	83 f8 52             	cmp    $0x52,%eax
  8004214104:	74 77                	je     800421417d <_dwarf_frame_parse_lsb_cie_augment+0x111>
  8004214106:	83 f8 4c             	cmp    $0x4c,%eax
  8004214109:	0f 85 86 00 00 00    	jne    8004214195 <_dwarf_frame_parse_lsb_cie_augment+0x129>
		case 'L':
			/* Skip one augment in augment data. */
			augdata_p++;
  800421410f:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
			break;
  8004214114:	e9 83 00 00 00       	jmpq   800421419c <_dwarf_frame_parse_lsb_cie_augment+0x130>
		case 'P':
			/* Skip two augments in augment data. */
			encode = *augdata_p++;
  8004214119:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421411d:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004214121:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  8004214125:	0f b6 00             	movzbl (%rax),%eax
  8004214128:	88 45 ef             	mov    %al,-0x11(%rbp)
			offset = 0;
  800421412b:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  8004214132:	00 
			ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004214133:	44 0f b6 45 ef       	movzbl -0x11(%rbp),%r8d
  8004214138:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  800421413c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004214140:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  8004214144:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214148:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  800421414c:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004214150:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8004214156:	48 89 c7             	mov    %rax,%rdi
  8004214159:	48 b8 52 3e 21 04 80 	movabs $0x8004213e52,%rax
  8004214160:	00 00 00 
  8004214163:	ff d0                	callq  *%rax
  8004214165:	89 45 e8             	mov    %eax,-0x18(%rbp)
							    augdata_p, &offset, encode, 0, error);
			if (ret != DW_DLE_NONE)
  8004214168:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  800421416c:	74 05                	je     8004214173 <_dwarf_frame_parse_lsb_cie_augment+0x107>
				return (ret);
  800421416e:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004214171:	eb 42                	jmp    80042141b5 <_dwarf_frame_parse_lsb_cie_augment+0x149>
			augdata_p += offset;
  8004214173:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214177:	48 01 45 f0          	add    %rax,-0x10(%rbp)
			break;
  800421417b:	eb 1f                	jmp    800421419c <_dwarf_frame_parse_lsb_cie_augment+0x130>
		case 'R':
			cie->cie_fde_encode = *augdata_p++;
  800421417d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214181:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004214185:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  8004214189:	0f b6 10             	movzbl (%rax),%edx
  800421418c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214190:	88 50 60             	mov    %dl,0x60(%rax)
			break;
  8004214193:	eb 07                	jmp    800421419c <_dwarf_frame_parse_lsb_cie_augment+0x130>
		default:
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
			return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
  8004214195:	b8 14 00 00 00       	mov    $0x14,%eax
  800421419a:	eb 19                	jmp    80042141b5 <_dwarf_frame_parse_lsb_cie_augment+0x149>
		}
		aug_p++;
  800421419c:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
	 * and associated CIE augment data, which describes the
	 * encoding scheme of FDE PC begin and range.
	 */
	aug_p = &cie->cie_augment[1];
	augdata_p = cie->cie_augdata;
	while (*aug_p != '\0') {
  80042141a1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042141a5:	0f b6 00             	movzbl (%rax),%eax
  80042141a8:	84 c0                	test   %al,%al
  80042141aa:	0f 85 42 ff ff ff    	jne    80042140f2 <_dwarf_frame_parse_lsb_cie_augment+0x86>
			return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
		}
		aug_p++;
	}

	return (DW_DLE_NONE);
  80042141b0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042141b5:	c9                   	leaveq 
  80042141b6:	c3                   	retq   

00000080042141b7 <_dwarf_frame_set_cie>:


static int
_dwarf_frame_set_cie(Dwarf_Debug dbg, Dwarf_Section *ds,
		     Dwarf_Unsigned *off, Dwarf_Cie ret_cie, Dwarf_Error *error)
{
  80042141b7:	55                   	push   %rbp
  80042141b8:	48 89 e5             	mov    %rsp,%rbp
  80042141bb:	48 83 ec 60          	sub    $0x60,%rsp
  80042141bf:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80042141c3:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  80042141c7:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  80042141cb:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  80042141cf:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
	Dwarf_Cie cie;
	uint64_t length;
	int dwarf_size, ret;
	char *p;

	assert(ret_cie);
  80042141d3:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  80042141d8:	75 35                	jne    800421420f <_dwarf_frame_set_cie+0x58>
  80042141da:	48 b9 fd b4 21 04 80 	movabs $0x800421b4fd,%rcx
  80042141e1:	00 00 00 
  80042141e4:	48 ba 47 b3 21 04 80 	movabs $0x800421b347,%rdx
  80042141eb:	00 00 00 
  80042141ee:	be 7b 02 00 00       	mov    $0x27b,%esi
  80042141f3:	48 bf 5c b3 21 04 80 	movabs $0x800421b35c,%rdi
  80042141fa:	00 00 00 
  80042141fd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214202:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004214209:	00 00 00 
  800421420c:	41 ff d0             	callq  *%r8
	cie = ret_cie;
  800421420f:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214213:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	cie->cie_dbg = dbg;
  8004214217:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421421b:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421421f:	48 89 10             	mov    %rdx,(%rax)
	cie->cie_offset = *off;
  8004214222:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214226:	48 8b 10             	mov    (%rax),%rdx
  8004214229:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421422d:	48 89 50 10          	mov    %rdx,0x10(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  8004214231:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214235:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214239:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421423d:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004214241:	48 89 d1             	mov    %rdx,%rcx
  8004214244:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004214248:	ba 04 00 00 00       	mov    $0x4,%edx
  800421424d:	48 89 cf             	mov    %rcx,%rdi
  8004214250:	ff d0                	callq  *%rax
  8004214252:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (length == 0xffffffff) {
  8004214256:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800421425b:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  800421425f:	75 2e                	jne    800421428f <_dwarf_frame_set_cie+0xd8>
		dwarf_size = 8;
  8004214261:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 8);
  8004214268:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421426c:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214270:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004214274:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004214278:	48 89 d1             	mov    %rdx,%rcx
  800421427b:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  800421427f:	ba 08 00 00 00       	mov    $0x8,%edx
  8004214284:	48 89 cf             	mov    %rcx,%rdi
  8004214287:	ff d0                	callq  *%rax
  8004214289:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421428d:	eb 07                	jmp    8004214296 <_dwarf_frame_set_cie+0xdf>
	} else
		dwarf_size = 4;
  800421428f:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

	if (length > dbg->dbg_eh_size - *off) {
  8004214296:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421429a:	48 8b 50 40          	mov    0x40(%rax),%rdx
  800421429e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042142a2:	48 8b 00             	mov    (%rax),%rax
  80042142a5:	48 29 c2             	sub    %rax,%rdx
  80042142a8:	48 89 d0             	mov    %rdx,%rax
  80042142ab:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042142af:	73 0a                	jae    80042142bb <_dwarf_frame_set_cie+0x104>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_FRAME_LENGTH_BAD);
		return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  80042142b1:	b8 12 00 00 00       	mov    $0x12,%eax
  80042142b6:	e9 5d 03 00 00       	jmpq   8004214618 <_dwarf_frame_set_cie+0x461>
	}

	(void) dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size); /* Skip CIE id. */
  80042142bb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042142bf:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042142c3:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042142c7:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  80042142cb:	48 89 d1             	mov    %rdx,%rcx
  80042142ce:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042142d1:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  80042142d5:	48 89 cf             	mov    %rcx,%rdi
  80042142d8:	ff d0                	callq  *%rax
	cie->cie_length = length;
  80042142da:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042142de:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042142e2:	48 89 50 18          	mov    %rdx,0x18(%rax)

	cie->cie_version = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
  80042142e6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042142ea:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042142ee:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042142f2:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  80042142f6:	48 89 d1             	mov    %rdx,%rcx
  80042142f9:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  80042142fd:	ba 01 00 00 00       	mov    $0x1,%edx
  8004214302:	48 89 cf             	mov    %rcx,%rdi
  8004214305:	ff d0                	callq  *%rax
  8004214307:	89 c2                	mov    %eax,%edx
  8004214309:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421430d:	66 89 50 20          	mov    %dx,0x20(%rax)
	if (cie->cie_version != 1 && cie->cie_version != 3 &&
  8004214311:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214315:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  8004214319:	66 83 f8 01          	cmp    $0x1,%ax
  800421431d:	74 26                	je     8004214345 <_dwarf_frame_set_cie+0x18e>
  800421431f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214323:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  8004214327:	66 83 f8 03          	cmp    $0x3,%ax
  800421432b:	74 18                	je     8004214345 <_dwarf_frame_set_cie+0x18e>
	    cie->cie_version != 4) {
  800421432d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214331:	0f b7 40 20          	movzwl 0x20(%rax),%eax

	(void) dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size); /* Skip CIE id. */
	cie->cie_length = length;

	cie->cie_version = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
	if (cie->cie_version != 1 && cie->cie_version != 3 &&
  8004214335:	66 83 f8 04          	cmp    $0x4,%ax
  8004214339:	74 0a                	je     8004214345 <_dwarf_frame_set_cie+0x18e>
	    cie->cie_version != 4) {
		DWARF_SET_ERROR(dbg, error, DW_DLE_FRAME_VERSION_BAD);
		return (DW_DLE_FRAME_VERSION_BAD);
  800421433b:	b8 16 00 00 00       	mov    $0x16,%eax
  8004214340:	e9 d3 02 00 00       	jmpq   8004214618 <_dwarf_frame_set_cie+0x461>
	}

	cie->cie_augment = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004214345:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214349:	48 8b 10             	mov    (%rax),%rdx
  800421434c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214350:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004214354:	48 01 d0             	add    %rdx,%rax
  8004214357:	48 89 c2             	mov    %rax,%rdx
  800421435a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421435e:	48 89 50 28          	mov    %rdx,0x28(%rax)
	p = (char *)dbg->dbg_eh_offset;
  8004214362:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214366:	48 8b 40 38          	mov    0x38(%rax),%rax
  800421436a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	while (p[(*off)++] != '\0')
  800421436e:	90                   	nop
  800421436f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214373:	48 8b 00             	mov    (%rax),%rax
  8004214376:	48 8d 48 01          	lea    0x1(%rax),%rcx
  800421437a:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800421437e:	48 89 0a             	mov    %rcx,(%rdx)
  8004214381:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004214385:	48 01 d0             	add    %rdx,%rax
  8004214388:	0f b6 00             	movzbl (%rax),%eax
  800421438b:	84 c0                	test   %al,%al
  800421438d:	75 e0                	jne    800421436f <_dwarf_frame_set_cie+0x1b8>
		;

	/* We only recognize normal .dwarf_frame and GNU .eh_frame sections. */
	if (*cie->cie_augment != 0 && *cie->cie_augment != 'z') {
  800421438f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214393:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004214397:	0f b6 00             	movzbl (%rax),%eax
  800421439a:	84 c0                	test   %al,%al
  800421439c:	74 48                	je     80042143e6 <_dwarf_frame_set_cie+0x22f>
  800421439e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042143a2:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042143a6:	0f b6 00             	movzbl (%rax),%eax
  80042143a9:	3c 7a                	cmp    $0x7a,%al
  80042143ab:	74 39                	je     80042143e6 <_dwarf_frame_set_cie+0x22f>
		*off = cie->cie_offset + ((dwarf_size == 4) ? 4 : 12) +
  80042143ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042143b1:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042143b5:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  80042143b9:	75 07                	jne    80042143c2 <_dwarf_frame_set_cie+0x20b>
  80042143bb:	b8 04 00 00 00       	mov    $0x4,%eax
  80042143c0:	eb 05                	jmp    80042143c7 <_dwarf_frame_set_cie+0x210>
  80042143c2:	b8 0c 00 00 00       	mov    $0xc,%eax
  80042143c7:	48 01 c2             	add    %rax,%rdx
			cie->cie_length;
  80042143ca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042143ce:	48 8b 40 18          	mov    0x18(%rax),%rax
	while (p[(*off)++] != '\0')
		;

	/* We only recognize normal .dwarf_frame and GNU .eh_frame sections. */
	if (*cie->cie_augment != 0 && *cie->cie_augment != 'z') {
		*off = cie->cie_offset + ((dwarf_size == 4) ? 4 : 12) +
  80042143d2:	48 01 c2             	add    %rax,%rdx
  80042143d5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042143d9:	48 89 10             	mov    %rdx,(%rax)
			cie->cie_length;
		return (DW_DLE_NONE);
  80042143dc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042143e1:	e9 32 02 00 00       	jmpq   8004214618 <_dwarf_frame_set_cie+0x461>
	}

	/* Optional EH Data field for .eh_frame section. */
	if (strstr((char *)cie->cie_augment, "eh") != NULL)
  80042143e6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042143ea:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042143ee:	48 be 05 b5 21 04 80 	movabs $0x800421b505,%rsi
  80042143f5:	00 00 00 
  80042143f8:	48 89 c7             	mov    %rax,%rdi
  80042143fb:	48 b8 f9 07 21 04 80 	movabs $0x80042107f9,%rax
  8004214402:	00 00 00 
  8004214405:	ff d0                	callq  *%rax
  8004214407:	48 85 c0             	test   %rax,%rax
  800421440a:	74 28                	je     8004214434 <_dwarf_frame_set_cie+0x27d>
		cie->cie_ehdata = dbg->read((uint8_t *)dbg->dbg_eh_offset, off,
  800421440c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214410:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214414:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004214418:	8b 52 28             	mov    0x28(%rdx),%edx
  800421441b:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  800421441f:	48 8b 49 38          	mov    0x38(%rcx),%rcx
  8004214423:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004214427:	48 89 cf             	mov    %rcx,%rdi
  800421442a:	ff d0                	callq  *%rax
  800421442c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214430:	48 89 42 30          	mov    %rax,0x30(%rdx)
					    dbg->dbg_pointer_size);

	cie->cie_caf = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004214434:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214438:	48 8b 40 38          	mov    0x38(%rax),%rax
  800421443c:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004214440:	48 89 d6             	mov    %rdx,%rsi
  8004214443:	48 89 c7             	mov    %rax,%rdi
  8004214446:	48 b8 e6 0e 21 04 80 	movabs $0x8004210ee6,%rax
  800421444d:	00 00 00 
  8004214450:	ff d0                	callq  *%rax
  8004214452:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214456:	48 89 42 38          	mov    %rax,0x38(%rdx)
	cie->cie_daf = _dwarf_read_sleb128((uint8_t *)dbg->dbg_eh_offset, off);
  800421445a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421445e:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004214462:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004214466:	48 89 d6             	mov    %rdx,%rsi
  8004214469:	48 89 c7             	mov    %rax,%rdi
  800421446c:	48 b8 42 0e 21 04 80 	movabs $0x8004210e42,%rax
  8004214473:	00 00 00 
  8004214476:	ff d0                	callq  *%rax
  8004214478:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421447c:	48 89 42 40          	mov    %rax,0x40(%rdx)

	/* Return address register. */
	if (cie->cie_version == 1)
  8004214480:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214484:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  8004214488:	66 83 f8 01          	cmp    $0x1,%ax
  800421448c:	75 2b                	jne    80042144b9 <_dwarf_frame_set_cie+0x302>
		cie->cie_ra = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
  800421448e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214492:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214496:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421449a:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  800421449e:	48 89 d1             	mov    %rdx,%rcx
  80042144a1:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  80042144a5:	ba 01 00 00 00       	mov    $0x1,%edx
  80042144aa:	48 89 cf             	mov    %rcx,%rdi
  80042144ad:	ff d0                	callq  *%rax
  80042144af:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042144b3:	48 89 42 48          	mov    %rax,0x48(%rdx)
  80042144b7:	eb 26                	jmp    80042144df <_dwarf_frame_set_cie+0x328>
	else
		cie->cie_ra = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  80042144b9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042144bd:	48 8b 40 38          	mov    0x38(%rax),%rax
  80042144c1:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  80042144c5:	48 89 d6             	mov    %rdx,%rsi
  80042144c8:	48 89 c7             	mov    %rax,%rdi
  80042144cb:	48 b8 e6 0e 21 04 80 	movabs $0x8004210ee6,%rax
  80042144d2:	00 00 00 
  80042144d5:	ff d0                	callq  *%rax
  80042144d7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042144db:	48 89 42 48          	mov    %rax,0x48(%rdx)

	/* Optional CIE augmentation data for .eh_frame section. */
	if (*cie->cie_augment == 'z') {
  80042144df:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042144e3:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042144e7:	0f b6 00             	movzbl (%rax),%eax
  80042144ea:	3c 7a                	cmp    $0x7a,%al
  80042144ec:	0f 85 93 00 00 00    	jne    8004214585 <_dwarf_frame_set_cie+0x3ce>
		cie->cie_auglen = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  80042144f2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042144f6:	48 8b 40 38          	mov    0x38(%rax),%rax
  80042144fa:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  80042144fe:	48 89 d6             	mov    %rdx,%rsi
  8004214501:	48 89 c7             	mov    %rax,%rdi
  8004214504:	48 b8 e6 0e 21 04 80 	movabs $0x8004210ee6,%rax
  800421450b:	00 00 00 
  800421450e:	ff d0                	callq  *%rax
  8004214510:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214514:	48 89 42 50          	mov    %rax,0x50(%rdx)
		cie->cie_augdata = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004214518:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421451c:	48 8b 10             	mov    (%rax),%rdx
  800421451f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214523:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004214527:	48 01 d0             	add    %rdx,%rax
  800421452a:	48 89 c2             	mov    %rax,%rdx
  800421452d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214531:	48 89 50 58          	mov    %rdx,0x58(%rax)
		*off += cie->cie_auglen;
  8004214535:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214539:	48 8b 10             	mov    (%rax),%rdx
  800421453c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214540:	48 8b 40 50          	mov    0x50(%rax),%rax
  8004214544:	48 01 c2             	add    %rax,%rdx
  8004214547:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421454b:	48 89 10             	mov    %rdx,(%rax)
		/*
		 * XXX Use DW_EH_PE_absptr for default FDE PC start/range,
		 * in case _dwarf_frame_parse_lsb_cie_augment fails to
		 * find out the real encode.
		 */
		cie->cie_fde_encode = DW_EH_PE_absptr;
  800421454e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214552:	c6 40 60 00          	movb   $0x0,0x60(%rax)
		ret = _dwarf_frame_parse_lsb_cie_augment(dbg, cie, error);
  8004214556:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800421455a:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421455e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214562:	48 89 ce             	mov    %rcx,%rsi
  8004214565:	48 89 c7             	mov    %rax,%rdi
  8004214568:	48 b8 6c 40 21 04 80 	movabs $0x800421406c,%rax
  800421456f:	00 00 00 
  8004214572:	ff d0                	callq  *%rax
  8004214574:	89 45 dc             	mov    %eax,-0x24(%rbp)
		if (ret != DW_DLE_NONE)
  8004214577:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800421457b:	74 08                	je     8004214585 <_dwarf_frame_set_cie+0x3ce>
			return (ret);
  800421457d:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004214580:	e9 93 00 00 00       	jmpq   8004214618 <_dwarf_frame_set_cie+0x461>
	}

	/* CIE Initial instructions. */
	cie->cie_initinst = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004214585:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214589:	48 8b 10             	mov    (%rax),%rdx
  800421458c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214590:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004214594:	48 01 d0             	add    %rdx,%rax
  8004214597:	48 89 c2             	mov    %rax,%rdx
  800421459a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421459e:	48 89 50 68          	mov    %rdx,0x68(%rax)
	if (dwarf_size == 4)
  80042145a2:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  80042145a6:	75 2a                	jne    80042145d2 <_dwarf_frame_set_cie+0x41b>
		cie->cie_instlen = cie->cie_offset + 4 + length - *off;
  80042145a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042145ac:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042145b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042145b4:	48 01 c2             	add    %rax,%rdx
  80042145b7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042145bb:	48 8b 00             	mov    (%rax),%rax
  80042145be:	48 29 c2             	sub    %rax,%rdx
  80042145c1:	48 89 d0             	mov    %rdx,%rax
  80042145c4:	48 8d 50 04          	lea    0x4(%rax),%rdx
  80042145c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042145cc:	48 89 50 70          	mov    %rdx,0x70(%rax)
  80042145d0:	eb 28                	jmp    80042145fa <_dwarf_frame_set_cie+0x443>
	else
		cie->cie_instlen = cie->cie_offset + 12 + length - *off;
  80042145d2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042145d6:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042145da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042145de:	48 01 c2             	add    %rax,%rdx
  80042145e1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042145e5:	48 8b 00             	mov    (%rax),%rax
  80042145e8:	48 29 c2             	sub    %rax,%rdx
  80042145eb:	48 89 d0             	mov    %rdx,%rax
  80042145ee:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  80042145f2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042145f6:	48 89 50 70          	mov    %rdx,0x70(%rax)

	*off += cie->cie_instlen;
  80042145fa:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042145fe:	48 8b 10             	mov    (%rax),%rdx
  8004214601:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214605:	48 8b 40 70          	mov    0x70(%rax),%rax
  8004214609:	48 01 c2             	add    %rax,%rdx
  800421460c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214610:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLE_NONE);
  8004214613:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004214618:	c9                   	leaveq 
  8004214619:	c3                   	retq   

000000800421461a <_dwarf_frame_set_fde>:

static int
_dwarf_frame_set_fde(Dwarf_Debug dbg, Dwarf_Fde ret_fde, Dwarf_Section *ds,
		     Dwarf_Unsigned *off, int eh_frame, Dwarf_Cie cie, Dwarf_Error *error)
{
  800421461a:	55                   	push   %rbp
  800421461b:	48 89 e5             	mov    %rsp,%rbp
  800421461e:	48 83 ec 70          	sub    $0x70,%rsp
  8004214622:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004214626:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800421462a:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  800421462e:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  8004214632:	44 89 45 ac          	mov    %r8d,-0x54(%rbp)
  8004214636:	4c 89 4d a0          	mov    %r9,-0x60(%rbp)
	Dwarf_Fde fde;
	Dwarf_Unsigned cieoff;
	uint64_t length, val;
	int dwarf_size, ret;

	fde = ret_fde;
  800421463a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421463e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	fde->fde_dbg = dbg;
  8004214642:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214646:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421464a:	48 89 10             	mov    %rdx,(%rax)
	fde->fde_addr = (uint8_t *)dbg->dbg_eh_offset + *off;
  800421464d:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214651:	48 8b 10             	mov    (%rax),%rdx
  8004214654:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214658:	48 8b 40 38          	mov    0x38(%rax),%rax
  800421465c:	48 01 d0             	add    %rdx,%rax
  800421465f:	48 89 c2             	mov    %rax,%rdx
  8004214662:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214666:	48 89 50 10          	mov    %rdx,0x10(%rax)
	fde->fde_offset = *off;
  800421466a:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421466e:	48 8b 10             	mov    (%rax),%rdx
  8004214671:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214675:	48 89 50 18          	mov    %rdx,0x18(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  8004214679:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421467d:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214681:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004214685:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004214689:	48 89 d1             	mov    %rdx,%rcx
  800421468c:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004214690:	ba 04 00 00 00       	mov    $0x4,%edx
  8004214695:	48 89 cf             	mov    %rcx,%rdi
  8004214698:	ff d0                	callq  *%rax
  800421469a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (length == 0xffffffff) {
  800421469e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042146a3:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80042146a7:	75 2e                	jne    80042146d7 <_dwarf_frame_set_fde+0xbd>
		dwarf_size = 8;
  80042146a9:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 8);
  80042146b0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042146b4:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042146b8:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042146bc:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  80042146c0:	48 89 d1             	mov    %rdx,%rcx
  80042146c3:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  80042146c7:	ba 08 00 00 00       	mov    $0x8,%edx
  80042146cc:	48 89 cf             	mov    %rcx,%rdi
  80042146cf:	ff d0                	callq  *%rax
  80042146d1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042146d5:	eb 07                	jmp    80042146de <_dwarf_frame_set_fde+0xc4>
	} else
		dwarf_size = 4;
  80042146d7:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

	if (length > dbg->dbg_eh_size - *off) {
  80042146de:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042146e2:	48 8b 50 40          	mov    0x40(%rax),%rdx
  80042146e6:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042146ea:	48 8b 00             	mov    (%rax),%rax
  80042146ed:	48 29 c2             	sub    %rax,%rdx
  80042146f0:	48 89 d0             	mov    %rdx,%rax
  80042146f3:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042146f7:	73 0a                	jae    8004214703 <_dwarf_frame_set_fde+0xe9>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_FRAME_LENGTH_BAD);
		return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  80042146f9:	b8 12 00 00 00       	mov    $0x12,%eax
  80042146fe:	e9 ca 02 00 00       	jmpq   80042149cd <_dwarf_frame_set_fde+0x3b3>
	}

	fde->fde_length = length;
  8004214703:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214707:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421470b:	48 89 50 20          	mov    %rdx,0x20(%rax)

	if (eh_frame) {
  800421470f:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8004214713:	74 5e                	je     8004214773 <_dwarf_frame_set_fde+0x159>
		fde->fde_cieoff = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  8004214715:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214719:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421471d:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004214721:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004214725:	48 89 d1             	mov    %rdx,%rcx
  8004214728:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  800421472c:	ba 04 00 00 00       	mov    $0x4,%edx
  8004214731:	48 89 cf             	mov    %rcx,%rdi
  8004214734:	ff d0                	callq  *%rax
  8004214736:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421473a:	48 89 42 28          	mov    %rax,0x28(%rdx)
		cieoff = *off - (4 + fde->fde_cieoff);
  800421473e:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214742:	48 8b 10             	mov    (%rax),%rdx
  8004214745:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214749:	48 8b 40 28          	mov    0x28(%rax),%rax
  800421474d:	48 29 c2             	sub    %rax,%rdx
  8004214750:	48 89 d0             	mov    %rdx,%rax
  8004214753:	48 83 e8 04          	sub    $0x4,%rax
  8004214757:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		/* This delta should never be 0. */
		if (cieoff == fde->fde_offset) {
  800421475b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421475f:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214763:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004214767:	75 3d                	jne    80042147a6 <_dwarf_frame_set_fde+0x18c>
			DWARF_SET_ERROR(dbg, error, DW_DLE_NO_CIE_FOR_FDE);
			return (DW_DLE_NO_CIE_FOR_FDE);
  8004214769:	b8 13 00 00 00       	mov    $0x13,%eax
  800421476e:	e9 5a 02 00 00       	jmpq   80042149cd <_dwarf_frame_set_fde+0x3b3>
		}
	} else {
		fde->fde_cieoff = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size);
  8004214773:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214777:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421477b:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421477f:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004214783:	48 89 d1             	mov    %rdx,%rcx
  8004214786:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004214789:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  800421478d:	48 89 cf             	mov    %rcx,%rdi
  8004214790:	ff d0                	callq  *%rax
  8004214792:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214796:	48 89 42 28          	mov    %rax,0x28(%rdx)
		cieoff = fde->fde_cieoff;
  800421479a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421479e:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042147a2:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	}

	if (eh_frame) {
  80042147a6:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  80042147aa:	0f 84 c9 00 00 00    	je     8004214879 <_dwarf_frame_set_fde+0x25f>
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
  80042147b0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042147b4:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042147b8:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042147bc:	48 8b 00             	mov    (%rax),%rax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  80042147bf:	4c 8d 0c 02          	lea    (%rdx,%rax,1),%r9
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
  80042147c3:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042147c7:	0f b6 40 60          	movzbl 0x60(%rax),%eax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  80042147cb:	44 0f b6 c0          	movzbl %al,%r8d
						    (uint8_t *)dbg->dbg_eh_offset,
  80042147cf:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042147d3:	48 8b 40 38          	mov    0x38(%rax),%rax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  80042147d7:	48 89 c2             	mov    %rax,%rdx
  80042147da:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  80042147de:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  80042147e2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042147e6:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  80042147ea:	48 89 3c 24          	mov    %rdi,(%rsp)
  80042147ee:	48 89 c7             	mov    %rax,%rdi
  80042147f1:	48 b8 52 3e 21 04 80 	movabs $0x8004213e52,%rax
  80042147f8:	00 00 00 
  80042147fb:	ff d0                	callq  *%rax
  80042147fd:	89 45 dc             	mov    %eax,-0x24(%rbp)
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
		if (ret != DW_DLE_NONE)
  8004214800:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004214804:	74 08                	je     800421480e <_dwarf_frame_set_fde+0x1f4>
			return (ret);
  8004214806:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004214809:	e9 bf 01 00 00       	jmpq   80042149cd <_dwarf_frame_set_fde+0x3b3>
		fde->fde_initloc = val;
  800421480e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214812:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214816:	48 89 50 30          	mov    %rdx,0x30(%rax)
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, 0, error);
  800421481a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421481e:	0f b6 40 60          	movzbl 0x60(%rax),%eax
		fde->fde_initloc = val;
		/*
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004214822:	44 0f b6 c0          	movzbl %al,%r8d
						    (uint8_t *)dbg->dbg_eh_offset,
  8004214826:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421482a:	48 8b 40 38          	mov    0x38(%rax),%rax
		fde->fde_initloc = val;
		/*
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  800421482e:	48 89 c2             	mov    %rax,%rdx
  8004214831:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004214835:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8004214839:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421483d:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  8004214841:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004214845:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  800421484b:	48 89 c7             	mov    %rax,%rdi
  800421484e:	48 b8 52 3e 21 04 80 	movabs $0x8004213e52,%rax
  8004214855:	00 00 00 
  8004214858:	ff d0                	callq  *%rax
  800421485a:	89 45 dc             	mov    %eax,-0x24(%rbp)
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, 0, error);
		if (ret != DW_DLE_NONE)
  800421485d:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004214861:	74 08                	je     800421486b <_dwarf_frame_set_fde+0x251>
			return (ret);
  8004214863:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004214866:	e9 62 01 00 00       	jmpq   80042149cd <_dwarf_frame_set_fde+0x3b3>
		fde->fde_adrange = val;
  800421486b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421486f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214873:	48 89 50 38          	mov    %rdx,0x38(%rax)
  8004214877:	eb 50                	jmp    80042148c9 <_dwarf_frame_set_fde+0x2af>
	} else {
		fde->fde_initloc = dbg->read((uint8_t *)dbg->dbg_eh_offset, off,
  8004214879:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421487d:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214881:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004214885:	8b 52 28             	mov    0x28(%rdx),%edx
  8004214888:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  800421488c:	48 8b 49 38          	mov    0x38(%rcx),%rcx
  8004214890:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004214894:	48 89 cf             	mov    %rcx,%rdi
  8004214897:	ff d0                	callq  *%rax
  8004214899:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421489d:	48 89 42 30          	mov    %rax,0x30(%rdx)
					     dbg->dbg_pointer_size);
		fde->fde_adrange = dbg->read((uint8_t *)dbg->dbg_eh_offset, off,
  80042148a1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042148a5:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042148a9:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042148ad:	8b 52 28             	mov    0x28(%rdx),%edx
  80042148b0:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  80042148b4:	48 8b 49 38          	mov    0x38(%rcx),%rcx
  80042148b8:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  80042148bc:	48 89 cf             	mov    %rcx,%rdi
  80042148bf:	ff d0                	callq  *%rax
  80042148c1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042148c5:	48 89 42 38          	mov    %rax,0x38(%rdx)
					     dbg->dbg_pointer_size);
	}

	/* Optional FDE augmentation data for .eh_frame section. (ignored) */
	if (eh_frame && *cie->cie_augment == 'z') {
  80042148c9:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  80042148cd:	74 6b                	je     800421493a <_dwarf_frame_set_fde+0x320>
  80042148cf:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042148d3:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042148d7:	0f b6 00             	movzbl (%rax),%eax
  80042148da:	3c 7a                	cmp    $0x7a,%al
  80042148dc:	75 5c                	jne    800421493a <_dwarf_frame_set_fde+0x320>
		fde->fde_auglen = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  80042148de:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042148e2:	48 8b 40 38          	mov    0x38(%rax),%rax
  80042148e6:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  80042148ea:	48 89 d6             	mov    %rdx,%rsi
  80042148ed:	48 89 c7             	mov    %rax,%rdi
  80042148f0:	48 b8 e6 0e 21 04 80 	movabs $0x8004210ee6,%rax
  80042148f7:	00 00 00 
  80042148fa:	ff d0                	callq  *%rax
  80042148fc:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214900:	48 89 42 40          	mov    %rax,0x40(%rdx)
		fde->fde_augdata = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004214904:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214908:	48 8b 10             	mov    (%rax),%rdx
  800421490b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421490f:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004214913:	48 01 d0             	add    %rdx,%rax
  8004214916:	48 89 c2             	mov    %rax,%rdx
  8004214919:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421491d:	48 89 50 48          	mov    %rdx,0x48(%rax)
		*off += fde->fde_auglen;
  8004214921:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214925:	48 8b 10             	mov    (%rax),%rdx
  8004214928:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421492c:	48 8b 40 40          	mov    0x40(%rax),%rax
  8004214930:	48 01 c2             	add    %rax,%rdx
  8004214933:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214937:	48 89 10             	mov    %rdx,(%rax)
	}

	fde->fde_inst = (uint8_t *)dbg->dbg_eh_offset + *off;
  800421493a:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421493e:	48 8b 10             	mov    (%rax),%rdx
  8004214941:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214945:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004214949:	48 01 d0             	add    %rdx,%rax
  800421494c:	48 89 c2             	mov    %rax,%rdx
  800421494f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214953:	48 89 50 50          	mov    %rdx,0x50(%rax)
	if (dwarf_size == 4)
  8004214957:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  800421495b:	75 2a                	jne    8004214987 <_dwarf_frame_set_fde+0x36d>
		fde->fde_instlen = fde->fde_offset + 4 + length - *off;
  800421495d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214961:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214965:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214969:	48 01 c2             	add    %rax,%rdx
  800421496c:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214970:	48 8b 00             	mov    (%rax),%rax
  8004214973:	48 29 c2             	sub    %rax,%rdx
  8004214976:	48 89 d0             	mov    %rdx,%rax
  8004214979:	48 8d 50 04          	lea    0x4(%rax),%rdx
  800421497d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214981:	48 89 50 58          	mov    %rdx,0x58(%rax)
  8004214985:	eb 28                	jmp    80042149af <_dwarf_frame_set_fde+0x395>
	else
		fde->fde_instlen = fde->fde_offset + 12 + length - *off;
  8004214987:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421498b:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421498f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214993:	48 01 c2             	add    %rax,%rdx
  8004214996:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421499a:	48 8b 00             	mov    (%rax),%rax
  800421499d:	48 29 c2             	sub    %rax,%rdx
  80042149a0:	48 89 d0             	mov    %rdx,%rax
  80042149a3:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  80042149a7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042149ab:	48 89 50 58          	mov    %rdx,0x58(%rax)

	*off += fde->fde_instlen;
  80042149af:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042149b3:	48 8b 10             	mov    (%rax),%rdx
  80042149b6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042149ba:	48 8b 40 58          	mov    0x58(%rax),%rax
  80042149be:	48 01 c2             	add    %rax,%rdx
  80042149c1:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042149c5:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLE_NONE);
  80042149c8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042149cd:	c9                   	leaveq 
  80042149ce:	c3                   	retq   

00000080042149cf <_dwarf_frame_interal_table_init>:


int
_dwarf_frame_interal_table_init(Dwarf_Debug dbg, Dwarf_Error *error)
{
  80042149cf:	55                   	push   %rbp
  80042149d0:	48 89 e5             	mov    %rsp,%rbp
  80042149d3:	48 83 ec 20          	sub    $0x20,%rsp
  80042149d7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042149db:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	Dwarf_Regtable3 *rt = &global_rt_table;
  80042149df:	48 b8 a0 e6 49 04 80 	movabs $0x800449e6a0,%rax
  80042149e6:	00 00 00 
  80042149e9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	if (dbg->dbg_internal_reg_table != NULL)
  80042149ed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042149f1:	48 8b 40 58          	mov    0x58(%rax),%rax
  80042149f5:	48 85 c0             	test   %rax,%rax
  80042149f8:	74 07                	je     8004214a01 <_dwarf_frame_interal_table_init+0x32>
		return (DW_DLE_NONE);
  80042149fa:	b8 00 00 00 00       	mov    $0x0,%eax
  80042149ff:	eb 33                	jmp    8004214a34 <_dwarf_frame_interal_table_init+0x65>

	rt->rt3_reg_table_size = dbg->dbg_frame_rule_table_size;
  8004214a01:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214a05:	0f b7 50 48          	movzwl 0x48(%rax),%edx
  8004214a09:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214a0d:	66 89 50 18          	mov    %dx,0x18(%rax)
	rt->rt3_rules = global_rules;
  8004214a11:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214a15:	48 b9 20 ce 69 04 80 	movabs $0x800469ce20,%rcx
  8004214a1c:	00 00 00 
  8004214a1f:	48 89 48 20          	mov    %rcx,0x20(%rax)

	dbg->dbg_internal_reg_table = rt;
  8004214a23:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214a27:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004214a2b:	48 89 50 58          	mov    %rdx,0x58(%rax)

	return (DW_DLE_NONE);
  8004214a2f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004214a34:	c9                   	leaveq 
  8004214a35:	c3                   	retq   

0000008004214a36 <_dwarf_get_next_fde>:

static int
_dwarf_get_next_fde(Dwarf_Debug dbg,
		    int eh_frame, Dwarf_Error *error, Dwarf_Fde ret_fde)
{
  8004214a36:	55                   	push   %rbp
  8004214a37:	48 89 e5             	mov    %rsp,%rbp
  8004214a3a:	48 83 ec 60          	sub    $0x60,%rsp
  8004214a3e:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004214a42:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  8004214a45:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004214a49:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	Dwarf_Section *ds = &debug_frame_sec; 
  8004214a4d:	48 b8 a0 c6 22 04 80 	movabs $0x800422c6a0,%rax
  8004214a54:	00 00 00 
  8004214a57:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uint64_t length, offset, cie_id, entry_off;
	int dwarf_size, i, ret=-1;
  8004214a5b:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%rbp)

	offset = dbg->curr_off_eh;
  8004214a62:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214a66:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004214a6a:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	if (offset < dbg->dbg_eh_size) {
  8004214a6e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214a72:	48 8b 50 40          	mov    0x40(%rax),%rdx
  8004214a76:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214a7a:	48 39 c2             	cmp    %rax,%rdx
  8004214a7d:	0f 86 fe 01 00 00    	jbe    8004214c81 <_dwarf_get_next_fde+0x24b>
		entry_off = offset;
  8004214a83:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214a87:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, 4);
  8004214a8b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214a8f:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214a93:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004214a97:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004214a9b:	48 89 d1             	mov    %rdx,%rcx
  8004214a9e:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  8004214aa2:	ba 04 00 00 00       	mov    $0x4,%edx
  8004214aa7:	48 89 cf             	mov    %rcx,%rdi
  8004214aaa:	ff d0                	callq  *%rax
  8004214aac:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (length == 0xffffffff) {
  8004214ab0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004214ab5:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004214ab9:	75 2e                	jne    8004214ae9 <_dwarf_get_next_fde+0xb3>
			dwarf_size = 8;
  8004214abb:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
			length = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, 8);
  8004214ac2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214ac6:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214aca:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004214ace:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004214ad2:	48 89 d1             	mov    %rdx,%rcx
  8004214ad5:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  8004214ad9:	ba 08 00 00 00       	mov    $0x8,%edx
  8004214ade:	48 89 cf             	mov    %rcx,%rdi
  8004214ae1:	ff d0                	callq  *%rax
  8004214ae3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004214ae7:	eb 07                	jmp    8004214af0 <_dwarf_get_next_fde+0xba>
		} else
			dwarf_size = 4;
  8004214ae9:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

		if (length > dbg->dbg_eh_size - offset || (length == 0 && !eh_frame)) {
  8004214af0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214af4:	48 8b 50 40          	mov    0x40(%rax),%rdx
  8004214af8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214afc:	48 29 c2             	sub    %rax,%rdx
  8004214aff:	48 89 d0             	mov    %rdx,%rax
  8004214b02:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004214b06:	72 0d                	jb     8004214b15 <_dwarf_get_next_fde+0xdf>
  8004214b08:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004214b0d:	75 10                	jne    8004214b1f <_dwarf_get_next_fde+0xe9>
  8004214b0f:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  8004214b13:	75 0a                	jne    8004214b1f <_dwarf_get_next_fde+0xe9>
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_DEBUG_FRAME_LENGTH_BAD);
			return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  8004214b15:	b8 12 00 00 00       	mov    $0x12,%eax
  8004214b1a:	e9 67 01 00 00       	jmpq   8004214c86 <_dwarf_get_next_fde+0x250>
		}

		/* Check terminator for .eh_frame */
		if (eh_frame && length == 0)
  8004214b1f:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  8004214b23:	74 11                	je     8004214b36 <_dwarf_get_next_fde+0x100>
  8004214b25:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004214b2a:	75 0a                	jne    8004214b36 <_dwarf_get_next_fde+0x100>
			return(-1);
  8004214b2c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004214b31:	e9 50 01 00 00       	jmpq   8004214c86 <_dwarf_get_next_fde+0x250>

		cie_id = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, dwarf_size);
  8004214b36:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214b3a:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214b3e:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004214b42:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004214b46:	48 89 d1             	mov    %rdx,%rcx
  8004214b49:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004214b4c:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  8004214b50:	48 89 cf             	mov    %rcx,%rdi
  8004214b53:	ff d0                	callq  *%rax
  8004214b55:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

		if (eh_frame) {
  8004214b59:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  8004214b5d:	74 79                	je     8004214bd8 <_dwarf_get_next_fde+0x1a2>
			/* GNU .eh_frame use CIE id 0. */
			if (cie_id == 0)
  8004214b5f:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004214b64:	75 32                	jne    8004214b98 <_dwarf_get_next_fde+0x162>
				ret = _dwarf_frame_set_cie(dbg, ds,
  8004214b66:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214b6a:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004214b6e:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004214b72:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  8004214b76:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  8004214b7a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214b7e:	49 89 f8             	mov    %rdi,%r8
  8004214b81:	48 89 c7             	mov    %rax,%rdi
  8004214b84:	48 b8 b7 41 21 04 80 	movabs $0x80042141b7,%rax
  8004214b8b:	00 00 00 
  8004214b8e:	ff d0                	callq  *%rax
  8004214b90:	89 45 f0             	mov    %eax,-0x10(%rbp)
  8004214b93:	e9 c8 00 00 00       	jmpq   8004214c60 <_dwarf_get_next_fde+0x22a>
							   &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg,ret_fde, ds,
  8004214b98:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214b9c:	4c 8b 40 08          	mov    0x8(%rax),%r8
  8004214ba0:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  8004214ba4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214ba8:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004214bac:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214bb0:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004214bb4:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004214bb8:	4d 89 c1             	mov    %r8,%r9
  8004214bbb:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  8004214bc1:	48 89 c7             	mov    %rax,%rdi
  8004214bc4:	48 b8 1a 46 21 04 80 	movabs $0x800421461a,%rax
  8004214bcb:	00 00 00 
  8004214bce:	ff d0                	callq  *%rax
  8004214bd0:	89 45 f0             	mov    %eax,-0x10(%rbp)
  8004214bd3:	e9 88 00 00 00       	jmpq   8004214c60 <_dwarf_get_next_fde+0x22a>
							   &entry_off, 1, ret_fde->fde_cie, error);
		} else {
			/* .dwarf_frame use CIE id ~0 */
			if ((dwarf_size == 4 && cie_id == ~0U) ||
  8004214bd8:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004214bdc:	75 0b                	jne    8004214be9 <_dwarf_get_next_fde+0x1b3>
  8004214bde:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004214be3:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  8004214be7:	74 0d                	je     8004214bf6 <_dwarf_get_next_fde+0x1c0>
  8004214be9:	83 7d f4 08          	cmpl   $0x8,-0xc(%rbp)
  8004214bed:	75 36                	jne    8004214c25 <_dwarf_get_next_fde+0x1ef>
			    (dwarf_size == 8 && cie_id == ~0ULL))
  8004214bef:	48 83 7d e0 ff       	cmpq   $0xffffffffffffffff,-0x20(%rbp)
  8004214bf4:	75 2f                	jne    8004214c25 <_dwarf_get_next_fde+0x1ef>
				ret = _dwarf_frame_set_cie(dbg, ds,
  8004214bf6:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214bfa:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004214bfe:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004214c02:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  8004214c06:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  8004214c0a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214c0e:	49 89 f8             	mov    %rdi,%r8
  8004214c11:	48 89 c7             	mov    %rax,%rdi
  8004214c14:	48 b8 b7 41 21 04 80 	movabs $0x80042141b7,%rax
  8004214c1b:	00 00 00 
  8004214c1e:	ff d0                	callq  *%rax
  8004214c20:	89 45 f0             	mov    %eax,-0x10(%rbp)
  8004214c23:	eb 3b                	jmp    8004214c60 <_dwarf_get_next_fde+0x22a>
							   &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg, ret_fde, ds,
  8004214c25:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214c29:	4c 8b 40 08          	mov    0x8(%rax),%r8
  8004214c2d:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  8004214c31:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214c35:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004214c39:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214c3d:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004214c41:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004214c45:	4d 89 c1             	mov    %r8,%r9
  8004214c48:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8004214c4e:	48 89 c7             	mov    %rax,%rdi
  8004214c51:	48 b8 1a 46 21 04 80 	movabs $0x800421461a,%rax
  8004214c58:	00 00 00 
  8004214c5b:	ff d0                	callq  *%rax
  8004214c5d:	89 45 f0             	mov    %eax,-0x10(%rbp)
							   &entry_off, 0, ret_fde->fde_cie, error);
		}

		if (ret != DW_DLE_NONE)
  8004214c60:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  8004214c64:	74 07                	je     8004214c6d <_dwarf_get_next_fde+0x237>
			return(-1);
  8004214c66:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004214c6b:	eb 19                	jmp    8004214c86 <_dwarf_get_next_fde+0x250>

		offset = entry_off;
  8004214c6d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214c71:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		dbg->curr_off_eh = offset;
  8004214c75:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004214c79:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214c7d:	48 89 50 30          	mov    %rdx,0x30(%rax)
	}

	return (0);
  8004214c81:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004214c86:	c9                   	leaveq 
  8004214c87:	c3                   	retq   

0000008004214c88 <dwarf_set_frame_cfa_value>:

Dwarf_Half
dwarf_set_frame_cfa_value(Dwarf_Debug dbg, Dwarf_Half value)
{
  8004214c88:	55                   	push   %rbp
  8004214c89:	48 89 e5             	mov    %rsp,%rbp
  8004214c8c:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004214c90:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004214c94:	89 f0                	mov    %esi,%eax
  8004214c96:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
	Dwarf_Half old_value;

	old_value = dbg->dbg_frame_cfa_value;
  8004214c9a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214c9e:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004214ca2:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
	dbg->dbg_frame_cfa_value = value;
  8004214ca6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214caa:	0f b7 55 e4          	movzwl -0x1c(%rbp),%edx
  8004214cae:	66 89 50 4c          	mov    %dx,0x4c(%rax)

	return (old_value);
  8004214cb2:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
}
  8004214cb6:	c9                   	leaveq 
  8004214cb7:	c3                   	retq   

0000008004214cb8 <dwarf_init_eh_section>:

int dwarf_init_eh_section(Dwarf_Debug dbg, Dwarf_Error *error)
{
  8004214cb8:	55                   	push   %rbp
  8004214cb9:	48 89 e5             	mov    %rsp,%rbp
  8004214cbc:	48 83 ec 10          	sub    $0x10,%rsp
  8004214cc0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004214cc4:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	Dwarf_Section *section;

	if (dbg == NULL) {
  8004214cc8:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004214ccd:	75 0a                	jne    8004214cd9 <dwarf_init_eh_section+0x21>
		DWARF_SET_ERROR(dbg, error, DW_DLE_ARGUMENT);
		return (DW_DLV_ERROR);
  8004214ccf:	b8 01 00 00 00       	mov    $0x1,%eax
  8004214cd4:	e9 85 00 00 00       	jmpq   8004214d5e <dwarf_init_eh_section+0xa6>
	}

	if (dbg->dbg_internal_reg_table == NULL) {
  8004214cd9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214cdd:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004214ce1:	48 85 c0             	test   %rax,%rax
  8004214ce4:	75 25                	jne    8004214d0b <dwarf_init_eh_section+0x53>
		if (_dwarf_frame_interal_table_init(dbg, error) != DW_DLE_NONE)
  8004214ce6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004214cea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214cee:	48 89 d6             	mov    %rdx,%rsi
  8004214cf1:	48 89 c7             	mov    %rax,%rdi
  8004214cf4:	48 b8 cf 49 21 04 80 	movabs $0x80042149cf,%rax
  8004214cfb:	00 00 00 
  8004214cfe:	ff d0                	callq  *%rax
  8004214d00:	85 c0                	test   %eax,%eax
  8004214d02:	74 07                	je     8004214d0b <dwarf_init_eh_section+0x53>
			return (DW_DLV_ERROR);
  8004214d04:	b8 01 00 00 00       	mov    $0x1,%eax
  8004214d09:	eb 53                	jmp    8004214d5e <dwarf_init_eh_section+0xa6>
	}

	_dwarf_find_section_enhanced(&debug_frame_sec);
  8004214d0b:	48 bf a0 c6 22 04 80 	movabs $0x800422c6a0,%rdi
  8004214d12:	00 00 00 
  8004214d15:	48 b8 84 27 21 04 80 	movabs $0x8004212784,%rax
  8004214d1c:	00 00 00 
  8004214d1f:	ff d0                	callq  *%rax

	dbg->curr_off_eh = 0;
  8004214d21:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214d25:	48 c7 40 30 00 00 00 	movq   $0x0,0x30(%rax)
  8004214d2c:	00 
	dbg->dbg_eh_offset = debug_frame_sec.ds_addr;
  8004214d2d:	48 b8 a0 c6 22 04 80 	movabs $0x800422c6a0,%rax
  8004214d34:	00 00 00 
  8004214d37:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004214d3b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214d3f:	48 89 50 38          	mov    %rdx,0x38(%rax)
	dbg->dbg_eh_size = debug_frame_sec.ds_size;
  8004214d43:	48 b8 a0 c6 22 04 80 	movabs $0x800422c6a0,%rax
  8004214d4a:	00 00 00 
  8004214d4d:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214d51:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214d55:	48 89 50 40          	mov    %rdx,0x40(%rax)

	return (DW_DLV_OK);
  8004214d59:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004214d5e:	c9                   	leaveq 
  8004214d5f:	c3                   	retq   

0000008004214d60 <_dwarf_lineno_run_program>:
int  _dwarf_find_section_enhanced(Dwarf_Section *ds);

static int
_dwarf_lineno_run_program(Dwarf_CU *cu, Dwarf_LineInfo li, uint8_t *p,
			  uint8_t *pe, Dwarf_Addr pc, Dwarf_Error *error)
{
  8004214d60:	55                   	push   %rbp
  8004214d61:	48 89 e5             	mov    %rsp,%rbp
  8004214d64:	53                   	push   %rbx
  8004214d65:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
  8004214d6c:	48 89 7d 88          	mov    %rdi,-0x78(%rbp)
  8004214d70:	48 89 75 80          	mov    %rsi,-0x80(%rbp)
  8004214d74:	48 89 95 78 ff ff ff 	mov    %rdx,-0x88(%rbp)
  8004214d7b:	48 89 8d 70 ff ff ff 	mov    %rcx,-0x90(%rbp)
  8004214d82:	4c 89 85 68 ff ff ff 	mov    %r8,-0x98(%rbp)
  8004214d89:	4c 89 8d 60 ff ff ff 	mov    %r9,-0xa0(%rbp)
	uint64_t address, file, line, column, isa, opsize;
	int is_stmt, basic_block, end_sequence;
	int prologue_end, epilogue_begin;
	int ret;

	ln = &li->li_line;
  8004214d90:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214d94:	48 83 c0 48          	add    $0x48,%rax
  8004214d98:	48 89 45 b8          	mov    %rax,-0x48(%rbp)

	/*
	 *   ln->ln_li     = li;             \
	 * Set registers to their default values.
	 */
	RESET_REGISTERS;
  8004214d9c:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004214da3:	00 
  8004214da4:	48 c7 45 e0 01 00 00 	movq   $0x1,-0x20(%rbp)
  8004214dab:	00 
  8004214dac:	48 c7 45 d8 01 00 00 	movq   $0x1,-0x28(%rbp)
  8004214db3:	00 
  8004214db4:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  8004214dbb:	00 
  8004214dbc:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214dc0:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  8004214dc4:	0f b6 c0             	movzbl %al,%eax
  8004214dc7:	89 45 cc             	mov    %eax,-0x34(%rbp)
  8004214dca:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
  8004214dd1:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
  8004214dd8:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
  8004214ddf:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)

	/*
	 * Start line number program.
	 */
	while (p < pe) {
  8004214de6:	e9 0a 05 00 00       	jmpq   80042152f5 <_dwarf_lineno_run_program+0x595>
		if (*p == 0) {
  8004214deb:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004214df2:	0f b6 00             	movzbl (%rax),%eax
  8004214df5:	84 c0                	test   %al,%al
  8004214df7:	0f 85 78 01 00 00    	jne    8004214f75 <_dwarf_lineno_run_program+0x215>

			/*
			 * Extended Opcodes.
			 */

			p++;
  8004214dfd:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004214e04:	48 83 c0 01          	add    $0x1,%rax
  8004214e08:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
			opsize = _dwarf_decode_uleb128(&p);
  8004214e0f:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  8004214e16:	48 89 c7             	mov    %rax,%rdi
  8004214e19:	48 b8 f7 0f 21 04 80 	movabs $0x8004210ff7,%rax
  8004214e20:	00 00 00 
  8004214e23:	ff d0                	callq  *%rax
  8004214e25:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			switch (*p) {
  8004214e29:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004214e30:	0f b6 00             	movzbl (%rax),%eax
  8004214e33:	0f b6 c0             	movzbl %al,%eax
  8004214e36:	83 f8 02             	cmp    $0x2,%eax
  8004214e39:	74 7a                	je     8004214eb5 <_dwarf_lineno_run_program+0x155>
  8004214e3b:	83 f8 03             	cmp    $0x3,%eax
  8004214e3e:	0f 84 b3 00 00 00    	je     8004214ef7 <_dwarf_lineno_run_program+0x197>
  8004214e44:	83 f8 01             	cmp    $0x1,%eax
  8004214e47:	0f 85 09 01 00 00    	jne    8004214f56 <_dwarf_lineno_run_program+0x1f6>
			case DW_LNE_end_sequence:
				p++;
  8004214e4d:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004214e54:	48 83 c0 01          	add    $0x1,%rax
  8004214e58:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
				end_sequence = 1;
  8004214e5f:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%rbp)
				RESET_REGISTERS;
  8004214e66:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004214e6d:	00 
  8004214e6e:	48 c7 45 e0 01 00 00 	movq   $0x1,-0x20(%rbp)
  8004214e75:	00 
  8004214e76:	48 c7 45 d8 01 00 00 	movq   $0x1,-0x28(%rbp)
  8004214e7d:	00 
  8004214e7e:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  8004214e85:	00 
  8004214e86:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214e8a:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  8004214e8e:	0f b6 c0             	movzbl %al,%eax
  8004214e91:	89 45 cc             	mov    %eax,-0x34(%rbp)
  8004214e94:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
  8004214e9b:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
  8004214ea2:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
  8004214ea9:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
				break;
  8004214eb0:	e9 bb 00 00 00       	jmpq   8004214f70 <_dwarf_lineno_run_program+0x210>
			case DW_LNE_set_address:
				p++;
  8004214eb5:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004214ebc:	48 83 c0 01          	add    $0x1,%rax
  8004214ec0:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
				address = dbg->decode(&p, cu->addr_size);
  8004214ec7:	48 b8 88 c6 22 04 80 	movabs $0x800422c688,%rax
  8004214ece:	00 00 00 
  8004214ed1:	48 8b 00             	mov    (%rax),%rax
  8004214ed4:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004214ed8:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  8004214edc:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  8004214ee0:	0f b6 ca             	movzbl %dl,%ecx
  8004214ee3:	48 8d 95 78 ff ff ff 	lea    -0x88(%rbp),%rdx
  8004214eea:	89 ce                	mov    %ecx,%esi
  8004214eec:	48 89 d7             	mov    %rdx,%rdi
  8004214eef:	ff d0                	callq  *%rax
  8004214ef1:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				break;
  8004214ef5:	eb 79                	jmp    8004214f70 <_dwarf_lineno_run_program+0x210>
			case DW_LNE_define_file:
				p++;
  8004214ef7:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004214efe:	48 83 c0 01          	add    $0x1,%rax
  8004214f02:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
				ret = _dwarf_lineno_add_file(li, &p, NULL,
  8004214f09:	48 b8 88 c6 22 04 80 	movabs $0x800422c688,%rax
  8004214f10:	00 00 00 
  8004214f13:	48 8b 08             	mov    (%rax),%rcx
  8004214f16:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004214f1d:	48 8d b5 78 ff ff ff 	lea    -0x88(%rbp),%rsi
  8004214f24:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214f28:	49 89 c8             	mov    %rcx,%r8
  8004214f2b:	48 89 d1             	mov    %rdx,%rcx
  8004214f2e:	ba 00 00 00 00       	mov    $0x0,%edx
  8004214f33:	48 89 c7             	mov    %rax,%rdi
  8004214f36:	48 b8 18 53 21 04 80 	movabs $0x8004215318,%rax
  8004214f3d:	00 00 00 
  8004214f40:	ff d0                	callq  *%rax
  8004214f42:	89 45 a4             	mov    %eax,-0x5c(%rbp)
							     error, dbg);
				if (ret != DW_DLE_NONE)
  8004214f45:	83 7d a4 00          	cmpl   $0x0,-0x5c(%rbp)
  8004214f49:	74 09                	je     8004214f54 <_dwarf_lineno_run_program+0x1f4>
					goto prog_fail;
  8004214f4b:	90                   	nop

	return (DW_DLE_NONE);

prog_fail:

	return (ret);
  8004214f4c:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  8004214f4f:	e9 ba 03 00 00       	jmpq   800421530e <_dwarf_lineno_run_program+0x5ae>
				p++;
				ret = _dwarf_lineno_add_file(li, &p, NULL,
							     error, dbg);
				if (ret != DW_DLE_NONE)
					goto prog_fail;
				break;
  8004214f54:	eb 1a                	jmp    8004214f70 <_dwarf_lineno_run_program+0x210>
			default:
				/* Unrecognized extened opcodes. */
				p += opsize;
  8004214f56:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  8004214f5d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004214f61:	48 01 d0             	add    %rdx,%rax
  8004214f64:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  8004214f6b:	e9 85 03 00 00       	jmpq   80042152f5 <_dwarf_lineno_run_program+0x595>
  8004214f70:	e9 80 03 00 00       	jmpq   80042152f5 <_dwarf_lineno_run_program+0x595>
			}

		} else if (*p > 0 && *p < li->li_opbase) {
  8004214f75:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004214f7c:	0f b6 00             	movzbl (%rax),%eax
  8004214f7f:	84 c0                	test   %al,%al
  8004214f81:	0f 84 3c 02 00 00    	je     80042151c3 <_dwarf_lineno_run_program+0x463>
  8004214f87:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004214f8e:	0f b6 10             	movzbl (%rax),%edx
  8004214f91:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214f95:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004214f99:	38 c2                	cmp    %al,%dl
  8004214f9b:	0f 83 22 02 00 00    	jae    80042151c3 <_dwarf_lineno_run_program+0x463>

			/*
			 * Standard Opcodes.
			 */

			switch (*p++) {
  8004214fa1:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004214fa8:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004214fac:	48 89 95 78 ff ff ff 	mov    %rdx,-0x88(%rbp)
  8004214fb3:	0f b6 00             	movzbl (%rax),%eax
  8004214fb6:	0f b6 c0             	movzbl %al,%eax
  8004214fb9:	83 f8 0c             	cmp    $0xc,%eax
  8004214fbc:	0f 87 fb 01 00 00    	ja     80042151bd <_dwarf_lineno_run_program+0x45d>
  8004214fc2:	89 c0                	mov    %eax,%eax
  8004214fc4:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004214fcb:	00 
  8004214fcc:	48 b8 08 b5 21 04 80 	movabs $0x800421b508,%rax
  8004214fd3:	00 00 00 
  8004214fd6:	48 01 d0             	add    %rdx,%rax
  8004214fd9:	48 8b 00             	mov    (%rax),%rax
  8004214fdc:	ff e0                	jmpq   *%rax
			case DW_LNS_copy:
				APPEND_ROW;
  8004214fde:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004214fe5:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004214fe9:	73 0a                	jae    8004214ff5 <_dwarf_lineno_run_program+0x295>
  8004214feb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214ff0:	e9 19 03 00 00       	jmpq   800421530e <_dwarf_lineno_run_program+0x5ae>
  8004214ff5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214ff9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214ffd:	48 89 10             	mov    %rdx,(%rax)
  8004215000:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004215004:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  800421500b:	00 
  800421500c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004215010:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004215014:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004215018:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421501c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004215020:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004215024:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004215028:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421502c:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004215030:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004215034:	8b 55 c8             	mov    -0x38(%rbp),%edx
  8004215037:	89 50 28             	mov    %edx,0x28(%rax)
  800421503a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421503e:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004215041:	89 50 2c             	mov    %edx,0x2c(%rax)
  8004215044:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004215048:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  800421504b:	89 50 30             	mov    %edx,0x30(%rax)
  800421504e:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004215052:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8004215059:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800421505d:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004215061:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
				basic_block = 0;
  8004215068:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
				prologue_end = 0;
  800421506f:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
				epilogue_begin = 0;
  8004215076:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
				break;
  800421507d:	e9 3c 01 00 00       	jmpq   80042151be <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_advance_pc:
				address += _dwarf_decode_uleb128(&p) *
  8004215082:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  8004215089:	48 89 c7             	mov    %rax,%rdi
  800421508c:	48 b8 f7 0f 21 04 80 	movabs $0x8004210ff7,%rax
  8004215093:	00 00 00 
  8004215096:	ff d0                	callq  *%rax
					li->li_minlen;
  8004215098:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  800421509c:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
				basic_block = 0;
				prologue_end = 0;
				epilogue_begin = 0;
				break;
			case DW_LNS_advance_pc:
				address += _dwarf_decode_uleb128(&p) *
  80042150a0:	0f b6 d2             	movzbl %dl,%edx
  80042150a3:	48 0f af c2          	imul   %rdx,%rax
  80042150a7:	48 01 45 e8          	add    %rax,-0x18(%rbp)
					li->li_minlen;
				break;
  80042150ab:	e9 0e 01 00 00       	jmpq   80042151be <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_advance_line:
				line += _dwarf_decode_sleb128(&p);
  80042150b0:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  80042150b7:	48 89 c7             	mov    %rax,%rdi
  80042150ba:	48 b8 65 0f 21 04 80 	movabs $0x8004210f65,%rax
  80042150c1:	00 00 00 
  80042150c4:	ff d0                	callq  *%rax
  80042150c6:	48 01 45 d8          	add    %rax,-0x28(%rbp)
				break;
  80042150ca:	e9 ef 00 00 00       	jmpq   80042151be <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_file:
				file = _dwarf_decode_uleb128(&p);
  80042150cf:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  80042150d6:	48 89 c7             	mov    %rax,%rdi
  80042150d9:	48 b8 f7 0f 21 04 80 	movabs $0x8004210ff7,%rax
  80042150e0:	00 00 00 
  80042150e3:	ff d0                	callq  *%rax
  80042150e5:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
				break;
  80042150e9:	e9 d0 00 00 00       	jmpq   80042151be <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_column:
				column = _dwarf_decode_uleb128(&p);
  80042150ee:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  80042150f5:	48 89 c7             	mov    %rax,%rdi
  80042150f8:	48 b8 f7 0f 21 04 80 	movabs $0x8004210ff7,%rax
  80042150ff:	00 00 00 
  8004215102:	ff d0                	callq  *%rax
  8004215104:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
				break;
  8004215108:	e9 b1 00 00 00       	jmpq   80042151be <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_negate_stmt:
				is_stmt = !is_stmt;
  800421510d:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  8004215111:	0f 94 c0             	sete   %al
  8004215114:	0f b6 c0             	movzbl %al,%eax
  8004215117:	89 45 cc             	mov    %eax,-0x34(%rbp)
				break;
  800421511a:	e9 9f 00 00 00       	jmpq   80042151be <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_basic_block:
				basic_block = 1;
  800421511f:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%rbp)
				break;
  8004215126:	e9 93 00 00 00       	jmpq   80042151be <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_const_add_pc:
				address += ADDRESS(255);
  800421512b:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421512f:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004215133:	0f b6 c0             	movzbl %al,%eax
  8004215136:	ba ff 00 00 00       	mov    $0xff,%edx
  800421513b:	89 d1                	mov    %edx,%ecx
  800421513d:	29 c1                	sub    %eax,%ecx
  800421513f:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004215143:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  8004215147:	0f b6 d8             	movzbl %al,%ebx
  800421514a:	89 c8                	mov    %ecx,%eax
  800421514c:	99                   	cltd   
  800421514d:	f7 fb                	idiv   %ebx
  800421514f:	89 c2                	mov    %eax,%edx
  8004215151:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004215155:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  8004215159:	0f b6 c0             	movzbl %al,%eax
  800421515c:	0f af c2             	imul   %edx,%eax
  800421515f:	48 98                	cltq   
  8004215161:	48 01 45 e8          	add    %rax,-0x18(%rbp)
				break;
  8004215165:	eb 57                	jmp    80042151be <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_fixed_advance_pc:
				address += dbg->decode(&p, 2);
  8004215167:	48 b8 88 c6 22 04 80 	movabs $0x800422c688,%rax
  800421516e:	00 00 00 
  8004215171:	48 8b 00             	mov    (%rax),%rax
  8004215174:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004215178:	48 8d 95 78 ff ff ff 	lea    -0x88(%rbp),%rdx
  800421517f:	be 02 00 00 00       	mov    $0x2,%esi
  8004215184:	48 89 d7             	mov    %rdx,%rdi
  8004215187:	ff d0                	callq  *%rax
  8004215189:	48 01 45 e8          	add    %rax,-0x18(%rbp)
				break;
  800421518d:	eb 2f                	jmp    80042151be <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_prologue_end:
				prologue_end = 1;
  800421518f:	c7 45 b4 01 00 00 00 	movl   $0x1,-0x4c(%rbp)
				break;
  8004215196:	eb 26                	jmp    80042151be <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_epilogue_begin:
				epilogue_begin = 1;
  8004215198:	c7 45 b0 01 00 00 00 	movl   $0x1,-0x50(%rbp)
				break;
  800421519f:	eb 1d                	jmp    80042151be <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_isa:
				isa = _dwarf_decode_uleb128(&p);
  80042151a1:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  80042151a8:	48 89 c7             	mov    %rax,%rdi
  80042151ab:	48 b8 f7 0f 21 04 80 	movabs $0x8004210ff7,%rax
  80042151b2:	00 00 00 
  80042151b5:	ff d0                	callq  *%rax
  80042151b7:	48 89 45 98          	mov    %rax,-0x68(%rbp)
				break;
  80042151bb:	eb 01                	jmp    80042151be <_dwarf_lineno_run_program+0x45e>
			default:
				/* Unrecognized extened opcodes. What to do? */
				break;
  80042151bd:	90                   	nop
			}

		} else {
  80042151be:	e9 32 01 00 00       	jmpq   80042152f5 <_dwarf_lineno_run_program+0x595>

			/*
			 * Special Opcodes.
			 */

			line += LINE(*p);
  80042151c3:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042151c7:	0f b6 40 1a          	movzbl 0x1a(%rax),%eax
  80042151cb:	0f be c8             	movsbl %al,%ecx
  80042151ce:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042151d5:	0f b6 00             	movzbl (%rax),%eax
  80042151d8:	0f b6 d0             	movzbl %al,%edx
  80042151db:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042151df:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  80042151e3:	0f b6 c0             	movzbl %al,%eax
  80042151e6:	29 c2                	sub    %eax,%edx
  80042151e8:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042151ec:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  80042151f0:	0f b6 f0             	movzbl %al,%esi
  80042151f3:	89 d0                	mov    %edx,%eax
  80042151f5:	99                   	cltd   
  80042151f6:	f7 fe                	idiv   %esi
  80042151f8:	89 d0                	mov    %edx,%eax
  80042151fa:	01 c8                	add    %ecx,%eax
  80042151fc:	48 98                	cltq   
  80042151fe:	48 01 45 d8          	add    %rax,-0x28(%rbp)
			address += ADDRESS(*p);
  8004215202:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004215209:	0f b6 00             	movzbl (%rax),%eax
  800421520c:	0f b6 d0             	movzbl %al,%edx
  800421520f:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004215213:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004215217:	0f b6 c0             	movzbl %al,%eax
  800421521a:	89 d1                	mov    %edx,%ecx
  800421521c:	29 c1                	sub    %eax,%ecx
  800421521e:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004215222:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  8004215226:	0f b6 d8             	movzbl %al,%ebx
  8004215229:	89 c8                	mov    %ecx,%eax
  800421522b:	99                   	cltd   
  800421522c:	f7 fb                	idiv   %ebx
  800421522e:	89 c2                	mov    %eax,%edx
  8004215230:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004215234:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  8004215238:	0f b6 c0             	movzbl %al,%eax
  800421523b:	0f af c2             	imul   %edx,%eax
  800421523e:	48 98                	cltq   
  8004215240:	48 01 45 e8          	add    %rax,-0x18(%rbp)
			APPEND_ROW;
  8004215244:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421524b:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  800421524f:	73 0a                	jae    800421525b <_dwarf_lineno_run_program+0x4fb>
  8004215251:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215256:	e9 b3 00 00 00       	jmpq   800421530e <_dwarf_lineno_run_program+0x5ae>
  800421525b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421525f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004215263:	48 89 10             	mov    %rdx,(%rax)
  8004215266:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421526a:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8004215271:	00 
  8004215272:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004215276:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421527a:	48 89 50 10          	mov    %rdx,0x10(%rax)
  800421527e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004215282:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004215286:	48 89 50 18          	mov    %rdx,0x18(%rax)
  800421528a:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421528e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004215292:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004215296:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421529a:	8b 55 c8             	mov    -0x38(%rbp),%edx
  800421529d:	89 50 28             	mov    %edx,0x28(%rax)
  80042152a0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042152a4:	8b 55 cc             	mov    -0x34(%rbp),%edx
  80042152a7:	89 50 2c             	mov    %edx,0x2c(%rax)
  80042152aa:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042152ae:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  80042152b1:	89 50 30             	mov    %edx,0x30(%rax)
  80042152b4:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042152b8:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  80042152bf:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042152c3:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042152c7:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
			basic_block = 0;
  80042152ce:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
			prologue_end = 0;
  80042152d5:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
			epilogue_begin = 0;
  80042152dc:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
			p++;
  80042152e3:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042152ea:	48 83 c0 01          	add    $0x1,%rax
  80042152ee:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
	RESET_REGISTERS;

	/*
	 * Start line number program.
	 */
	while (p < pe) {
  80042152f5:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042152fc:	48 3b 85 70 ff ff ff 	cmp    -0x90(%rbp),%rax
  8004215303:	0f 82 e2 fa ff ff    	jb     8004214deb <_dwarf_lineno_run_program+0x8b>
			epilogue_begin = 0;
			p++;
		}
	}

	return (DW_DLE_NONE);
  8004215309:	b8 00 00 00 00       	mov    $0x0,%eax

#undef  RESET_REGISTERS
#undef  APPEND_ROW
#undef  LINE
#undef  ADDRESS
}
  800421530e:	48 81 c4 98 00 00 00 	add    $0x98,%rsp
  8004215315:	5b                   	pop    %rbx
  8004215316:	5d                   	pop    %rbp
  8004215317:	c3                   	retq   

0000008004215318 <_dwarf_lineno_add_file>:

static int
_dwarf_lineno_add_file(Dwarf_LineInfo li, uint8_t **p, const char *compdir,
		       Dwarf_Error *error, Dwarf_Debug dbg)
{
  8004215318:	55                   	push   %rbp
  8004215319:	48 89 e5             	mov    %rsp,%rbp
  800421531c:	53                   	push   %rbx
  800421531d:	48 83 ec 48          	sub    $0x48,%rsp
  8004215321:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004215325:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004215329:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  800421532d:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  8004215331:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
	char *fname;
	//const char *dirname;
	uint8_t *src;
	int slen;

	src = *p;
  8004215335:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215339:	48 8b 00             	mov    (%rax),%rax
  800421533c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  DWARF_SET_ERROR(dbg, error, DW_DLE_MEMORY);
  return (DW_DLE_MEMORY);
  }
*/  
	//lf->lf_fullpath = NULL;
	fname = (char *) src;
  8004215340:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215344:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	src += strlen(fname) + 1;
  8004215348:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
  800421534c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215350:	48 89 c7             	mov    %rax,%rdi
  8004215353:	48 b8 cf 00 21 04 80 	movabs $0x80042100cf,%rax
  800421535a:	00 00 00 
  800421535d:	ff d0                	callq  *%rax
  800421535f:	48 98                	cltq   
  8004215361:	48 83 c0 01          	add    $0x1,%rax
  8004215365:	48 01 d8             	add    %rbx,%rax
  8004215368:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	_dwarf_decode_uleb128(&src);
  800421536c:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004215370:	48 89 c7             	mov    %rax,%rdi
  8004215373:	48 b8 f7 0f 21 04 80 	movabs $0x8004210ff7,%rax
  800421537a:	00 00 00 
  800421537d:	ff d0                	callq  *%rax
	   snprintf(lf->lf_fullpath, slen, "%s/%s", dirname,
	   lf->lf_fname);
	   }
	   }
	*/
	_dwarf_decode_uleb128(&src);
  800421537f:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004215383:	48 89 c7             	mov    %rax,%rdi
  8004215386:	48 b8 f7 0f 21 04 80 	movabs $0x8004210ff7,%rax
  800421538d:	00 00 00 
  8004215390:	ff d0                	callq  *%rax
	_dwarf_decode_uleb128(&src);
  8004215392:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004215396:	48 89 c7             	mov    %rax,%rdi
  8004215399:	48 b8 f7 0f 21 04 80 	movabs $0x8004210ff7,%rax
  80042153a0:	00 00 00 
  80042153a3:	ff d0                	callq  *%rax
	//STAILQ_INSERT_TAIL(&li->li_lflist, lf, lf_next);
	//li->li_lflen++;

	*p = src;
  80042153a5:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042153a9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042153ad:	48 89 10             	mov    %rdx,(%rax)

	return (DW_DLE_NONE);
  80042153b0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042153b5:	48 83 c4 48          	add    $0x48,%rsp
  80042153b9:	5b                   	pop    %rbx
  80042153ba:	5d                   	pop    %rbp
  80042153bb:	c3                   	retq   

00000080042153bc <_dwarf_lineno_init>:

int     
_dwarf_lineno_init(Dwarf_Die *die, uint64_t offset, Dwarf_LineInfo linfo, Dwarf_Addr pc, Dwarf_Error *error)
{   
  80042153bc:	55                   	push   %rbp
  80042153bd:	48 89 e5             	mov    %rsp,%rbp
  80042153c0:	53                   	push   %rbx
  80042153c1:	48 81 ec 08 01 00 00 	sub    $0x108,%rsp
  80042153c8:	48 89 bd 18 ff ff ff 	mov    %rdi,-0xe8(%rbp)
  80042153cf:	48 89 b5 10 ff ff ff 	mov    %rsi,-0xf0(%rbp)
  80042153d6:	48 89 95 08 ff ff ff 	mov    %rdx,-0xf8(%rbp)
  80042153dd:	48 89 8d 00 ff ff ff 	mov    %rcx,-0x100(%rbp)
  80042153e4:	4c 89 85 f8 fe ff ff 	mov    %r8,-0x108(%rbp)
	Dwarf_Section myds = {.ds_name = ".debug_line"};
  80042153eb:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
  80042153f2:	00 
  80042153f3:	48 c7 45 98 00 00 00 	movq   $0x0,-0x68(%rbp)
  80042153fa:	00 
  80042153fb:	48 c7 45 a0 00 00 00 	movq   $0x0,-0x60(%rbp)
  8004215402:	00 
  8004215403:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  800421540a:	00 
  800421540b:	48 b8 70 b5 21 04 80 	movabs $0x800421b570,%rax
  8004215412:	00 00 00 
  8004215415:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	Dwarf_Section *ds = &myds;
  8004215419:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800421541d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	//Dwarf_LineFile lf, tlf;
	uint64_t length, hdroff, endoff;
	uint8_t *p;
	int dwarf_size, i, ret;
            
	cu = die->cu_header;
  8004215421:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004215428:	48 8b 80 60 03 00 00 	mov    0x360(%rax),%rax
  800421542f:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	assert(cu != NULL); 
  8004215433:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004215438:	75 35                	jne    800421546f <_dwarf_lineno_init+0xb3>
  800421543a:	48 b9 7c b5 21 04 80 	movabs $0x800421b57c,%rcx
  8004215441:	00 00 00 
  8004215444:	48 ba 87 b5 21 04 80 	movabs $0x800421b587,%rdx
  800421544b:	00 00 00 
  800421544e:	be 13 01 00 00       	mov    $0x113,%esi
  8004215453:	48 bf 9c b5 21 04 80 	movabs $0x800421b59c,%rdi
  800421545a:	00 00 00 
  800421545d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215462:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004215469:	00 00 00 
  800421546c:	41 ff d0             	callq  *%r8
	assert(dbg != NULL);
  800421546f:	48 b8 88 c6 22 04 80 	movabs $0x800422c688,%rax
  8004215476:	00 00 00 
  8004215479:	48 8b 00             	mov    (%rax),%rax
  800421547c:	48 85 c0             	test   %rax,%rax
  800421547f:	75 35                	jne    80042154b6 <_dwarf_lineno_init+0xfa>
  8004215481:	48 b9 b3 b5 21 04 80 	movabs $0x800421b5b3,%rcx
  8004215488:	00 00 00 
  800421548b:	48 ba 87 b5 21 04 80 	movabs $0x800421b587,%rdx
  8004215492:	00 00 00 
  8004215495:	be 14 01 00 00       	mov    $0x114,%esi
  800421549a:	48 bf 9c b5 21 04 80 	movabs $0x800421b59c,%rdi
  80042154a1:	00 00 00 
  80042154a4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042154a9:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042154b0:	00 00 00 
  80042154b3:	41 ff d0             	callq  *%r8

	if ((_dwarf_find_section_enhanced(ds)) != 0)
  80042154b6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042154ba:	48 89 c7             	mov    %rax,%rdi
  80042154bd:	48 b8 84 27 21 04 80 	movabs $0x8004212784,%rax
  80042154c4:	00 00 00 
  80042154c7:	ff d0                	callq  *%rax
  80042154c9:	85 c0                	test   %eax,%eax
  80042154cb:	74 0a                	je     80042154d7 <_dwarf_lineno_init+0x11b>
		return (DW_DLE_NONE);
  80042154cd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042154d2:	e9 4f 04 00 00       	jmpq   8004215926 <_dwarf_lineno_init+0x56a>

	li = linfo;
  80042154d7:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  80042154de:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
	 break;
	 }
	 }
	*/

	length = dbg->read(ds->ds_data, &offset, 4);
  80042154e2:	48 b8 88 c6 22 04 80 	movabs $0x800422c688,%rax
  80042154e9:	00 00 00 
  80042154ec:	48 8b 00             	mov    (%rax),%rax
  80042154ef:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042154f3:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042154f7:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80042154fb:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004215502:	ba 04 00 00 00       	mov    $0x4,%edx
  8004215507:	48 89 cf             	mov    %rcx,%rdi
  800421550a:	ff d0                	callq  *%rax
  800421550c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (length == 0xffffffff) {
  8004215510:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004215515:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  8004215519:	75 37                	jne    8004215552 <_dwarf_lineno_init+0x196>
		dwarf_size = 8;
  800421551b:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%rbp)
		length = dbg->read(ds->ds_data, &offset, 8);
  8004215522:	48 b8 88 c6 22 04 80 	movabs $0x800422c688,%rax
  8004215529:	00 00 00 
  800421552c:	48 8b 00             	mov    (%rax),%rax
  800421552f:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004215533:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004215537:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800421553b:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004215542:	ba 08 00 00 00       	mov    $0x8,%edx
  8004215547:	48 89 cf             	mov    %rcx,%rdi
  800421554a:	ff d0                	callq  *%rax
  800421554c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004215550:	eb 07                	jmp    8004215559 <_dwarf_lineno_init+0x19d>
	} else
		dwarf_size = 4;
  8004215552:	c7 45 e4 04 00 00 00 	movl   $0x4,-0x1c(%rbp)

	if (length > ds->ds_size - offset) {
  8004215559:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421555d:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004215561:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004215568:	48 29 c2             	sub    %rax,%rdx
  800421556b:	48 89 d0             	mov    %rdx,%rax
  800421556e:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004215572:	73 0a                	jae    800421557e <_dwarf_lineno_init+0x1c2>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_LINE_LENGTH_BAD);
		return (DW_DLE_DEBUG_LINE_LENGTH_BAD);
  8004215574:	b8 0f 00 00 00       	mov    $0xf,%eax
  8004215579:	e9 a8 03 00 00       	jmpq   8004215926 <_dwarf_lineno_init+0x56a>
	}
	/*
	 * Read in line number program header.
	 */
	li->li_length = length;
  800421557e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004215582:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004215586:	48 89 10             	mov    %rdx,(%rax)
	endoff = offset + length;
  8004215589:	48 8b 95 10 ff ff ff 	mov    -0xf0(%rbp),%rdx
  8004215590:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215594:	48 01 d0             	add    %rdx,%rax
  8004215597:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	li->li_version = dbg->read(ds->ds_data, &offset, 2); /* FIXME: verify version */
  800421559b:	48 b8 88 c6 22 04 80 	movabs $0x800422c688,%rax
  80042155a2:	00 00 00 
  80042155a5:	48 8b 00             	mov    (%rax),%rax
  80042155a8:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042155ac:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042155b0:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80042155b4:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  80042155bb:	ba 02 00 00 00       	mov    $0x2,%edx
  80042155c0:	48 89 cf             	mov    %rcx,%rdi
  80042155c3:	ff d0                	callq  *%rax
  80042155c5:	89 c2                	mov    %eax,%edx
  80042155c7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042155cb:	66 89 50 08          	mov    %dx,0x8(%rax)
	li->li_hdrlen = dbg->read(ds->ds_data, &offset, dwarf_size);
  80042155cf:	48 b8 88 c6 22 04 80 	movabs $0x800422c688,%rax
  80042155d6:	00 00 00 
  80042155d9:	48 8b 00             	mov    (%rax),%rax
  80042155dc:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042155e0:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042155e4:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80042155e8:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80042155eb:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  80042155f2:	48 89 cf             	mov    %rcx,%rdi
  80042155f5:	ff d0                	callq  *%rax
  80042155f7:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042155fb:	48 89 42 10          	mov    %rax,0x10(%rdx)
	hdroff = offset;
  80042155ff:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004215606:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	li->li_minlen = dbg->read(ds->ds_data, &offset, 1);
  800421560a:	48 b8 88 c6 22 04 80 	movabs $0x800422c688,%rax
  8004215611:	00 00 00 
  8004215614:	48 8b 00             	mov    (%rax),%rax
  8004215617:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421561b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421561f:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004215623:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  800421562a:	ba 01 00 00 00       	mov    $0x1,%edx
  800421562f:	48 89 cf             	mov    %rcx,%rdi
  8004215632:	ff d0                	callq  *%rax
  8004215634:	89 c2                	mov    %eax,%edx
  8004215636:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421563a:	88 50 18             	mov    %dl,0x18(%rax)
	li->li_defstmt = dbg->read(ds->ds_data, &offset, 1);
  800421563d:	48 b8 88 c6 22 04 80 	movabs $0x800422c688,%rax
  8004215644:	00 00 00 
  8004215647:	48 8b 00             	mov    (%rax),%rax
  800421564a:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421564e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004215652:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004215656:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  800421565d:	ba 01 00 00 00       	mov    $0x1,%edx
  8004215662:	48 89 cf             	mov    %rcx,%rdi
  8004215665:	ff d0                	callq  *%rax
  8004215667:	89 c2                	mov    %eax,%edx
  8004215669:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421566d:	88 50 19             	mov    %dl,0x19(%rax)
	li->li_lbase = dbg->read(ds->ds_data, &offset, 1);
  8004215670:	48 b8 88 c6 22 04 80 	movabs $0x800422c688,%rax
  8004215677:	00 00 00 
  800421567a:	48 8b 00             	mov    (%rax),%rax
  800421567d:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004215681:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004215685:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004215689:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004215690:	ba 01 00 00 00       	mov    $0x1,%edx
  8004215695:	48 89 cf             	mov    %rcx,%rdi
  8004215698:	ff d0                	callq  *%rax
  800421569a:	89 c2                	mov    %eax,%edx
  800421569c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042156a0:	88 50 1a             	mov    %dl,0x1a(%rax)
	li->li_lrange = dbg->read(ds->ds_data, &offset, 1);
  80042156a3:	48 b8 88 c6 22 04 80 	movabs $0x800422c688,%rax
  80042156aa:	00 00 00 
  80042156ad:	48 8b 00             	mov    (%rax),%rax
  80042156b0:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042156b4:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042156b8:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80042156bc:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  80042156c3:	ba 01 00 00 00       	mov    $0x1,%edx
  80042156c8:	48 89 cf             	mov    %rcx,%rdi
  80042156cb:	ff d0                	callq  *%rax
  80042156cd:	89 c2                	mov    %eax,%edx
  80042156cf:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042156d3:	88 50 1b             	mov    %dl,0x1b(%rax)
	li->li_opbase = dbg->read(ds->ds_data, &offset, 1);
  80042156d6:	48 b8 88 c6 22 04 80 	movabs $0x800422c688,%rax
  80042156dd:	00 00 00 
  80042156e0:	48 8b 00             	mov    (%rax),%rax
  80042156e3:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042156e7:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042156eb:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80042156ef:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  80042156f6:	ba 01 00 00 00       	mov    $0x1,%edx
  80042156fb:	48 89 cf             	mov    %rcx,%rdi
  80042156fe:	ff d0                	callq  *%rax
  8004215700:	89 c2                	mov    %eax,%edx
  8004215702:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004215706:	88 50 1c             	mov    %dl,0x1c(%rax)
	//STAILQ_INIT(&li->li_lflist);
	//STAILQ_INIT(&li->li_lnlist);

	if ((int)li->li_hdrlen - 5 < li->li_opbase - 1) {
  8004215709:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421570d:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004215711:	8d 50 fb             	lea    -0x5(%rax),%edx
  8004215714:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004215718:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  800421571c:	0f b6 c0             	movzbl %al,%eax
  800421571f:	83 e8 01             	sub    $0x1,%eax
  8004215722:	39 c2                	cmp    %eax,%edx
  8004215724:	7d 0c                	jge    8004215732 <_dwarf_lineno_init+0x376>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004215726:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  800421572d:	e9 f1 01 00 00       	jmpq   8004215923 <_dwarf_lineno_init+0x567>
	}

	li->li_oplen = global_std_op;
  8004215732:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004215736:	48 bb 60 d4 69 04 80 	movabs $0x800469d460,%rbx
  800421573d:	00 00 00 
  8004215740:	48 89 58 20          	mov    %rbx,0x20(%rax)

	/*
	 * Read in std opcode arg length list. Note that the first
	 * element is not used.
	 */
	for (i = 1; i < li->li_opbase; i++)
  8004215744:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%rbp)
  800421574b:	eb 41                	jmp    800421578e <_dwarf_lineno_init+0x3d2>
		li->li_oplen[i] = dbg->read(ds->ds_data, &offset, 1);
  800421574d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004215751:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215755:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004215758:	48 98                	cltq   
  800421575a:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800421575e:	48 b8 88 c6 22 04 80 	movabs $0x800422c688,%rax
  8004215765:	00 00 00 
  8004215768:	48 8b 00             	mov    (%rax),%rax
  800421576b:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421576f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004215773:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004215777:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  800421577e:	ba 01 00 00 00       	mov    $0x1,%edx
  8004215783:	48 89 cf             	mov    %rcx,%rdi
  8004215786:	ff d0                	callq  *%rax
  8004215788:	88 03                	mov    %al,(%rbx)

	/*
	 * Read in std opcode arg length list. Note that the first
	 * element is not used.
	 */
	for (i = 1; i < li->li_opbase; i++)
  800421578a:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
  800421578e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004215792:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004215796:	0f b6 c0             	movzbl %al,%eax
  8004215799:	3b 45 e0             	cmp    -0x20(%rbp),%eax
  800421579c:	7f af                	jg     800421574d <_dwarf_lineno_init+0x391>
		li->li_oplen[i] = dbg->read(ds->ds_data, &offset, 1);

	/*
	 * Check how many strings in the include dir string array.
	 */
	length = 0;
  800421579e:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80042157a5:	00 
	p = ds->ds_data + offset;
  80042157a6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042157aa:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80042157ae:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  80042157b5:	48 01 d0             	add    %rdx,%rax
  80042157b8:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	while (*p != '\0') {
  80042157bf:	eb 1f                	jmp    80042157e0 <_dwarf_lineno_init+0x424>
		while (*p++ != '\0')
  80042157c1:	90                   	nop
  80042157c2:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042157c9:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042157cd:	48 89 95 28 ff ff ff 	mov    %rdx,-0xd8(%rbp)
  80042157d4:	0f b6 00             	movzbl (%rax),%eax
  80042157d7:	84 c0                	test   %al,%al
  80042157d9:	75 e7                	jne    80042157c2 <_dwarf_lineno_init+0x406>
			;
		length++;
  80042157db:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
	/*
	 * Check how many strings in the include dir string array.
	 */
	length = 0;
	p = ds->ds_data + offset;
	while (*p != '\0') {
  80042157e0:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042157e7:	0f b6 00             	movzbl (%rax),%eax
  80042157ea:	84 c0                	test   %al,%al
  80042157ec:	75 d3                	jne    80042157c1 <_dwarf_lineno_init+0x405>
		while (*p++ != '\0')
			;
		length++;
	}
	li->li_inclen = length;
  80042157ee:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042157f2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042157f6:	48 89 50 30          	mov    %rdx,0x30(%rax)

	/* Sanity check. */
	if (p - ds->ds_data > (int) ds->ds_size) {
  80042157fa:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004215801:	48 89 c2             	mov    %rax,%rdx
  8004215804:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215808:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421580c:	48 29 c2             	sub    %rax,%rdx
  800421580f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215813:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004215817:	48 98                	cltq   
  8004215819:	48 39 c2             	cmp    %rax,%rdx
  800421581c:	7e 0c                	jle    800421582a <_dwarf_lineno_init+0x46e>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  800421581e:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  8004215825:	e9 f9 00 00 00       	jmpq   8004215923 <_dwarf_lineno_init+0x567>
	}
	p++;
  800421582a:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004215831:	48 83 c0 01          	add    $0x1,%rax
  8004215835:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)

	/*
	 * Process file list.
	 */
	while (*p != '\0') {
  800421583c:	eb 3c                	jmp    800421587a <_dwarf_lineno_init+0x4be>
		ret = _dwarf_lineno_add_file(li, &p, NULL, error, dbg);
  800421583e:	48 b8 88 c6 22 04 80 	movabs $0x800422c688,%rax
  8004215845:	00 00 00 
  8004215848:	48 8b 08             	mov    (%rax),%rcx
  800421584b:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  8004215852:	48 8d b5 28 ff ff ff 	lea    -0xd8(%rbp),%rsi
  8004215859:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421585d:	49 89 c8             	mov    %rcx,%r8
  8004215860:	48 89 d1             	mov    %rdx,%rcx
  8004215863:	ba 00 00 00 00       	mov    $0x0,%edx
  8004215868:	48 89 c7             	mov    %rax,%rdi
  800421586b:	48 b8 18 53 21 04 80 	movabs $0x8004215318,%rax
  8004215872:	00 00 00 
  8004215875:	ff d0                	callq  *%rax
  8004215877:	89 45 dc             	mov    %eax,-0x24(%rbp)
	p++;

	/*
	 * Process file list.
	 */
	while (*p != '\0') {
  800421587a:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004215881:	0f b6 00             	movzbl (%rax),%eax
  8004215884:	84 c0                	test   %al,%al
  8004215886:	75 b6                	jne    800421583e <_dwarf_lineno_init+0x482>
		ret = _dwarf_lineno_add_file(li, &p, NULL, error, dbg);
		//p++;
	}

	p++;
  8004215888:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800421588f:	48 83 c0 01          	add    $0x1,%rax
  8004215893:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	/* Sanity check. */
	if (p - ds->ds_data - hdroff != li->li_hdrlen) {
  800421589a:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042158a1:	48 89 c2             	mov    %rax,%rdx
  80042158a4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042158a8:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042158ac:	48 29 c2             	sub    %rax,%rdx
  80042158af:	48 89 d0             	mov    %rdx,%rax
  80042158b2:	48 2b 45 b0          	sub    -0x50(%rbp),%rax
  80042158b6:	48 89 c2             	mov    %rax,%rdx
  80042158b9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042158bd:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042158c1:	48 39 c2             	cmp    %rax,%rdx
  80042158c4:	74 09                	je     80042158cf <_dwarf_lineno_init+0x513>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  80042158c6:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  80042158cd:	eb 54                	jmp    8004215923 <_dwarf_lineno_init+0x567>
	}

	/*
	 * Process line number program.
	 */
	ret = _dwarf_lineno_run_program(cu, li, p, ds->ds_data + endoff, pc,
  80042158cf:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042158d3:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80042158d7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042158db:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  80042158df:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  80042158e6:	4c 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%r8
  80042158ed:	48 8b bd 00 ff ff ff 	mov    -0x100(%rbp),%rdi
  80042158f4:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80042158f8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042158fc:	4d 89 c1             	mov    %r8,%r9
  80042158ff:	49 89 f8             	mov    %rdi,%r8
  8004215902:	48 89 c7             	mov    %rax,%rdi
  8004215905:	48 b8 60 4d 21 04 80 	movabs $0x8004214d60,%rax
  800421590c:	00 00 00 
  800421590f:	ff d0                	callq  *%rax
  8004215911:	89 45 dc             	mov    %eax,-0x24(%rbp)
					error);
	if (ret != DW_DLE_NONE)
  8004215914:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004215918:	74 02                	je     800421591c <_dwarf_lineno_init+0x560>
		goto fail_cleanup;
  800421591a:	eb 07                	jmp    8004215923 <_dwarf_lineno_init+0x567>

	//cu->cu_lineinfo = li;

	return (DW_DLE_NONE);
  800421591c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215921:	eb 03                	jmp    8004215926 <_dwarf_lineno_init+0x56a>
fail_cleanup:

	/*if (li->li_oplen)
	  free(li->li_oplen);*/

	return (ret);
  8004215923:	8b 45 dc             	mov    -0x24(%rbp),%eax
}
  8004215926:	48 81 c4 08 01 00 00 	add    $0x108,%rsp
  800421592d:	5b                   	pop    %rbx
  800421592e:	5d                   	pop    %rbp
  800421592f:	c3                   	retq   

0000008004215930 <dwarf_srclines>:

int
dwarf_srclines(Dwarf_Die *die, Dwarf_Line linebuf, Dwarf_Addr pc, Dwarf_Error *error)
{
  8004215930:	55                   	push   %rbp
  8004215931:	48 89 e5             	mov    %rsp,%rbp
  8004215934:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  800421593b:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  8004215942:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  8004215949:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
  8004215950:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
	_Dwarf_LineInfo li;
	Dwarf_Attribute *at;

	assert(die);
  8004215957:	48 83 bd 68 ff ff ff 	cmpq   $0x0,-0x98(%rbp)
  800421595e:	00 
  800421595f:	75 35                	jne    8004215996 <dwarf_srclines+0x66>
  8004215961:	48 b9 bf b5 21 04 80 	movabs $0x800421b5bf,%rcx
  8004215968:	00 00 00 
  800421596b:	48 ba 87 b5 21 04 80 	movabs $0x800421b587,%rdx
  8004215972:	00 00 00 
  8004215975:	be 9a 01 00 00       	mov    $0x19a,%esi
  800421597a:	48 bf 9c b5 21 04 80 	movabs $0x800421b59c,%rdi
  8004215981:	00 00 00 
  8004215984:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215989:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004215990:	00 00 00 
  8004215993:	41 ff d0             	callq  *%r8
	assert(linebuf);
  8004215996:	48 83 bd 60 ff ff ff 	cmpq   $0x0,-0xa0(%rbp)
  800421599d:	00 
  800421599e:	75 35                	jne    80042159d5 <dwarf_srclines+0xa5>
  80042159a0:	48 b9 c3 b5 21 04 80 	movabs $0x800421b5c3,%rcx
  80042159a7:	00 00 00 
  80042159aa:	48 ba 87 b5 21 04 80 	movabs $0x800421b587,%rdx
  80042159b1:	00 00 00 
  80042159b4:	be 9b 01 00 00       	mov    $0x19b,%esi
  80042159b9:	48 bf 9c b5 21 04 80 	movabs $0x800421b59c,%rdi
  80042159c0:	00 00 00 
  80042159c3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042159c8:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042159cf:	00 00 00 
  80042159d2:	41 ff d0             	callq  *%r8

	memset(&li, 0, sizeof(_Dwarf_LineInfo));
  80042159d5:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  80042159dc:	ba 88 00 00 00       	mov    $0x88,%edx
  80042159e1:	be 00 00 00 00       	mov    $0x0,%esi
  80042159e6:	48 89 c7             	mov    %rax,%rdi
  80042159e9:	48 b8 d4 03 21 04 80 	movabs $0x80042103d4,%rax
  80042159f0:	00 00 00 
  80042159f3:	ff d0                	callq  *%rax

	if ((at = _dwarf_attr_find(die, DW_AT_stmt_list)) == NULL) {
  80042159f5:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042159fc:	be 10 00 00 00       	mov    $0x10,%esi
  8004215a01:	48 89 c7             	mov    %rax,%rdi
  8004215a04:	48 b8 09 23 21 04 80 	movabs $0x8004212309,%rax
  8004215a0b:	00 00 00 
  8004215a0e:	ff d0                	callq  *%rax
  8004215a10:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004215a14:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004215a19:	75 0a                	jne    8004215a25 <dwarf_srclines+0xf5>
		DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
		return (DW_DLV_NO_ENTRY);
  8004215a1b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004215a20:	e9 84 00 00 00       	jmpq   8004215aa9 <dwarf_srclines+0x179>
	}

	if (_dwarf_lineno_init(die, at->u[0].u64, &li, pc, error) !=
  8004215a25:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215a29:	48 8b 70 28          	mov    0x28(%rax),%rsi
  8004215a2d:	48 8b bd 50 ff ff ff 	mov    -0xb0(%rbp),%rdi
  8004215a34:	48 8b 8d 58 ff ff ff 	mov    -0xa8(%rbp),%rcx
  8004215a3b:	48 8d 95 70 ff ff ff 	lea    -0x90(%rbp),%rdx
  8004215a42:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004215a49:	49 89 f8             	mov    %rdi,%r8
  8004215a4c:	48 89 c7             	mov    %rax,%rdi
  8004215a4f:	48 b8 bc 53 21 04 80 	movabs $0x80042153bc,%rax
  8004215a56:	00 00 00 
  8004215a59:	ff d0                	callq  *%rax
  8004215a5b:	85 c0                	test   %eax,%eax
  8004215a5d:	74 07                	je     8004215a66 <dwarf_srclines+0x136>
	    DW_DLE_NONE)
	{
		return (DW_DLV_ERROR);
  8004215a5f:	b8 01 00 00 00       	mov    $0x1,%eax
  8004215a64:	eb 43                	jmp    8004215aa9 <dwarf_srclines+0x179>
	}
	*linebuf = li.li_line;
  8004215a66:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004215a6d:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004215a71:	48 89 10             	mov    %rdx,(%rax)
  8004215a74:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004215a78:	48 89 50 08          	mov    %rdx,0x8(%rax)
  8004215a7c:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004215a80:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004215a84:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004215a88:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004215a8c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004215a90:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004215a94:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004215a98:	48 89 50 28          	mov    %rdx,0x28(%rax)
  8004215a9c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004215aa0:	48 89 50 30          	mov    %rdx,0x30(%rax)

	return (DW_DLV_OK);
  8004215aa4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004215aa9:	c9                   	leaveq 
  8004215aaa:	c3                   	retq   

0000008004215aab <_dwarf_find_section>:
uintptr_t
read_section_headers(uintptr_t, uintptr_t);

Dwarf_Section *
_dwarf_find_section(const char *name)
{
  8004215aab:	55                   	push   %rbp
  8004215aac:	48 89 e5             	mov    %rsp,%rbp
  8004215aaf:	48 83 ec 20          	sub    $0x20,%rsp
  8004215ab3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Dwarf_Section *ret=NULL;
  8004215ab7:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004215abe:	00 
	int i;

	for(i=0; i < NDEBUG_SECT; i++) {
  8004215abf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004215ac6:	eb 57                	jmp    8004215b1f <_dwarf_find_section+0x74>
		if(!strcmp(section_info[i].ds_name, name)) {
  8004215ac8:	48 b8 c0 c6 22 04 80 	movabs $0x800422c6c0,%rax
  8004215acf:	00 00 00 
  8004215ad2:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004215ad5:	48 63 d2             	movslq %edx,%rdx
  8004215ad8:	48 c1 e2 05          	shl    $0x5,%rdx
  8004215adc:	48 01 d0             	add    %rdx,%rax
  8004215adf:	48 8b 00             	mov    (%rax),%rax
  8004215ae2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004215ae6:	48 89 d6             	mov    %rdx,%rsi
  8004215ae9:	48 89 c7             	mov    %rax,%rdi
  8004215aec:	48 b8 9d 02 21 04 80 	movabs $0x800421029d,%rax
  8004215af3:	00 00 00 
  8004215af6:	ff d0                	callq  *%rax
  8004215af8:	85 c0                	test   %eax,%eax
  8004215afa:	75 1f                	jne    8004215b1b <_dwarf_find_section+0x70>
			ret = (section_info + i);
  8004215afc:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215aff:	48 98                	cltq   
  8004215b01:	48 c1 e0 05          	shl    $0x5,%rax
  8004215b05:	48 89 c2             	mov    %rax,%rdx
  8004215b08:	48 b8 c0 c6 22 04 80 	movabs $0x800422c6c0,%rax
  8004215b0f:	00 00 00 
  8004215b12:	48 01 d0             	add    %rdx,%rax
  8004215b15:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  8004215b19:	eb 0a                	jmp    8004215b25 <_dwarf_find_section+0x7a>
_dwarf_find_section(const char *name)
{
	Dwarf_Section *ret=NULL;
	int i;

	for(i=0; i < NDEBUG_SECT; i++) {
  8004215b1b:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004215b1f:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004215b23:	7e a3                	jle    8004215ac8 <_dwarf_find_section+0x1d>
			ret = (section_info + i);
			break;
		}
	}

	return ret;
  8004215b25:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004215b29:	c9                   	leaveq 
  8004215b2a:	c3                   	retq   

0000008004215b2b <find_debug_sections>:

void find_debug_sections(uintptr_t elf) 
{
  8004215b2b:	55                   	push   %rbp
  8004215b2c:	48 89 e5             	mov    %rsp,%rbp
  8004215b2f:	48 83 ec 40          	sub    $0x40,%rsp
  8004215b33:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
	Elf *ehdr = (Elf *)elf;
  8004215b37:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215b3b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uintptr_t debug_address = USTABDATA;
  8004215b3f:	48 c7 45 f8 00 00 20 	movq   $0x200000,-0x8(%rbp)
  8004215b46:	00 
	Secthdr *sh = (Secthdr *)(((uint8_t *)ehdr + ehdr->e_shoff));
  8004215b47:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215b4b:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004215b4f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215b53:	48 01 d0             	add    %rdx,%rax
  8004215b56:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	Secthdr *shstr_tab = sh + ehdr->e_shstrndx;
  8004215b5a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215b5e:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  8004215b62:	0f b7 c0             	movzwl %ax,%eax
  8004215b65:	48 c1 e0 06          	shl    $0x6,%rax
  8004215b69:	48 89 c2             	mov    %rax,%rdx
  8004215b6c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215b70:	48 01 d0             	add    %rdx,%rax
  8004215b73:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	Secthdr* esh = sh + ehdr->e_shnum;
  8004215b77:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215b7b:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  8004215b7f:	0f b7 c0             	movzwl %ax,%eax
  8004215b82:	48 c1 e0 06          	shl    $0x6,%rax
  8004215b86:	48 89 c2             	mov    %rax,%rdx
  8004215b89:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215b8d:	48 01 d0             	add    %rdx,%rax
  8004215b90:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	for(;sh < esh; sh++) {
  8004215b94:	e9 4b 02 00 00       	jmpq   8004215de4 <find_debug_sections+0x2b9>
		char* name = (char*)((uint8_t*)elf + shstr_tab->sh_offset) + sh->sh_name;
  8004215b99:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215b9d:	8b 00                	mov    (%rax),%eax
  8004215b9f:	89 c2                	mov    %eax,%edx
  8004215ba1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215ba5:	48 8b 48 18          	mov    0x18(%rax),%rcx
  8004215ba9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215bad:	48 01 c8             	add    %rcx,%rax
  8004215bb0:	48 01 d0             	add    %rdx,%rax
  8004215bb3:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if(!strcmp(name, ".debug_info")) {
  8004215bb7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215bbb:	48 be cb b5 21 04 80 	movabs $0x800421b5cb,%rsi
  8004215bc2:	00 00 00 
  8004215bc5:	48 89 c7             	mov    %rax,%rdi
  8004215bc8:	48 b8 9d 02 21 04 80 	movabs $0x800421029d,%rax
  8004215bcf:	00 00 00 
  8004215bd2:	ff d0                	callq  *%rax
  8004215bd4:	85 c0                	test   %eax,%eax
  8004215bd6:	75 4b                	jne    8004215c23 <find_debug_sections+0xf8>
			section_info[DEBUG_INFO].ds_data = (uint8_t*)debug_address;
  8004215bd8:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215bdc:	48 b8 c0 c6 22 04 80 	movabs $0x800422c6c0,%rax
  8004215be3:	00 00 00 
  8004215be6:	48 89 50 08          	mov    %rdx,0x8(%rax)
			section_info[DEBUG_INFO].ds_addr = debug_address;
  8004215bea:	48 b8 c0 c6 22 04 80 	movabs $0x800422c6c0,%rax
  8004215bf1:	00 00 00 
  8004215bf4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215bf8:	48 89 50 10          	mov    %rdx,0x10(%rax)
			section_info[DEBUG_INFO].ds_size = sh->sh_size;
  8004215bfc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215c00:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215c04:	48 b8 c0 c6 22 04 80 	movabs $0x800422c6c0,%rax
  8004215c0b:	00 00 00 
  8004215c0e:	48 89 50 18          	mov    %rdx,0x18(%rax)
			debug_address += sh->sh_size;
  8004215c12:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215c16:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004215c1a:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  8004215c1e:	e9 bc 01 00 00       	jmpq   8004215ddf <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_abbrev")) {
  8004215c23:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215c27:	48 be d7 b5 21 04 80 	movabs $0x800421b5d7,%rsi
  8004215c2e:	00 00 00 
  8004215c31:	48 89 c7             	mov    %rax,%rdi
  8004215c34:	48 b8 9d 02 21 04 80 	movabs $0x800421029d,%rax
  8004215c3b:	00 00 00 
  8004215c3e:	ff d0                	callq  *%rax
  8004215c40:	85 c0                	test   %eax,%eax
  8004215c42:	75 4b                	jne    8004215c8f <find_debug_sections+0x164>
			section_info[DEBUG_ABBREV].ds_data = (uint8_t*)debug_address;
  8004215c44:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215c48:	48 b8 c0 c6 22 04 80 	movabs $0x800422c6c0,%rax
  8004215c4f:	00 00 00 
  8004215c52:	48 89 50 28          	mov    %rdx,0x28(%rax)
			section_info[DEBUG_ABBREV].ds_addr = debug_address;
  8004215c56:	48 b8 c0 c6 22 04 80 	movabs $0x800422c6c0,%rax
  8004215c5d:	00 00 00 
  8004215c60:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215c64:	48 89 50 30          	mov    %rdx,0x30(%rax)
			section_info[DEBUG_ABBREV].ds_size = sh->sh_size;
  8004215c68:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215c6c:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215c70:	48 b8 c0 c6 22 04 80 	movabs $0x800422c6c0,%rax
  8004215c77:	00 00 00 
  8004215c7a:	48 89 50 38          	mov    %rdx,0x38(%rax)
			debug_address += sh->sh_size;
  8004215c7e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215c82:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004215c86:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  8004215c8a:	e9 50 01 00 00       	jmpq   8004215ddf <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_line")){
  8004215c8f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215c93:	48 be ef b5 21 04 80 	movabs $0x800421b5ef,%rsi
  8004215c9a:	00 00 00 
  8004215c9d:	48 89 c7             	mov    %rax,%rdi
  8004215ca0:	48 b8 9d 02 21 04 80 	movabs $0x800421029d,%rax
  8004215ca7:	00 00 00 
  8004215caa:	ff d0                	callq  *%rax
  8004215cac:	85 c0                	test   %eax,%eax
  8004215cae:	75 4b                	jne    8004215cfb <find_debug_sections+0x1d0>
			section_info[DEBUG_LINE].ds_data = (uint8_t*)debug_address;
  8004215cb0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215cb4:	48 b8 c0 c6 22 04 80 	movabs $0x800422c6c0,%rax
  8004215cbb:	00 00 00 
  8004215cbe:	48 89 50 68          	mov    %rdx,0x68(%rax)
			section_info[DEBUG_LINE].ds_addr = debug_address;
  8004215cc2:	48 b8 c0 c6 22 04 80 	movabs $0x800422c6c0,%rax
  8004215cc9:	00 00 00 
  8004215ccc:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215cd0:	48 89 50 70          	mov    %rdx,0x70(%rax)
			section_info[DEBUG_LINE].ds_size = sh->sh_size;
  8004215cd4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215cd8:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215cdc:	48 b8 c0 c6 22 04 80 	movabs $0x800422c6c0,%rax
  8004215ce3:	00 00 00 
  8004215ce6:	48 89 50 78          	mov    %rdx,0x78(%rax)
			debug_address += sh->sh_size;
  8004215cea:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215cee:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004215cf2:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  8004215cf6:	e9 e4 00 00 00       	jmpq   8004215ddf <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".eh_frame")){
  8004215cfb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215cff:	48 be e5 b5 21 04 80 	movabs $0x800421b5e5,%rsi
  8004215d06:	00 00 00 
  8004215d09:	48 89 c7             	mov    %rax,%rdi
  8004215d0c:	48 b8 9d 02 21 04 80 	movabs $0x800421029d,%rax
  8004215d13:	00 00 00 
  8004215d16:	ff d0                	callq  *%rax
  8004215d18:	85 c0                	test   %eax,%eax
  8004215d1a:	75 53                	jne    8004215d6f <find_debug_sections+0x244>
			section_info[DEBUG_FRAME].ds_data = (uint8_t*)sh->sh_addr;
  8004215d1c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215d20:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004215d24:	48 89 c2             	mov    %rax,%rdx
  8004215d27:	48 b8 c0 c6 22 04 80 	movabs $0x800422c6c0,%rax
  8004215d2e:	00 00 00 
  8004215d31:	48 89 50 48          	mov    %rdx,0x48(%rax)
			section_info[DEBUG_FRAME].ds_addr = sh->sh_addr;
  8004215d35:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215d39:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004215d3d:	48 b8 c0 c6 22 04 80 	movabs $0x800422c6c0,%rax
  8004215d44:	00 00 00 
  8004215d47:	48 89 50 50          	mov    %rdx,0x50(%rax)
			section_info[DEBUG_FRAME].ds_size = sh->sh_size;
  8004215d4b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215d4f:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215d53:	48 b8 c0 c6 22 04 80 	movabs $0x800422c6c0,%rax
  8004215d5a:	00 00 00 
  8004215d5d:	48 89 50 58          	mov    %rdx,0x58(%rax)
			debug_address += sh->sh_size;
  8004215d61:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215d65:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004215d69:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  8004215d6d:	eb 70                	jmp    8004215ddf <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_str")) {
  8004215d6f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215d73:	48 be fb b5 21 04 80 	movabs $0x800421b5fb,%rsi
  8004215d7a:	00 00 00 
  8004215d7d:	48 89 c7             	mov    %rax,%rdi
  8004215d80:	48 b8 9d 02 21 04 80 	movabs $0x800421029d,%rax
  8004215d87:	00 00 00 
  8004215d8a:	ff d0                	callq  *%rax
  8004215d8c:	85 c0                	test   %eax,%eax
  8004215d8e:	75 4f                	jne    8004215ddf <find_debug_sections+0x2b4>
			section_info[DEBUG_STR].ds_data = (uint8_t*)debug_address;
  8004215d90:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215d94:	48 b8 c0 c6 22 04 80 	movabs $0x800422c6c0,%rax
  8004215d9b:	00 00 00 
  8004215d9e:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
			section_info[DEBUG_STR].ds_addr = debug_address;
  8004215da5:	48 b8 c0 c6 22 04 80 	movabs $0x800422c6c0,%rax
  8004215dac:	00 00 00 
  8004215daf:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215db3:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
			section_info[DEBUG_STR].ds_size = sh->sh_size;
  8004215dba:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215dbe:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215dc2:	48 b8 c0 c6 22 04 80 	movabs $0x800422c6c0,%rax
  8004215dc9:	00 00 00 
  8004215dcc:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
			debug_address += sh->sh_size;
  8004215dd3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215dd7:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004215ddb:	48 01 45 f8          	add    %rax,-0x8(%rbp)
	Elf *ehdr = (Elf *)elf;
	uintptr_t debug_address = USTABDATA;
	Secthdr *sh = (Secthdr *)(((uint8_t *)ehdr + ehdr->e_shoff));
	Secthdr *shstr_tab = sh + ehdr->e_shstrndx;
	Secthdr* esh = sh + ehdr->e_shnum;
	for(;sh < esh; sh++) {
  8004215ddf:	48 83 45 f0 40       	addq   $0x40,-0x10(%rbp)
  8004215de4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215de8:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004215dec:	0f 82 a7 fd ff ff    	jb     8004215b99 <find_debug_sections+0x6e>
			section_info[DEBUG_STR].ds_size = sh->sh_size;
			debug_address += sh->sh_size;
		}
	}

}
  8004215df2:	c9                   	leaveq 
  8004215df3:	c3                   	retq   

0000008004215df4 <read_section_headers>:

uint64_t
read_section_headers(uintptr_t elfhdr, uintptr_t to_va)
{
  8004215df4:	55                   	push   %rbp
  8004215df5:	48 89 e5             	mov    %rsp,%rbp
  8004215df8:	48 81 ec 60 01 00 00 	sub    $0x160,%rsp
  8004215dff:	48 89 bd a8 fe ff ff 	mov    %rdi,-0x158(%rbp)
  8004215e06:	48 89 b5 a0 fe ff ff 	mov    %rsi,-0x160(%rbp)
	Secthdr* secthdr_ptr[20] = {0};
  8004215e0d:	48 8d b5 c0 fe ff ff 	lea    -0x140(%rbp),%rsi
  8004215e14:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215e19:	ba 14 00 00 00       	mov    $0x14,%edx
  8004215e1e:	48 89 f7             	mov    %rsi,%rdi
  8004215e21:	48 89 d1             	mov    %rdx,%rcx
  8004215e24:	f3 48 ab             	rep stos %rax,%es:(%rdi)
	char* kvbase = ROUNDUP((char*)to_va, SECTSIZE);
  8004215e27:	48 c7 45 e8 00 02 00 	movq   $0x200,-0x18(%rbp)
  8004215e2e:	00 
  8004215e2f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215e33:	48 8b 95 a0 fe ff ff 	mov    -0x160(%rbp),%rdx
  8004215e3a:	48 01 d0             	add    %rdx,%rax
  8004215e3d:	48 83 e8 01          	sub    $0x1,%rax
  8004215e41:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004215e45:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215e49:	ba 00 00 00 00       	mov    $0x0,%edx
  8004215e4e:	48 f7 75 e8          	divq   -0x18(%rbp)
  8004215e52:	48 89 d0             	mov    %rdx,%rax
  8004215e55:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004215e59:	48 29 c2             	sub    %rax,%rdx
  8004215e5c:	48 89 d0             	mov    %rdx,%rax
  8004215e5f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	uint64_t kvoffset = 0;
  8004215e63:	48 c7 85 b8 fe ff ff 	movq   $0x0,-0x148(%rbp)
  8004215e6a:	00 00 00 00 
	char *orig_secthdr = (char*)kvbase;
  8004215e6e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215e72:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	char * secthdr = NULL;
  8004215e76:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  8004215e7d:	00 
	uint64_t offset;
	if(elfhdr == KELFHDR)
  8004215e7e:	48 b8 00 00 01 04 80 	movabs $0x8004010000,%rax
  8004215e85:	00 00 00 
  8004215e88:	48 39 85 a8 fe ff ff 	cmp    %rax,-0x158(%rbp)
  8004215e8f:	75 11                	jne    8004215ea2 <read_section_headers+0xae>
		offset = ((Elf*)elfhdr)->e_shoff;
  8004215e91:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004215e98:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004215e9c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004215ea0:	eb 26                	jmp    8004215ec8 <read_section_headers+0xd4>
	else
		offset = ((Elf*)elfhdr)->e_shoff + (elfhdr - KERNBASE);
  8004215ea2:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004215ea9:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004215ead:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004215eb4:	48 01 c2             	add    %rax,%rdx
  8004215eb7:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  8004215ebe:	ff ff ff 
  8004215ec1:	48 01 d0             	add    %rdx,%rax
  8004215ec4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	int numSectionHeaders = ((Elf*)elfhdr)->e_shnum;
  8004215ec8:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004215ecf:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  8004215ed3:	0f b7 c0             	movzwl %ax,%eax
  8004215ed6:	89 45 c4             	mov    %eax,-0x3c(%rbp)
	int sizeSections = ((Elf*)elfhdr)->e_shentsize;
  8004215ed9:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004215ee0:	0f b7 40 3a          	movzwl 0x3a(%rax),%eax
  8004215ee4:	0f b7 c0             	movzwl %ax,%eax
  8004215ee7:	89 45 c0             	mov    %eax,-0x40(%rbp)
	char *nametab;
	int i;
	uint64_t temp;
	char *name;

	Elf *ehdr = (Elf *)elfhdr;
  8004215eea:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004215ef1:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	Secthdr *sec_name;  

	readseg((uint64_t)orig_secthdr , numSectionHeaders * sizeSections,
  8004215ef5:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004215ef8:	0f af 45 c0          	imul   -0x40(%rbp),%eax
  8004215efc:	48 63 f0             	movslq %eax,%rsi
  8004215eff:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215f03:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004215f0a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215f0e:	48 89 c7             	mov    %rax,%rdi
  8004215f11:	48 b8 33 65 21 04 80 	movabs $0x8004216533,%rax
  8004215f18:	00 00 00 
  8004215f1b:	ff d0                	callq  *%rax
		offset, &kvoffset);
	secthdr = (char*)orig_secthdr + (offset - ROUNDDOWN(offset, SECTSIZE));
  8004215f1d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215f21:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  8004215f25:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004215f29:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004215f2f:	48 89 c2             	mov    %rax,%rdx
  8004215f32:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215f36:	48 29 d0             	sub    %rdx,%rax
  8004215f39:	48 89 c2             	mov    %rax,%rdx
  8004215f3c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215f40:	48 01 d0             	add    %rdx,%rax
  8004215f43:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	for (i = 0; i < numSectionHeaders; i++)
  8004215f47:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004215f4e:	eb 24                	jmp    8004215f74 <read_section_headers+0x180>
	{
		secthdr_ptr[i] = (Secthdr*)(secthdr) + i;
  8004215f50:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215f53:	48 98                	cltq   
  8004215f55:	48 c1 e0 06          	shl    $0x6,%rax
  8004215f59:	48 89 c2             	mov    %rax,%rdx
  8004215f5c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215f60:	48 01 c2             	add    %rax,%rdx
  8004215f63:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215f66:	48 98                	cltq   
  8004215f68:	48 89 94 c5 c0 fe ff 	mov    %rdx,-0x140(%rbp,%rax,8)
  8004215f6f:	ff 
	Secthdr *sec_name;  

	readseg((uint64_t)orig_secthdr , numSectionHeaders * sizeSections,
		offset, &kvoffset);
	secthdr = (char*)orig_secthdr + (offset - ROUNDDOWN(offset, SECTSIZE));
	for (i = 0; i < numSectionHeaders; i++)
  8004215f70:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004215f74:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215f77:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  8004215f7a:	7c d4                	jl     8004215f50 <read_section_headers+0x15c>
	{
		secthdr_ptr[i] = (Secthdr*)(secthdr) + i;
	}
	
	sec_name = secthdr_ptr[ehdr->e_shstrndx]; 
  8004215f7c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004215f80:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  8004215f84:	0f b7 c0             	movzwl %ax,%eax
  8004215f87:	48 98                	cltq   
  8004215f89:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215f90:	ff 
  8004215f91:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	temp = kvoffset;
  8004215f95:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004215f9c:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
	readseg((uint64_t)((char *)kvbase + kvoffset), sec_name->sh_size,
  8004215fa0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004215fa4:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004215fa8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004215fac:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004215fb0:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  8004215fb7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215fbb:	48 01 c8             	add    %rcx,%rax
  8004215fbe:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004215fc5:	48 89 c7             	mov    %rax,%rdi
  8004215fc8:	48 b8 33 65 21 04 80 	movabs $0x8004216533,%rax
  8004215fcf:	00 00 00 
  8004215fd2:	ff d0                	callq  *%rax
		sec_name->sh_offset, &kvoffset);
	nametab = (char *)((char *)kvbase + temp) + OFFSET_CORRECT(sec_name->sh_offset);	
  8004215fd4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004215fd8:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004215fdc:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004215fe0:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004215fe4:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  8004215fe8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004215fec:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004215ff2:	48 29 c2             	sub    %rax,%rdx
  8004215ff5:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004215ff9:	48 01 c2             	add    %rax,%rdx
  8004215ffc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216000:	48 01 d0             	add    %rdx,%rax
  8004216003:	48 89 45 90          	mov    %rax,-0x70(%rbp)

	for (i = 0; i < numSectionHeaders; i++)
  8004216007:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  800421600e:	e9 04 05 00 00       	jmpq   8004216517 <read_section_headers+0x723>
	{
		name = (char *)(nametab + secthdr_ptr[i]->sh_name);
  8004216013:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216016:	48 98                	cltq   
  8004216018:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421601f:	ff 
  8004216020:	8b 00                	mov    (%rax),%eax
  8004216022:	89 c2                	mov    %eax,%edx
  8004216024:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004216028:	48 01 d0             	add    %rdx,%rax
  800421602b:	48 89 45 88          	mov    %rax,-0x78(%rbp)
		assert(kvoffset % SECTSIZE == 0);
  800421602f:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004216036:	25 ff 01 00 00       	and    $0x1ff,%eax
  800421603b:	48 85 c0             	test   %rax,%rax
  800421603e:	74 35                	je     8004216075 <read_section_headers+0x281>
  8004216040:	48 b9 06 b6 21 04 80 	movabs $0x800421b606,%rcx
  8004216047:	00 00 00 
  800421604a:	48 ba 1f b6 21 04 80 	movabs $0x800421b61f,%rdx
  8004216051:	00 00 00 
  8004216054:	be 88 00 00 00       	mov    $0x88,%esi
  8004216059:	48 bf 34 b6 21 04 80 	movabs $0x800421b634,%rdi
  8004216060:	00 00 00 
  8004216063:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216068:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  800421606f:	00 00 00 
  8004216072:	41 ff d0             	callq  *%r8
		temp = kvoffset;
  8004216075:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  800421607c:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
#ifdef DWARF_DEBUG
		cprintf("SectName: %s\n", name);
#endif
		if(!strcmp(name, ".debug_info"))
  8004216080:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004216084:	48 be cb b5 21 04 80 	movabs $0x800421b5cb,%rsi
  800421608b:	00 00 00 
  800421608e:	48 89 c7             	mov    %rax,%rdi
  8004216091:	48 b8 9d 02 21 04 80 	movabs $0x800421029d,%rax
  8004216098:	00 00 00 
  800421609b:	ff d0                	callq  *%rax
  800421609d:	85 c0                	test   %eax,%eax
  800421609f:	0f 85 d8 00 00 00    	jne    800421617d <read_section_headers+0x389>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  80042160a5:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042160a8:	48 98                	cltq   
  80042160aa:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042160b1:	ff 
#ifdef DWARF_DEBUG
		cprintf("SectName: %s\n", name);
#endif
		if(!strcmp(name, ".debug_info"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  80042160b2:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042160b6:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042160b9:	48 98                	cltq   
  80042160bb:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042160c2:	ff 
  80042160c3:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80042160c7:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  80042160ce:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042160d2:	48 01 c8             	add    %rcx,%rax
  80042160d5:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  80042160dc:	48 89 c7             	mov    %rax,%rdi
  80042160df:	48 b8 33 65 21 04 80 	movabs $0x8004216533,%rax
  80042160e6:	00 00 00 
  80042160e9:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_INFO].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  80042160eb:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042160ee:	48 98                	cltq   
  80042160f0:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042160f7:	ff 
  80042160f8:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042160fc:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042160ff:	48 98                	cltq   
  8004216101:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216108:	ff 
  8004216109:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421610d:	48 89 45 80          	mov    %rax,-0x80(%rbp)
  8004216111:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004216115:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  800421611b:	48 29 c2             	sub    %rax,%rdx
  800421611e:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004216122:	48 01 c2             	add    %rax,%rdx
  8004216125:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216129:	48 01 c2             	add    %rax,%rdx
  800421612c:	48 b8 c0 c6 22 04 80 	movabs $0x800422c6c0,%rax
  8004216133:	00 00 00 
  8004216136:	48 89 50 08          	mov    %rdx,0x8(%rax)
			section_info[DEBUG_INFO].ds_addr = (uintptr_t)section_info[DEBUG_INFO].ds_data;
  800421613a:	48 b8 c0 c6 22 04 80 	movabs $0x800422c6c0,%rax
  8004216141:	00 00 00 
  8004216144:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004216148:	48 89 c2             	mov    %rax,%rdx
  800421614b:	48 b8 c0 c6 22 04 80 	movabs $0x800422c6c0,%rax
  8004216152:	00 00 00 
  8004216155:	48 89 50 10          	mov    %rdx,0x10(%rax)
			section_info[DEBUG_INFO].ds_size = secthdr_ptr[i]->sh_size;
  8004216159:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421615c:	48 98                	cltq   
  800421615e:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216165:	ff 
  8004216166:	48 8b 50 20          	mov    0x20(%rax),%rdx
  800421616a:	48 b8 c0 c6 22 04 80 	movabs $0x800422c6c0,%rax
  8004216171:	00 00 00 
  8004216174:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004216178:	e9 96 03 00 00       	jmpq   8004216513 <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".debug_abbrev"))
  800421617d:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004216181:	48 be d7 b5 21 04 80 	movabs $0x800421b5d7,%rsi
  8004216188:	00 00 00 
  800421618b:	48 89 c7             	mov    %rax,%rdi
  800421618e:	48 b8 9d 02 21 04 80 	movabs $0x800421029d,%rax
  8004216195:	00 00 00 
  8004216198:	ff d0                	callq  *%rax
  800421619a:	85 c0                	test   %eax,%eax
  800421619c:	0f 85 de 00 00 00    	jne    8004216280 <read_section_headers+0x48c>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  80042161a2:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042161a5:	48 98                	cltq   
  80042161a7:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042161ae:	ff 
			section_info[DEBUG_INFO].ds_addr = (uintptr_t)section_info[DEBUG_INFO].ds_data;
			section_info[DEBUG_INFO].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_abbrev"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  80042161af:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042161b3:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042161b6:	48 98                	cltq   
  80042161b8:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042161bf:	ff 
  80042161c0:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80042161c4:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  80042161cb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042161cf:	48 01 c8             	add    %rcx,%rax
  80042161d2:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  80042161d9:	48 89 c7             	mov    %rax,%rdi
  80042161dc:	48 b8 33 65 21 04 80 	movabs $0x8004216533,%rax
  80042161e3:	00 00 00 
  80042161e6:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_ABBREV].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  80042161e8:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042161eb:	48 98                	cltq   
  80042161ed:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042161f4:	ff 
  80042161f5:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042161f9:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042161fc:	48 98                	cltq   
  80042161fe:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216205:	ff 
  8004216206:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421620a:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  8004216211:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004216218:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  800421621e:	48 29 c2             	sub    %rax,%rdx
  8004216221:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004216225:	48 01 c2             	add    %rax,%rdx
  8004216228:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421622c:	48 01 c2             	add    %rax,%rdx
  800421622f:	48 b8 c0 c6 22 04 80 	movabs $0x800422c6c0,%rax
  8004216236:	00 00 00 
  8004216239:	48 89 50 28          	mov    %rdx,0x28(%rax)
			section_info[DEBUG_ABBREV].ds_addr = (uintptr_t)section_info[DEBUG_ABBREV].ds_data;
  800421623d:	48 b8 c0 c6 22 04 80 	movabs $0x800422c6c0,%rax
  8004216244:	00 00 00 
  8004216247:	48 8b 40 28          	mov    0x28(%rax),%rax
  800421624b:	48 89 c2             	mov    %rax,%rdx
  800421624e:	48 b8 c0 c6 22 04 80 	movabs $0x800422c6c0,%rax
  8004216255:	00 00 00 
  8004216258:	48 89 50 30          	mov    %rdx,0x30(%rax)
			section_info[DEBUG_ABBREV].ds_size = secthdr_ptr[i]->sh_size;
  800421625c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421625f:	48 98                	cltq   
  8004216261:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216268:	ff 
  8004216269:	48 8b 50 20          	mov    0x20(%rax),%rdx
  800421626d:	48 b8 c0 c6 22 04 80 	movabs $0x800422c6c0,%rax
  8004216274:	00 00 00 
  8004216277:	48 89 50 38          	mov    %rdx,0x38(%rax)
  800421627b:	e9 93 02 00 00       	jmpq   8004216513 <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".debug_line"))
  8004216280:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004216284:	48 be ef b5 21 04 80 	movabs $0x800421b5ef,%rsi
  800421628b:	00 00 00 
  800421628e:	48 89 c7             	mov    %rax,%rdi
  8004216291:	48 b8 9d 02 21 04 80 	movabs $0x800421029d,%rax
  8004216298:	00 00 00 
  800421629b:	ff d0                	callq  *%rax
  800421629d:	85 c0                	test   %eax,%eax
  800421629f:	0f 85 de 00 00 00    	jne    8004216383 <read_section_headers+0x58f>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  80042162a5:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042162a8:	48 98                	cltq   
  80042162aa:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042162b1:	ff 
			section_info[DEBUG_ABBREV].ds_addr = (uintptr_t)section_info[DEBUG_ABBREV].ds_data;
			section_info[DEBUG_ABBREV].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_line"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  80042162b2:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042162b6:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042162b9:	48 98                	cltq   
  80042162bb:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042162c2:	ff 
  80042162c3:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80042162c7:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  80042162ce:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042162d2:	48 01 c8             	add    %rcx,%rax
  80042162d5:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  80042162dc:	48 89 c7             	mov    %rax,%rdi
  80042162df:	48 b8 33 65 21 04 80 	movabs $0x8004216533,%rax
  80042162e6:	00 00 00 
  80042162e9:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_LINE].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  80042162eb:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042162ee:	48 98                	cltq   
  80042162f0:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042162f7:	ff 
  80042162f8:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042162fc:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042162ff:	48 98                	cltq   
  8004216301:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216308:	ff 
  8004216309:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421630d:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  8004216314:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  800421631b:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004216321:	48 29 c2             	sub    %rax,%rdx
  8004216324:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004216328:	48 01 c2             	add    %rax,%rdx
  800421632b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421632f:	48 01 c2             	add    %rax,%rdx
  8004216332:	48 b8 c0 c6 22 04 80 	movabs $0x800422c6c0,%rax
  8004216339:	00 00 00 
  800421633c:	48 89 50 68          	mov    %rdx,0x68(%rax)
			section_info[DEBUG_LINE].ds_addr = (uintptr_t)section_info[DEBUG_LINE].ds_data;
  8004216340:	48 b8 c0 c6 22 04 80 	movabs $0x800422c6c0,%rax
  8004216347:	00 00 00 
  800421634a:	48 8b 40 68          	mov    0x68(%rax),%rax
  800421634e:	48 89 c2             	mov    %rax,%rdx
  8004216351:	48 b8 c0 c6 22 04 80 	movabs $0x800422c6c0,%rax
  8004216358:	00 00 00 
  800421635b:	48 89 50 70          	mov    %rdx,0x70(%rax)
			section_info[DEBUG_LINE].ds_size = secthdr_ptr[i]->sh_size;
  800421635f:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216362:	48 98                	cltq   
  8004216364:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421636b:	ff 
  800421636c:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004216370:	48 b8 c0 c6 22 04 80 	movabs $0x800422c6c0,%rax
  8004216377:	00 00 00 
  800421637a:	48 89 50 78          	mov    %rdx,0x78(%rax)
  800421637e:	e9 90 01 00 00       	jmpq   8004216513 <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".eh_frame"))
  8004216383:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004216387:	48 be e5 b5 21 04 80 	movabs $0x800421b5e5,%rsi
  800421638e:	00 00 00 
  8004216391:	48 89 c7             	mov    %rax,%rdi
  8004216394:	48 b8 9d 02 21 04 80 	movabs $0x800421029d,%rax
  800421639b:	00 00 00 
  800421639e:	ff d0                	callq  *%rax
  80042163a0:	85 c0                	test   %eax,%eax
  80042163a2:	75 65                	jne    8004216409 <read_section_headers+0x615>
		{
			section_info[DEBUG_FRAME].ds_data = (uint8_t *)secthdr_ptr[i]->sh_addr;
  80042163a4:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042163a7:	48 98                	cltq   
  80042163a9:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042163b0:	ff 
  80042163b1:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042163b5:	48 89 c2             	mov    %rax,%rdx
  80042163b8:	48 b8 c0 c6 22 04 80 	movabs $0x800422c6c0,%rax
  80042163bf:	00 00 00 
  80042163c2:	48 89 50 48          	mov    %rdx,0x48(%rax)
			section_info[DEBUG_FRAME].ds_addr = (uintptr_t)section_info[DEBUG_FRAME].ds_data;
  80042163c6:	48 b8 c0 c6 22 04 80 	movabs $0x800422c6c0,%rax
  80042163cd:	00 00 00 
  80042163d0:	48 8b 40 48          	mov    0x48(%rax),%rax
  80042163d4:	48 89 c2             	mov    %rax,%rdx
  80042163d7:	48 b8 c0 c6 22 04 80 	movabs $0x800422c6c0,%rax
  80042163de:	00 00 00 
  80042163e1:	48 89 50 50          	mov    %rdx,0x50(%rax)
			section_info[DEBUG_FRAME].ds_size = secthdr_ptr[i]->sh_size;
  80042163e5:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042163e8:	48 98                	cltq   
  80042163ea:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042163f1:	ff 
  80042163f2:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042163f6:	48 b8 c0 c6 22 04 80 	movabs $0x800422c6c0,%rax
  80042163fd:	00 00 00 
  8004216400:	48 89 50 58          	mov    %rdx,0x58(%rax)
  8004216404:	e9 0a 01 00 00       	jmpq   8004216513 <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".debug_str"))
  8004216409:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800421640d:	48 be fb b5 21 04 80 	movabs $0x800421b5fb,%rsi
  8004216414:	00 00 00 
  8004216417:	48 89 c7             	mov    %rax,%rdi
  800421641a:	48 b8 9d 02 21 04 80 	movabs $0x800421029d,%rax
  8004216421:	00 00 00 
  8004216424:	ff d0                	callq  *%rax
  8004216426:	85 c0                	test   %eax,%eax
  8004216428:	0f 85 e5 00 00 00    	jne    8004216513 <read_section_headers+0x71f>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  800421642e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216431:	48 98                	cltq   
  8004216433:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421643a:	ff 
			section_info[DEBUG_FRAME].ds_addr = (uintptr_t)section_info[DEBUG_FRAME].ds_data;
			section_info[DEBUG_FRAME].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_str"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  800421643b:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421643f:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216442:	48 98                	cltq   
  8004216444:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421644b:	ff 
  800421644c:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004216450:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  8004216457:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421645b:	48 01 c8             	add    %rcx,%rax
  800421645e:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004216465:	48 89 c7             	mov    %rax,%rdi
  8004216468:	48 b8 33 65 21 04 80 	movabs $0x8004216533,%rax
  800421646f:	00 00 00 
  8004216472:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_STR].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  8004216474:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216477:	48 98                	cltq   
  8004216479:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216480:	ff 
  8004216481:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004216485:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216488:	48 98                	cltq   
  800421648a:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216491:	ff 
  8004216492:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004216496:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
  800421649d:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042164a4:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  80042164aa:	48 29 c2             	sub    %rax,%rdx
  80042164ad:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042164b1:	48 01 c2             	add    %rax,%rdx
  80042164b4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042164b8:	48 01 c2             	add    %rax,%rdx
  80042164bb:	48 b8 c0 c6 22 04 80 	movabs $0x800422c6c0,%rax
  80042164c2:	00 00 00 
  80042164c5:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
			section_info[DEBUG_STR].ds_addr = (uintptr_t)section_info[DEBUG_STR].ds_data;
  80042164cc:	48 b8 c0 c6 22 04 80 	movabs $0x800422c6c0,%rax
  80042164d3:	00 00 00 
  80042164d6:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  80042164dd:	48 89 c2             	mov    %rax,%rdx
  80042164e0:	48 b8 c0 c6 22 04 80 	movabs $0x800422c6c0,%rax
  80042164e7:	00 00 00 
  80042164ea:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
			section_info[DEBUG_STR].ds_size = secthdr_ptr[i]->sh_size;
  80042164f1:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042164f4:	48 98                	cltq   
  80042164f6:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042164fd:	ff 
  80042164fe:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004216502:	48 b8 c0 c6 22 04 80 	movabs $0x800422c6c0,%rax
  8004216509:	00 00 00 
  800421650c:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	temp = kvoffset;
	readseg((uint64_t)((char *)kvbase + kvoffset), sec_name->sh_size,
		sec_name->sh_offset, &kvoffset);
	nametab = (char *)((char *)kvbase + temp) + OFFSET_CORRECT(sec_name->sh_offset);	

	for (i = 0; i < numSectionHeaders; i++)
  8004216513:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004216517:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421651a:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  800421651d:	0f 8c f0 fa ff ff    	jl     8004216013 <read_section_headers+0x21f>
			section_info[DEBUG_STR].ds_addr = (uintptr_t)section_info[DEBUG_STR].ds_data;
			section_info[DEBUG_STR].ds_size = secthdr_ptr[i]->sh_size;
		}
	}
	
	return ((uintptr_t)kvbase + kvoffset);
  8004216523:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004216527:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  800421652e:	48 01 d0             	add    %rdx,%rax
}
  8004216531:	c9                   	leaveq 
  8004216532:	c3                   	retq   

0000008004216533 <readseg>:

// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.
// Might copy more than asked
void
readseg(uint64_t pa, uint64_t count, uint64_t offset, uint64_t* kvoffset)
{
  8004216533:	55                   	push   %rbp
  8004216534:	48 89 e5             	mov    %rsp,%rbp
  8004216537:	48 83 ec 30          	sub    $0x30,%rsp
  800421653b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421653f:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004216543:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004216547:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
	uint64_t end_pa;
	uint64_t orgoff = offset;
  800421654b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421654f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	end_pa = pa + count;
  8004216553:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216557:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421655b:	48 01 d0             	add    %rdx,%rax
  800421655e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	assert(pa % SECTSIZE == 0);	
  8004216562:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216566:	25 ff 01 00 00       	and    $0x1ff,%eax
  800421656b:	48 85 c0             	test   %rax,%rax
  800421656e:	74 35                	je     80042165a5 <readseg+0x72>
  8004216570:	48 b9 42 b6 21 04 80 	movabs $0x800421b642,%rcx
  8004216577:	00 00 00 
  800421657a:	48 ba 1f b6 21 04 80 	movabs $0x800421b61f,%rdx
  8004216581:	00 00 00 
  8004216584:	be c2 00 00 00       	mov    $0xc2,%esi
  8004216589:	48 bf 34 b6 21 04 80 	movabs $0x800421b634,%rdi
  8004216590:	00 00 00 
  8004216593:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216598:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  800421659f:	00 00 00 
  80042165a2:	41 ff d0             	callq  *%r8
	// round down to sector boundary
	pa &= ~(SECTSIZE - 1);
  80042165a5:	48 81 65 e8 00 fe ff 	andq   $0xfffffffffffffe00,-0x18(%rbp)
  80042165ac:	ff 

	// translate from bytes to sectors, and kernel starts at sector 1
	offset = (offset / SECTSIZE) + 1;
  80042165ad:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042165b1:	48 c1 e8 09          	shr    $0x9,%rax
  80042165b5:	48 83 c0 01          	add    $0x1,%rax
  80042165b9:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

	// If this is too slow, we could read lots of sectors at a time.
	// We'd write more to memory than asked, but it doesn't matter --
	// we load in increasing order.
	while (pa < end_pa) {
  80042165bd:	eb 3c                	jmp    80042165fb <readseg+0xc8>
		readsect((uint8_t*) pa, offset);
  80042165bf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042165c3:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042165c7:	48 89 d6             	mov    %rdx,%rsi
  80042165ca:	48 89 c7             	mov    %rax,%rdi
  80042165cd:	48 b8 c3 66 21 04 80 	movabs $0x80042166c3,%rax
  80042165d4:	00 00 00 
  80042165d7:	ff d0                	callq  *%rax
		pa += SECTSIZE;
  80042165d9:	48 81 45 e8 00 02 00 	addq   $0x200,-0x18(%rbp)
  80042165e0:	00 
		*kvoffset += SECTSIZE;
  80042165e1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042165e5:	48 8b 00             	mov    (%rax),%rax
  80042165e8:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
  80042165ef:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042165f3:	48 89 10             	mov    %rdx,(%rax)
		offset++;
  80042165f6:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
	offset = (offset / SECTSIZE) + 1;

	// If this is too slow, we could read lots of sectors at a time.
	// We'd write more to memory than asked, but it doesn't matter --
	// we load in increasing order.
	while (pa < end_pa) {
  80042165fb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042165ff:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004216603:	72 ba                	jb     80042165bf <readseg+0x8c>
		pa += SECTSIZE;
		*kvoffset += SECTSIZE;
		offset++;
	}

	if(((orgoff % SECTSIZE) + count) > SECTSIZE)
  8004216605:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216609:	25 ff 01 00 00       	and    $0x1ff,%eax
  800421660e:	48 89 c2             	mov    %rax,%rdx
  8004216611:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216615:	48 01 d0             	add    %rdx,%rax
  8004216618:	48 3d 00 02 00 00    	cmp    $0x200,%rax
  800421661e:	76 2f                	jbe    800421664f <readseg+0x11c>
	{
		readsect((uint8_t*) pa, offset);
  8004216620:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216624:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004216628:	48 89 d6             	mov    %rdx,%rsi
  800421662b:	48 89 c7             	mov    %rax,%rdi
  800421662e:	48 b8 c3 66 21 04 80 	movabs $0x80042166c3,%rax
  8004216635:	00 00 00 
  8004216638:	ff d0                	callq  *%rax
		*kvoffset += SECTSIZE;
  800421663a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421663e:	48 8b 00             	mov    (%rax),%rax
  8004216641:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
  8004216648:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421664c:	48 89 10             	mov    %rdx,(%rax)
	}
	assert(*kvoffset % SECTSIZE == 0);
  800421664f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216653:	48 8b 00             	mov    (%rax),%rax
  8004216656:	25 ff 01 00 00       	and    $0x1ff,%eax
  800421665b:	48 85 c0             	test   %rax,%rax
  800421665e:	74 35                	je     8004216695 <readseg+0x162>
  8004216660:	48 b9 55 b6 21 04 80 	movabs $0x800421b655,%rcx
  8004216667:	00 00 00 
  800421666a:	48 ba 1f b6 21 04 80 	movabs $0x800421b61f,%rdx
  8004216671:	00 00 00 
  8004216674:	be d8 00 00 00       	mov    $0xd8,%esi
  8004216679:	48 bf 34 b6 21 04 80 	movabs $0x800421b634,%rdi
  8004216680:	00 00 00 
  8004216683:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216688:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  800421668f:	00 00 00 
  8004216692:	41 ff d0             	callq  *%r8
}
  8004216695:	c9                   	leaveq 
  8004216696:	c3                   	retq   

0000008004216697 <waitdisk>:

void
waitdisk(void)
{
  8004216697:	55                   	push   %rbp
  8004216698:	48 89 e5             	mov    %rsp,%rbp
  800421669b:	48 83 ec 10          	sub    $0x10,%rsp
	// wait for disk reaady
	while ((inb(0x1F7) & 0xC0) != 0x40)
  800421669f:	90                   	nop
  80042166a0:	c7 45 fc f7 01 00 00 	movl   $0x1f7,-0x4(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042166a7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042166aa:	89 c2                	mov    %eax,%edx
  80042166ac:	ec                   	in     (%dx),%al
  80042166ad:	88 45 fb             	mov    %al,-0x5(%rbp)
	return data;
  80042166b0:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  80042166b4:	0f b6 c0             	movzbl %al,%eax
  80042166b7:	25 c0 00 00 00       	and    $0xc0,%eax
  80042166bc:	83 f8 40             	cmp    $0x40,%eax
  80042166bf:	75 df                	jne    80042166a0 <waitdisk+0x9>
		/* do nothing */;
}
  80042166c1:	c9                   	leaveq 
  80042166c2:	c3                   	retq   

00000080042166c3 <readsect>:

void
readsect(void *dst, uint64_t offset)
{
  80042166c3:	55                   	push   %rbp
  80042166c4:	48 89 e5             	mov    %rsp,%rbp
  80042166c7:	48 83 ec 60          	sub    $0x60,%rsp
  80042166cb:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  80042166cf:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
	// wait for disk to be ready
	waitdisk();
  80042166d3:	48 b8 97 66 21 04 80 	movabs $0x8004216697,%rax
  80042166da:	00 00 00 
  80042166dd:	ff d0                	callq  *%rax
  80042166df:	c7 45 fc f2 01 00 00 	movl   $0x1f2,-0x4(%rbp)
  80042166e6:	c6 45 fb 01          	movb   $0x1,-0x5(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042166ea:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  80042166ee:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042166f1:	ee                   	out    %al,(%dx)

	outb(0x1F2, 1);		// count = 1
	outb(0x1F3, offset);
  80042166f2:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042166f6:	0f b6 c0             	movzbl %al,%eax
  80042166f9:	c7 45 f4 f3 01 00 00 	movl   $0x1f3,-0xc(%rbp)
  8004216700:	88 45 f3             	mov    %al,-0xd(%rbp)
  8004216703:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004216707:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800421670a:	ee                   	out    %al,(%dx)
	outb(0x1F4, offset >> 8);
  800421670b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421670f:	48 c1 e8 08          	shr    $0x8,%rax
  8004216713:	0f b6 c0             	movzbl %al,%eax
  8004216716:	c7 45 ec f4 01 00 00 	movl   $0x1f4,-0x14(%rbp)
  800421671d:	88 45 eb             	mov    %al,-0x15(%rbp)
  8004216720:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004216724:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004216727:	ee                   	out    %al,(%dx)
	outb(0x1F5, offset >> 16);
  8004216728:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421672c:	48 c1 e8 10          	shr    $0x10,%rax
  8004216730:	0f b6 c0             	movzbl %al,%eax
  8004216733:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%rbp)
  800421673a:	88 45 e3             	mov    %al,-0x1d(%rbp)
  800421673d:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004216741:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004216744:	ee                   	out    %al,(%dx)
	outb(0x1F6, (offset >> 24) | 0xE0);
  8004216745:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004216749:	48 c1 e8 18          	shr    $0x18,%rax
  800421674d:	83 c8 e0             	or     $0xffffffe0,%eax
  8004216750:	0f b6 c0             	movzbl %al,%eax
  8004216753:	c7 45 dc f6 01 00 00 	movl   $0x1f6,-0x24(%rbp)
  800421675a:	88 45 db             	mov    %al,-0x25(%rbp)
  800421675d:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004216761:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004216764:	ee                   	out    %al,(%dx)
  8004216765:	c7 45 d4 f7 01 00 00 	movl   $0x1f7,-0x2c(%rbp)
  800421676c:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
  8004216770:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004216774:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004216777:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x20);	// cmd 0x20 - read sectors

	// wait for disk to be ready
	waitdisk();
  8004216778:	48 b8 97 66 21 04 80 	movabs $0x8004216697,%rax
  800421677f:	00 00 00 
  8004216782:	ff d0                	callq  *%rax
  8004216784:	c7 45 cc f0 01 00 00 	movl   $0x1f0,-0x34(%rbp)
  800421678b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421678f:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004216793:	c7 45 bc 80 00 00 00 	movl   $0x80,-0x44(%rbp)
}

static __inline void
insl(int port, void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\tinsl"			:
  800421679a:	8b 55 cc             	mov    -0x34(%rbp),%edx
  800421679d:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  80042167a1:	8b 45 bc             	mov    -0x44(%rbp),%eax
  80042167a4:	48 89 ce             	mov    %rcx,%rsi
  80042167a7:	48 89 f7             	mov    %rsi,%rdi
  80042167aa:	89 c1                	mov    %eax,%ecx
  80042167ac:	fc                   	cld    
  80042167ad:	f2 6d                	repnz insl (%dx),%es:(%rdi)
  80042167af:	89 c8                	mov    %ecx,%eax
  80042167b1:	48 89 fe             	mov    %rdi,%rsi
  80042167b4:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  80042167b8:	89 45 bc             	mov    %eax,-0x44(%rbp)

	// read a sector
	insl(0x1F0, dst, SECTSIZE/4);
}
  80042167bb:	c9                   	leaveq 
  80042167bc:	c3                   	retq   
  80042167bd:	0f 1f 00             	nopl   (%rax)

00000080042167c0 <mpentry_start>:
.set pml4, pml4phys

.code16           
.globl mpentry_start
mpentry_start:
	cli
  80042167c0:	fa                   	cli    
	xorw    %ax, %ax
  80042167c1:	31 c0                	xor    %eax,%eax
	movw    %ax, %ds
  80042167c3:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  80042167c5:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  80042167c7:	8e d0                	mov    %eax,%ss
	
	
	lgdt    MPBOOTPHYS(gdt32desc)   // load 32 bit global descritor table
  80042167c9:	0f 01 16             	lgdt   (%rsi)
  80042167cc:	e0 70                	loopne 800421683e <start64+0x10>
	movl    %cr0, %eax
  80042167ce:	0f 20 c0             	mov    %cr0,%rax
	orl     $CR0_PE, %eax
  80042167d1:	66 83 c8 01          	or     $0x1,%ax
	movl    %eax, %cr0
  80042167d5:	0f 22 c0             	mov    %rax,%cr0
	ljmp	$(PROT_MODE_CSEG),$(MPBOOTPHYS(start32))
  80042167d8:	ea                   	(bad)  
  80042167d9:	1d 70 08 00 66       	sbb    $0x66000870,%eax

00000080042167dd <start32>:

.code32
start32:
	
	movw    $(PROT_MODE_DSEG), %ax
  80042167dd:	66 b8 10 00          	mov    $0x10,%ax
	movw    %ax, %ds
  80042167e1:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  80042167e3:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  80042167e5:	8e d0                	mov    %eax,%ss
	movw    $0, %ax
  80042167e7:	66 b8 00 00          	mov    $0x0,%ax
	movw    %ax, %fs
  80042167eb:	8e e0                	mov    %eax,%fs
	movw    %ax, %gs
  80042167ed:	8e e8                	mov    %eax,%gs

#ifndef VMM_GUEST
	movl $CR4_PAE,%eax
#else
	movl $(CR4_PAE|CR4_VMXE),%eax
  80042167ef:	b8 20 20 00 00       	mov    $0x2020,%eax
#endif

	movl %eax,%cr4
  80042167f4:	0f 22 e0             	mov    %rax,%cr4
	
	lgdt    MPBOOTPHYS(gdtdesc)
  80042167f7:	0f 01 15 c0 70 00 00 	lgdt   0x70c0(%rip)        # 800421d8be <bootstack+0x18be>
	movl    %cr0, %eax
  80042167fe:	0f 20 c0             	mov    %cr0,%rax
	orl     $CR0_PE, %eax
  8004216801:	83 c8 01             	or     $0x1,%eax
	movl    %eax, %cr0
  8004216804:	0f 22 c0             	mov    %rax,%cr0
	
	# Set up initial page table. We cannot use kern_pgdir yet because
	# we are still running at a low EIP.
	movl    $pml4, %eax
  8004216807:	b8 00 20 10 00       	mov    $0x102000,%eax
	movl    %eax, %cr3
  800421680c:	0f 22 d8             	mov    %rax,%cr3
	
	# enable the long mode in MSR
	movl $EFER_MSR,%ecx
  800421680f:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
	rdmsr
  8004216814:	0f 32                	rdmsr  
	btsl $EFER_LME,%eax
  8004216816:	0f ba e8 08          	bts    $0x8,%eax
	wrmsr
  800421681a:	0f 30                	wrmsr  
	
	# Turn on paging.
	movl    %cr0, %eax
  800421681c:	0f 20 c0             	mov    %cr0,%rax
	orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
  800421681f:	0d 01 00 01 80       	or     $0x80010001,%eax
	movl    %eax, %cr0
  8004216824:	0f 22 c0             	mov    %rax,%cr0
	

	ljmpl   $(LONG_MODE_CSEG), $(MPBOOTPHYS(start64))
  8004216827:	ea                   	(bad)  
  8004216828:	6e                   	outsb  %ds:(%rsi),(%dx)
  8004216829:	70 00                	jo     800421682b <start32+0x4e>
  800421682b:	00 08                	add    %cl,(%rax)
	...

000000800421682e <start64>:

.code64
start64:
	movw    $(LONG_MODE_DSEG), %ax
  800421682e:	66 b8 10 00          	mov    $0x10,%ax
	movw    %ax, %ds
  8004216832:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  8004216834:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  8004216836:	8e d0                	mov    %eax,%ss
	movw    $0, %ax
  8004216838:	66 b8 00 00          	mov    $0x0,%ax
	movw    %ax, %fs
  800421683c:	8e e0                	mov    %eax,%fs
	movw    %ax, %gs
  800421683e:	8e e8                	mov    %eax,%gs

	# Switch to the per-cpu stack allocated in boot_aps()
	movabs    mpentry_kstack, %rax
  8004216840:	48 a1 d8 c5 69 04 80 	movabs 0x800469c5d8,%rax
  8004216847:	00 00 00 
	movq    %rax,%rsp
  800421684a:	48 89 c4             	mov    %rax,%rsp
	movq    $0x0, %rbp       # nuke frame pointer
  800421684d:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp

	# Call mp_main().  (Exercise for the reader: why the indirect call?)
	movabs    $mp_main, %rax
  8004216854:	48 b8 1e 05 20 04 80 	movabs $0x800420051e,%rax
  800421685b:	00 00 00 
	call    *%rax
  800421685e:	ff d0                	callq  *%rax

0000008004216860 <spin>:

	# If mp_main returns (it shouldn't), loop.
spin:
	jmp     spin
  8004216860:	eb fe                	jmp    8004216860 <spin>
  8004216862:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000008004216868 <gdt>:
	...
  8004216870:	ff                   	(bad)  
  8004216871:	ff 00                	incl   (%rax)
  8004216873:	00 00                	add    %al,(%rax)
  8004216875:	9a                   	(bad)  
  8004216876:	af                   	scas   %es:(%rdi),%eax
  8004216877:	00 ff                	add    %bh,%bh
  8004216879:	ff 00                	incl   (%rax)
  800421687b:	00 00                	add    %al,(%rax)
  800421687d:	92                   	xchg   %eax,%edx
  800421687e:	af                   	scas   %es:(%rdi),%eax
	...

0000008004216880 <gdtdesc>:
  8004216880:	17                   	(bad)  
  8004216881:	00 a8 70 00 00 66    	add    %ch,0x66000070(%rax)
  8004216887:	90                   	nop

0000008004216888 <gdt32>:
	...
  8004216890:	ff                   	(bad)  
  8004216891:	ff 00                	incl   (%rax)
  8004216893:	00 00                	add    %al,(%rax)
  8004216895:	9a                   	(bad)  
  8004216896:	cf                   	iret   
  8004216897:	00 ff                	add    %bh,%bh
  8004216899:	ff 00                	incl   (%rax)
  800421689b:	00 00                	add    %al,(%rax)
  800421689d:	92                   	xchg   %eax,%edx
  800421689e:	cf                   	iret   
	...

00000080042168a0 <gdt32desc>:
  80042168a0:	17                   	(bad)  
  80042168a1:	00 c8                	add    %cl,%al
  80042168a3:	70 00                	jo     80042168a5 <gdt32desc+0x5>
	...

00000080042168a6 <mpentry_end>:
	.long   MPBOOTPHYS(gdt32)			# address gdt


.globl mpentry_end
mpentry_end:
	nop
  80042168a6:	90                   	nop

00000080042168a7 <sum>:
#define MPIOINTR  0x03  // One per bus interrupt source
#define MPLINTR   0x04  // One per system interrupt source

static uint8_t
sum(void *addr, int len)
{
  80042168a7:	55                   	push   %rbp
  80042168a8:	48 89 e5             	mov    %rsp,%rbp
  80042168ab:	48 83 ec 1c          	sub    $0x1c,%rsp
  80042168af:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042168b3:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	int i, sum;

	sum = 0;
  80042168b6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	for (i = 0; i < len; i++)
  80042168bd:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042168c4:	eb 1a                	jmp    80042168e0 <sum+0x39>
		sum += ((uint8_t *)addr)[i];
  80042168c6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042168c9:	48 63 d0             	movslq %eax,%rdx
  80042168cc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042168d0:	48 01 d0             	add    %rdx,%rax
  80042168d3:	0f b6 00             	movzbl (%rax),%eax
  80042168d6:	0f b6 c0             	movzbl %al,%eax
  80042168d9:	01 45 f8             	add    %eax,-0x8(%rbp)
sum(void *addr, int len)
{
	int i, sum;

	sum = 0;
	for (i = 0; i < len; i++)
  80042168dc:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042168e0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042168e3:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  80042168e6:	7c de                	jl     80042168c6 <sum+0x1f>
		sum += ((uint8_t *)addr)[i];
	return sum;
  80042168e8:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
  80042168eb:	c9                   	leaveq 
  80042168ec:	c3                   	retq   

00000080042168ed <mpsearch1>:

// Look for an MP structure in the len bytes at physical address addr.
static struct mp *
mpsearch1(physaddr_t a, int len)
{
  80042168ed:	55                   	push   %rbp
  80042168ee:	48 89 e5             	mov    %rsp,%rbp
  80042168f1:	48 83 ec 40          	sub    $0x40,%rsp
  80042168f5:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80042168f9:	89 75 c4             	mov    %esi,-0x3c(%rbp)
	struct mp *mp = KADDR(a), *end = KADDR(a + len);
  80042168fc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004216900:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004216904:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216908:	48 c1 e8 0c          	shr    $0xc,%rax
  800421690c:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800421690f:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004216912:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  8004216919:	00 00 00 
  800421691c:	48 8b 00             	mov    (%rax),%rax
  800421691f:	48 39 c2             	cmp    %rax,%rdx
  8004216922:	72 32                	jb     8004216956 <mpsearch1+0x69>
  8004216924:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216928:	48 89 c1             	mov    %rax,%rcx
  800421692b:	48 ba 70 b6 21 04 80 	movabs $0x800421b670,%rdx
  8004216932:	00 00 00 
  8004216935:	be 5a 00 00 00       	mov    $0x5a,%esi
  800421693a:	48 bf 93 b6 21 04 80 	movabs $0x800421b693,%rdi
  8004216941:	00 00 00 
  8004216944:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216949:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004216950:	00 00 00 
  8004216953:	41 ff d0             	callq  *%r8
  8004216956:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800421695d:	00 00 00 
  8004216960:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216964:	48 01 d0             	add    %rdx,%rax
  8004216967:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421696b:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800421696e:	48 63 d0             	movslq %eax,%rdx
  8004216971:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004216975:	48 01 d0             	add    %rdx,%rax
  8004216978:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800421697c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216980:	48 c1 e8 0c          	shr    $0xc,%rax
  8004216984:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004216987:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800421698a:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  8004216991:	00 00 00 
  8004216994:	48 8b 00             	mov    (%rax),%rax
  8004216997:	48 39 c2             	cmp    %rax,%rdx
  800421699a:	72 32                	jb     80042169ce <mpsearch1+0xe1>
  800421699c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042169a0:	48 89 c1             	mov    %rax,%rcx
  80042169a3:	48 ba 70 b6 21 04 80 	movabs $0x800421b670,%rdx
  80042169aa:	00 00 00 
  80042169ad:	be 5a 00 00 00       	mov    $0x5a,%esi
  80042169b2:	48 bf 93 b6 21 04 80 	movabs $0x800421b693,%rdi
  80042169b9:	00 00 00 
  80042169bc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042169c1:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042169c8:	00 00 00 
  80042169cb:	41 ff d0             	callq  *%r8
  80042169ce:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042169d5:	00 00 00 
  80042169d8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042169dc:	48 01 d0             	add    %rdx,%rax
  80042169df:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

	for (; mp < end; mp++)
  80042169e3:	eb 4d                	jmp    8004216a32 <mpsearch1+0x145>
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
  80042169e5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042169e9:	ba 04 00 00 00       	mov    $0x4,%edx
  80042169ee:	48 be a3 b6 21 04 80 	movabs $0x800421b6a3,%rsi
  80042169f5:	00 00 00 
  80042169f8:	48 89 c7             	mov    %rax,%rdi
  80042169fb:	48 b8 aa 05 21 04 80 	movabs $0x80042105aa,%rax
  8004216a02:	00 00 00 
  8004216a05:	ff d0                	callq  *%rax
  8004216a07:	85 c0                	test   %eax,%eax
  8004216a09:	75 22                	jne    8004216a2d <mpsearch1+0x140>
		    sum(mp, sizeof(*mp)) == 0)
  8004216a0b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216a0f:	be 10 00 00 00       	mov    $0x10,%esi
  8004216a14:	48 89 c7             	mov    %rax,%rdi
  8004216a17:	48 b8 a7 68 21 04 80 	movabs $0x80042168a7,%rax
  8004216a1e:	00 00 00 
  8004216a21:	ff d0                	callq  *%rax
mpsearch1(physaddr_t a, int len)
{
	struct mp *mp = KADDR(a), *end = KADDR(a + len);

	for (; mp < end; mp++)
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
  8004216a23:	84 c0                	test   %al,%al
  8004216a25:	75 06                	jne    8004216a2d <mpsearch1+0x140>
		    sum(mp, sizeof(*mp)) == 0)
			return mp;
  8004216a27:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216a2b:	eb 14                	jmp    8004216a41 <mpsearch1+0x154>
static struct mp *
mpsearch1(physaddr_t a, int len)
{
	struct mp *mp = KADDR(a), *end = KADDR(a + len);

	for (; mp < end; mp++)
  8004216a2d:	48 83 45 f8 10       	addq   $0x10,-0x8(%rbp)
  8004216a32:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216a36:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004216a3a:	72 a9                	jb     80042169e5 <mpsearch1+0xf8>
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
		    sum(mp, sizeof(*mp)) == 0)
			return mp;
	return NULL;
  8004216a3c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004216a41:	c9                   	leaveq 
  8004216a42:	c3                   	retq   

0000008004216a43 <mpsearch>:
// 1) in the first KB of the EBDA;
// 2) if there is no EBDA, in the last KB of system base memory;
// 3) in the BIOS ROM between 0xE0000 and 0xFFFFF.
static struct mp *
mpsearch(void)
{
  8004216a43:	55                   	push   %rbp
  8004216a44:	48 89 e5             	mov    %rsp,%rbp
  8004216a47:	48 83 ec 30          	sub    $0x30,%rsp
	struct mp *mp;

	//static_assert(sizeof(*mp) == 32);

	// The BIOS data area lives in 16-bit segment 0x40.
	bda = (uint8_t *) KADDR(0x40 << 4);
  8004216a4b:	48 c7 45 f8 00 04 00 	movq   $0x400,-0x8(%rbp)
  8004216a52:	00 
  8004216a53:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216a57:	48 c1 e8 0c          	shr    $0xc,%rax
  8004216a5b:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004216a5e:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004216a61:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  8004216a68:	00 00 00 
  8004216a6b:	48 8b 00             	mov    (%rax),%rax
  8004216a6e:	48 39 c2             	cmp    %rax,%rdx
  8004216a71:	72 32                	jb     8004216aa5 <mpsearch+0x62>
  8004216a73:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216a77:	48 89 c1             	mov    %rax,%rcx
  8004216a7a:	48 ba 70 b6 21 04 80 	movabs $0x800421b670,%rdx
  8004216a81:	00 00 00 
  8004216a84:	be 72 00 00 00       	mov    $0x72,%esi
  8004216a89:	48 bf 93 b6 21 04 80 	movabs $0x800421b693,%rdi
  8004216a90:	00 00 00 
  8004216a93:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216a98:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004216a9f:	00 00 00 
  8004216aa2:	41 ff d0             	callq  *%r8
  8004216aa5:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004216aac:	00 00 00 
  8004216aaf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216ab3:	48 01 d0             	add    %rdx,%rax
  8004216ab6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	// [MP 4] The 16-bit segment of the EBDA is in the two bytes
	// starting at byte 0x0E of the BDA.  0 if not present.
	if ((p = *(uint16_t *) (bda + 0x0E))) {
  8004216aba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216abe:	48 83 c0 0e          	add    $0xe,%rax
  8004216ac2:	0f b7 00             	movzwl (%rax),%eax
  8004216ac5:	0f b7 c0             	movzwl %ax,%eax
  8004216ac8:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004216acb:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004216acf:	74 2c                	je     8004216afd <mpsearch+0xba>
		p <<= 4;	// Translate from segment to PA
  8004216ad1:	c1 65 e4 04          	shll   $0x4,-0x1c(%rbp)
		if ((mp = mpsearch1(p, 1024)))
  8004216ad5:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004216ad8:	be 00 04 00 00       	mov    $0x400,%esi
  8004216add:	48 89 c7             	mov    %rax,%rdi
  8004216ae0:	48 b8 ed 68 21 04 80 	movabs $0x80042168ed,%rax
  8004216ae7:	00 00 00 
  8004216aea:	ff d0                	callq  *%rax
  8004216aec:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004216af0:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004216af5:	74 49                	je     8004216b40 <mpsearch+0xfd>
			return mp;
  8004216af7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216afb:	eb 59                	jmp    8004216b56 <mpsearch+0x113>
	} else {
		// The size of base memory, in KB is in the two bytes
		// starting at 0x13 of the BDA.
		p = *(uint16_t *) (bda + 0x13) * 1024;
  8004216afd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216b01:	48 83 c0 13          	add    $0x13,%rax
  8004216b05:	0f b7 00             	movzwl (%rax),%eax
  8004216b08:	0f b7 c0             	movzwl %ax,%eax
  8004216b0b:	c1 e0 0a             	shl    $0xa,%eax
  8004216b0e:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		if ((mp = mpsearch1(p - 1024, 1024)))
  8004216b11:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004216b14:	2d 00 04 00 00       	sub    $0x400,%eax
  8004216b19:	89 c0                	mov    %eax,%eax
  8004216b1b:	be 00 04 00 00       	mov    $0x400,%esi
  8004216b20:	48 89 c7             	mov    %rax,%rdi
  8004216b23:	48 b8 ed 68 21 04 80 	movabs $0x80042168ed,%rax
  8004216b2a:	00 00 00 
  8004216b2d:	ff d0                	callq  *%rax
  8004216b2f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004216b33:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004216b38:	74 06                	je     8004216b40 <mpsearch+0xfd>
			return mp;
  8004216b3a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216b3e:	eb 16                	jmp    8004216b56 <mpsearch+0x113>
	}
	return mpsearch1(0xF0000, 0x10000);
  8004216b40:	be 00 00 01 00       	mov    $0x10000,%esi
  8004216b45:	bf 00 00 0f 00       	mov    $0xf0000,%edi
  8004216b4a:	48 b8 ed 68 21 04 80 	movabs $0x80042168ed,%rax
  8004216b51:	00 00 00 
  8004216b54:	ff d0                	callq  *%rax
}
  8004216b56:	c9                   	leaveq 
  8004216b57:	c3                   	retq   

0000008004216b58 <mpconfig>:
// Search for an MP configuration table.  For now, don't accept the
// default configurations (physaddr == 0).
// Check for the correct signature, checksum, and version.
static struct mpconf *
mpconfig(struct mp **pmp)
{
  8004216b58:	55                   	push   %rbp
  8004216b59:	48 89 e5             	mov    %rsp,%rbp
  8004216b5c:	48 83 ec 30          	sub    $0x30,%rsp
  8004216b60:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	struct mpconf *conf;
	struct mp *mp;

	if ((mp = mpsearch()) == 0)
  8004216b64:	48 b8 43 6a 21 04 80 	movabs $0x8004216a43,%rax
  8004216b6b:	00 00 00 
  8004216b6e:	ff d0                	callq  *%rax
  8004216b70:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004216b74:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004216b79:	75 0a                	jne    8004216b85 <mpconfig+0x2d>
		return NULL;
  8004216b7b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216b80:	e9 f6 01 00 00       	jmpq   8004216d7b <mpconfig+0x223>
	if (mp->physaddr == 0 || mp->type != 0) {
  8004216b85:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216b89:	8b 40 04             	mov    0x4(%rax),%eax
  8004216b8c:	85 c0                	test   %eax,%eax
  8004216b8e:	74 0c                	je     8004216b9c <mpconfig+0x44>
  8004216b90:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216b94:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  8004216b98:	84 c0                	test   %al,%al
  8004216b9a:	74 25                	je     8004216bc1 <mpconfig+0x69>
		cprintf("SMP: Default configurations not implemented\n");
  8004216b9c:	48 bf a8 b6 21 04 80 	movabs $0x800421b6a8,%rdi
  8004216ba3:	00 00 00 
  8004216ba6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216bab:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  8004216bb2:	00 00 00 
  8004216bb5:	ff d2                	callq  *%rdx
		return NULL;
  8004216bb7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216bbc:	e9 ba 01 00 00       	jmpq   8004216d7b <mpconfig+0x223>
	}
	conf = (struct mpconf *) KADDR(mp->physaddr);
  8004216bc1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216bc5:	8b 40 04             	mov    0x4(%rax),%eax
  8004216bc8:	89 c0                	mov    %eax,%eax
  8004216bca:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004216bce:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216bd2:	48 c1 e8 0c          	shr    $0xc,%rax
  8004216bd6:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004216bd9:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004216bdc:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  8004216be3:	00 00 00 
  8004216be6:	48 8b 00             	mov    (%rax),%rax
  8004216be9:	48 39 c2             	cmp    %rax,%rdx
  8004216bec:	72 32                	jb     8004216c20 <mpconfig+0xc8>
  8004216bee:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216bf2:	48 89 c1             	mov    %rax,%rcx
  8004216bf5:	48 ba 70 b6 21 04 80 	movabs $0x800421b670,%rdx
  8004216bfc:	00 00 00 
  8004216bff:	be 93 00 00 00       	mov    $0x93,%esi
  8004216c04:	48 bf 93 b6 21 04 80 	movabs $0x800421b693,%rdi
  8004216c0b:	00 00 00 
  8004216c0e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216c13:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004216c1a:	00 00 00 
  8004216c1d:	41 ff d0             	callq  *%r8
  8004216c20:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004216c27:	00 00 00 
  8004216c2a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216c2e:	48 01 d0             	add    %rdx,%rax
  8004216c31:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if (memcmp(conf, "PCMP", 4) != 0) {
  8004216c35:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216c39:	ba 04 00 00 00       	mov    $0x4,%edx
  8004216c3e:	48 be d5 b6 21 04 80 	movabs $0x800421b6d5,%rsi
  8004216c45:	00 00 00 
  8004216c48:	48 89 c7             	mov    %rax,%rdi
  8004216c4b:	48 b8 aa 05 21 04 80 	movabs $0x80042105aa,%rax
  8004216c52:	00 00 00 
  8004216c55:	ff d0                	callq  *%rax
  8004216c57:	85 c0                	test   %eax,%eax
  8004216c59:	74 25                	je     8004216c80 <mpconfig+0x128>
		cprintf("SMP: Incorrect MP configuration table signature\n");
  8004216c5b:	48 bf e0 b6 21 04 80 	movabs $0x800421b6e0,%rdi
  8004216c62:	00 00 00 
  8004216c65:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216c6a:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  8004216c71:	00 00 00 
  8004216c74:	ff d2                	callq  *%rdx
		return NULL;
  8004216c76:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216c7b:	e9 fb 00 00 00       	jmpq   8004216d7b <mpconfig+0x223>
	}
	if (sum(conf, conf->length) != 0) {
  8004216c80:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216c84:	0f b7 40 04          	movzwl 0x4(%rax),%eax
  8004216c88:	0f b7 d0             	movzwl %ax,%edx
  8004216c8b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216c8f:	89 d6                	mov    %edx,%esi
  8004216c91:	48 89 c7             	mov    %rax,%rdi
  8004216c94:	48 b8 a7 68 21 04 80 	movabs $0x80042168a7,%rax
  8004216c9b:	00 00 00 
  8004216c9e:	ff d0                	callq  *%rax
  8004216ca0:	84 c0                	test   %al,%al
  8004216ca2:	74 25                	je     8004216cc9 <mpconfig+0x171>
		cprintf("SMP: Bad MP configuration checksum\n");
  8004216ca4:	48 bf 18 b7 21 04 80 	movabs $0x800421b718,%rdi
  8004216cab:	00 00 00 
  8004216cae:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216cb3:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  8004216cba:	00 00 00 
  8004216cbd:	ff d2                	callq  *%rdx
		return NULL;
  8004216cbf:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216cc4:	e9 b2 00 00 00       	jmpq   8004216d7b <mpconfig+0x223>
	}
	if (conf->version != 1 && conf->version != 4) {
  8004216cc9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216ccd:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  8004216cd1:	3c 01                	cmp    $0x1,%al
  8004216cd3:	74 3b                	je     8004216d10 <mpconfig+0x1b8>
  8004216cd5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216cd9:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  8004216cdd:	3c 04                	cmp    $0x4,%al
  8004216cdf:	74 2f                	je     8004216d10 <mpconfig+0x1b8>
		cprintf("SMP: Unsupported MP version %d\n", conf->version);
  8004216ce1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216ce5:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  8004216ce9:	0f b6 c0             	movzbl %al,%eax
  8004216cec:	89 c6                	mov    %eax,%esi
  8004216cee:	48 bf 40 b7 21 04 80 	movabs $0x800421b740,%rdi
  8004216cf5:	00 00 00 
  8004216cf8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216cfd:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  8004216d04:	00 00 00 
  8004216d07:	ff d2                	callq  *%rdx
		return NULL;
  8004216d09:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216d0e:	eb 6b                	jmp    8004216d7b <mpconfig+0x223>
	}
	if (sum((uint8_t *)conf + conf->length, conf->xlength) != conf->xchecksum) {
  8004216d10:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216d14:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  8004216d18:	0f b7 c0             	movzwl %ax,%eax
  8004216d1b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004216d1f:	0f b7 52 04          	movzwl 0x4(%rdx),%edx
  8004216d23:	0f b7 ca             	movzwl %dx,%ecx
  8004216d26:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004216d2a:	48 01 ca             	add    %rcx,%rdx
  8004216d2d:	89 c6                	mov    %eax,%esi
  8004216d2f:	48 89 d7             	mov    %rdx,%rdi
  8004216d32:	48 b8 a7 68 21 04 80 	movabs $0x80042168a7,%rax
  8004216d39:	00 00 00 
  8004216d3c:	ff d0                	callq  *%rax
  8004216d3e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004216d42:	0f b6 52 2a          	movzbl 0x2a(%rdx),%edx
  8004216d46:	38 d0                	cmp    %dl,%al
  8004216d48:	74 22                	je     8004216d6c <mpconfig+0x214>
		cprintf("SMP: Bad MP configuration extended checksum\n");
  8004216d4a:	48 bf 60 b7 21 04 80 	movabs $0x800421b760,%rdi
  8004216d51:	00 00 00 
  8004216d54:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216d59:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  8004216d60:	00 00 00 
  8004216d63:	ff d2                	callq  *%rdx
		return NULL;
  8004216d65:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216d6a:	eb 0f                	jmp    8004216d7b <mpconfig+0x223>
	}
	*pmp = mp;
  8004216d6c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216d70:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004216d74:	48 89 10             	mov    %rdx,(%rax)
	return conf;
  8004216d77:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
}
  8004216d7b:	c9                   	leaveq 
  8004216d7c:	c3                   	retq   

0000008004216d7d <mp_init>:

void
mp_init(void)
{
  8004216d7d:	55                   	push   %rbp
  8004216d7e:	48 89 e5             	mov    %rsp,%rbp
  8004216d81:	53                   	push   %rbx
  8004216d82:	48 83 ec 58          	sub    $0x58,%rsp
	struct mpconf *conf;
	struct mpproc *proc;
	uint8_t *p;
	unsigned int i;

	bootcpu = &cpus[0];
  8004216d86:	48 b8 40 e2 69 04 80 	movabs $0x800469e240,%rax
  8004216d8d:	00 00 00 
  8004216d90:	48 bb 20 e0 69 04 80 	movabs $0x800469e020,%rbx
  8004216d97:	00 00 00 
  8004216d9a:	48 89 18             	mov    %rbx,(%rax)
	if ((conf = mpconfig(&mp)) == 0)
  8004216d9d:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
  8004216da1:	48 89 c7             	mov    %rax,%rdi
  8004216da4:	48 b8 58 6b 21 04 80 	movabs $0x8004216b58,%rax
  8004216dab:	00 00 00 
  8004216dae:	ff d0                	callq  *%rax
  8004216db0:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004216db4:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004216db9:	75 05                	jne    8004216dc0 <mp_init+0x43>
		return;
  8004216dbb:	e9 d2 03 00 00       	jmpq   8004217192 <mp_init+0x415>
	ismp = 1;
  8004216dc0:	48 b8 00 e0 69 04 80 	movabs $0x800469e000,%rax
  8004216dc7:	00 00 00 
  8004216dca:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
	lapicaddr = conf->lapicaddr;
  8004216dd0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216dd4:	8b 40 24             	mov    0x24(%rax),%eax
  8004216dd7:	89 c2                	mov    %eax,%edx
  8004216dd9:	48 b8 00 f0 6d 04 80 	movabs $0x80046df000,%rax
  8004216de0:	00 00 00 
  8004216de3:	48 89 10             	mov    %rdx,(%rax)

	for (p = conf->entries, i = 0; i < conf->entry; i++) {
  8004216de6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216dea:	48 83 c0 2c          	add    $0x2c,%rax
  8004216dee:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004216df2:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
  8004216df9:	e9 17 02 00 00       	jmpq   8004217015 <mp_init+0x298>
		switch (*p) {
  8004216dfe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216e02:	0f b6 00             	movzbl (%rax),%eax
  8004216e05:	0f b6 c0             	movzbl %al,%eax
  8004216e08:	85 c0                	test   %eax,%eax
  8004216e0a:	74 16                	je     8004216e22 <mp_init+0xa5>
  8004216e0c:	85 c0                	test   %eax,%eax
  8004216e0e:	0f 88 b8 01 00 00    	js     8004216fcc <mp_init+0x24f>
  8004216e14:	83 f8 04             	cmp    $0x4,%eax
  8004216e17:	0f 8f af 01 00 00    	jg     8004216fcc <mp_init+0x24f>
  8004216e1d:	e9 a3 01 00 00       	jmpq   8004216fc5 <mp_init+0x248>
		case MPPROC:
			proc = (struct mpproc *)p;
  8004216e22:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216e26:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			if (proc->flags & MPPROC_BOOT) {
  8004216e2a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216e2e:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  8004216e32:	0f b6 c0             	movzbl %al,%eax
  8004216e35:	83 e0 02             	and    $0x2,%eax
  8004216e38:	85 c0                	test   %eax,%eax
  8004216e3a:	74 51                	je     8004216e8d <mp_init+0x110>
				bootcpu = &cpus[ncpu];
  8004216e3c:	48 b8 48 e2 69 04 80 	movabs $0x800469e248,%rax
  8004216e43:	00 00 00 
  8004216e46:	8b 00                	mov    (%rax),%eax
  8004216e48:	48 98                	cltq   
  8004216e4a:	48 c1 e0 03          	shl    $0x3,%rax
  8004216e4e:	48 89 c2             	mov    %rax,%rdx
  8004216e51:	48 c1 e2 04          	shl    $0x4,%rdx
  8004216e55:	48 01 d0             	add    %rdx,%rax
  8004216e58:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  8004216e5f:	00 00 00 
  8004216e62:	48 01 c2             	add    %rax,%rdx
  8004216e65:	48 b8 40 e2 69 04 80 	movabs $0x800469e240,%rax
  8004216e6c:	00 00 00 
  8004216e6f:	48 89 10             	mov    %rdx,(%rax)
				cprintf("Found boot cpu..\n");
  8004216e72:	48 bf 8d b7 21 04 80 	movabs $0x800421b78d,%rdi
  8004216e79:	00 00 00 
  8004216e7c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216e81:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  8004216e88:	00 00 00 
  8004216e8b:	ff d2                	callq  *%rdx
			}
			if (ncpu < NCPU) {
  8004216e8d:	48 b8 48 e2 69 04 80 	movabs $0x800469e248,%rax
  8004216e94:	00 00 00 
  8004216e97:	8b 00                	mov    (%rax),%eax
  8004216e99:	83 f8 03             	cmp    $0x3,%eax
  8004216e9c:	0f 8f f4 00 00 00    	jg     8004216f96 <mp_init+0x219>
				cprintf("type: %d apicid:%d version:%d signature:%x feature:%x flags:%x reserved:%x\n", proc->type, proc->apicid, proc->version, proc->signature, proc->feature, proc->flags, proc->reserved);
  8004216ea2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216ea6:	4c 8d 40 0c          	lea    0xc(%rax),%r8
  8004216eaa:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216eae:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  8004216eb2:	0f b6 f0             	movzbl %al,%esi
  8004216eb5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216eb9:	8b 78 08             	mov    0x8(%rax),%edi
  8004216ebc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216ec0:	4c 8d 50 04          	lea    0x4(%rax),%r10
  8004216ec4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216ec8:	0f b6 40 02          	movzbl 0x2(%rax),%eax
  8004216ecc:	0f b6 c8             	movzbl %al,%ecx
  8004216ecf:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216ed3:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8004216ed7:	0f b6 d0             	movzbl %al,%edx
  8004216eda:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216ede:	0f b6 00             	movzbl (%rax),%eax
  8004216ee1:	0f b6 c0             	movzbl %al,%eax
  8004216ee4:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  8004216ee9:	89 34 24             	mov    %esi,(%rsp)
  8004216eec:	41 89 f9             	mov    %edi,%r9d
  8004216eef:	4d 89 d0             	mov    %r10,%r8
  8004216ef2:	89 c6                	mov    %eax,%esi
  8004216ef4:	48 bf a0 b7 21 04 80 	movabs $0x800421b7a0,%rdi
  8004216efb:	00 00 00 
  8004216efe:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216f03:	49 ba 90 95 20 04 80 	movabs $0x8004209590,%r10
  8004216f0a:	00 00 00 
  8004216f0d:	41 ff d2             	callq  *%r10
				if (proc->flags & MPROC_EN) {
  8004216f10:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216f14:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  8004216f18:	0f b6 c0             	movzbl %al,%eax
  8004216f1b:	83 e0 01             	and    $0x1,%eax
  8004216f1e:	85 c0                	test   %eax,%eax
  8004216f20:	74 57                	je     8004216f79 <mp_init+0x1fc>
					cpus[ncpu].cpu_id = ncpu;
  8004216f22:	48 b8 48 e2 69 04 80 	movabs $0x800469e248,%rax
  8004216f29:	00 00 00 
  8004216f2c:	8b 30                	mov    (%rax),%esi
  8004216f2e:	48 b8 48 e2 69 04 80 	movabs $0x800469e248,%rax
  8004216f35:	00 00 00 
  8004216f38:	8b 00                	mov    (%rax),%eax
  8004216f3a:	89 c2                	mov    %eax,%edx
  8004216f3c:	48 b9 20 e0 69 04 80 	movabs $0x800469e020,%rcx
  8004216f43:	00 00 00 
  8004216f46:	48 63 c6             	movslq %esi,%rax
  8004216f49:	48 c1 e0 03          	shl    $0x3,%rax
  8004216f4d:	48 89 c6             	mov    %rax,%rsi
  8004216f50:	48 c1 e6 04          	shl    $0x4,%rsi
  8004216f54:	48 01 f0             	add    %rsi,%rax
  8004216f57:	48 01 c8             	add    %rcx,%rax
  8004216f5a:	88 10                	mov    %dl,(%rax)
					ncpu++;
  8004216f5c:	48 b8 48 e2 69 04 80 	movabs $0x800469e248,%rax
  8004216f63:	00 00 00 
  8004216f66:	8b 00                	mov    (%rax),%eax
  8004216f68:	8d 50 01             	lea    0x1(%rax),%edx
  8004216f6b:	48 b8 48 e2 69 04 80 	movabs $0x800469e248,%rax
  8004216f72:	00 00 00 
  8004216f75:	89 10                	mov    %edx,(%rax)
  8004216f77:	eb 45                	jmp    8004216fbe <mp_init+0x241>
				} else {
					cprintf("Found unusable CPU. Not intiializing it..\n");
  8004216f79:	48 bf f0 b7 21 04 80 	movabs $0x800421b7f0,%rdi
  8004216f80:	00 00 00 
  8004216f83:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216f88:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  8004216f8f:	00 00 00 
  8004216f92:	ff d2                	callq  *%rdx
  8004216f94:	eb 28                	jmp    8004216fbe <mp_init+0x241>
				}
			} else {
				cprintf("SMP: too many CPUs, CPU %d disabled\n",
					proc->apicid);
  8004216f96:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216f9a:	0f b6 40 01          	movzbl 0x1(%rax),%eax
					ncpu++;
				} else {
					cprintf("Found unusable CPU. Not intiializing it..\n");
				}
			} else {
				cprintf("SMP: too many CPUs, CPU %d disabled\n",
  8004216f9e:	0f b6 c0             	movzbl %al,%eax
  8004216fa1:	89 c6                	mov    %eax,%esi
  8004216fa3:	48 bf 20 b8 21 04 80 	movabs $0x800421b820,%rdi
  8004216faa:	00 00 00 
  8004216fad:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216fb2:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  8004216fb9:	00 00 00 
  8004216fbc:	ff d2                	callq  *%rdx
					proc->apicid);
			}
			p += sizeof(struct mpproc);
  8004216fbe:	48 83 45 e8 14       	addq   $0x14,-0x18(%rbp)
			continue;
  8004216fc3:	eb 4c                	jmp    8004217011 <mp_init+0x294>
		case MPBUS:
		case MPIOAPIC:
		case MPIOINTR:
		case MPLINTR:

		p += 8;
  8004216fc5:	48 83 45 e8 08       	addq   $0x8,-0x18(%rbp)
		continue;
  8004216fca:	eb 45                	jmp    8004217011 <mp_init+0x294>
		default:
			cprintf("mpinit: unknown config type %x\n", *p);
  8004216fcc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216fd0:	0f b6 00             	movzbl (%rax),%eax
  8004216fd3:	0f b6 c0             	movzbl %al,%eax
  8004216fd6:	89 c6                	mov    %eax,%esi
  8004216fd8:	48 bf 48 b8 21 04 80 	movabs $0x800421b848,%rdi
  8004216fdf:	00 00 00 
  8004216fe2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216fe7:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  8004216fee:	00 00 00 
  8004216ff1:	ff d2                	callq  *%rdx
			ismp = 0;
  8004216ff3:	48 b8 00 e0 69 04 80 	movabs $0x800469e000,%rax
  8004216ffa:	00 00 00 
  8004216ffd:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
			i = conf->entry;
  8004217003:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217007:	0f b7 40 22          	movzwl 0x22(%rax),%eax
  800421700b:	0f b7 c0             	movzwl %ax,%eax
  800421700e:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	if ((conf = mpconfig(&mp)) == 0)
		return;
	ismp = 1;
	lapicaddr = conf->lapicaddr;

	for (p = conf->entries, i = 0; i < conf->entry; i++) {
  8004217011:	83 45 e4 01          	addl   $0x1,-0x1c(%rbp)
  8004217015:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217019:	0f b7 40 22          	movzwl 0x22(%rax),%eax
  800421701d:	0f b7 c0             	movzwl %ax,%eax
  8004217020:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  8004217023:	0f 87 d5 fd ff ff    	ja     8004216dfe <mp_init+0x81>
			i = conf->entry;
		}
	}


	for (i=0; i< NCPU; ++i) {
  8004217029:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
  8004217030:	eb 53                	jmp    8004217085 <mp_init+0x308>
		cpus[i].is_vmx_root = false;
  8004217032:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  8004217039:	00 00 00 
  800421703c:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421703f:	48 c1 e0 03          	shl    $0x3,%rax
  8004217043:	48 89 c1             	mov    %rax,%rcx
  8004217046:	48 c1 e1 04          	shl    $0x4,%rcx
  800421704a:	48 01 c8             	add    %rcx,%rax
  800421704d:	48 01 d0             	add    %rdx,%rax
  8004217050:	48 83 c0 70          	add    $0x70,%rax
  8004217054:	c6 40 08 00          	movb   $0x0,0x8(%rax)
		cpus[i].vmxon_region = 0;
  8004217058:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800421705f:	00 00 00 
  8004217062:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004217065:	48 c1 e0 03          	shl    $0x3,%rax
  8004217069:	48 89 c1             	mov    %rax,%rcx
  800421706c:	48 c1 e1 04          	shl    $0x4,%rcx
  8004217070:	48 01 c8             	add    %rcx,%rax
  8004217073:	48 01 d0             	add    %rdx,%rax
  8004217076:	48 83 e8 80          	sub    $0xffffffffffffff80,%rax
  800421707a:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			i = conf->entry;
		}
	}


	for (i=0; i< NCPU; ++i) {
  8004217081:	83 45 e4 01          	addl   $0x1,-0x1c(%rbp)
  8004217085:	83 7d e4 03          	cmpl   $0x3,-0x1c(%rbp)
  8004217089:	76 a7                	jbe    8004217032 <mp_init+0x2b5>
		cpus[i].is_vmx_root = false;
		cpus[i].vmxon_region = 0;
	}


	bootcpu->cpu_status = CPU_STARTED;
  800421708b:	48 b8 40 e2 69 04 80 	movabs $0x800469e240,%rax
  8004217092:	00 00 00 
  8004217095:	48 8b 00             	mov    (%rax),%rax
  8004217098:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%rax)
	if (!ismp) {
  800421709f:	48 b8 00 e0 69 04 80 	movabs $0x800469e000,%rax
  80042170a6:	00 00 00 
  80042170a9:	8b 00                	mov    (%rax),%eax
  80042170ab:	85 c0                	test   %eax,%eax
  80042170ad:	75 41                	jne    80042170f0 <mp_init+0x373>
		// Didn't like what we found; fall back to no MP.
		ncpu = 1;
  80042170af:	48 b8 48 e2 69 04 80 	movabs $0x800469e248,%rax
  80042170b6:	00 00 00 
  80042170b9:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
		lapicaddr = 0;
  80042170bf:	48 b8 00 f0 6d 04 80 	movabs $0x80046df000,%rax
  80042170c6:	00 00 00 
  80042170c9:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		cprintf("SMP: configuration not found, SMP disabled\n");
  80042170d0:	48 bf 68 b8 21 04 80 	movabs $0x800421b868,%rdi
  80042170d7:	00 00 00 
  80042170da:	b8 00 00 00 00       	mov    $0x0,%eax
  80042170df:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  80042170e6:	00 00 00 
  80042170e9:	ff d2                	callq  *%rdx
		return;
  80042170eb:	e9 a2 00 00 00       	jmpq   8004217192 <mp_init+0x415>
	}
	cprintf("SMP: CPU %d found %d CPU(s)\n", bootcpu->cpu_id,  ncpu);
  80042170f0:	48 b8 48 e2 69 04 80 	movabs $0x800469e248,%rax
  80042170f7:	00 00 00 
  80042170fa:	8b 10                	mov    (%rax),%edx
  80042170fc:	48 b8 40 e2 69 04 80 	movabs $0x800469e240,%rax
  8004217103:	00 00 00 
  8004217106:	48 8b 00             	mov    (%rax),%rax
  8004217109:	0f b6 00             	movzbl (%rax),%eax
  800421710c:	0f b6 c0             	movzbl %al,%eax
  800421710f:	89 c6                	mov    %eax,%esi
  8004217111:	48 bf 94 b8 21 04 80 	movabs $0x800421b894,%rdi
  8004217118:	00 00 00 
  800421711b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217120:	48 b9 90 95 20 04 80 	movabs $0x8004209590,%rcx
  8004217127:	00 00 00 
  800421712a:	ff d1                	callq  *%rcx

	if (mp->imcrp) {
  800421712c:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004217130:	0f b6 40 0c          	movzbl 0xc(%rax),%eax
  8004217134:	84 c0                	test   %al,%al
  8004217136:	74 5a                	je     8004217192 <mp_init+0x415>
		// [MP 3.2.6.1] If the hardware implements PIC mode,
		// switch to getting interrupts from the LAPIC.
		cprintf("SMP: Setting IMCR to switch from PIC mode to symmetric I/O mode\n");
  8004217138:	48 bf b8 b8 21 04 80 	movabs $0x800421b8b8,%rdi
  800421713f:	00 00 00 
  8004217142:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217147:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  800421714e:	00 00 00 
  8004217151:	ff d2                	callq  *%rdx
  8004217153:	c7 45 cc 22 00 00 00 	movl   $0x22,-0x34(%rbp)
  800421715a:	c6 45 cb 70          	movb   $0x70,-0x35(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  800421715e:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  8004217162:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004217165:	ee                   	out    %al,(%dx)
  8004217166:	c7 45 c4 23 00 00 00 	movl   $0x23,-0x3c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  800421716d:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004217170:	89 c2                	mov    %eax,%edx
  8004217172:	ec                   	in     (%dx),%al
  8004217173:	88 45 c3             	mov    %al,-0x3d(%rbp)
	return data;
  8004217176:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
		outb(0x22, 0x70);   // Select IMCR
		outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
  800421717a:	83 c8 01             	or     $0x1,%eax
  800421717d:	0f b6 c0             	movzbl %al,%eax
  8004217180:	c7 45 bc 23 00 00 00 	movl   $0x23,-0x44(%rbp)
  8004217187:	88 45 bb             	mov    %al,-0x45(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  800421718a:	0f b6 45 bb          	movzbl -0x45(%rbp),%eax
  800421718e:	8b 55 bc             	mov    -0x44(%rbp),%edx
  8004217191:	ee                   	out    %al,(%dx)
	}
}
  8004217192:	48 83 c4 58          	add    $0x58,%rsp
  8004217196:	5b                   	pop    %rbx
  8004217197:	5d                   	pop    %rbp
  8004217198:	c3                   	retq   

0000008004217199 <lapicw>:
physaddr_t lapicaddr;        // Initialized in mpconfig.c
volatile uint32_t *lapic;

static void
lapicw(int index, int value)
{
  8004217199:	55                   	push   %rbp
  800421719a:	48 89 e5             	mov    %rsp,%rbp
  800421719d:	48 83 ec 08          	sub    $0x8,%rsp
  80042171a1:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80042171a4:	89 75 f8             	mov    %esi,-0x8(%rbp)
	lapic[index] = value;
  80042171a7:	48 b8 08 f0 6d 04 80 	movabs $0x80046df008,%rax
  80042171ae:	00 00 00 
  80042171b1:	48 8b 00             	mov    (%rax),%rax
  80042171b4:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042171b7:	48 63 d2             	movslq %edx,%rdx
  80042171ba:	48 c1 e2 02          	shl    $0x2,%rdx
  80042171be:	48 01 c2             	add    %rax,%rdx
  80042171c1:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042171c4:	89 02                	mov    %eax,(%rdx)
	lapic[ID];  // wait for write to finish, by reading
  80042171c6:	48 b8 08 f0 6d 04 80 	movabs $0x80046df008,%rax
  80042171cd:	00 00 00 
  80042171d0:	48 8b 00             	mov    (%rax),%rax
  80042171d3:	48 83 c0 20          	add    $0x20,%rax
  80042171d7:	8b 00                	mov    (%rax),%eax
}
  80042171d9:	c9                   	leaveq 
  80042171da:	c3                   	retq   

00000080042171db <lapic_init>:

void
lapic_init(void)
{
  80042171db:	55                   	push   %rbp
  80042171dc:	48 89 e5             	mov    %rsp,%rbp
	if (!lapicaddr)
  80042171df:	48 b8 00 f0 6d 04 80 	movabs $0x80046df000,%rax
  80042171e6:	00 00 00 
  80042171e9:	48 8b 00             	mov    (%rax),%rax
  80042171ec:	48 85 c0             	test   %rax,%rax
  80042171ef:	75 05                	jne    80042171f6 <lapic_init+0x1b>
		return;
  80042171f1:	e9 da 01 00 00       	jmpq   80042173d0 <lapic_init+0x1f5>

	// lapicaddr is the physical address of the LAPIC's 4K MMIO
	// region.  Map it in to virtual memory so we can access it.
	lapic = mmio_map_region(lapicaddr, 4096);
  80042171f6:	48 b8 00 f0 6d 04 80 	movabs $0x80046df000,%rax
  80042171fd:	00 00 00 
  8004217200:	48 8b 00             	mov    (%rax),%rax
  8004217203:	be 00 10 00 00       	mov    $0x1000,%esi
  8004217208:	48 89 c7             	mov    %rax,%rdi
  800421720b:	48 b8 8f 40 20 04 80 	movabs $0x800420408f,%rax
  8004217212:	00 00 00 
  8004217215:	ff d0                	callq  *%rax
  8004217217:	48 ba 08 f0 6d 04 80 	movabs $0x80046df008,%rdx
  800421721e:	00 00 00 
  8004217221:	48 89 02             	mov    %rax,(%rdx)

	// Enable local APIC; set spurious interrupt vector.
	lapicw(SVR, ENABLE | (IRQ_OFFSET + IRQ_SPURIOUS));
  8004217224:	be 27 01 00 00       	mov    $0x127,%esi
  8004217229:	bf 3c 00 00 00       	mov    $0x3c,%edi
  800421722e:	48 b8 99 71 21 04 80 	movabs $0x8004217199,%rax
  8004217235:	00 00 00 
  8004217238:	ff d0                	callq  *%rax

	// The timer repeatedly counts down at bus frequency
	// from lapic[TICR] and then issues an interrupt.  
	// If we cared more about precise timekeeping,
	// TICR would be calibrated using an external time source.
	lapicw(TDCR, X1);
  800421723a:	be 0b 00 00 00       	mov    $0xb,%esi
  800421723f:	bf f8 00 00 00       	mov    $0xf8,%edi
  8004217244:	48 b8 99 71 21 04 80 	movabs $0x8004217199,%rax
  800421724b:	00 00 00 
  800421724e:	ff d0                	callq  *%rax
	lapicw(TIMER, PERIODIC | (IRQ_OFFSET + IRQ_TIMER));
  8004217250:	be 20 00 02 00       	mov    $0x20020,%esi
  8004217255:	bf c8 00 00 00       	mov    $0xc8,%edi
  800421725a:	48 b8 99 71 21 04 80 	movabs $0x8004217199,%rax
  8004217261:	00 00 00 
  8004217264:	ff d0                	callq  *%rax
	lapicw(TICR, 10000000); 
  8004217266:	be 80 96 98 00       	mov    $0x989680,%esi
  800421726b:	bf e0 00 00 00       	mov    $0xe0,%edi
  8004217270:	48 b8 99 71 21 04 80 	movabs $0x8004217199,%rax
  8004217277:	00 00 00 
  800421727a:	ff d0                	callq  *%rax
	//
	// According to Intel MP Specification, the BIOS should initialize
	// BSP's local APIC in Virtual Wire Mode, in which 8259A's
	// INTR is virtually connected to BSP's LINTIN0. In this mode,
	// we do not need to program the IOAPIC.
	if (thiscpu != bootcpu)
  800421727c:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  8004217283:	00 00 00 
  8004217286:	ff d0                	callq  *%rax
  8004217288:	48 98                	cltq   
  800421728a:	48 c1 e0 03          	shl    $0x3,%rax
  800421728e:	48 89 c2             	mov    %rax,%rdx
  8004217291:	48 c1 e2 04          	shl    $0x4,%rdx
  8004217295:	48 01 d0             	add    %rdx,%rax
  8004217298:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800421729f:	00 00 00 
  80042172a2:	48 01 c2             	add    %rax,%rdx
  80042172a5:	48 b8 40 e2 69 04 80 	movabs $0x800469e240,%rax
  80042172ac:	00 00 00 
  80042172af:	48 8b 00             	mov    (%rax),%rax
  80042172b2:	48 39 c2             	cmp    %rax,%rdx
  80042172b5:	74 16                	je     80042172cd <lapic_init+0xf2>
		lapicw(LINT0, MASKED);
  80042172b7:	be 00 00 01 00       	mov    $0x10000,%esi
  80042172bc:	bf d4 00 00 00       	mov    $0xd4,%edi
  80042172c1:	48 b8 99 71 21 04 80 	movabs $0x8004217199,%rax
  80042172c8:	00 00 00 
  80042172cb:	ff d0                	callq  *%rax

	// Disable NMI (LINT1) on all CPUs
	lapicw(LINT1, MASKED);
  80042172cd:	be 00 00 01 00       	mov    $0x10000,%esi
  80042172d2:	bf d8 00 00 00       	mov    $0xd8,%edi
  80042172d7:	48 b8 99 71 21 04 80 	movabs $0x8004217199,%rax
  80042172de:	00 00 00 
  80042172e1:	ff d0                	callq  *%rax

	// Disable performance counter overflow interrupts
	// on machines that provide that interrupt entry.
	if (((lapic[VER]>>16) & 0xFF) >= 4)
  80042172e3:	48 b8 08 f0 6d 04 80 	movabs $0x80046df008,%rax
  80042172ea:	00 00 00 
  80042172ed:	48 8b 00             	mov    (%rax),%rax
  80042172f0:	48 83 c0 30          	add    $0x30,%rax
  80042172f4:	8b 00                	mov    (%rax),%eax
  80042172f6:	c1 e8 10             	shr    $0x10,%eax
  80042172f9:	0f b6 c0             	movzbl %al,%eax
  80042172fc:	83 f8 03             	cmp    $0x3,%eax
  80042172ff:	76 16                	jbe    8004217317 <lapic_init+0x13c>
		lapicw(PCINT, MASKED);
  8004217301:	be 00 00 01 00       	mov    $0x10000,%esi
  8004217306:	bf d0 00 00 00       	mov    $0xd0,%edi
  800421730b:	48 b8 99 71 21 04 80 	movabs $0x8004217199,%rax
  8004217312:	00 00 00 
  8004217315:	ff d0                	callq  *%rax

	// Map error interrupt to IRQ_ERROR.
	lapicw(ERROR, IRQ_OFFSET + IRQ_ERROR);
  8004217317:	be 33 00 00 00       	mov    $0x33,%esi
  800421731c:	bf dc 00 00 00       	mov    $0xdc,%edi
  8004217321:	48 b8 99 71 21 04 80 	movabs $0x8004217199,%rax
  8004217328:	00 00 00 
  800421732b:	ff d0                	callq  *%rax

	// Clear error status register (requires back-to-back writes).
	lapicw(ESR, 0);
  800421732d:	be 00 00 00 00       	mov    $0x0,%esi
  8004217332:	bf a0 00 00 00       	mov    $0xa0,%edi
  8004217337:	48 b8 99 71 21 04 80 	movabs $0x8004217199,%rax
  800421733e:	00 00 00 
  8004217341:	ff d0                	callq  *%rax
	lapicw(ESR, 0);
  8004217343:	be 00 00 00 00       	mov    $0x0,%esi
  8004217348:	bf a0 00 00 00       	mov    $0xa0,%edi
  800421734d:	48 b8 99 71 21 04 80 	movabs $0x8004217199,%rax
  8004217354:	00 00 00 
  8004217357:	ff d0                	callq  *%rax

	// Ack any outstanding interrupts.
	lapicw(EOI, 0);
  8004217359:	be 00 00 00 00       	mov    $0x0,%esi
  800421735e:	bf 2c 00 00 00       	mov    $0x2c,%edi
  8004217363:	48 b8 99 71 21 04 80 	movabs $0x8004217199,%rax
  800421736a:	00 00 00 
  800421736d:	ff d0                	callq  *%rax

	// Send an Init Level De-Assert to synchronize arbitration ID's.
	lapicw(ICRHI, 0);
  800421736f:	be 00 00 00 00       	mov    $0x0,%esi
  8004217374:	bf c4 00 00 00       	mov    $0xc4,%edi
  8004217379:	48 b8 99 71 21 04 80 	movabs $0x8004217199,%rax
  8004217380:	00 00 00 
  8004217383:	ff d0                	callq  *%rax
	lapicw(ICRLO, BCAST | INIT | LEVEL);
  8004217385:	be 00 85 08 00       	mov    $0x88500,%esi
  800421738a:	bf c0 00 00 00       	mov    $0xc0,%edi
  800421738f:	48 b8 99 71 21 04 80 	movabs $0x8004217199,%rax
  8004217396:	00 00 00 
  8004217399:	ff d0                	callq  *%rax
	while(lapic[ICRLO] & DELIVS)
  800421739b:	90                   	nop
  800421739c:	48 b8 08 f0 6d 04 80 	movabs $0x80046df008,%rax
  80042173a3:	00 00 00 
  80042173a6:	48 8b 00             	mov    (%rax),%rax
  80042173a9:	48 05 00 03 00 00    	add    $0x300,%rax
  80042173af:	8b 00                	mov    (%rax),%eax
  80042173b1:	25 00 10 00 00       	and    $0x1000,%eax
  80042173b6:	85 c0                	test   %eax,%eax
  80042173b8:	75 e2                	jne    800421739c <lapic_init+0x1c1>
		;

	// Enable interrupts on the APIC (but not on the processor).
	lapicw(TPR, 0);
  80042173ba:	be 00 00 00 00       	mov    $0x0,%esi
  80042173bf:	bf 20 00 00 00       	mov    $0x20,%edi
  80042173c4:	48 b8 99 71 21 04 80 	movabs $0x8004217199,%rax
  80042173cb:	00 00 00 
  80042173ce:	ff d0                	callq  *%rax
}
  80042173d0:	5d                   	pop    %rbp
  80042173d1:	c3                   	retq   

00000080042173d2 <cpunum>:

int
cpunum(void)
{
  80042173d2:	55                   	push   %rbp
  80042173d3:	48 89 e5             	mov    %rsp,%rbp
	if (lapic)
  80042173d6:	48 b8 08 f0 6d 04 80 	movabs $0x80046df008,%rax
  80042173dd:	00 00 00 
  80042173e0:	48 8b 00             	mov    (%rax),%rax
  80042173e3:	48 85 c0             	test   %rax,%rax
  80042173e6:	74 18                	je     8004217400 <cpunum+0x2e>
		return lapic[ID] >> 24;
  80042173e8:	48 b8 08 f0 6d 04 80 	movabs $0x80046df008,%rax
  80042173ef:	00 00 00 
  80042173f2:	48 8b 00             	mov    (%rax),%rax
  80042173f5:	48 83 c0 20          	add    $0x20,%rax
  80042173f9:	8b 00                	mov    (%rax),%eax
  80042173fb:	c1 e8 18             	shr    $0x18,%eax
  80042173fe:	eb 05                	jmp    8004217405 <cpunum+0x33>
	return 0;
  8004217400:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004217405:	5d                   	pop    %rbp
  8004217406:	c3                   	retq   

0000008004217407 <lapic_eoi>:

// Acknowledge interrupt.
void
lapic_eoi(void)
{
  8004217407:	55                   	push   %rbp
  8004217408:	48 89 e5             	mov    %rsp,%rbp
	if (lapic)
  800421740b:	48 b8 08 f0 6d 04 80 	movabs $0x80046df008,%rax
  8004217412:	00 00 00 
  8004217415:	48 8b 00             	mov    (%rax),%rax
  8004217418:	48 85 c0             	test   %rax,%rax
  800421741b:	74 16                	je     8004217433 <lapic_eoi+0x2c>
		lapicw(EOI, 0);
  800421741d:	be 00 00 00 00       	mov    $0x0,%esi
  8004217422:	bf 2c 00 00 00       	mov    $0x2c,%edi
  8004217427:	48 b8 99 71 21 04 80 	movabs $0x8004217199,%rax
  800421742e:	00 00 00 
  8004217431:	ff d0                	callq  *%rax
}
  8004217433:	5d                   	pop    %rbp
  8004217434:	c3                   	retq   

0000008004217435 <microdelay>:

// Spin for a given number of microseconds.
// On real hardware would want to tune this dynamically.
static void
microdelay(int us)
{
  8004217435:	55                   	push   %rbp
  8004217436:	48 89 e5             	mov    %rsp,%rbp
  8004217439:	48 83 ec 04          	sub    $0x4,%rsp
  800421743d:	89 7d fc             	mov    %edi,-0x4(%rbp)
}
  8004217440:	c9                   	leaveq 
  8004217441:	c3                   	retq   

0000008004217442 <lapic_startap>:

// Start additional processor running entry code at addr.
// See Appendix B of MultiProcessor Specification.
void
lapic_startap(uint8_t apicid, uint32_t addr)
{
  8004217442:	55                   	push   %rbp
  8004217443:	48 89 e5             	mov    %rsp,%rbp
  8004217446:	48 83 ec 40          	sub    $0x40,%rsp
  800421744a:	89 f8                	mov    %edi,%eax
  800421744c:	89 75 c8             	mov    %esi,-0x38(%rbp)
  800421744f:	88 45 cc             	mov    %al,-0x34(%rbp)
  8004217452:	c7 45 dc 70 00 00 00 	movl   $0x70,-0x24(%rbp)
  8004217459:	c6 45 db 0f          	movb   $0xf,-0x25(%rbp)
  800421745d:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004217461:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004217464:	ee                   	out    %al,(%dx)
  8004217465:	c7 45 d4 71 00 00 00 	movl   $0x71,-0x2c(%rbp)
  800421746c:	c6 45 d3 0a          	movb   $0xa,-0x2d(%rbp)
  8004217470:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004217474:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004217477:	ee                   	out    %al,(%dx)
	// "The BSP must initialize CMOS shutdown code to 0AH
	// and the warm reset vector (DWORD based at 40:67) to point at
	// the AP startup code prior to the [universal startup algorithm]."
	outb(IO_RTC, 0xF);  // offset 0xF is shutdown code
	outb(IO_RTC+1, 0x0A);
	wrv = (uint16_t *)KADDR((0x40 << 4 | 0x67));  // Warm reset vector
  8004217478:	48 c7 45 f0 67 04 00 	movq   $0x467,-0x10(%rbp)
  800421747f:	00 
  8004217480:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004217484:	48 c1 e8 0c          	shr    $0xc,%rax
  8004217488:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800421748b:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800421748e:	48 b8 f0 c5 69 04 80 	movabs $0x800469c5f0,%rax
  8004217495:	00 00 00 
  8004217498:	48 8b 00             	mov    (%rax),%rax
  800421749b:	48 39 c2             	cmp    %rax,%rdx
  800421749e:	72 32                	jb     80042174d2 <lapic_startap+0x90>
  80042174a0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042174a4:	48 89 c1             	mov    %rax,%rcx
  80042174a7:	48 ba 00 b9 21 04 80 	movabs $0x800421b900,%rdx
  80042174ae:	00 00 00 
  80042174b1:	be 99 00 00 00       	mov    $0x99,%esi
  80042174b6:	48 bf 23 b9 21 04 80 	movabs $0x800421b923,%rdi
  80042174bd:	00 00 00 
  80042174c0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042174c5:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042174cc:	00 00 00 
  80042174cf:	41 ff d0             	callq  *%r8
  80042174d2:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042174d9:	00 00 00 
  80042174dc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042174e0:	48 01 d0             	add    %rdx,%rax
  80042174e3:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	wrv[0] = 0;
  80042174e7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042174eb:	66 c7 00 00 00       	movw   $0x0,(%rax)
	wrv[1] = addr >> 4;
  80042174f0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042174f4:	48 8d 50 02          	lea    0x2(%rax),%rdx
  80042174f8:	8b 45 c8             	mov    -0x38(%rbp),%eax
  80042174fb:	c1 e8 04             	shr    $0x4,%eax
  80042174fe:	66 89 02             	mov    %ax,(%rdx)

	// "Universal startup algorithm."
	// Send INIT (level-triggered) interrupt to reset other CPU.
	lapicw(ICRHI, apicid << 24);
  8004217501:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004217505:	c1 e0 18             	shl    $0x18,%eax
  8004217508:	89 c6                	mov    %eax,%esi
  800421750a:	bf c4 00 00 00       	mov    $0xc4,%edi
  800421750f:	48 b8 99 71 21 04 80 	movabs $0x8004217199,%rax
  8004217516:	00 00 00 
  8004217519:	ff d0                	callq  *%rax
	lapicw(ICRLO, INIT | LEVEL | ASSERT);
  800421751b:	be 00 c5 00 00       	mov    $0xc500,%esi
  8004217520:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004217525:	48 b8 99 71 21 04 80 	movabs $0x8004217199,%rax
  800421752c:	00 00 00 
  800421752f:	ff d0                	callq  *%rax
	microdelay(200);
  8004217531:	bf c8 00 00 00       	mov    $0xc8,%edi
  8004217536:	48 b8 35 74 21 04 80 	movabs $0x8004217435,%rax
  800421753d:	00 00 00 
  8004217540:	ff d0                	callq  *%rax
	lapicw(ICRLO, INIT | LEVEL);
  8004217542:	be 00 85 00 00       	mov    $0x8500,%esi
  8004217547:	bf c0 00 00 00       	mov    $0xc0,%edi
  800421754c:	48 b8 99 71 21 04 80 	movabs $0x8004217199,%rax
  8004217553:	00 00 00 
  8004217556:	ff d0                	callq  *%rax
	microdelay(100);    // should be 10ms, but too slow in Bochs!
  8004217558:	bf 64 00 00 00       	mov    $0x64,%edi
  800421755d:	48 b8 35 74 21 04 80 	movabs $0x8004217435,%rax
  8004217564:	00 00 00 
  8004217567:	ff d0                	callq  *%rax
	// Send startup IPI (twice!) to enter code.
	// Regular hardware is supposed to only accept a STARTUP
	// when it is in the halted state due to an INIT.  So the second
	// should be ignored, but it is part of the official Intel algorithm.
	// Bochs complains about the second one.  Too bad for Bochs.
	for (i = 0; i < 2; i++) {
  8004217569:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004217570:	eb 4b                	jmp    80042175bd <lapic_startap+0x17b>
		lapicw(ICRHI, apicid << 24);
  8004217572:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004217576:	c1 e0 18             	shl    $0x18,%eax
  8004217579:	89 c6                	mov    %eax,%esi
  800421757b:	bf c4 00 00 00       	mov    $0xc4,%edi
  8004217580:	48 b8 99 71 21 04 80 	movabs $0x8004217199,%rax
  8004217587:	00 00 00 
  800421758a:	ff d0                	callq  *%rax
		lapicw(ICRLO, STARTUP | (addr >> 12));
  800421758c:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800421758f:	c1 e8 0c             	shr    $0xc,%eax
  8004217592:	80 cc 06             	or     $0x6,%ah
  8004217595:	89 c6                	mov    %eax,%esi
  8004217597:	bf c0 00 00 00       	mov    $0xc0,%edi
  800421759c:	48 b8 99 71 21 04 80 	movabs $0x8004217199,%rax
  80042175a3:	00 00 00 
  80042175a6:	ff d0                	callq  *%rax
		microdelay(200);
  80042175a8:	bf c8 00 00 00       	mov    $0xc8,%edi
  80042175ad:	48 b8 35 74 21 04 80 	movabs $0x8004217435,%rax
  80042175b4:	00 00 00 
  80042175b7:	ff d0                	callq  *%rax
	// Send startup IPI (twice!) to enter code.
	// Regular hardware is supposed to only accept a STARTUP
	// when it is in the halted state due to an INIT.  So the second
	// should be ignored, but it is part of the official Intel algorithm.
	// Bochs complains about the second one.  Too bad for Bochs.
	for (i = 0; i < 2; i++) {
  80042175b9:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042175bd:	83 7d fc 01          	cmpl   $0x1,-0x4(%rbp)
  80042175c1:	7e af                	jle    8004217572 <lapic_startap+0x130>
		lapicw(ICRHI, apicid << 24);
		lapicw(ICRLO, STARTUP | (addr >> 12));
		microdelay(200);
	}
}
  80042175c3:	c9                   	leaveq 
  80042175c4:	c3                   	retq   

00000080042175c5 <lapic_ipi>:

void
lapic_ipi(int vector)
{
  80042175c5:	55                   	push   %rbp
  80042175c6:	48 89 e5             	mov    %rsp,%rbp
  80042175c9:	48 83 ec 08          	sub    $0x8,%rsp
  80042175cd:	89 7d fc             	mov    %edi,-0x4(%rbp)
	lapicw(ICRLO, OTHERS | FIXED | vector);
  80042175d0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042175d3:	0d 00 00 0c 00       	or     $0xc0000,%eax
  80042175d8:	89 c6                	mov    %eax,%esi
  80042175da:	bf c0 00 00 00       	mov    $0xc0,%edi
  80042175df:	48 b8 99 71 21 04 80 	movabs $0x8004217199,%rax
  80042175e6:	00 00 00 
  80042175e9:	ff d0                	callq  *%rax
	while (lapic[ICRLO] & DELIVS)
  80042175eb:	90                   	nop
  80042175ec:	48 b8 08 f0 6d 04 80 	movabs $0x80046df008,%rax
  80042175f3:	00 00 00 
  80042175f6:	48 8b 00             	mov    (%rax),%rax
  80042175f9:	48 05 00 03 00 00    	add    $0x300,%rax
  80042175ff:	8b 00                	mov    (%rax),%eax
  8004217601:	25 00 10 00 00       	and    $0x1000,%eax
  8004217606:	85 c0                	test   %eax,%eax
  8004217608:	75 e2                	jne    80042175ec <lapic_ipi+0x27>
		;
}
  800421760a:	c9                   	leaveq 
  800421760b:	c3                   	retq   

000000800421760c <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  800421760c:	55                   	push   %rbp
  800421760d:	48 89 e5             	mov    %rsp,%rbp
  8004217610:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004217614:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004217618:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  800421761b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421761f:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004217622:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004217626:	f0 87 02             	lock xchg %eax,(%rdx)
  8004217629:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  800421762c:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800421762f:	c9                   	leaveq 
  8004217630:	c3                   	retq   

0000008004217631 <get_caller_pcs>:

#ifdef DEBUG_SPINLOCK
// Record the current call stack in pcs[] by following the %ebp chain.
static void
get_caller_pcs(uint64_t pcs[])
{
  8004217631:	55                   	push   %rbp
  8004217632:	48 89 e5             	mov    %rsp,%rbp
  8004217635:	48 83 ec 28          	sub    $0x28,%rsp
  8004217639:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)

static __inline uint64_t
read_rbp(void)
{
	uint64_t rbp;
	__asm __volatile("movq %%rbp,%0" : "=r" (rbp)::"cc","memory");
  800421763d:	48 89 e8             	mov    %rbp,%rax
  8004217640:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	return rbp;
  8004217644:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
	uint64_t *rbp;
	int i;

	rbp = (uint64_t *)read_rbp();
  8004217648:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (i = 0; i < 10; i++){
  800421764c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004217653:	eb 45                	jmp    800421769a <get_caller_pcs+0x69>
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
  8004217655:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800421765a:	74 44                	je     80042176a0 <get_caller_pcs+0x6f>
  800421765c:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004217663:	00 00 00 
  8004217666:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  800421766a:	76 34                	jbe    80042176a0 <get_caller_pcs+0x6f>
			break;
		pcs[i] = rbp[1];          // saved %rip
  800421766c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421766f:	48 98                	cltq   
  8004217671:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004217678:	00 
  8004217679:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421767d:	48 01 c2             	add    %rax,%rdx
  8004217680:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004217684:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004217688:	48 89 02             	mov    %rax,(%rdx)
		rbp = (uint64_t *)rbp[0]; // saved %rbp
  800421768b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421768f:	48 8b 00             	mov    (%rax),%rax
  8004217692:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
{
	uint64_t *rbp;
	int i;

	rbp = (uint64_t *)read_rbp();
	for (i = 0; i < 10; i++){
  8004217696:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  800421769a:	83 7d f4 09          	cmpl   $0x9,-0xc(%rbp)
  800421769e:	7e b5                	jle    8004217655 <get_caller_pcs+0x24>
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
			break;
		pcs[i] = rbp[1];          // saved %rip
		rbp = (uint64_t *)rbp[0]; // saved %rbp
	}
	for (; i < 10; i++)
  80042176a0:	eb 1f                	jmp    80042176c1 <get_caller_pcs+0x90>
		pcs[i] = 0;
  80042176a2:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042176a5:	48 98                	cltq   
  80042176a7:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042176ae:	00 
  80042176af:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042176b3:	48 01 d0             	add    %rdx,%rax
  80042176b6:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
			break;
		pcs[i] = rbp[1];          // saved %rip
		rbp = (uint64_t *)rbp[0]; // saved %rbp
	}
	for (; i < 10; i++)
  80042176bd:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  80042176c1:	83 7d f4 09          	cmpl   $0x9,-0xc(%rbp)
  80042176c5:	7e db                	jle    80042176a2 <get_caller_pcs+0x71>
		pcs[i] = 0;
}
  80042176c7:	c9                   	leaveq 
  80042176c8:	c3                   	retq   

00000080042176c9 <holding>:

// Check whether this CPU is holding the lock.
static int
holding(struct spinlock *lock)
{
  80042176c9:	55                   	push   %rbp
  80042176ca:	48 89 e5             	mov    %rsp,%rbp
  80042176cd:	53                   	push   %rbx
  80042176ce:	48 83 ec 18          	sub    $0x18,%rsp
  80042176d2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return lock->locked && lock->cpu == thiscpu;
  80042176d6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042176da:	8b 00                	mov    (%rax),%eax
  80042176dc:	85 c0                	test   %eax,%eax
  80042176de:	74 3d                	je     800421771d <holding+0x54>
  80042176e0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042176e4:	48 8b 58 10          	mov    0x10(%rax),%rbx
  80042176e8:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  80042176ef:	00 00 00 
  80042176f2:	ff d0                	callq  *%rax
  80042176f4:	48 98                	cltq   
  80042176f6:	48 c1 e0 03          	shl    $0x3,%rax
  80042176fa:	48 89 c2             	mov    %rax,%rdx
  80042176fd:	48 c1 e2 04          	shl    $0x4,%rdx
  8004217701:	48 01 d0             	add    %rdx,%rax
  8004217704:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  800421770b:	00 00 00 
  800421770e:	48 01 d0             	add    %rdx,%rax
  8004217711:	48 39 c3             	cmp    %rax,%rbx
  8004217714:	75 07                	jne    800421771d <holding+0x54>
  8004217716:	b8 01 00 00 00       	mov    $0x1,%eax
  800421771b:	eb 05                	jmp    8004217722 <holding+0x59>
  800421771d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004217722:	48 83 c4 18          	add    $0x18,%rsp
  8004217726:	5b                   	pop    %rbx
  8004217727:	5d                   	pop    %rbp
  8004217728:	c3                   	retq   

0000008004217729 <__spin_initlock>:
#endif

void
__spin_initlock(struct spinlock *lk, char *name)
{
  8004217729:	55                   	push   %rbp
  800421772a:	48 89 e5             	mov    %rsp,%rbp
  800421772d:	48 83 ec 10          	sub    $0x10,%rsp
  8004217731:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004217735:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	lk->locked = 0;
  8004217739:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421773d:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
#ifdef DEBUG_SPINLOCK
	lk->name = name;
  8004217743:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004217747:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421774b:	48 89 50 08          	mov    %rdx,0x8(%rax)
	lk->cpu = 0;
  800421774f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004217753:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  800421775a:	00 
#endif
}
  800421775b:	c9                   	leaveq 
  800421775c:	c3                   	retq   

000000800421775d <spin_lock>:
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void
spin_lock(struct spinlock *lk)
{
  800421775d:	55                   	push   %rbp
  800421775e:	48 89 e5             	mov    %rsp,%rbp
  8004217761:	53                   	push   %rbx
  8004217762:	48 83 ec 18          	sub    $0x18,%rsp
  8004217766:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
#ifdef DEBUG_SPINLOCK
	if (holding(lk))
  800421776a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421776e:	48 89 c7             	mov    %rax,%rdi
  8004217771:	48 b8 c9 76 21 04 80 	movabs $0x80042176c9,%rax
  8004217778:	00 00 00 
  800421777b:	ff d0                	callq  *%rax
  800421777d:	85 c0                	test   %eax,%eax
  800421777f:	74 44                	je     80042177c5 <spin_lock+0x68>
		panic("CPU %d cannot acquire %s: already holding", cpunum(), lk->name);
  8004217781:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217785:	48 8b 58 08          	mov    0x8(%rax),%rbx
  8004217789:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  8004217790:	00 00 00 
  8004217793:	ff d0                	callq  *%rax
  8004217795:	49 89 d8             	mov    %rbx,%r8
  8004217798:	89 c1                	mov    %eax,%ecx
  800421779a:	48 ba 40 b9 21 04 80 	movabs $0x800421b940,%rdx
  80042177a1:	00 00 00 
  80042177a4:	be 42 00 00 00       	mov    $0x42,%esi
  80042177a9:	48 bf 6a b9 21 04 80 	movabs $0x800421b96a,%rdi
  80042177b0:	00 00 00 
  80042177b3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042177b8:	49 b9 e4 05 20 04 80 	movabs $0x80042005e4,%r9
  80042177bf:	00 00 00 
  80042177c2:	41 ff d1             	callq  *%r9
#endif

	// The xchg is atomic.
	// It also serializes, so that reads after acquire are not
	// reordered before it. 
	while (xchg(&lk->locked, 1) != 0)
  80042177c5:	eb 02                	jmp    80042177c9 <spin_lock+0x6c>
		asm volatile ("pause");
  80042177c7:	f3 90                	pause  
#endif

	// The xchg is atomic.
	// It also serializes, so that reads after acquire are not
	// reordered before it. 
	while (xchg(&lk->locked, 1) != 0)
  80042177c9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042177cd:	be 01 00 00 00       	mov    $0x1,%esi
  80042177d2:	48 89 c7             	mov    %rax,%rdi
  80042177d5:	48 b8 0c 76 21 04 80 	movabs $0x800421760c,%rax
  80042177dc:	00 00 00 
  80042177df:	ff d0                	callq  *%rax
  80042177e1:	85 c0                	test   %eax,%eax
  80042177e3:	75 e2                	jne    80042177c7 <spin_lock+0x6a>
		asm volatile ("pause");

	// Record info about lock acquisition for debugging.
#ifdef DEBUG_SPINLOCK
	lk->cpu = thiscpu;
  80042177e5:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  80042177ec:	00 00 00 
  80042177ef:	ff d0                	callq  *%rax
  80042177f1:	48 98                	cltq   
  80042177f3:	48 c1 e0 03          	shl    $0x3,%rax
  80042177f7:	48 89 c2             	mov    %rax,%rdx
  80042177fa:	48 c1 e2 04          	shl    $0x4,%rdx
  80042177fe:	48 01 d0             	add    %rdx,%rax
  8004217801:	48 ba 20 e0 69 04 80 	movabs $0x800469e020,%rdx
  8004217808:	00 00 00 
  800421780b:	48 01 c2             	add    %rax,%rdx
  800421780e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217812:	48 89 50 10          	mov    %rdx,0x10(%rax)
	get_caller_pcs(lk->pcs);
  8004217816:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421781a:	48 83 c0 18          	add    $0x18,%rax
  800421781e:	48 89 c7             	mov    %rax,%rdi
  8004217821:	48 b8 31 76 21 04 80 	movabs $0x8004217631,%rax
  8004217828:	00 00 00 
  800421782b:	ff d0                	callq  *%rax
#endif
}
  800421782d:	48 83 c4 18          	add    $0x18,%rsp
  8004217831:	5b                   	pop    %rbx
  8004217832:	5d                   	pop    %rbp
  8004217833:	c3                   	retq   

0000008004217834 <spin_unlock>:

// Release the lock.
void
spin_unlock(struct spinlock *lk)
{
  8004217834:	55                   	push   %rbp
  8004217835:	48 89 e5             	mov    %rsp,%rbp
  8004217838:	41 54                	push   %r12
  800421783a:	53                   	push   %rbx
  800421783b:	48 81 ec 20 05 00 00 	sub    $0x520,%rsp
  8004217842:	48 89 bd d8 fa ff ff 	mov    %rdi,-0x528(%rbp)
#ifdef DEBUG_SPINLOCK
	if (!holding(lk)) {
  8004217849:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004217850:	48 89 c7             	mov    %rax,%rdi
  8004217853:	48 b8 c9 76 21 04 80 	movabs $0x80042176c9,%rax
  800421785a:	00 00 00 
  800421785d:	ff d0                	callq  *%rax
  800421785f:	85 c0                	test   %eax,%eax
  8004217861:	0f 85 d2 01 00 00    	jne    8004217a39 <spin_unlock+0x205>
		int i;
		uint32_t pcs[10];
		// Nab the acquiring EIP chain before it gets released
		memmove(pcs, lk->pcs, sizeof pcs);
  8004217867:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  800421786e:	48 8d 48 18          	lea    0x18(%rax),%rcx
  8004217872:	48 8d 85 e0 fa ff ff 	lea    -0x520(%rbp),%rax
  8004217879:	ba 28 00 00 00       	mov    $0x28,%edx
  800421787e:	48 89 ce             	mov    %rcx,%rsi
  8004217881:	48 89 c7             	mov    %rax,%rdi
  8004217884:	48 b8 5f 04 21 04 80 	movabs $0x800421045f,%rax
  800421788b:	00 00 00 
  800421788e:	ff d0                	callq  *%rax
		if (!lk->cpu) 
  8004217890:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004217897:	48 8b 40 10          	mov    0x10(%rax),%rax
  800421789b:	48 85 c0             	test   %rax,%rax
  800421789e:	75 39                	jne    80042178d9 <spin_unlock+0xa5>
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
  80042178a0:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  80042178a7:	48 8b 58 08          	mov    0x8(%rax),%rbx
  80042178ab:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  80042178b2:	00 00 00 
  80042178b5:	ff d0                	callq  *%rax
  80042178b7:	48 89 da             	mov    %rbx,%rdx
  80042178ba:	89 c6                	mov    %eax,%esi
  80042178bc:	48 bf 80 b9 21 04 80 	movabs $0x800421b980,%rdi
  80042178c3:	00 00 00 
  80042178c6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042178cb:	48 b9 90 95 20 04 80 	movabs $0x8004209590,%rcx
  80042178d2:	00 00 00 
  80042178d5:	ff d1                	callq  *%rcx
  80042178d7:	eb 4d                	jmp    8004217926 <spin_unlock+0xf2>
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
  80042178d9:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  80042178e0:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042178e4:	0f b6 00             	movzbl (%rax),%eax
		memmove(pcs, lk->pcs, sizeof pcs);
		if (!lk->cpu) 
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
  80042178e7:	44 0f b6 e0          	movzbl %al,%r12d
  80042178eb:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  80042178f2:	48 8b 58 08          	mov    0x8(%rax),%rbx
  80042178f6:	48 b8 d2 73 21 04 80 	movabs $0x80042173d2,%rax
  80042178fd:	00 00 00 
  8004217900:	ff d0                	callq  *%rax
  8004217902:	44 89 e1             	mov    %r12d,%ecx
  8004217905:	48 89 da             	mov    %rbx,%rdx
  8004217908:	89 c6                	mov    %eax,%esi
  800421790a:	48 bf c0 b9 21 04 80 	movabs $0x800421b9c0,%rdi
  8004217911:	00 00 00 
  8004217914:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217919:	49 b8 90 95 20 04 80 	movabs $0x8004209590,%r8
  8004217920:	00 00 00 
  8004217923:	41 ff d0             	callq  *%r8
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
  8004217926:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  800421792d:	e9 c3 00 00 00       	jmpq   80042179f5 <spin_unlock+0x1c1>
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
  8004217932:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004217935:	48 98                	cltq   
  8004217937:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  800421793e:	89 c0                	mov    %eax,%eax
  8004217940:	48 8d 95 10 fb ff ff 	lea    -0x4f0(%rbp),%rdx
  8004217947:	48 89 d6             	mov    %rdx,%rsi
  800421794a:	48 89 c7             	mov    %rax,%rdi
  800421794d:	48 b8 40 f0 20 04 80 	movabs $0x800420f040,%rax
  8004217954:	00 00 00 
  8004217957:	ff d0                	callq  *%rax
  8004217959:	85 c0                	test   %eax,%eax
  800421795b:	78 6b                	js     80042179c8 <spin_unlock+0x194>
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
  800421795d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004217960:	48 98                	cltq   
  8004217962:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
  8004217969:	89 c2                	mov    %eax,%edx
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
  800421796b:	48 8b 85 30 fb ff ff 	mov    -0x4d0(%rbp),%rax
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
  8004217972:	48 29 c2             	sub    %rax,%rdx
  8004217975:	49 89 d0             	mov    %rdx,%r8
  8004217978:	48 8b bd 20 fb ff ff 	mov    -0x4e0(%rbp),%rdi
  800421797f:	8b b5 28 fb ff ff    	mov    -0x4d8(%rbp),%esi
  8004217985:	8b 8d 18 fb ff ff    	mov    -0x4e8(%rbp),%ecx
  800421798b:	48 8b 95 10 fb ff ff 	mov    -0x4f0(%rbp),%rdx
  8004217992:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004217995:	48 98                	cltq   
  8004217997:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  800421799e:	4c 89 04 24          	mov    %r8,(%rsp)
  80042179a2:	49 89 f9             	mov    %rdi,%r9
  80042179a5:	41 89 f0             	mov    %esi,%r8d
  80042179a8:	89 c6                	mov    %eax,%esi
  80042179aa:	48 bf f6 b9 21 04 80 	movabs $0x800421b9f6,%rdi
  80042179b1:	00 00 00 
  80042179b4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042179b9:	49 ba 90 95 20 04 80 	movabs $0x8004209590,%r10
  80042179c0:	00 00 00 
  80042179c3:	41 ff d2             	callq  *%r10
  80042179c6:	eb 29                	jmp    80042179f1 <spin_unlock+0x1bd>
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
			else
				cprintf("  %08x\n", pcs[i]);
  80042179c8:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042179cb:	48 98                	cltq   
  80042179cd:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  80042179d4:	89 c6                	mov    %eax,%esi
  80042179d6:	48 bf 0d ba 21 04 80 	movabs $0x800421ba0d,%rdi
  80042179dd:	00 00 00 
  80042179e0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042179e5:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  80042179ec:	00 00 00 
  80042179ef:	ff d2                	callq  *%rdx
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
  80042179f1:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  80042179f5:	83 7d ec 09          	cmpl   $0x9,-0x14(%rbp)
  80042179f9:	7f 14                	jg     8004217a0f <spin_unlock+0x1db>
  80042179fb:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042179fe:	48 98                	cltq   
  8004217a00:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  8004217a07:	85 c0                	test   %eax,%eax
  8004217a09:	0f 85 23 ff ff ff    	jne    8004217932 <spin_unlock+0xfe>
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
			else
				cprintf("  %08x\n", pcs[i]);
		}
		panic("spin_unlock");
  8004217a0f:	48 ba 15 ba 21 04 80 	movabs $0x800421ba15,%rdx
  8004217a16:	00 00 00 
  8004217a19:	be 6c 00 00 00       	mov    $0x6c,%esi
  8004217a1e:	48 bf 6a b9 21 04 80 	movabs $0x800421b96a,%rdi
  8004217a25:	00 00 00 
  8004217a28:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217a2d:	48 b9 e4 05 20 04 80 	movabs $0x80042005e4,%rcx
  8004217a34:	00 00 00 
  8004217a37:	ff d1                	callq  *%rcx
	}

	lk->pcs[0] = 0;
  8004217a39:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004217a40:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  8004217a47:	00 
	lk->cpu = 0;
  8004217a48:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004217a4f:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  8004217a56:	00 
	// But the 2007 Intel 64 Architecture Memory Ordering White
	// Paper says that Intel 64 and IA-32 will not move a load
	// after a store. So lock->locked = 0 would work here.
	// The xchg being asm volatile ensures gcc emits it after
	// the above assignments (and after the critical section).
	xchg(&lk->locked, 0);
  8004217a57:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004217a5e:	be 00 00 00 00       	mov    $0x0,%esi
  8004217a63:	48 89 c7             	mov    %rax,%rdi
  8004217a66:	48 b8 0c 76 21 04 80 	movabs $0x800421760c,%rax
  8004217a6d:	00 00 00 
  8004217a70:	ff d0                	callq  *%rax
}
  8004217a72:	48 81 c4 20 05 00 00 	add    $0x520,%rsp
  8004217a79:	5b                   	pop    %rbx
  8004217a7a:	41 5c                	pop    %r12
  8004217a7c:	5d                   	pop    %rbp
  8004217a7d:	c3                   	retq   

0000008004217a7e <e1000_attach>:
static struct rx_desc rx_ring[RX_RING_SIZE] __attribute__((aligned(16)));
static char rx_data[RX_RING_SIZE][2048];

int
e1000_attach(struct pci_func *pcif)
{
  8004217a7e:	55                   	push   %rbp
  8004217a7f:	48 89 e5             	mov    %rsp,%rbp
  8004217a82:	48 83 ec 40          	sub    $0x40,%rsp
  8004217a86:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
	int i;

	pci_func_enable(pcif);
  8004217a8a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004217a8e:	48 89 c7             	mov    %rax,%rdi
  8004217a91:	48 b8 3b 89 21 04 80 	movabs $0x800421893b,%rax
  8004217a98:	00 00 00 
  8004217a9b:	ff d0                	callq  *%rax

	// [E1000 Table 4-2] BAR 0 gives the register base address.
	regs = mmio_map_region(pcif->reg_base[0], pcif->reg_size[0]);
  8004217a9d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004217aa1:	8b 40 30             	mov    0x30(%rax),%eax
  8004217aa4:	89 c2                	mov    %eax,%edx
  8004217aa6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004217aaa:	8b 40 18             	mov    0x18(%rax),%eax
  8004217aad:	89 c0                	mov    %eax,%eax
  8004217aaf:	48 89 d6             	mov    %rdx,%rsi
  8004217ab2:	48 89 c7             	mov    %rax,%rdi
  8004217ab5:	48 b8 8f 40 20 04 80 	movabs $0x800420408f,%rax
  8004217abc:	00 00 00 
  8004217abf:	ff d0                	callq  *%rax
  8004217ac1:	48 ba 20 e7 49 04 80 	movabs $0x800449e720,%rdx
  8004217ac8:	00 00 00 
  8004217acb:	48 89 02             	mov    %rax,(%rdx)

	// [E1000 14.5] Transmit initialization
	for (i = 0; i < TX_RING_SIZE; i++) {
  8004217ace:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004217ad5:	e9 a9 00 00 00       	jmpq   8004217b83 <e1000_attach+0x105>
		tx_ring[i].addr = PADDR(tx_data[i]);
  8004217ada:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004217add:	48 98                	cltq   
  8004217adf:	48 69 d0 ee 05 00 00 	imul   $0x5ee,%rax,%rdx
  8004217ae6:	48 b8 40 e8 49 04 80 	movabs $0x800449e840,%rax
  8004217aed:	00 00 00 
  8004217af0:	48 01 d0             	add    %rdx,%rax
  8004217af3:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004217af7:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004217afe:	00 00 00 
  8004217b01:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  8004217b05:	77 32                	ja     8004217b39 <e1000_attach+0xbb>
  8004217b07:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004217b0b:	48 89 c1             	mov    %rax,%rcx
  8004217b0e:	48 ba 28 ba 21 04 80 	movabs $0x800421ba28,%rdx
  8004217b15:	00 00 00 
  8004217b18:	be 97 00 00 00       	mov    $0x97,%esi
  8004217b1d:	48 bf 4c ba 21 04 80 	movabs $0x800421ba4c,%rdi
  8004217b24:	00 00 00 
  8004217b27:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217b2c:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004217b33:	00 00 00 
  8004217b36:	41 ff d0             	callq  *%r8
  8004217b39:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004217b40:	ff ff ff 
  8004217b43:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004217b47:	48 01 c2             	add    %rax,%rdx
  8004217b4a:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  8004217b51:	00 00 00 
  8004217b54:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004217b57:	48 63 c9             	movslq %ecx,%rcx
  8004217b5a:	48 c1 e1 04          	shl    $0x4,%rcx
  8004217b5e:	48 01 c8             	add    %rcx,%rax
  8004217b61:	48 89 10             	mov    %rdx,(%rax)
		tx_ring[i].status = E1000_TXD_STAT_DD;
  8004217b64:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  8004217b6b:	00 00 00 
  8004217b6e:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004217b71:	48 63 d2             	movslq %edx,%rdx
  8004217b74:	48 c1 e2 04          	shl    $0x4,%rdx
  8004217b78:	48 01 d0             	add    %rdx,%rax
  8004217b7b:	c6 40 0c 01          	movb   $0x1,0xc(%rax)

	// [E1000 Table 4-2] BAR 0 gives the register base address.
	regs = mmio_map_region(pcif->reg_base[0], pcif->reg_size[0]);

	// [E1000 14.5] Transmit initialization
	for (i = 0; i < TX_RING_SIZE; i++) {
  8004217b7f:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004217b83:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
  8004217b87:	0f 8e 4d ff ff ff    	jle    8004217ada <e1000_attach+0x5c>
		tx_ring[i].addr = PADDR(tx_data[i]);
		tx_ring[i].status = E1000_TXD_STAT_DD;
	}
	regs[E1000_TDBAL] = PADDR(tx_ring);
  8004217b8d:	48 b8 20 e7 49 04 80 	movabs $0x800449e720,%rax
  8004217b94:	00 00 00 
  8004217b97:	48 8b 00             	mov    (%rax),%rax
  8004217b9a:	48 8d 90 00 38 00 00 	lea    0x3800(%rax),%rdx
  8004217ba1:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  8004217ba8:	00 00 00 
  8004217bab:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004217baf:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004217bb6:	00 00 00 
  8004217bb9:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  8004217bbd:	77 32                	ja     8004217bf1 <e1000_attach+0x173>
  8004217bbf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217bc3:	48 89 c1             	mov    %rax,%rcx
  8004217bc6:	48 ba 28 ba 21 04 80 	movabs $0x800421ba28,%rdx
  8004217bcd:	00 00 00 
  8004217bd0:	be 9a 00 00 00       	mov    $0x9a,%esi
  8004217bd5:	48 bf 4c ba 21 04 80 	movabs $0x800421ba4c,%rdi
  8004217bdc:	00 00 00 
  8004217bdf:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217be4:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004217beb:	00 00 00 
  8004217bee:	41 ff d0             	callq  *%r8
  8004217bf1:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  8004217bf8:	ff ff ff 
  8004217bfb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217bff:	48 01 c8             	add    %rcx,%rax
  8004217c02:	89 02                	mov    %eax,(%rdx)
	static_assert(sizeof(tx_ring) % 128 == 0);
	regs[E1000_TDLEN] = sizeof(tx_ring);
  8004217c04:	48 b8 20 e7 49 04 80 	movabs $0x800449e720,%rax
  8004217c0b:	00 00 00 
  8004217c0e:	48 8b 00             	mov    (%rax),%rax
  8004217c11:	48 05 08 38 00 00    	add    $0x3808,%rax
  8004217c17:	c7 00 00 01 00 00    	movl   $0x100,(%rax)
	regs[E1000_TDH] = regs[E1000_TDT] = 0;
  8004217c1d:	48 b8 20 e7 49 04 80 	movabs $0x800449e720,%rax
  8004217c24:	00 00 00 
  8004217c27:	48 8b 00             	mov    (%rax),%rax
  8004217c2a:	48 8d 90 10 38 00 00 	lea    0x3810(%rax),%rdx
  8004217c31:	48 b8 20 e7 49 04 80 	movabs $0x800449e720,%rax
  8004217c38:	00 00 00 
  8004217c3b:	48 8b 00             	mov    (%rax),%rax
  8004217c3e:	48 8d 88 18 38 00 00 	lea    0x3818(%rax),%rcx
  8004217c45:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217c4a:	89 01                	mov    %eax,(%rcx)
  8004217c4c:	89 02                	mov    %eax,(%rdx)
	regs[E1000_TCTL] = (E1000_TCTL_EN | E1000_TCTL_PSP |
  8004217c4e:	48 b8 20 e7 49 04 80 	movabs $0x800449e720,%rax
  8004217c55:	00 00 00 
  8004217c58:	48 8b 00             	mov    (%rax),%rax
  8004217c5b:	48 05 00 04 00 00    	add    $0x400,%rax
  8004217c61:	c7 00 0a 01 04 00    	movl   $0x4010a,(%rax)
			    (0x10 << E1000_TCTL_CT_SHIFT) |
			    (0x40 << E1000_TCTL_COLD_SHIFT));
	regs[E1000_TIPG] = 10 | (8<<10) | (6<<20);
  8004217c67:	48 b8 20 e7 49 04 80 	movabs $0x800449e720,%rax
  8004217c6e:	00 00 00 
  8004217c71:	48 8b 00             	mov    (%rax),%rax
  8004217c74:	48 05 10 04 00 00    	add    $0x410,%rax
  8004217c7a:	c7 00 0a 20 60 00    	movl   $0x60200a,(%rax)
	regs[E1000_RAH] = regs[E1000_EERD] >> 16;

	regs[E1000_RAH] |= 0x1 << 31;
#endif

	for (i = 0; i < RX_RING_SIZE; i++) {
  8004217c80:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004217c87:	e9 8e 00 00 00       	jmpq   8004217d1a <e1000_attach+0x29c>
		rx_ring[i].addr = PADDR(rx_data[i]);
  8004217c8c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004217c8f:	48 98                	cltq   
  8004217c91:	48 c1 e0 0b          	shl    $0xb,%rax
  8004217c95:	48 89 c2             	mov    %rax,%rdx
  8004217c98:	48 b8 a0 85 4a 04 80 	movabs $0x80044a85a0,%rax
  8004217c9f:	00 00 00 
  8004217ca2:	48 01 d0             	add    %rdx,%rax
  8004217ca5:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004217ca9:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004217cb0:	00 00 00 
  8004217cb3:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  8004217cb7:	77 32                	ja     8004217ceb <e1000_attach+0x26d>
  8004217cb9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217cbd:	48 89 c1             	mov    %rax,%rcx
  8004217cc0:	48 ba 28 ba 21 04 80 	movabs $0x800421ba28,%rdx
  8004217cc7:	00 00 00 
  8004217cca:	be b8 00 00 00       	mov    $0xb8,%esi
  8004217ccf:	48 bf 4c ba 21 04 80 	movabs $0x800421ba4c,%rdi
  8004217cd6:	00 00 00 
  8004217cd9:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217cde:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004217ce5:	00 00 00 
  8004217ce8:	41 ff d0             	callq  *%r8
  8004217ceb:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004217cf2:	ff ff ff 
  8004217cf5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217cf9:	48 01 c2             	add    %rax,%rdx
  8004217cfc:	48 b8 20 47 4a 04 80 	movabs $0x80044a4720,%rax
  8004217d03:	00 00 00 
  8004217d06:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004217d09:	48 63 c9             	movslq %ecx,%rcx
  8004217d0c:	48 c1 e1 04          	shl    $0x4,%rcx
  8004217d10:	48 01 c8             	add    %rcx,%rax
  8004217d13:	48 89 10             	mov    %rdx,(%rax)
	regs[E1000_RAH] = regs[E1000_EERD] >> 16;

	regs[E1000_RAH] |= 0x1 << 31;
#endif

	for (i = 0; i < RX_RING_SIZE; i++) {
  8004217d16:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004217d1a:	81 7d fc e7 03 00 00 	cmpl   $0x3e7,-0x4(%rbp)
  8004217d21:	0f 8e 65 ff ff ff    	jle    8004217c8c <e1000_attach+0x20e>
		rx_ring[i].addr = PADDR(rx_data[i]);
	}
	regs[E1000_RDBAL] = PADDR(rx_ring);
  8004217d27:	48 b8 20 e7 49 04 80 	movabs $0x800449e720,%rax
  8004217d2e:	00 00 00 
  8004217d31:	48 8b 00             	mov    (%rax),%rax
  8004217d34:	48 8d 90 00 28 00 00 	lea    0x2800(%rax),%rdx
  8004217d3b:	48 b8 20 47 4a 04 80 	movabs $0x80044a4720,%rax
  8004217d42:	00 00 00 
  8004217d45:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004217d49:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004217d50:	00 00 00 
  8004217d53:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  8004217d57:	77 32                	ja     8004217d8b <e1000_attach+0x30d>
  8004217d59:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217d5d:	48 89 c1             	mov    %rax,%rcx
  8004217d60:	48 ba 28 ba 21 04 80 	movabs $0x800421ba28,%rdx
  8004217d67:	00 00 00 
  8004217d6a:	be ba 00 00 00       	mov    $0xba,%esi
  8004217d6f:	48 bf 4c ba 21 04 80 	movabs $0x800421ba4c,%rdi
  8004217d76:	00 00 00 
  8004217d79:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217d7e:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004217d85:	00 00 00 
  8004217d88:	41 ff d0             	callq  *%r8
  8004217d8b:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  8004217d92:	ff ff ff 
  8004217d95:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217d99:	48 01 c8             	add    %rcx,%rax
  8004217d9c:	89 02                	mov    %eax,(%rdx)
	static_assert(sizeof(rx_ring) % 128 == 0);
	regs[E1000_RDLEN] = sizeof(rx_ring);
  8004217d9e:	48 b8 20 e7 49 04 80 	movabs $0x800449e720,%rax
  8004217da5:	00 00 00 
  8004217da8:	48 8b 00             	mov    (%rax),%rax
  8004217dab:	48 05 08 28 00 00    	add    $0x2808,%rax
  8004217db1:	c7 00 80 3e 00 00    	movl   $0x3e80,(%rax)
	regs[E1000_RDH] = 0;
  8004217db7:	48 b8 20 e7 49 04 80 	movabs $0x800449e720,%rax
  8004217dbe:	00 00 00 
  8004217dc1:	48 8b 00             	mov    (%rax),%rax
  8004217dc4:	48 05 10 28 00 00    	add    $0x2810,%rax
  8004217dca:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
	regs[E1000_RDT] = RX_RING_SIZE - 1;
  8004217dd0:	48 b8 20 e7 49 04 80 	movabs $0x800449e720,%rax
  8004217dd7:	00 00 00 
  8004217dda:	48 8b 00             	mov    (%rax),%rax
  8004217ddd:	48 05 18 28 00 00    	add    $0x2818,%rax
  8004217de3:	c7 00 e7 03 00 00    	movl   $0x3e7,(%rax)
	// Strip CRC because that's what the grade script expects
	regs[E1000_RCTL] = E1000_RCTL_EN | E1000_RCTL_BAM | E1000_RCTL_SZ_2048
  8004217de9:	48 b8 20 e7 49 04 80 	movabs $0x800449e720,%rax
  8004217df0:	00 00 00 
  8004217df3:	48 8b 00             	mov    (%rax),%rax
  8004217df6:	48 05 00 01 00 00    	add    $0x100,%rax
  8004217dfc:	c7 00 02 80 00 04    	movl   $0x4008002,(%rax)
		| E1000_RCTL_SECRC;

	return 0;
  8004217e02:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004217e07:	c9                   	leaveq 
  8004217e08:	c3                   	retq   

0000008004217e09 <e1000_transmit>:

int
e1000_transmit(const char *buf, unsigned int len)
{
  8004217e09:	55                   	push   %rbp
  8004217e0a:	48 89 e5             	mov    %rsp,%rbp
  8004217e0d:	48 83 ec 20          	sub    $0x20,%rsp
  8004217e11:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004217e15:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	if (!regs || len > DATA_MAX)
  8004217e18:	48 b8 20 e7 49 04 80 	movabs $0x800449e720,%rax
  8004217e1f:	00 00 00 
  8004217e22:	48 8b 00             	mov    (%rax),%rax
  8004217e25:	48 85 c0             	test   %rax,%rax
  8004217e28:	74 09                	je     8004217e33 <e1000_transmit+0x2a>
  8004217e2a:	81 7d e4 ee 05 00 00 	cmpl   $0x5ee,-0x1c(%rbp)
  8004217e31:	76 0a                	jbe    8004217e3d <e1000_transmit+0x34>
		return -E_INVAL;
  8004217e33:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  8004217e38:	e9 39 01 00 00       	jmpq   8004217f76 <e1000_transmit+0x16d>

	int tail = regs[E1000_TDT];
  8004217e3d:	48 b8 20 e7 49 04 80 	movabs $0x800449e720,%rax
  8004217e44:	00 00 00 
  8004217e47:	48 8b 00             	mov    (%rax),%rax
  8004217e4a:	48 05 18 38 00 00    	add    $0x3818,%rax
  8004217e50:	8b 00                	mov    (%rax),%eax
  8004217e52:	89 45 fc             	mov    %eax,-0x4(%rbp)

	// [E1000 3.3.3.2] Check if this descriptor is done.
	// According to [E1000 13.4.39], using TDH for this is not
	// reliable.
	if (!(tx_ring[tail].status & E1000_TXD_STAT_DD)) {
  8004217e55:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  8004217e5c:	00 00 00 
  8004217e5f:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004217e62:	48 63 d2             	movslq %edx,%rdx
  8004217e65:	48 c1 e2 04          	shl    $0x4,%rdx
  8004217e69:	48 01 d0             	add    %rdx,%rax
  8004217e6c:	0f b6 40 0c          	movzbl 0xc(%rax),%eax
  8004217e70:	0f b6 c0             	movzbl %al,%eax
  8004217e73:	83 e0 01             	and    $0x1,%eax
  8004217e76:	85 c0                	test   %eax,%eax
  8004217e78:	75 25                	jne    8004217e9f <e1000_transmit+0x96>
		cprintf("TX ring overflow\n");
  8004217e7a:	48 bf 59 ba 21 04 80 	movabs $0x800421ba59,%rdi
  8004217e81:	00 00 00 
  8004217e84:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217e89:	48 ba 90 95 20 04 80 	movabs $0x8004209590,%rdx
  8004217e90:	00 00 00 
  8004217e93:	ff d2                	callq  *%rdx
		return 0;
  8004217e95:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217e9a:	e9 d7 00 00 00       	jmpq   8004217f76 <e1000_transmit+0x16d>
	}

	// Fill in the next descriptor
	memmove(tx_data[tail], buf, len);
  8004217e9f:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004217ea2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004217ea5:	48 98                	cltq   
  8004217ea7:	48 69 c8 ee 05 00 00 	imul   $0x5ee,%rax,%rcx
  8004217eae:	48 b8 40 e8 49 04 80 	movabs $0x800449e840,%rax
  8004217eb5:	00 00 00 
  8004217eb8:	48 01 c1             	add    %rax,%rcx
  8004217ebb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217ebf:	48 89 c6             	mov    %rax,%rsi
  8004217ec2:	48 89 cf             	mov    %rcx,%rdi
  8004217ec5:	48 b8 5f 04 21 04 80 	movabs $0x800421045f,%rax
  8004217ecc:	00 00 00 
  8004217ecf:	ff d0                	callq  *%rax
	tx_ring[tail].length = len;
  8004217ed1:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004217ed4:	48 ba 30 e7 49 04 80 	movabs $0x800449e730,%rdx
  8004217edb:	00 00 00 
  8004217ede:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004217ee1:	48 63 c9             	movslq %ecx,%rcx
  8004217ee4:	48 c1 e1 04          	shl    $0x4,%rcx
  8004217ee8:	48 01 ca             	add    %rcx,%rdx
  8004217eeb:	66 89 42 08          	mov    %ax,0x8(%rdx)
	tx_ring[tail].status &= ~E1000_TXD_STAT_DD;
  8004217eef:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  8004217ef6:	00 00 00 
  8004217ef9:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004217efc:	48 63 d2             	movslq %edx,%rdx
  8004217eff:	48 c1 e2 04          	shl    $0x4,%rdx
  8004217f03:	48 01 d0             	add    %rdx,%rax
  8004217f06:	0f b6 40 0c          	movzbl 0xc(%rax),%eax
  8004217f0a:	83 e0 fe             	and    $0xfffffffe,%eax
  8004217f0d:	89 c2                	mov    %eax,%edx
  8004217f0f:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  8004217f16:	00 00 00 
  8004217f19:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004217f1c:	48 63 c9             	movslq %ecx,%rcx
  8004217f1f:	48 c1 e1 04          	shl    $0x4,%rcx
  8004217f23:	48 01 c8             	add    %rcx,%rax
  8004217f26:	88 50 0c             	mov    %dl,0xc(%rax)
	// Set EOP to actually send this packet.  Set RS to get DD
	// status bit when sent.
	tx_ring[tail].cmd = E1000_TXD_CMD_EOP | E1000_TXD_CMD_RS;
  8004217f29:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  8004217f30:	00 00 00 
  8004217f33:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004217f36:	48 63 d2             	movslq %edx,%rdx
  8004217f39:	48 c1 e2 04          	shl    $0x4,%rdx
  8004217f3d:	48 01 d0             	add    %rdx,%rax
  8004217f40:	c6 40 0b 09          	movb   $0x9,0xb(%rax)

	// Move the tail pointer
	regs[E1000_TDT] = (tail + 1) % TX_RING_SIZE;
  8004217f44:	48 b8 20 e7 49 04 80 	movabs $0x800449e720,%rax
  8004217f4b:	00 00 00 
  8004217f4e:	48 8b 00             	mov    (%rax),%rax
  8004217f51:	48 8d 88 18 38 00 00 	lea    0x3818(%rax),%rcx
  8004217f58:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004217f5b:	8d 50 01             	lea    0x1(%rax),%edx
  8004217f5e:	89 d0                	mov    %edx,%eax
  8004217f60:	c1 f8 1f             	sar    $0x1f,%eax
  8004217f63:	c1 e8 1c             	shr    $0x1c,%eax
  8004217f66:	01 c2                	add    %eax,%edx
  8004217f68:	83 e2 0f             	and    $0xf,%edx
  8004217f6b:	29 c2                	sub    %eax,%edx
  8004217f6d:	89 d0                	mov    %edx,%eax
  8004217f6f:	89 01                	mov    %eax,(%rcx)

	return 0;
  8004217f71:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004217f76:	c9                   	leaveq 
  8004217f77:	c3                   	retq   

0000008004217f78 <e1000_receive>:

int
e1000_receive(char *buf, unsigned int len)
{
  8004217f78:	55                   	push   %rbp
  8004217f79:	48 89 e5             	mov    %rsp,%rbp
  8004217f7c:	48 83 ec 20          	sub    $0x20,%rsp
  8004217f80:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004217f84:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	if (!regs)
  8004217f87:	48 b8 20 e7 49 04 80 	movabs $0x800449e720,%rax
  8004217f8e:	00 00 00 
  8004217f91:	48 8b 00             	mov    (%rax),%rax
  8004217f94:	48 85 c0             	test   %rax,%rax
  8004217f97:	75 0a                	jne    8004217fa3 <e1000_receive+0x2b>
		return 0;
  8004217f99:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217f9e:	e9 59 01 00 00       	jmpq   80042180fc <e1000_receive+0x184>

	int tail = (regs[E1000_RDT] + 1) % RX_RING_SIZE;
  8004217fa3:	48 b8 20 e7 49 04 80 	movabs $0x800449e720,%rax
  8004217faa:	00 00 00 
  8004217fad:	48 8b 00             	mov    (%rax),%rax
  8004217fb0:	48 05 18 28 00 00    	add    $0x2818,%rax
  8004217fb6:	8b 00                	mov    (%rax),%eax
  8004217fb8:	8d 48 01             	lea    0x1(%rax),%ecx
  8004217fbb:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  8004217fc0:	89 c8                	mov    %ecx,%eax
  8004217fc2:	f7 e2                	mul    %edx
  8004217fc4:	89 d0                	mov    %edx,%eax
  8004217fc6:	c1 e8 06             	shr    $0x6,%eax
  8004217fc9:	69 c0 e8 03 00 00    	imul   $0x3e8,%eax,%eax
  8004217fcf:	29 c1                	sub    %eax,%ecx
  8004217fd1:	89 c8                	mov    %ecx,%eax
  8004217fd3:	89 45 fc             	mov    %eax,-0x4(%rbp)

	// Check if the descriptor has been filled
	if (!(rx_ring[tail].status & E1000_RXD_STAT_DD))
  8004217fd6:	48 b8 20 47 4a 04 80 	movabs $0x80044a4720,%rax
  8004217fdd:	00 00 00 
  8004217fe0:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004217fe3:	48 63 d2             	movslq %edx,%rdx
  8004217fe6:	48 c1 e2 04          	shl    $0x4,%rdx
  8004217fea:	48 01 d0             	add    %rdx,%rax
  8004217fed:	0f b6 40 0c          	movzbl 0xc(%rax),%eax
  8004217ff1:	0f b6 c0             	movzbl %al,%eax
  8004217ff4:	83 e0 01             	and    $0x1,%eax
  8004217ff7:	85 c0                	test   %eax,%eax
  8004217ff9:	75 0a                	jne    8004218005 <e1000_receive+0x8d>
		return 0;
  8004217ffb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218000:	e9 f7 00 00 00       	jmpq   80042180fc <e1000_receive+0x184>
	assert(rx_ring[tail].status & E1000_RXD_STAT_EOP);
  8004218005:	48 b8 20 47 4a 04 80 	movabs $0x80044a4720,%rax
  800421800c:	00 00 00 
  800421800f:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004218012:	48 63 d2             	movslq %edx,%rdx
  8004218015:	48 c1 e2 04          	shl    $0x4,%rdx
  8004218019:	48 01 d0             	add    %rdx,%rax
  800421801c:	0f b6 40 0c          	movzbl 0xc(%rax),%eax
  8004218020:	0f b6 c0             	movzbl %al,%eax
  8004218023:	83 e0 02             	and    $0x2,%eax
  8004218026:	85 c0                	test   %eax,%eax
  8004218028:	75 35                	jne    800421805f <e1000_receive+0xe7>
  800421802a:	48 b9 70 ba 21 04 80 	movabs $0x800421ba70,%rcx
  8004218031:	00 00 00 
  8004218034:	48 ba 9a ba 21 04 80 	movabs $0x800421ba9a,%rdx
  800421803b:	00 00 00 
  800421803e:	be ef 00 00 00       	mov    $0xef,%esi
  8004218043:	48 bf 4c ba 21 04 80 	movabs $0x800421ba4c,%rdi
  800421804a:	00 00 00 
  800421804d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218052:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004218059:	00 00 00 
  800421805c:	41 ff d0             	callq  *%r8

	// Copy the packet data
	len = MIN(len, rx_ring[tail].length);
  800421805f:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004218062:	89 45 f8             	mov    %eax,-0x8(%rbp)
  8004218065:	48 b8 20 47 4a 04 80 	movabs $0x80044a4720,%rax
  800421806c:	00 00 00 
  800421806f:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004218072:	48 63 d2             	movslq %edx,%rdx
  8004218075:	48 c1 e2 04          	shl    $0x4,%rdx
  8004218079:	48 01 d0             	add    %rdx,%rax
  800421807c:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004218080:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
  8004218084:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  8004218088:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421808b:	39 c2                	cmp    %eax,%edx
  800421808d:	0f 46 c2             	cmovbe %edx,%eax
  8004218090:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	memmove(buf, rx_data[tail], len);
  8004218093:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004218096:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004218099:	48 98                	cltq   
  800421809b:	48 c1 e0 0b          	shl    $0xb,%rax
  800421809f:	48 89 c1             	mov    %rax,%rcx
  80042180a2:	48 b8 a0 85 4a 04 80 	movabs $0x80044a85a0,%rax
  80042180a9:	00 00 00 
  80042180ac:	48 01 c1             	add    %rax,%rcx
  80042180af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042180b3:	48 89 ce             	mov    %rcx,%rsi
  80042180b6:	48 89 c7             	mov    %rax,%rdi
  80042180b9:	48 b8 5f 04 21 04 80 	movabs $0x800421045f,%rax
  80042180c0:	00 00 00 
  80042180c3:	ff d0                	callq  *%rax
	rx_ring[tail].status = 0;
  80042180c5:	48 b8 20 47 4a 04 80 	movabs $0x80044a4720,%rax
  80042180cc:	00 00 00 
  80042180cf:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042180d2:	48 63 d2             	movslq %edx,%rdx
  80042180d5:	48 c1 e2 04          	shl    $0x4,%rdx
  80042180d9:	48 01 d0             	add    %rdx,%rax
  80042180dc:	c6 40 0c 00          	movb   $0x0,0xc(%rax)

	// Move the tail pointer
	regs[E1000_RDT] = tail;
  80042180e0:	48 b8 20 e7 49 04 80 	movabs $0x800449e720,%rax
  80042180e7:	00 00 00 
  80042180ea:	48 8b 00             	mov    (%rax),%rax
  80042180ed:	48 8d 90 18 28 00 00 	lea    0x2818(%rax),%rdx
  80042180f4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042180f7:	89 02                	mov    %eax,(%rdx)
	return len;
  80042180f9:	8b 45 e4             	mov    -0x1c(%rbp),%eax
}
  80042180fc:	c9                   	leaveq 
  80042180fd:	c3                   	retq   

00000080042180fe <pci_conf1_set_addr>:
static void
pci_conf1_set_addr(uint32_t bus,
		   uint32_t dev,
		   uint32_t func,
		   uint32_t offset)
{
  80042180fe:	55                   	push   %rbp
  80042180ff:	48 89 e5             	mov    %rsp,%rbp
  8004218102:	48 83 ec 20          	sub    $0x20,%rsp
  8004218106:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004218109:	89 75 e8             	mov    %esi,-0x18(%rbp)
  800421810c:	89 55 e4             	mov    %edx,-0x1c(%rbp)
  800421810f:	89 4d e0             	mov    %ecx,-0x20(%rbp)
	assert(bus < 256);
  8004218112:	81 7d ec ff 00 00 00 	cmpl   $0xff,-0x14(%rbp)
  8004218119:	76 35                	jbe    8004218150 <pci_conf1_set_addr+0x52>
  800421811b:	48 b9 b0 ba 21 04 80 	movabs $0x800421bab0,%rcx
  8004218122:	00 00 00 
  8004218125:	48 ba ba ba 21 04 80 	movabs $0x800421baba,%rdx
  800421812c:	00 00 00 
  800421812f:	be 31 00 00 00       	mov    $0x31,%esi
  8004218134:	48 bf cf ba 21 04 80 	movabs $0x800421bacf,%rdi
  800421813b:	00 00 00 
  800421813e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218143:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  800421814a:	00 00 00 
  800421814d:	41 ff d0             	callq  *%r8
	assert(dev < 32);
  8004218150:	83 7d e8 1f          	cmpl   $0x1f,-0x18(%rbp)
  8004218154:	76 35                	jbe    800421818b <pci_conf1_set_addr+0x8d>
  8004218156:	48 b9 da ba 21 04 80 	movabs $0x800421bada,%rcx
  800421815d:	00 00 00 
  8004218160:	48 ba ba ba 21 04 80 	movabs $0x800421baba,%rdx
  8004218167:	00 00 00 
  800421816a:	be 32 00 00 00       	mov    $0x32,%esi
  800421816f:	48 bf cf ba 21 04 80 	movabs $0x800421bacf,%rdi
  8004218176:	00 00 00 
  8004218179:	b8 00 00 00 00       	mov    $0x0,%eax
  800421817e:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  8004218185:	00 00 00 
  8004218188:	41 ff d0             	callq  *%r8
	assert(func < 8);
  800421818b:	83 7d e4 07          	cmpl   $0x7,-0x1c(%rbp)
  800421818f:	76 35                	jbe    80042181c6 <pci_conf1_set_addr+0xc8>
  8004218191:	48 b9 e3 ba 21 04 80 	movabs $0x800421bae3,%rcx
  8004218198:	00 00 00 
  800421819b:	48 ba ba ba 21 04 80 	movabs $0x800421baba,%rdx
  80042181a2:	00 00 00 
  80042181a5:	be 33 00 00 00       	mov    $0x33,%esi
  80042181aa:	48 bf cf ba 21 04 80 	movabs $0x800421bacf,%rdi
  80042181b1:	00 00 00 
  80042181b4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042181b9:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042181c0:	00 00 00 
  80042181c3:	41 ff d0             	callq  *%r8
	assert(offset < 256);
  80042181c6:	81 7d e0 ff 00 00 00 	cmpl   $0xff,-0x20(%rbp)
  80042181cd:	76 35                	jbe    8004218204 <pci_conf1_set_addr+0x106>
  80042181cf:	48 b9 ec ba 21 04 80 	movabs $0x800421baec,%rcx
  80042181d6:	00 00 00 
  80042181d9:	48 ba ba ba 21 04 80 	movabs $0x800421baba,%rdx
  80042181e0:	00 00 00 
  80042181e3:	be 34 00 00 00       	mov    $0x34,%esi
  80042181e8:	48 bf cf ba 21 04 80 	movabs $0x800421bacf,%rdi
  80042181ef:	00 00 00 
  80042181f2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042181f7:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  80042181fe:	00 00 00 
  8004218201:	41 ff d0             	callq  *%r8
	assert((offset & 0x3) == 0);
  8004218204:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004218207:	83 e0 03             	and    $0x3,%eax
  800421820a:	85 c0                	test   %eax,%eax
  800421820c:	74 35                	je     8004218243 <pci_conf1_set_addr+0x145>
  800421820e:	48 b9 f9 ba 21 04 80 	movabs $0x800421baf9,%rcx
  8004218215:	00 00 00 
  8004218218:	48 ba ba ba 21 04 80 	movabs $0x800421baba,%rdx
  800421821f:	00 00 00 
  8004218222:	be 35 00 00 00       	mov    $0x35,%esi
  8004218227:	48 bf cf ba 21 04 80 	movabs $0x800421bacf,%rdi
  800421822e:	00 00 00 
  8004218231:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218236:	49 b8 e4 05 20 04 80 	movabs $0x80042005e4,%r8
  800421823d:	00 00 00 
  8004218240:	41 ff d0             	callq  *%r8

	uint32_t v = (1 << 31) |		// config-space
		(bus << 16) | (dev << 11) | (func << 8) | (offset);
  8004218243:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004218246:	c1 e0 10             	shl    $0x10,%eax
  8004218249:	89 c2                	mov    %eax,%edx
  800421824b:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800421824e:	c1 e0 0b             	shl    $0xb,%eax
  8004218251:	09 c2                	or     %eax,%edx
  8004218253:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004218256:	c1 e0 08             	shl    $0x8,%eax
  8004218259:	09 d0                	or     %edx,%eax
  800421825b:	0b 45 e0             	or     -0x20(%rbp),%eax
	assert(dev < 32);
	assert(func < 8);
	assert(offset < 256);
	assert((offset & 0x3) == 0);

	uint32_t v = (1 << 31) |		// config-space
  800421825e:	0d 00 00 00 80       	or     $0x80000000,%eax
  8004218263:	89 45 fc             	mov    %eax,-0x4(%rbp)
		(bus << 16) | (dev << 11) | (func << 8) | (offset);
	outl(pci_conf1_addr_ioport, v);
  8004218266:	48 b8 e4 c7 22 04 80 	movabs $0x800422c7e4,%rax
  800421826d:	00 00 00 
  8004218270:	8b 00                	mov    (%rax),%eax
  8004218272:	89 45 f8             	mov    %eax,-0x8(%rbp)
  8004218275:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004218278:	89 45 f4             	mov    %eax,-0xc(%rbp)
}

static __inline void
outl(int port, uint32_t data)
{
	__asm __volatile("outl %0,%w1" : : "a" (data), "d" (port));
  800421827b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421827e:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004218281:	ef                   	out    %eax,(%dx)
}
  8004218282:	c9                   	leaveq 
  8004218283:	c3                   	retq   

0000008004218284 <pci_conf_read>:

static uint32_t
pci_conf_read(struct pci_func *f, uint32_t off)
{
  8004218284:	55                   	push   %rbp
  8004218285:	48 89 e5             	mov    %rsp,%rbp
  8004218288:	48 83 ec 20          	sub    $0x20,%rsp
  800421828c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004218290:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	pci_conf1_set_addr(f->bus->busno, f->dev, f->func, off);
  8004218293:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218297:	8b 50 0c             	mov    0xc(%rax),%edx
  800421829a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421829e:	8b 70 08             	mov    0x8(%rax),%esi
  80042182a1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042182a5:	48 8b 00             	mov    (%rax),%rax
  80042182a8:	8b 40 08             	mov    0x8(%rax),%eax
  80042182ab:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  80042182ae:	89 c7                	mov    %eax,%edi
  80042182b0:	48 b8 fe 80 21 04 80 	movabs $0x80042180fe,%rax
  80042182b7:	00 00 00 
  80042182ba:	ff d0                	callq  *%rax
	return inl(pci_conf1_data_ioport);
  80042182bc:	48 b8 e8 c7 22 04 80 	movabs $0x800422c7e8,%rax
  80042182c3:	00 00 00 
  80042182c6:	8b 00                	mov    (%rax),%eax
  80042182c8:	89 45 fc             	mov    %eax,-0x4(%rbp)

static __inline uint32_t
inl(int port)
{
	uint32_t data;
	__asm __volatile("inl %w1,%0" : "=a" (data) : "d" (port));
  80042182cb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042182ce:	89 c2                	mov    %eax,%edx
  80042182d0:	ed                   	in     (%dx),%eax
  80042182d1:	89 45 f8             	mov    %eax,-0x8(%rbp)
	return data;
  80042182d4:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
  80042182d7:	c9                   	leaveq 
  80042182d8:	c3                   	retq   

00000080042182d9 <pci_conf_write>:

static void
pci_conf_write(struct pci_func *f, uint32_t off, uint32_t v)
{
  80042182d9:	55                   	push   %rbp
  80042182da:	48 89 e5             	mov    %rsp,%rbp
  80042182dd:	48 83 ec 20          	sub    $0x20,%rsp
  80042182e1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042182e5:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  80042182e8:	89 55 e0             	mov    %edx,-0x20(%rbp)
	pci_conf1_set_addr(f->bus->busno, f->dev, f->func, off);
  80042182eb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042182ef:	8b 50 0c             	mov    0xc(%rax),%edx
  80042182f2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042182f6:	8b 70 08             	mov    0x8(%rax),%esi
  80042182f9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042182fd:	48 8b 00             	mov    (%rax),%rax
  8004218300:	8b 40 08             	mov    0x8(%rax),%eax
  8004218303:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8004218306:	89 c7                	mov    %eax,%edi
  8004218308:	48 b8 fe 80 21 04 80 	movabs $0x80042180fe,%rax
  800421830f:	00 00 00 
  8004218312:	ff d0                	callq  *%rax
	outl(pci_conf1_data_ioport, v);
  8004218314:	48 b8 e8 c7 22 04 80 	movabs $0x800422c7e8,%rax
  800421831b:	00 00 00 
  800421831e:	8b 00                	mov    (%rax),%eax
  8004218320:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8004218323:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004218326:	89 45 f8             	mov    %eax,-0x8(%rbp)
}

static __inline void
outl(int port, uint32_t data)
{
	__asm __volatile("outl %0,%w1" : : "a" (data), "d" (port));
  8004218329:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421832c:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800421832f:	ef                   	out    %eax,(%dx)
}
  8004218330:	c9                   	leaveq 
  8004218331:	c3                   	retq   

0000008004218332 <pci_attach_match>:

static int __attribute__((warn_unused_result))
pci_attach_match(uint32_t key1, uint32_t key2,
		 struct pci_driver *list, struct pci_func *pcif)
{
  8004218332:	55                   	push   %rbp
  8004218333:	48 89 e5             	mov    %rsp,%rbp
  8004218336:	48 83 ec 30          	sub    $0x30,%rsp
  800421833a:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800421833d:	89 75 e8             	mov    %esi,-0x18(%rbp)
  8004218340:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  8004218344:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
	uint32_t i;

	for (i = 0; list[i].attachfn; i++) {
  8004218348:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800421834f:	e9 aa 00 00 00       	jmpq   80042183fe <pci_attach_match+0xcc>
		if (list[i].key1 == key1 && list[i].key2 == key2) {
  8004218354:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004218357:	48 c1 e0 04          	shl    $0x4,%rax
  800421835b:	48 89 c2             	mov    %rax,%rdx
  800421835e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004218362:	48 01 d0             	add    %rdx,%rax
  8004218365:	8b 00                	mov    (%rax),%eax
  8004218367:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  800421836a:	0f 85 8a 00 00 00    	jne    80042183fa <pci_attach_match+0xc8>
  8004218370:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004218373:	48 c1 e0 04          	shl    $0x4,%rax
  8004218377:	48 89 c2             	mov    %rax,%rdx
  800421837a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421837e:	48 01 d0             	add    %rdx,%rax
  8004218381:	8b 40 04             	mov    0x4(%rax),%eax
  8004218384:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  8004218387:	75 71                	jne    80042183fa <pci_attach_match+0xc8>
			int r = list[i].attachfn(pcif);
  8004218389:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421838c:	48 c1 e0 04          	shl    $0x4,%rax
  8004218390:	48 89 c2             	mov    %rax,%rdx
  8004218393:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004218397:	48 01 d0             	add    %rdx,%rax
  800421839a:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421839e:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042183a2:	48 89 d7             	mov    %rdx,%rdi
  80042183a5:	ff d0                	callq  *%rax
  80042183a7:	89 45 f8             	mov    %eax,-0x8(%rbp)
			if (r > 0)
  80042183aa:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  80042183ae:	7e 05                	jle    80042183b5 <pci_attach_match+0x83>
				return r;
  80042183b0:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042183b3:	eb 6c                	jmp    8004218421 <pci_attach_match+0xef>
			if (r < 0)
  80042183b5:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  80042183b9:	79 3f                	jns    80042183fa <pci_attach_match+0xc8>
				cprintf("pci_attach_match: attaching "
					"%x.%x (%p): e\n",
					key1, key2, list[i].attachfn, r);
  80042183bb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042183be:	48 c1 e0 04          	shl    $0x4,%rax
  80042183c2:	48 89 c2             	mov    %rax,%rdx
  80042183c5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042183c9:	48 01 d0             	add    %rdx,%rax
		if (list[i].key1 == key1 && list[i].key2 == key2) {
			int r = list[i].attachfn(pcif);
			if (r > 0)
				return r;
			if (r < 0)
				cprintf("pci_attach_match: attaching "
  80042183cc:	48 8b 48 08          	mov    0x8(%rax),%rcx
  80042183d0:	8b 75 f8             	mov    -0x8(%rbp),%esi
  80042183d3:	8b 55 e8             	mov    -0x18(%rbp),%edx
  80042183d6:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042183d9:	41 89 f0             	mov    %esi,%r8d
  80042183dc:	89 c6                	mov    %eax,%esi
  80042183de:	48 bf 10 bb 21 04 80 	movabs $0x800421bb10,%rdi
  80042183e5:	00 00 00 
  80042183e8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042183ed:	49 b9 90 95 20 04 80 	movabs $0x8004209590,%r9
  80042183f4:	00 00 00 
  80042183f7:	41 ff d1             	callq  *%r9
pci_attach_match(uint32_t key1, uint32_t key2,
		 struct pci_driver *list, struct pci_func *pcif)
{
	uint32_t i;

	for (i = 0; list[i].attachfn; i++) {
  80042183fa:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042183fe:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004218401:	48 c1 e0 04          	shl    $0x4,%rax
  8004218405:	48 89 c2             	mov    %rax,%rdx
  8004218408:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421840c:	48 01 d0             	add    %rdx,%rax
  800421840f:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004218413:	48 85 c0             	test   %rax,%rax
  8004218416:	0f 85 38 ff ff ff    	jne    8004218354 <pci_attach_match+0x22>
				cprintf("pci_attach_match: attaching "
					"%x.%x (%p): e\n",
					key1, key2, list[i].attachfn, r);
		}
	}
	return 0;
  800421841c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004218421:	c9                   	leaveq 
  8004218422:	c3                   	retq   

0000008004218423 <pci_attach>:

static int
pci_attach(struct pci_func *f)
{
  8004218423:	55                   	push   %rbp
  8004218424:	48 89 e5             	mov    %rsp,%rbp
  8004218427:	48 83 ec 10          	sub    $0x10,%rsp
  800421842b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return
		pci_attach_match(PCI_CLASS(f->dev_class),
				 PCI_SUBCLASS(f->dev_class),
  800421842f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004218433:	8b 40 14             	mov    0x14(%rax),%eax
  8004218436:	c1 e8 10             	shr    $0x10,%eax

static int
pci_attach(struct pci_func *f)
{
	return
		pci_attach_match(PCI_CLASS(f->dev_class),
  8004218439:	0f b6 c0             	movzbl %al,%eax
  800421843c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004218440:	8b 52 14             	mov    0x14(%rdx),%edx
  8004218443:	89 d7                	mov    %edx,%edi
  8004218445:	c1 ef 18             	shr    $0x18,%edi
  8004218448:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421844c:	48 89 d1             	mov    %rdx,%rcx
  800421844f:	48 ba 00 c8 22 04 80 	movabs $0x800422c800,%rdx
  8004218456:	00 00 00 
  8004218459:	89 c6                	mov    %eax,%esi
  800421845b:	48 b8 32 83 21 04 80 	movabs $0x8004218332,%rax
  8004218462:	00 00 00 
  8004218465:	ff d0                	callq  *%rax
				 PCI_SUBCLASS(f->dev_class),
				 &pci_attach_class[0], f) ||
  8004218467:	85 c0                	test   %eax,%eax
  8004218469:	75 39                	jne    80042184a4 <pci_attach+0x81>
		pci_attach_match(PCI_VENDOR(f->dev_id),
				 PCI_PRODUCT(f->dev_id),
  800421846b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421846f:	8b 40 10             	mov    0x10(%rax),%eax
{
	return
		pci_attach_match(PCI_CLASS(f->dev_class),
				 PCI_SUBCLASS(f->dev_class),
				 &pci_attach_class[0], f) ||
		pci_attach_match(PCI_VENDOR(f->dev_id),
  8004218472:	c1 e8 10             	shr    $0x10,%eax
  8004218475:	89 c6                	mov    %eax,%esi
  8004218477:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421847b:	8b 40 10             	mov    0x10(%rax),%eax
  800421847e:	0f b7 c0             	movzwl %ax,%eax
  8004218481:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004218485:	48 89 d1             	mov    %rdx,%rcx
  8004218488:	48 ba 20 c8 22 04 80 	movabs $0x800422c820,%rdx
  800421848f:	00 00 00 
  8004218492:	89 c7                	mov    %eax,%edi
  8004218494:	48 b8 32 83 21 04 80 	movabs $0x8004218332,%rax
  800421849b:	00 00 00 
  800421849e:	ff d0                	callq  *%rax
pci_attach(struct pci_func *f)
{
	return
		pci_attach_match(PCI_CLASS(f->dev_class),
				 PCI_SUBCLASS(f->dev_class),
				 &pci_attach_class[0], f) ||
  80042184a0:	85 c0                	test   %eax,%eax
  80042184a2:	74 07                	je     80042184ab <pci_attach+0x88>
  80042184a4:	b8 01 00 00 00       	mov    $0x1,%eax
  80042184a9:	eb 05                	jmp    80042184b0 <pci_attach+0x8d>
  80042184ab:	b8 00 00 00 00       	mov    $0x0,%eax
		pci_attach_match(PCI_VENDOR(f->dev_id),
				 PCI_PRODUCT(f->dev_id),
				 &pci_attach_vendor[0], f);
}
  80042184b0:	c9                   	leaveq 
  80042184b1:	c3                   	retq   

00000080042184b2 <pci_print_func>:
	[0x6] = "Bridge device",
};

static void
pci_print_func(struct pci_func *f)
{
  80042184b2:	55                   	push   %rbp
  80042184b3:	48 89 e5             	mov    %rsp,%rbp
  80042184b6:	48 83 ec 40          	sub    $0x40,%rsp
  80042184ba:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	const char *class = pci_class[0];
  80042184be:	48 b8 40 c8 22 04 80 	movabs $0x800422c840,%rax
  80042184c5:	00 00 00 
  80042184c8:	48 8b 00             	mov    (%rax),%rax
  80042184cb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
  80042184cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042184d3:	8b 40 14             	mov    0x14(%rax),%eax
  80042184d6:	c1 e8 18             	shr    $0x18,%eax
  80042184d9:	83 f8 06             	cmp    $0x6,%eax
  80042184dc:	77 20                	ja     80042184fe <pci_print_func+0x4c>
		class = pci_class[PCI_CLASS(f->dev_class)];
  80042184de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042184e2:	8b 40 14             	mov    0x14(%rax),%eax
  80042184e5:	c1 e8 18             	shr    $0x18,%eax
  80042184e8:	89 c2                	mov    %eax,%edx
  80042184ea:	48 b8 40 c8 22 04 80 	movabs $0x800422c840,%rax
  80042184f1:	00 00 00 
  80042184f4:	89 d2                	mov    %edx,%edx
  80042184f6:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80042184fa:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
		f->irq_line);
  80042184fe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218502:	0f b6 40 48          	movzbl 0x48(%rax),%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004218506:	0f b6 f8             	movzbl %al,%edi
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
  8004218509:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421850d:	8b 40 14             	mov    0x14(%rax),%eax
  8004218510:	c1 e8 10             	shr    $0x10,%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004218513:	0f b6 f0             	movzbl %al,%esi
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
  8004218516:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421851a:	8b 40 14             	mov    0x14(%rax),%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  800421851d:	c1 e8 18             	shr    $0x18,%eax
  8004218520:	41 89 c1             	mov    %eax,%r9d
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  8004218523:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218527:	8b 40 10             	mov    0x10(%rax),%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  800421852a:	c1 e8 10             	shr    $0x10,%eax
  800421852d:	41 89 c2             	mov    %eax,%r10d
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  8004218530:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218534:	8b 40 10             	mov    0x10(%rax),%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004218537:	44 0f b7 c0          	movzwl %ax,%r8d
  800421853b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421853f:	8b 48 0c             	mov    0xc(%rax),%ecx
  8004218542:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218546:	8b 50 08             	mov    0x8(%rax),%edx
		f->bus->busno, f->dev, f->func,
  8004218549:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421854d:	48 8b 00             	mov    (%rax),%rax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004218550:	8b 40 08             	mov    0x8(%rax),%eax
  8004218553:	89 7c 24 18          	mov    %edi,0x18(%rsp)
  8004218557:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
  800421855b:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  8004218560:	89 74 24 08          	mov    %esi,0x8(%rsp)
  8004218564:	44 89 0c 24          	mov    %r9d,(%rsp)
  8004218568:	45 89 d1             	mov    %r10d,%r9d
  800421856b:	89 c6                	mov    %eax,%esi
  800421856d:	48 bf b0 bb 21 04 80 	movabs $0x800421bbb0,%rdi
  8004218574:	00 00 00 
  8004218577:	b8 00 00 00 00       	mov    $0x0,%eax
  800421857c:	49 ba 90 95 20 04 80 	movabs $0x8004209590,%r10
  8004218583:	00 00 00 
  8004218586:	41 ff d2             	callq  *%r10
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
		f->irq_line);
}
  8004218589:	c9                   	leaveq 
  800421858a:	c3                   	retq   

000000800421858b <pci_scan_bus>:

static int
pci_scan_bus(struct pci_bus *bus)
{
  800421858b:	55                   	push   %rbp
  800421858c:	48 89 e5             	mov    %rsp,%rbp
  800421858f:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  8004218596:	48 89 bd f8 fe ff ff 	mov    %rdi,-0x108(%rbp)
	int totaldev = 0;
  800421859d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	struct pci_func df;
	memset(&df, 0, sizeof(df));
  80042185a4:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042185a8:	ba 50 00 00 00       	mov    $0x50,%edx
  80042185ad:	be 00 00 00 00       	mov    $0x0,%esi
  80042185b2:	48 89 c7             	mov    %rax,%rdi
  80042185b5:	48 b8 d4 03 21 04 80 	movabs $0x80042103d4,%rax
  80042185bc:	00 00 00 
  80042185bf:	ff d0                	callq  *%rax
	df.bus = bus;
  80042185c1:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  80042185c8:	48 89 45 a0          	mov    %rax,-0x60(%rbp)

	for (df.dev = 0; df.dev < 32; df.dev++) {
  80042185cc:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%rbp)
  80042185d3:	e9 22 02 00 00       	jmpq   80042187fa <pci_scan_bus+0x26f>
		uint32_t bhlc = pci_conf_read(&df, PCI_BHLC_REG);
  80042185d8:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042185dc:	be 0c 00 00 00       	mov    $0xc,%esi
  80042185e1:	48 89 c7             	mov    %rax,%rdi
  80042185e4:	48 b8 84 82 21 04 80 	movabs $0x8004218284,%rax
  80042185eb:	00 00 00 
  80042185ee:	ff d0                	callq  *%rax
  80042185f0:	89 45 f8             	mov    %eax,-0x8(%rbp)
		if (PCI_HDRTYPE_TYPE(bhlc) > 1)	    // Unsupported or no device
  80042185f3:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042185f6:	c1 e8 10             	shr    $0x10,%eax
  80042185f9:	83 e0 7f             	and    $0x7f,%eax
  80042185fc:	83 f8 01             	cmp    $0x1,%eax
  80042185ff:	0f 87 ec 01 00 00    	ja     80042187f1 <pci_scan_bus+0x266>
			continue;

		totaldev++;
  8004218605:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)

		struct pci_func f = df;
  8004218609:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421860d:	48 89 85 00 ff ff ff 	mov    %rax,-0x100(%rbp)
  8004218614:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004218618:	48 89 85 08 ff ff ff 	mov    %rax,-0xf8(%rbp)
  800421861f:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004218623:	48 89 85 10 ff ff ff 	mov    %rax,-0xf0(%rbp)
  800421862a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421862e:	48 89 85 18 ff ff ff 	mov    %rax,-0xe8(%rbp)
  8004218635:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004218639:	48 89 85 20 ff ff ff 	mov    %rax,-0xe0(%rbp)
  8004218640:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004218644:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
  800421864b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421864f:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
  8004218656:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421865a:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  8004218661:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004218665:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  800421866c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218670:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
		for (f.func = 0; f.func < (PCI_HDRTYPE_MULTIFN(bhlc) ? 8 : 1);
  8004218677:	c7 85 0c ff ff ff 00 	movl   $0x0,-0xf4(%rbp)
  800421867e:	00 00 00 
  8004218681:	e9 45 01 00 00       	jmpq   80042187cb <pci_scan_bus+0x240>
		     f.func++) {
			struct pci_func af = f;
  8004218686:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
  800421868d:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
  8004218694:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  800421869b:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
  80042186a2:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  80042186a9:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
  80042186b0:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80042186b7:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
  80042186be:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  80042186c5:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  80042186cc:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042186d3:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  80042186da:	48 8b 85 30 ff ff ff 	mov    -0xd0(%rbp),%rax
  80042186e1:	48 89 45 80          	mov    %rax,-0x80(%rbp)
  80042186e5:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  80042186ec:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  80042186f0:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  80042186f7:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  80042186fb:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004218702:	48 89 45 98          	mov    %rax,-0x68(%rbp)

			af.dev_id = pci_conf_read(&f, PCI_ID_REG);
  8004218706:	48 8d 85 00 ff ff ff 	lea    -0x100(%rbp),%rax
  800421870d:	be 00 00 00 00       	mov    $0x0,%esi
  8004218712:	48 89 c7             	mov    %rax,%rdi
  8004218715:	48 b8 84 82 21 04 80 	movabs $0x8004218284,%rax
  800421871c:	00 00 00 
  800421871f:	ff d0                	callq  *%rax
  8004218721:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%rbp)
			if (PCI_VENDOR(af.dev_id) == 0xffff)
  8004218727:	8b 85 60 ff ff ff    	mov    -0xa0(%rbp),%eax
  800421872d:	0f b7 c0             	movzwl %ax,%eax
  8004218730:	3d ff ff 00 00       	cmp    $0xffff,%eax
  8004218735:	0f 84 81 00 00 00    	je     80042187bc <pci_scan_bus+0x231>
				continue;

			uint32_t intr = pci_conf_read(&af, PCI_INTERRUPT_REG);
  800421873b:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004218742:	be 3c 00 00 00       	mov    $0x3c,%esi
  8004218747:	48 89 c7             	mov    %rax,%rdi
  800421874a:	48 b8 84 82 21 04 80 	movabs $0x8004218284,%rax
  8004218751:	00 00 00 
  8004218754:	ff d0                	callq  *%rax
  8004218756:	89 45 f4             	mov    %eax,-0xc(%rbp)
			af.irq_line = PCI_INTERRUPT_LINE(intr);
  8004218759:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421875c:	88 45 98             	mov    %al,-0x68(%rbp)

			af.dev_class = pci_conf_read(&af, PCI_CLASS_REG);
  800421875f:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004218766:	be 08 00 00 00       	mov    $0x8,%esi
  800421876b:	48 89 c7             	mov    %rax,%rdi
  800421876e:	48 b8 84 82 21 04 80 	movabs $0x8004218284,%rax
  8004218775:	00 00 00 
  8004218778:	ff d0                	callq  *%rax
  800421877a:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%rbp)
			if (pci_show_devs)
  8004218780:	48 b8 e0 c7 22 04 80 	movabs $0x800422c7e0,%rax
  8004218787:	00 00 00 
  800421878a:	8b 00                	mov    (%rax),%eax
  800421878c:	85 c0                	test   %eax,%eax
  800421878e:	74 16                	je     80042187a6 <pci_scan_bus+0x21b>
				pci_print_func(&af);
  8004218790:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004218797:	48 89 c7             	mov    %rax,%rdi
  800421879a:	48 b8 b2 84 21 04 80 	movabs $0x80042184b2,%rax
  80042187a1:	00 00 00 
  80042187a4:	ff d0                	callq  *%rax
			pci_attach(&af);
  80042187a6:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  80042187ad:	48 89 c7             	mov    %rax,%rdi
  80042187b0:	48 b8 23 84 21 04 80 	movabs $0x8004218423,%rax
  80042187b7:	00 00 00 
  80042187ba:	ff d0                	callq  *%rax

		totaldev++;

		struct pci_func f = df;
		for (f.func = 0; f.func < (PCI_HDRTYPE_MULTIFN(bhlc) ? 8 : 1);
		     f.func++) {
  80042187bc:	8b 85 0c ff ff ff    	mov    -0xf4(%rbp),%eax
  80042187c2:	83 c0 01             	add    $0x1,%eax
  80042187c5:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%rbp)
			continue;

		totaldev++;

		struct pci_func f = df;
		for (f.func = 0; f.func < (PCI_HDRTYPE_MULTIFN(bhlc) ? 8 : 1);
  80042187cb:	8b 95 0c ff ff ff    	mov    -0xf4(%rbp),%edx
  80042187d1:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042187d4:	25 00 00 80 00       	and    $0x800000,%eax
  80042187d9:	85 c0                	test   %eax,%eax
  80042187db:	74 07                	je     80042187e4 <pci_scan_bus+0x259>
  80042187dd:	b8 08 00 00 00       	mov    $0x8,%eax
  80042187e2:	eb 05                	jmp    80042187e9 <pci_scan_bus+0x25e>
  80042187e4:	b8 01 00 00 00       	mov    $0x1,%eax
  80042187e9:	39 c2                	cmp    %eax,%edx
  80042187eb:	0f 82 95 fe ff ff    	jb     8004218686 <pci_scan_bus+0xfb>
	int totaldev = 0;
	struct pci_func df;
	memset(&df, 0, sizeof(df));
	df.bus = bus;

	for (df.dev = 0; df.dev < 32; df.dev++) {
  80042187f1:	8b 45 a8             	mov    -0x58(%rbp),%eax
  80042187f4:	83 c0 01             	add    $0x1,%eax
  80042187f7:	89 45 a8             	mov    %eax,-0x58(%rbp)
  80042187fa:	8b 45 a8             	mov    -0x58(%rbp),%eax
  80042187fd:	83 f8 1f             	cmp    $0x1f,%eax
  8004218800:	0f 86 d2 fd ff ff    	jbe    80042185d8 <pci_scan_bus+0x4d>
				pci_print_func(&af);
			pci_attach(&af);
		}
	}

	return totaldev;
  8004218806:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004218809:	c9                   	leaveq 
  800421880a:	c3                   	retq   

000000800421880b <pci_bridge_attach>:

static int
pci_bridge_attach(struct pci_func *pcif)
{
  800421880b:	55                   	push   %rbp
  800421880c:	48 89 e5             	mov    %rsp,%rbp
  800421880f:	48 83 ec 30          	sub    $0x30,%rsp
  8004218813:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	uint32_t ioreg  = pci_conf_read(pcif, PCI_BRIDGE_STATIO_REG);
  8004218817:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421881b:	be 1c 00 00 00       	mov    $0x1c,%esi
  8004218820:	48 89 c7             	mov    %rax,%rdi
  8004218823:	48 b8 84 82 21 04 80 	movabs $0x8004218284,%rax
  800421882a:	00 00 00 
  800421882d:	ff d0                	callq  *%rax
  800421882f:	89 45 fc             	mov    %eax,-0x4(%rbp)
	uint32_t busreg = pci_conf_read(pcif, PCI_BRIDGE_BUS_REG);
  8004218832:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218836:	be 18 00 00 00       	mov    $0x18,%esi
  800421883b:	48 89 c7             	mov    %rax,%rdi
  800421883e:	48 b8 84 82 21 04 80 	movabs $0x8004218284,%rax
  8004218845:	00 00 00 
  8004218848:	ff d0                	callq  *%rax
  800421884a:	89 45 f8             	mov    %eax,-0x8(%rbp)

	if (PCI_BRIDGE_IO_32BITS(ioreg)) {
  800421884d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004218850:	83 e0 0f             	and    $0xf,%eax
  8004218853:	83 f8 01             	cmp    $0x1,%eax
  8004218856:	75 40                	jne    8004218898 <pci_bridge_attach+0x8d>
		cprintf("PCI: %02x:%02x.%d: 32-bit bridge IO not supported.\n",
  8004218858:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421885c:	8b 48 0c             	mov    0xc(%rax),%ecx
  800421885f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218863:	8b 50 08             	mov    0x8(%rax),%edx
			pcif->bus->busno, pcif->dev, pcif->func);
  8004218866:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421886a:	48 8b 00             	mov    (%rax),%rax
{
	uint32_t ioreg  = pci_conf_read(pcif, PCI_BRIDGE_STATIO_REG);
	uint32_t busreg = pci_conf_read(pcif, PCI_BRIDGE_BUS_REG);

	if (PCI_BRIDGE_IO_32BITS(ioreg)) {
		cprintf("PCI: %02x:%02x.%d: 32-bit bridge IO not supported.\n",
  800421886d:	8b 40 08             	mov    0x8(%rax),%eax
  8004218870:	89 c6                	mov    %eax,%esi
  8004218872:	48 bf f0 bb 21 04 80 	movabs $0x800421bbf0,%rdi
  8004218879:	00 00 00 
  800421887c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218881:	49 b8 90 95 20 04 80 	movabs $0x8004209590,%r8
  8004218888:	00 00 00 
  800421888b:	41 ff d0             	callq  *%r8
			pcif->bus->busno, pcif->dev, pcif->func);
		return 0;
  800421888e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218893:	e9 a1 00 00 00       	jmpq   8004218939 <pci_bridge_attach+0x12e>
	}

	struct pci_bus nbus;
	memset(&nbus, 0, sizeof(nbus));
  8004218898:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  800421889c:	ba 10 00 00 00       	mov    $0x10,%edx
  80042188a1:	be 00 00 00 00       	mov    $0x0,%esi
  80042188a6:	48 89 c7             	mov    %rax,%rdi
  80042188a9:	48 b8 d4 03 21 04 80 	movabs $0x80042103d4,%rax
  80042188b0:	00 00 00 
  80042188b3:	ff d0                	callq  *%rax
	nbus.parent_bridge = pcif;
  80042188b5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042188b9:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	nbus.busno = (busreg >> PCI_BRIDGE_BUS_SECONDARY_SHIFT) & 0xff;
  80042188bd:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042188c0:	c1 e8 08             	shr    $0x8,%eax
  80042188c3:	0f b6 c0             	movzbl %al,%eax
  80042188c6:	89 45 e8             	mov    %eax,-0x18(%rbp)

	if (pci_show_devs)
  80042188c9:	48 b8 e0 c7 22 04 80 	movabs $0x800422c7e0,%rax
  80042188d0:	00 00 00 
  80042188d3:	8b 00                	mov    (%rax),%eax
  80042188d5:	85 c0                	test   %eax,%eax
  80042188d7:	74 48                	je     8004218921 <pci_bridge_attach+0x116>
		cprintf("PCI: %02x:%02x.%d: bridge to PCI bus %d--%d\n",
			pcif->bus->busno, pcif->dev, pcif->func,
			nbus.busno,
			(busreg >> PCI_BRIDGE_BUS_SUBORDINATE_SHIFT) & 0xff);
  80042188d9:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042188dc:	c1 e8 10             	shr    $0x10,%eax
	memset(&nbus, 0, sizeof(nbus));
	nbus.parent_bridge = pcif;
	nbus.busno = (busreg >> PCI_BRIDGE_BUS_SECONDARY_SHIFT) & 0xff;

	if (pci_show_devs)
		cprintf("PCI: %02x:%02x.%d: bridge to PCI bus %d--%d\n",
  80042188df:	0f b6 f8             	movzbl %al,%edi
  80042188e2:	8b 75 e8             	mov    -0x18(%rbp),%esi
  80042188e5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042188e9:	8b 48 0c             	mov    0xc(%rax),%ecx
  80042188ec:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042188f0:	8b 50 08             	mov    0x8(%rax),%edx
			pcif->bus->busno, pcif->dev, pcif->func,
  80042188f3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042188f7:	48 8b 00             	mov    (%rax),%rax
	memset(&nbus, 0, sizeof(nbus));
	nbus.parent_bridge = pcif;
	nbus.busno = (busreg >> PCI_BRIDGE_BUS_SECONDARY_SHIFT) & 0xff;

	if (pci_show_devs)
		cprintf("PCI: %02x:%02x.%d: bridge to PCI bus %d--%d\n",
  80042188fa:	8b 40 08             	mov    0x8(%rax),%eax
  80042188fd:	41 89 f9             	mov    %edi,%r9d
  8004218900:	41 89 f0             	mov    %esi,%r8d
  8004218903:	89 c6                	mov    %eax,%esi
  8004218905:	48 bf 28 bc 21 04 80 	movabs $0x800421bc28,%rdi
  800421890c:	00 00 00 
  800421890f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218914:	49 ba 90 95 20 04 80 	movabs $0x8004209590,%r10
  800421891b:	00 00 00 
  800421891e:	41 ff d2             	callq  *%r10
			pcif->bus->busno, pcif->dev, pcif->func,
			nbus.busno,
			(busreg >> PCI_BRIDGE_BUS_SUBORDINATE_SHIFT) & 0xff);

	pci_scan_bus(&nbus);
  8004218921:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004218925:	48 89 c7             	mov    %rax,%rdi
  8004218928:	48 b8 8b 85 21 04 80 	movabs $0x800421858b,%rax
  800421892f:	00 00 00 
  8004218932:	ff d0                	callq  *%rax
	return 1;
  8004218934:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8004218939:	c9                   	leaveq 
  800421893a:	c3                   	retq   

000000800421893b <pci_func_enable>:

// External PCI subsystem interface

void
pci_func_enable(struct pci_func *f)
{
  800421893b:	55                   	push   %rbp
  800421893c:	48 89 e5             	mov    %rsp,%rbp
  800421893f:	48 83 ec 40          	sub    $0x40,%rsp
  8004218943:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	pci_conf_write(f, PCI_COMMAND_STATUS_REG,
  8004218947:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421894b:	ba 07 00 00 00       	mov    $0x7,%edx
  8004218950:	be 04 00 00 00       	mov    $0x4,%esi
  8004218955:	48 89 c7             	mov    %rax,%rdi
  8004218958:	48 b8 d9 82 21 04 80 	movabs $0x80042182d9,%rax
  800421895f:	00 00 00 
  8004218962:	ff d0                	callq  *%rax
		       PCI_COMMAND_MEM_ENABLE |
		       PCI_COMMAND_MASTER_ENABLE);

	uint32_t bar_width;
	uint32_t bar;
	for (bar = PCI_MAPREG_START; bar < PCI_MAPREG_END;
  8004218964:	c7 45 f8 10 00 00 00 	movl   $0x10,-0x8(%rbp)
  800421896b:	e9 ee 01 00 00       	jmpq   8004218b5e <pci_func_enable+0x223>
	     bar += bar_width)
	{
		uint32_t oldv = pci_conf_read(f, bar);
  8004218970:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004218973:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218977:	89 d6                	mov    %edx,%esi
  8004218979:	48 89 c7             	mov    %rax,%rdi
  800421897c:	48 b8 84 82 21 04 80 	movabs $0x8004218284,%rax
  8004218983:	00 00 00 
  8004218986:	ff d0                	callq  *%rax
  8004218988:	89 45 ec             	mov    %eax,-0x14(%rbp)

		bar_width = 4;
  800421898b:	c7 45 fc 04 00 00 00 	movl   $0x4,-0x4(%rbp)
		pci_conf_write(f, bar, 0xffffffff);
  8004218992:	8b 4d f8             	mov    -0x8(%rbp),%ecx
  8004218995:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218999:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  800421899e:	89 ce                	mov    %ecx,%esi
  80042189a0:	48 89 c7             	mov    %rax,%rdi
  80042189a3:	48 b8 d9 82 21 04 80 	movabs $0x80042182d9,%rax
  80042189aa:	00 00 00 
  80042189ad:	ff d0                	callq  *%rax
		uint32_t rv = pci_conf_read(f, bar);
  80042189af:	8b 55 f8             	mov    -0x8(%rbp),%edx
  80042189b2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042189b6:	89 d6                	mov    %edx,%esi
  80042189b8:	48 89 c7             	mov    %rax,%rdi
  80042189bb:	48 b8 84 82 21 04 80 	movabs $0x8004218284,%rax
  80042189c2:	00 00 00 
  80042189c5:	ff d0                	callq  *%rax
  80042189c7:	89 45 e8             	mov    %eax,-0x18(%rbp)

		if (rv == 0)
  80042189ca:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  80042189ce:	75 05                	jne    80042189d5 <pci_func_enable+0x9a>
			continue;
  80042189d0:	e9 83 01 00 00       	jmpq   8004218b58 <pci_func_enable+0x21d>

		int regnum = PCI_MAPREG_NUM(bar);
  80042189d5:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042189d8:	83 e8 10             	sub    $0x10,%eax
  80042189db:	c1 e8 02             	shr    $0x2,%eax
  80042189de:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		uint32_t base, size;
		if (PCI_MAPREG_TYPE(rv) == PCI_MAPREG_TYPE_MEM) {
  80042189e1:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80042189e4:	83 e0 01             	and    $0x1,%eax
  80042189e7:	85 c0                	test   %eax,%eax
  80042189e9:	75 65                	jne    8004218a50 <pci_func_enable+0x115>
			if (PCI_MAPREG_MEM_TYPE(rv) == PCI_MAPREG_MEM_TYPE_64BIT)
  80042189eb:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80042189ee:	83 e0 06             	and    $0x6,%eax
  80042189f1:	83 f8 04             	cmp    $0x4,%eax
  80042189f4:	75 07                	jne    80042189fd <pci_func_enable+0xc2>
				bar_width = 8;
  80042189f6:	c7 45 fc 08 00 00 00 	movl   $0x8,-0x4(%rbp)

			size = PCI_MAPREG_MEM_SIZE(rv);
  80042189fd:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004218a00:	83 e0 f0             	and    $0xfffffff0,%eax
  8004218a03:	f7 d8                	neg    %eax
  8004218a05:	23 45 e8             	and    -0x18(%rbp),%eax
  8004218a08:	83 e0 f0             	and    $0xfffffff0,%eax
  8004218a0b:	89 45 f0             	mov    %eax,-0x10(%rbp)
			base = PCI_MAPREG_MEM_ADDR(oldv);
  8004218a0e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004218a11:	83 e0 f0             	and    $0xfffffff0,%eax
  8004218a14:	89 45 f4             	mov    %eax,-0xc(%rbp)
			if (pci_show_addrs)
  8004218a17:	48 b8 a0 c5 69 04 80 	movabs $0x800469c5a0,%rax
  8004218a1e:	00 00 00 
  8004218a21:	8b 00                	mov    (%rax),%eax
  8004218a23:	85 c0                	test   %eax,%eax
  8004218a25:	74 7a                	je     8004218aa1 <pci_func_enable+0x166>
				cprintf("  mem region %d: %d bytes at 0x%x\n",
  8004218a27:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  8004218a2a:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004218a2d:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004218a30:	89 c6                	mov    %eax,%esi
  8004218a32:	48 bf 58 bc 21 04 80 	movabs $0x800421bc58,%rdi
  8004218a39:	00 00 00 
  8004218a3c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218a41:	49 b8 90 95 20 04 80 	movabs $0x8004209590,%r8
  8004218a48:	00 00 00 
  8004218a4b:	41 ff d0             	callq  *%r8
  8004218a4e:	eb 51                	jmp    8004218aa1 <pci_func_enable+0x166>
					regnum, size, base);
		} else {
			size = PCI_MAPREG_IO_SIZE(rv);
  8004218a50:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004218a53:	83 e0 fc             	and    $0xfffffffc,%eax
  8004218a56:	f7 d8                	neg    %eax
  8004218a58:	23 45 e8             	and    -0x18(%rbp),%eax
  8004218a5b:	83 e0 fc             	and    $0xfffffffc,%eax
  8004218a5e:	89 45 f0             	mov    %eax,-0x10(%rbp)
			base = PCI_MAPREG_IO_ADDR(oldv);
  8004218a61:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004218a64:	83 e0 fc             	and    $0xfffffffc,%eax
  8004218a67:	89 45 f4             	mov    %eax,-0xc(%rbp)
			if (pci_show_addrs)
  8004218a6a:	48 b8 a0 c5 69 04 80 	movabs $0x800469c5a0,%rax
  8004218a71:	00 00 00 
  8004218a74:	8b 00                	mov    (%rax),%eax
  8004218a76:	85 c0                	test   %eax,%eax
  8004218a78:	74 27                	je     8004218aa1 <pci_func_enable+0x166>
				cprintf("  io region %d: %d bytes at 0x%x\n",
  8004218a7a:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  8004218a7d:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004218a80:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004218a83:	89 c6                	mov    %eax,%esi
  8004218a85:	48 bf 80 bc 21 04 80 	movabs $0x800421bc80,%rdi
  8004218a8c:	00 00 00 
  8004218a8f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218a94:	49 b8 90 95 20 04 80 	movabs $0x8004209590,%r8
  8004218a9b:	00 00 00 
  8004218a9e:	41 ff d0             	callq  *%r8
					regnum, size, base);
		}

		pci_conf_write(f, bar, oldv);
  8004218aa1:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004218aa4:	8b 4d f8             	mov    -0x8(%rbp),%ecx
  8004218aa7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218aab:	89 ce                	mov    %ecx,%esi
  8004218aad:	48 89 c7             	mov    %rax,%rdi
  8004218ab0:	48 b8 d9 82 21 04 80 	movabs $0x80042182d9,%rax
  8004218ab7:	00 00 00 
  8004218aba:	ff d0                	callq  *%rax
		f->reg_base[regnum] = base;
  8004218abc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218ac0:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004218ac3:	48 63 d2             	movslq %edx,%rdx
  8004218ac6:	48 8d 4a 04          	lea    0x4(%rdx),%rcx
  8004218aca:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004218acd:	89 54 88 08          	mov    %edx,0x8(%rax,%rcx,4)
		f->reg_size[regnum] = size;
  8004218ad1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218ad5:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004218ad8:	48 63 d2             	movslq %edx,%rdx
  8004218adb:	48 8d 4a 0c          	lea    0xc(%rdx),%rcx
  8004218adf:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004218ae2:	89 14 88             	mov    %edx,(%rax,%rcx,4)

		if (size && !base)
  8004218ae5:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  8004218ae9:	74 6d                	je     8004218b58 <pci_func_enable+0x21d>
  8004218aeb:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  8004218aef:	75 67                	jne    8004218b58 <pci_func_enable+0x21d>
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
				"may be misconfigured: "
				"region %d: base 0x%x, size %d\n",
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  8004218af1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218af5:	8b 40 10             	mov    0x10(%rax),%eax
		pci_conf_write(f, bar, oldv);
		f->reg_base[regnum] = base;
		f->reg_size[regnum] = size;

		if (size && !base)
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
  8004218af8:	c1 e8 10             	shr    $0x10,%eax
  8004218afb:	41 89 c0             	mov    %eax,%r8d
				"may be misconfigured: "
				"region %d: base 0x%x, size %d\n",
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  8004218afe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218b02:	8b 40 10             	mov    0x10(%rax),%eax
		pci_conf_write(f, bar, oldv);
		f->reg_base[regnum] = base;
		f->reg_size[regnum] = size;

		if (size && !base)
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
  8004218b05:	0f b7 f8             	movzwl %ax,%edi
  8004218b08:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218b0c:	8b 48 0c             	mov    0xc(%rax),%ecx
  8004218b0f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218b13:	8b 50 08             	mov    0x8(%rax),%edx
				"may be misconfigured: "
				"region %d: base 0x%x, size %d\n",
				f->bus->busno, f->dev, f->func,
  8004218b16:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218b1a:	48 8b 00             	mov    (%rax),%rax
		pci_conf_write(f, bar, oldv);
		f->reg_base[regnum] = base;
		f->reg_size[regnum] = size;

		if (size && !base)
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
  8004218b1d:	8b 40 08             	mov    0x8(%rax),%eax
  8004218b20:	8b 75 f0             	mov    -0x10(%rbp),%esi
  8004218b23:	89 74 24 10          	mov    %esi,0x10(%rsp)
  8004218b27:	8b 75 f4             	mov    -0xc(%rbp),%esi
  8004218b2a:	89 74 24 08          	mov    %esi,0x8(%rsp)
  8004218b2e:	8b 75 e4             	mov    -0x1c(%rbp),%esi
  8004218b31:	89 34 24             	mov    %esi,(%rsp)
  8004218b34:	45 89 c1             	mov    %r8d,%r9d
  8004218b37:	41 89 f8             	mov    %edi,%r8d
  8004218b3a:	89 c6                	mov    %eax,%esi
  8004218b3c:	48 bf a8 bc 21 04 80 	movabs $0x800421bca8,%rdi
  8004218b43:	00 00 00 
  8004218b46:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218b4b:	49 ba 90 95 20 04 80 	movabs $0x8004209590,%r10
  8004218b52:	00 00 00 
  8004218b55:	41 ff d2             	callq  *%r10
		       PCI_COMMAND_MASTER_ENABLE);

	uint32_t bar_width;
	uint32_t bar;
	for (bar = PCI_MAPREG_START; bar < PCI_MAPREG_END;
	     bar += bar_width)
  8004218b58:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004218b5b:	01 45 f8             	add    %eax,-0x8(%rbp)
		       PCI_COMMAND_MEM_ENABLE |
		       PCI_COMMAND_MASTER_ENABLE);

	uint32_t bar_width;
	uint32_t bar;
	for (bar = PCI_MAPREG_START; bar < PCI_MAPREG_END;
  8004218b5e:	83 7d f8 27          	cmpl   $0x27,-0x8(%rbp)
  8004218b62:	0f 86 08 fe ff ff    	jbe    8004218970 <pci_func_enable+0x35>
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id));
  8004218b68:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218b6c:	8b 40 10             	mov    0x10(%rax),%eax
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
  8004218b6f:	c1 e8 10             	shr    $0x10,%eax
  8004218b72:	89 c7                	mov    %eax,%edi
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id));
  8004218b74:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218b78:	8b 40 10             	mov    0x10(%rax),%eax
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
  8004218b7b:	0f b7 f0             	movzwl %ax,%esi
  8004218b7e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218b82:	8b 48 0c             	mov    0xc(%rax),%ecx
  8004218b85:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218b89:	8b 50 08             	mov    0x8(%rax),%edx
		f->bus->busno, f->dev, f->func,
  8004218b8c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218b90:	48 8b 00             	mov    (%rax),%rax
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
  8004218b93:	8b 40 08             	mov    0x8(%rax),%eax
  8004218b96:	41 89 f9             	mov    %edi,%r9d
  8004218b99:	41 89 f0             	mov    %esi,%r8d
  8004218b9c:	89 c6                	mov    %eax,%esi
  8004218b9e:	48 bf 08 bd 21 04 80 	movabs $0x800421bd08,%rdi
  8004218ba5:	00 00 00 
  8004218ba8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218bad:	49 ba 90 95 20 04 80 	movabs $0x8004209590,%r10
  8004218bb4:	00 00 00 
  8004218bb7:	41 ff d2             	callq  *%r10
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id));
}
  8004218bba:	c9                   	leaveq 
  8004218bbb:	c3                   	retq   

0000008004218bbc <pci_init>:

int
pci_init(void)
{
  8004218bbc:	55                   	push   %rbp
  8004218bbd:	48 89 e5             	mov    %rsp,%rbp
	static struct pci_bus root_bus;
	memset(&root_bus, 0, sizeof(root_bus));
  8004218bc0:	ba 10 00 00 00       	mov    $0x10,%edx
  8004218bc5:	be 00 00 00 00       	mov    $0x0,%esi
  8004218bca:	48 bf b0 c5 69 04 80 	movabs $0x800469c5b0,%rdi
  8004218bd1:	00 00 00 
  8004218bd4:	48 b8 d4 03 21 04 80 	movabs $0x80042103d4,%rax
  8004218bdb:	00 00 00 
  8004218bde:	ff d0                	callq  *%rax

	return pci_scan_bus(&root_bus);
  8004218be0:	48 bf b0 c5 69 04 80 	movabs $0x800469c5b0,%rdi
  8004218be7:	00 00 00 
  8004218bea:	48 b8 8b 85 21 04 80 	movabs $0x800421858b,%rax
  8004218bf1:	00 00 00 
  8004218bf4:	ff d0                	callq  *%rax
}
  8004218bf6:	5d                   	pop    %rbp
  8004218bf7:	c3                   	retq   

0000008004218bf8 <time_init>:

static unsigned int ticks;

void
time_init(void)
{
  8004218bf8:	55                   	push   %rbp
  8004218bf9:	48 89 e5             	mov    %rsp,%rbp
	ticks = 0;
  8004218bfc:	48 b8 c0 c5 69 04 80 	movabs $0x800469c5c0,%rax
  8004218c03:	00 00 00 
  8004218c06:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
}
  8004218c0c:	5d                   	pop    %rbp
  8004218c0d:	c3                   	retq   

0000008004218c0e <time_tick>:

// This should be called once per timer interrupt.  A timer interrupt
// fires every 10 ms.
void
time_tick(void)
{
  8004218c0e:	55                   	push   %rbp
  8004218c0f:	48 89 e5             	mov    %rsp,%rbp
	ticks++;
  8004218c12:	48 b8 c0 c5 69 04 80 	movabs $0x800469c5c0,%rax
  8004218c19:	00 00 00 
  8004218c1c:	8b 00                	mov    (%rax),%eax
  8004218c1e:	8d 50 01             	lea    0x1(%rax),%edx
  8004218c21:	48 b8 c0 c5 69 04 80 	movabs $0x800469c5c0,%rax
  8004218c28:	00 00 00 
  8004218c2b:	89 10                	mov    %edx,(%rax)
	if (ticks * 10 < ticks)
  8004218c2d:	48 b8 c0 c5 69 04 80 	movabs $0x800469c5c0,%rax
  8004218c34:	00 00 00 
  8004218c37:	8b 10                	mov    (%rax),%edx
  8004218c39:	89 d0                	mov    %edx,%eax
  8004218c3b:	c1 e0 02             	shl    $0x2,%eax
  8004218c3e:	01 d0                	add    %edx,%eax
  8004218c40:	01 c0                	add    %eax,%eax
  8004218c42:	89 c2                	mov    %eax,%edx
  8004218c44:	48 b8 c0 c5 69 04 80 	movabs $0x800469c5c0,%rax
  8004218c4b:	00 00 00 
  8004218c4e:	8b 00                	mov    (%rax),%eax
  8004218c50:	39 c2                	cmp    %eax,%edx
  8004218c52:	73 2a                	jae    8004218c7e <time_tick+0x70>
		panic("time_tick: time overflowed");
  8004218c54:	48 ba 37 bd 21 04 80 	movabs $0x800421bd37,%rdx
  8004218c5b:	00 00 00 
  8004218c5e:	be 14 00 00 00       	mov    $0x14,%esi
  8004218c63:	48 bf 52 bd 21 04 80 	movabs $0x800421bd52,%rdi
  8004218c6a:	00 00 00 
  8004218c6d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218c72:	48 b9 e4 05 20 04 80 	movabs $0x80042005e4,%rcx
  8004218c79:	00 00 00 
  8004218c7c:	ff d1                	callq  *%rcx
}
  8004218c7e:	5d                   	pop    %rbp
  8004218c7f:	c3                   	retq   

0000008004218c80 <time_msec>:

unsigned int
time_msec(void)
{
  8004218c80:	55                   	push   %rbp
  8004218c81:	48 89 e5             	mov    %rsp,%rbp
	return ticks * 10;
  8004218c84:	48 b8 c0 c5 69 04 80 	movabs $0x800469c5c0,%rax
  8004218c8b:	00 00 00 
  8004218c8e:	8b 10                	mov    (%rax),%edx
  8004218c90:	89 d0                	mov    %edx,%eax
  8004218c92:	c1 e0 02             	shl    $0x2,%eax
  8004218c95:	01 d0                	add    %edx,%eax
  8004218c97:	01 c0                	add    %eax,%eax
}
  8004218c99:	5d                   	pop    %rbp
  8004218c9a:	c3                   	retq   
