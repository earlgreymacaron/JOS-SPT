
vmm/guest/obj/net/ns:     file format elf64-x86-64


Disassembly of section .text:

0000000000800020 <_start>:
// starts us running when we are initially loaded into a new environment.
.text
.globl _start
_start:
	// See if we were started with arguments on the stack
	movabs $USTACKTOP, %rax
  800020:	48 b8 00 e0 7f ef 00 	movabs $0xef7fe000,%rax
  800027:	00 00 00 
	cmpq %rax,%rsp
  80002a:	48 39 c4             	cmp    %rax,%rsp
	jne args_exist
  80002d:	75 04                	jne    800033 <args_exist>

	// If not, push dummy argc/argv arguments.
	// This happens when we are loaded by the kernel,
	// because the kernel does not know about passing arguments.
	pushq $0
  80002f:	6a 00                	pushq  $0x0
	pushq $0
  800031:	6a 00                	pushq  $0x0

0000000000800033 <args_exist>:

args_exist:
	movq 8(%rsp), %rsi
  800033:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
	movq (%rsp), %rdi
  800038:	48 8b 3c 24          	mov    (%rsp),%rdi
	call libmain
  80003c:	e8 02 10 00 00       	callq  801043 <libmain>
1:	jmp 1b
  800041:	eb fe                	jmp    800041 <args_exist+0xe>

0000000000800043 <next_i>:
static envid_t timer_envid;
static envid_t input_envid;
static envid_t output_envid;

static bool buse[QUEUE_SIZE];
static int next_i(int i) { return (i+1) % QUEUE_SIZE; }
  800043:	55                   	push   %rbp
  800044:	48 89 e5             	mov    %rsp,%rbp
  800047:	48 83 ec 04          	sub    $0x4,%rsp
  80004b:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80004e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800051:	8d 48 01             	lea    0x1(%rax),%ecx
  800054:	ba 67 66 66 66       	mov    $0x66666667,%edx
  800059:	89 c8                	mov    %ecx,%eax
  80005b:	f7 ea                	imul   %edx
  80005d:	c1 fa 03             	sar    $0x3,%edx
  800060:	89 c8                	mov    %ecx,%eax
  800062:	c1 f8 1f             	sar    $0x1f,%eax
  800065:	29 c2                	sub    %eax,%edx
  800067:	89 d0                	mov    %edx,%eax
  800069:	c1 e0 02             	shl    $0x2,%eax
  80006c:	01 d0                	add    %edx,%eax
  80006e:	c1 e0 02             	shl    $0x2,%eax
  800071:	29 c1                	sub    %eax,%ecx
  800073:	89 ca                	mov    %ecx,%edx
  800075:	89 d0                	mov    %edx,%eax
  800077:	c9                   	leaveq 
  800078:	c3                   	retq   

0000000000800079 <prev_i>:
static int prev_i(int i) { return (i ? i-1 : QUEUE_SIZE-1); }
  800079:	55                   	push   %rbp
  80007a:	48 89 e5             	mov    %rsp,%rbp
  80007d:	48 83 ec 04          	sub    $0x4,%rsp
  800081:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800084:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800088:	74 08                	je     800092 <prev_i+0x19>
  80008a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80008d:	83 e8 01             	sub    $0x1,%eax
  800090:	eb 05                	jmp    800097 <prev_i+0x1e>
  800092:	b8 13 00 00 00       	mov    $0x13,%eax
  800097:	c9                   	leaveq 
  800098:	c3                   	retq   

0000000000800099 <get_buffer>:

static void *
get_buffer(void) {
  800099:	55                   	push   %rbp
  80009a:	48 89 e5             	mov    %rsp,%rbp
  80009d:	48 83 ec 10          	sub    $0x10,%rsp
    void *va;

    int64_t i;
    for (i = 0; i < QUEUE_SIZE; i++)
  8000a1:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8000a8:	00 
  8000a9:	eb 22                	jmp    8000cd <get_buffer+0x34>
        if (!buse[i]) break;
  8000ab:	48 ba 70 90 82 00 00 	movabs $0x829070,%rdx
  8000b2:	00 00 00 
  8000b5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8000b9:	48 01 d0             	add    %rdx,%rax
  8000bc:	0f b6 00             	movzbl (%rax),%eax
  8000bf:	83 f0 01             	xor    $0x1,%eax
  8000c2:	84 c0                	test   %al,%al
  8000c4:	74 02                	je     8000c8 <get_buffer+0x2f>
  8000c6:	eb 0c                	jmp    8000d4 <get_buffer+0x3b>
static void *
get_buffer(void) {
    void *va;

    int64_t i;
    for (i = 0; i < QUEUE_SIZE; i++)
  8000c8:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8000cd:	48 83 7d f8 13       	cmpq   $0x13,-0x8(%rbp)
  8000d2:	7e d7                	jle    8000ab <get_buffer+0x12>
        if (!buse[i]) break;

    if (i == QUEUE_SIZE) {
  8000d4:	48 83 7d f8 14       	cmpq   $0x14,-0x8(%rbp)
  8000d9:	75 2a                	jne    800105 <get_buffer+0x6c>
        panic("NS: buffer overflow");
  8000db:	48 ba 40 0a 82 00 00 	movabs $0x820a40,%rdx
  8000e2:	00 00 00 
  8000e5:	be 40 00 00 00       	mov    $0x40,%esi
  8000ea:	48 bf 54 0a 82 00 00 	movabs $0x820a54,%rdi
  8000f1:	00 00 00 
  8000f4:	b8 00 00 00 00       	mov    $0x0,%eax
  8000f9:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  800100:	00 00 00 
  800103:	ff d1                	callq  *%rcx
        return 0;
    }

    va = (void *)(REQVA + i * PGSIZE);
  800105:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800109:	48 05 eb ff 00 00    	add    $0xffeb,%rax
  80010f:	48 c1 e0 0c          	shl    $0xc,%rax
  800113:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    buse[i] = 1;
  800117:	48 ba 70 90 82 00 00 	movabs $0x829070,%rdx
  80011e:	00 00 00 
  800121:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800125:	48 01 d0             	add    %rdx,%rax
  800128:	c6 00 01             	movb   $0x1,(%rax)

    return va;
  80012b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  80012f:	c9                   	leaveq 
  800130:	c3                   	retq   

0000000000800131 <put_buffer>:

static void
put_buffer(void *va) {
  800131:	55                   	push   %rbp
  800132:	48 89 e5             	mov    %rsp,%rbp
  800135:	48 83 ec 18          	sub    $0x18,%rsp
  800139:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    int64_t i = ((uint64_t)va - REQVA) / PGSIZE;
  80013d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800141:	48 2d 00 b0 fe 0f    	sub    $0xffeb000,%rax
  800147:	48 c1 e8 0c          	shr    $0xc,%rax
  80014b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    buse[i] = 0;
  80014f:	48 ba 70 90 82 00 00 	movabs $0x829070,%rdx
  800156:	00 00 00 
  800159:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80015d:	48 01 d0             	add    %rdx,%rax
  800160:	c6 00 00             	movb   $0x0,(%rax)
}
  800163:	c9                   	leaveq 
  800164:	c3                   	retq   

0000000000800165 <lwip_init>:

    static void
lwip_init(struct netif *nif, void *if_state,
        uint32_t init_addr, uint32_t init_mask, uint32_t init_gw)
{
  800165:	55                   	push   %rbp
  800166:	48 89 e5             	mov    %rsp,%rbp
  800169:	53                   	push   %rbx
  80016a:	48 83 ec 68          	sub    $0x68,%rsp
  80016e:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  800172:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  800176:	89 55 ac             	mov    %edx,-0x54(%rbp)
  800179:	89 4d a8             	mov    %ecx,-0x58(%rbp)
  80017c:	44 89 45 a4          	mov    %r8d,-0x5c(%rbp)
    struct ip_addr ipaddr, netmask, gateway;
    ipaddr.addr  = init_addr;
  800180:	8b 45 ac             	mov    -0x54(%rbp),%eax
  800183:	89 45 e0             	mov    %eax,-0x20(%rbp)
    netmask.addr = init_mask;
  800186:	8b 45 a8             	mov    -0x58(%rbp),%eax
  800189:	89 45 d0             	mov    %eax,-0x30(%rbp)
    gateway.addr = init_gw;
  80018c:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  80018f:	89 45 c0             	mov    %eax,-0x40(%rbp)

    if (0 == netif_add(nif, &ipaddr, &netmask, &gateway,
  800192:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
  800196:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  80019a:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  80019e:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  8001a2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8001a6:	48 bb 90 0e 81 00 00 	movabs $0x810e90,%rbx
  8001ad:	00 00 00 
  8001b0:	48 89 1c 24          	mov    %rbx,(%rsp)
  8001b4:	49 b9 23 99 81 00 00 	movabs $0x819923,%r9
  8001bb:	00 00 00 
  8001be:	49 89 f8             	mov    %rdi,%r8
  8001c1:	48 89 c7             	mov    %rax,%rdi
  8001c4:	48 b8 84 cf 80 00 00 	movabs $0x80cf84,%rax
  8001cb:	00 00 00 
  8001ce:	ff d0                	callq  *%rax
  8001d0:	48 85 c0             	test   %rax,%rax
  8001d3:	75 2a                	jne    8001ff <lwip_init+0x9a>
                if_state,
                jif_init,
                ip_input))
        panic("lwip_init: error in netif_add\n");
  8001d5:	48 ba 60 0a 82 00 00 	movabs $0x820a60,%rdx
  8001dc:	00 00 00 
  8001df:	be 5d 00 00 00       	mov    $0x5d,%esi
  8001e4:	48 bf 54 0a 82 00 00 	movabs $0x820a54,%rdi
  8001eb:	00 00 00 
  8001ee:	b8 00 00 00 00       	mov    $0x0,%eax
  8001f3:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  8001fa:	00 00 00 
  8001fd:	ff d1                	callq  *%rcx

    netif_set_default(nif);
  8001ff:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800203:	48 89 c7             	mov    %rax,%rdi
  800206:	48 b8 84 d3 80 00 00 	movabs $0x80d384,%rax
  80020d:	00 00 00 
  800210:	ff d0                	callq  *%rax
    netif_set_up(nif);
  800212:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800216:	48 89 c7             	mov    %rax,%rdi
  800219:	48 b8 a3 d3 80 00 00 	movabs $0x80d3a3,%rax
  800220:	00 00 00 
  800223:	ff d0                	callq  *%rax
}
  800225:	48 83 c4 68          	add    $0x68,%rsp
  800229:	5b                   	pop    %rbx
  80022a:	5d                   	pop    %rbp
  80022b:	c3                   	retq   

000000000080022c <net_timer>:

    static void __attribute__((noreturn))
net_timer(uint64_t arg)
{
  80022c:	55                   	push   %rbp
  80022d:	48 89 e5             	mov    %rsp,%rbp
  800230:	48 83 ec 20          	sub    $0x20,%rsp
  800234:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    struct timer_thread *t = (struct timer_thread *) arg;
  800238:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80023c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

    for (;;) {
        uint32_t cur = sys_time_msec();
  800240:	48 b8 73 2a 80 00 00 	movabs $0x802a73,%rax
  800247:	00 00 00 
  80024a:	ff d0                	callq  *%rax
  80024c:	89 45 f4             	mov    %eax,-0xc(%rbp)

        lwip_core_lock();
  80024f:	48 b8 9e 8a 81 00 00 	movabs $0x818a9e,%rax
  800256:	00 00 00 
  800259:	ff d0                	callq  *%rax
        t->func();
  80025b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80025f:	48 8b 40 08          	mov    0x8(%rax),%rax
  800263:	ff d0                	callq  *%rax
        lwip_core_unlock();
  800265:	48 b8 a4 8a 81 00 00 	movabs $0x818aa4,%rax
  80026c:	00 00 00 
  80026f:	ff d0                	callq  *%rax

        thread_wait(0, 0, cur + t->msec);
  800271:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800275:	8b 10                	mov    (%rax),%edx
  800277:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80027a:	01 d0                	add    %edx,%eax
  80027c:	89 c2                	mov    %eax,%edx
  80027e:	be 00 00 00 00       	mov    $0x0,%esi
  800283:	bf 00 00 00 00       	mov    $0x0,%edi
  800288:	48 b8 19 8c 81 00 00 	movabs $0x818c19,%rax
  80028f:	00 00 00 
  800292:	ff d0                	callq  *%rax
    }
  800294:	eb aa                	jmp    800240 <net_timer+0x14>

0000000000800296 <start_timer>:
}

    static void
start_timer(struct timer_thread *t, void (*func)(void), const char *name, int msec)
{
  800296:	55                   	push   %rbp
  800297:	48 89 e5             	mov    %rsp,%rbp
  80029a:	48 83 ec 30          	sub    $0x30,%rsp
  80029e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8002a2:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8002a6:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8002aa:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
    t->msec = msec;
  8002ad:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8002b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8002b4:	89 10                	mov    %edx,(%rax)
    t->func = func;
  8002b6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8002ba:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8002be:	48 89 50 08          	mov    %rdx,0x8(%rax)
    t->name = name;
  8002c2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8002c6:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8002ca:	48 89 50 10          	mov    %rdx,0x10(%rax)
    int r = thread_create(0, name, &net_timer, (uint64_t)t);
  8002ce:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8002d2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8002d6:	48 89 d1             	mov    %rdx,%rcx
  8002d9:	48 ba 2c 02 80 00 00 	movabs $0x80022c,%rdx
  8002e0:	00 00 00 
  8002e3:	48 89 c6             	mov    %rax,%rsi
  8002e6:	bf 00 00 00 00       	mov    $0x0,%edi
  8002eb:	48 b8 8e 8e 81 00 00 	movabs $0x818e8e,%rax
  8002f2:	00 00 00 
  8002f5:	ff d0                	callq  *%rax
  8002f7:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (r < 0)
  8002fa:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8002fe:	79 3f                	jns    80033f <start_timer+0xa9>
        panic("cannot create timer thread: %s", e2s(r));
  800300:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800303:	89 c7                	mov    %eax,%edi
  800305:	48 b8 15 95 81 00 00 	movabs $0x819515,%rax
  80030c:	00 00 00 
  80030f:	ff d0                	callq  *%rax
  800311:	48 89 c1             	mov    %rax,%rcx
  800314:	48 ba 80 0a 82 00 00 	movabs $0x820a80,%rdx
  80031b:	00 00 00 
  80031e:	be 7b 00 00 00       	mov    $0x7b,%esi
  800323:	48 bf 54 0a 82 00 00 	movabs $0x820a54,%rdi
  80032a:	00 00 00 
  80032d:	b8 00 00 00 00       	mov    $0x0,%eax
  800332:	49 b8 e9 10 80 00 00 	movabs $0x8010e9,%r8
  800339:	00 00 00 
  80033c:	41 ff d0             	callq  *%r8
}
  80033f:	c9                   	leaveq 
  800340:	c3                   	retq   

0000000000800341 <tcpip_init_done>:

    static void
tcpip_init_done(void *arg)
{
  800341:	55                   	push   %rbp
  800342:	48 89 e5             	mov    %rsp,%rbp
  800345:	48 83 ec 20          	sub    $0x20,%rsp
  800349:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    uint32_t *done = arg;
  80034d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800351:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    *done = 1;
  800355:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800359:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
    thread_wakeup(done);
  80035f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800363:	48 89 c7             	mov    %rax,%rdi
  800366:	48 b8 c6 8b 81 00 00 	movabs $0x818bc6,%rax
  80036d:	00 00 00 
  800370:	ff d0                	callq  *%rax
}
  800372:	c9                   	leaveq 
  800373:	c3                   	retq   

0000000000800374 <serve_init>:

    void
serve_init(uint32_t ipaddr, uint32_t netmask, uint32_t gw)
{
  800374:	55                   	push   %rbp
  800375:	48 89 e5             	mov    %rsp,%rbp
  800378:	48 83 ec 30          	sub    $0x30,%rsp
  80037c:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80037f:	89 75 e8             	mov    %esi,-0x18(%rbp)
  800382:	89 55 e4             	mov    %edx,-0x1c(%rbp)
    int r;
    lwip_core_lock();
  800385:	48 b8 9e 8a 81 00 00 	movabs $0x818a9e,%rax
  80038c:	00 00 00 
  80038f:	ff d0                	callq  *%rax

    uint32_t done = 0;
  800391:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    tcpip_init(&tcpip_init_done, &done);
  800398:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  80039c:	48 89 c6             	mov    %rax,%rsi
  80039f:	48 bf 41 03 80 00 00 	movabs $0x800341,%rdi
  8003a6:	00 00 00 
  8003a9:	48 b8 4b 8d 80 00 00 	movabs $0x808d4b,%rax
  8003b0:	00 00 00 
  8003b3:	ff d0                	callq  *%rax
    lwip_core_unlock();
  8003b5:	48 b8 a4 8a 81 00 00 	movabs $0x818aa4,%rax
  8003bc:	00 00 00 
  8003bf:	ff d0                	callq  *%rax
    thread_wait(&done, 0, (uint32_t)~0);
  8003c1:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  8003c5:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  8003ca:	be 00 00 00 00       	mov    $0x0,%esi
  8003cf:	48 89 c7             	mov    %rax,%rdi
  8003d2:	48 b8 19 8c 81 00 00 	movabs $0x818c19,%rax
  8003d9:	00 00 00 
  8003dc:	ff d0                	callq  *%rax
    lwip_core_lock();
  8003de:	48 b8 9e 8a 81 00 00 	movabs $0x818a9e,%rax
  8003e5:	00 00 00 
  8003e8:	ff d0                	callq  *%rax

    lwip_init(&nif, &output_envid, ipaddr, netmask, gw);
  8003ea:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8003ed:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8003f0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8003f3:	41 89 c8             	mov    %ecx,%r8d
  8003f6:	89 d1                	mov    %edx,%ecx
  8003f8:	89 c2                	mov    %eax,%edx
  8003fa:	48 be 60 90 82 00 00 	movabs $0x829060,%rsi
  800401:	00 00 00 
  800404:	48 bf 20 75 b5 00 00 	movabs $0xb57520,%rdi
  80040b:	00 00 00 
  80040e:	48 b8 65 01 80 00 00 	movabs $0x800165,%rax
  800415:	00 00 00 
  800418:	ff d0                	callq  *%rax

    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
  80041a:	b9 88 13 00 00       	mov    $0x1388,%ecx
  80041f:	48 ba 9f 0a 82 00 00 	movabs $0x820a9f,%rdx
  800426:	00 00 00 
  800429:	48 be 8d 5a 81 00 00 	movabs $0x815a8d,%rsi
  800430:	00 00 00 
  800433:	48 bf 00 90 82 00 00 	movabs $0x829000,%rdi
  80043a:	00 00 00 
  80043d:	48 b8 96 02 80 00 00 	movabs $0x800296,%rax
  800444:	00 00 00 
  800447:	ff d0                	callq  *%rax
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
  800449:	b9 fa 00 00 00       	mov    $0xfa,%ecx
  80044e:	48 ba a9 0a 82 00 00 	movabs $0x820aa9,%rdx
  800455:	00 00 00 
  800458:	48 be 1b 03 81 00 00 	movabs $0x81031b,%rsi
  80045f:	00 00 00 
  800462:	48 bf 20 90 82 00 00 	movabs $0x829020,%rdi
  800469:	00 00 00 
  80046c:	48 b8 96 02 80 00 00 	movabs $0x800296,%rax
  800473:	00 00 00 
  800476:	ff d0                	callq  *%rax
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);
  800478:	b9 f4 01 00 00       	mov    $0x1f4,%ecx
  80047d:	48 ba b5 0a 82 00 00 	movabs $0x820ab5,%rdx
  800484:	00 00 00 
  800487:	48 be df fa 80 00 00 	movabs $0x80fadf,%rsi
  80048e:	00 00 00 
  800491:	48 bf 40 90 82 00 00 	movabs $0x829040,%rdi
  800498:	00 00 00 
  80049b:	48 b8 96 02 80 00 00 	movabs $0x800296,%rax
  8004a2:	00 00 00 
  8004a5:	ff d0                	callq  *%rax

    struct in_addr ia = {ipaddr};
  8004a7:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004aa:	89 45 f0             	mov    %eax,-0x10(%rbp)
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  8004ad:	8b 45 f0             	mov    -0x10(%rbp),%eax
  8004b0:	89 c7                	mov    %eax,%edi
  8004b2:	48 b8 dd 2e 81 00 00 	movabs $0x812edd,%rax
  8004b9:	00 00 00 
  8004bc:	ff d0                	callq  *%rax
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
            nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
  8004be:	48 ba 20 75 b5 00 00 	movabs $0xb57520,%rdx
  8004c5:	00 00 00 
  8004c8:	0f b6 52 46          	movzbl 0x46(%rdx),%edx
    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

    struct in_addr ia = {ipaddr};
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  8004cc:	0f b6 fa             	movzbl %dl,%edi
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
            nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
  8004cf:	48 ba 20 75 b5 00 00 	movabs $0xb57520,%rdx
  8004d6:	00 00 00 
  8004d9:	0f b6 52 45          	movzbl 0x45(%rdx),%edx
    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

    struct in_addr ia = {ipaddr};
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  8004dd:	44 0f b6 ca          	movzbl %dl,%r9d
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
            nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
  8004e1:	48 ba 20 75 b5 00 00 	movabs $0xb57520,%rdx
  8004e8:	00 00 00 
  8004eb:	0f b6 52 44          	movzbl 0x44(%rdx),%edx
    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

    struct in_addr ia = {ipaddr};
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  8004ef:	44 0f b6 c2          	movzbl %dl,%r8d
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
  8004f3:	48 ba 20 75 b5 00 00 	movabs $0xb57520,%rdx
  8004fa:	00 00 00 
  8004fd:	0f b6 52 43          	movzbl 0x43(%rdx),%edx
    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

    struct in_addr ia = {ipaddr};
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  800501:	0f b6 ca             	movzbl %dl,%ecx
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
  800504:	48 ba 20 75 b5 00 00 	movabs $0xb57520,%rdx
  80050b:	00 00 00 
  80050e:	0f b6 52 42          	movzbl 0x42(%rdx),%edx
    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

    struct in_addr ia = {ipaddr};
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  800512:	0f b6 d2             	movzbl %dl,%edx
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
  800515:	48 be 20 75 b5 00 00 	movabs $0xb57520,%rsi
  80051c:	00 00 00 
  80051f:	0f b6 76 41          	movzbl 0x41(%rsi),%esi
    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

    struct in_addr ia = {ipaddr};
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  800523:	40 0f b6 f6          	movzbl %sil,%esi
  800527:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  80052c:	89 3c 24             	mov    %edi,(%rsp)
  80052f:	48 bf c8 0a 82 00 00 	movabs $0x820ac8,%rdi
  800536:	00 00 00 
  800539:	b8 00 00 00 00       	mov    $0x0,%eax
  80053e:	49 ba 22 13 80 00 00 	movabs $0x801322,%r10
  800545:	00 00 00 
  800548:	41 ff d2             	callq  *%r10
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
            nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
            inet_ntoa(ia));

    lwip_core_unlock();
  80054b:	48 b8 a4 8a 81 00 00 	movabs $0x818aa4,%rax
  800552:	00 00 00 
  800555:	ff d0                	callq  *%rax

    cprintf("NS: TCP/IP initialized.\n");
  800557:	48 bf 01 0b 82 00 00 	movabs $0x820b01,%rdi
  80055e:	00 00 00 
  800561:	b8 00 00 00 00       	mov    $0x0,%eax
  800566:	48 ba 22 13 80 00 00 	movabs $0x801322,%rdx
  80056d:	00 00 00 
  800570:	ff d2                	callq  *%rdx
}
  800572:	c9                   	leaveq 
  800573:	c3                   	retq   

0000000000800574 <process_timer>:

static void
process_timer(envid_t envid) {
  800574:	55                   	push   %rbp
  800575:	48 89 e5             	mov    %rsp,%rbp
  800578:	48 83 ec 20          	sub    $0x20,%rsp
  80057c:	89 7d ec             	mov    %edi,-0x14(%rbp)
    uint32_t start, now, to;

    if (envid != timer_envid) {
  80057f:	48 b8 58 90 82 00 00 	movabs $0x829058,%rax
  800586:	00 00 00 
  800589:	8b 00                	mov    (%rax),%eax
  80058b:	39 45 ec             	cmp    %eax,-0x14(%rbp)
  80058e:	74 22                	je     8005b2 <process_timer+0x3e>
        cprintf("NS: received timer interrupt from envid %x not timer env\n", envid);
  800590:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800593:	89 c6                	mov    %eax,%esi
  800595:	48 bf 20 0b 82 00 00 	movabs $0x820b20,%rdi
  80059c:	00 00 00 
  80059f:	b8 00 00 00 00       	mov    $0x0,%eax
  8005a4:	48 ba 22 13 80 00 00 	movabs $0x801322,%rdx
  8005ab:	00 00 00 
  8005ae:	ff d2                	callq  *%rdx
        return;
  8005b0:	eb 5a                	jmp    80060c <process_timer+0x98>
    }

    start = sys_time_msec();
  8005b2:	48 b8 73 2a 80 00 00 	movabs $0x802a73,%rax
  8005b9:	00 00 00 
  8005bc:	ff d0                	callq  *%rax
  8005be:	89 45 fc             	mov    %eax,-0x4(%rbp)
    thread_yield();
  8005c1:	48 b8 0e 91 81 00 00 	movabs $0x81910e,%rax
  8005c8:	00 00 00 
  8005cb:	ff d0                	callq  *%rax
    now = sys_time_msec();
  8005cd:	48 b8 73 2a 80 00 00 	movabs $0x802a73,%rax
  8005d4:	00 00 00 
  8005d7:	ff d0                	callq  *%rax
  8005d9:	89 45 f8             	mov    %eax,-0x8(%rbp)

    to = TIMER_INTERVAL - (now - start);
  8005dc:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8005df:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8005e2:	29 c2                	sub    %eax,%edx
  8005e4:	89 d0                	mov    %edx,%eax
  8005e6:	05 fa 00 00 00       	add    $0xfa,%eax
  8005eb:	89 45 f4             	mov    %eax,-0xc(%rbp)
    ipc_send(envid, to, 0, 0);
  8005ee:	8b 75 f4             	mov    -0xc(%rbp),%esi
  8005f1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8005f4:	b9 00 00 00 00       	mov    $0x0,%ecx
  8005f9:	ba 00 00 00 00       	mov    $0x0,%edx
  8005fe:	89 c7                	mov    %eax,%edi
  800600:	48 b8 bc 32 80 00 00 	movabs $0x8032bc,%rax
  800607:	00 00 00 
  80060a:	ff d0                	callq  *%rax
}
  80060c:	c9                   	leaveq 
  80060d:	c3                   	retq   

000000000080060e <serve_thread>:
    uint32_t whom;
    union Nsipc *req;
};

static void
serve_thread(uint64_t a) {
  80060e:	55                   	push   %rbp
  80060f:	48 89 e5             	mov    %rsp,%rbp
  800612:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  800619:	48 89 bd 58 ff ff ff 	mov    %rdi,-0xa8(%rbp)
    struct st_args *args = (struct st_args *)a;
  800620:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800627:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    union Nsipc *req = args->req;
  80062b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80062f:	48 8b 40 08          	mov    0x8(%rax),%rax
  800633:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    int r;

    switch (args->reqno) {
  800637:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80063b:	8b 00                	mov    (%rax),%eax
  80063d:	83 f8 0a             	cmp    $0xa,%eax
  800640:	0f 87 d8 01 00 00    	ja     80081e <serve_thread+0x210>
  800646:	89 c0                	mov    %eax,%eax
  800648:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80064f:	00 
  800650:	48 b8 98 0b 82 00 00 	movabs $0x820b98,%rax
  800657:	00 00 00 
  80065a:	48 01 d0             	add    %rdx,%rax
  80065d:	48 8b 00             	mov    (%rax),%rax
  800660:	ff e0                	jmpq   *%rax
        case NSREQ_ACCEPT:
            {
                struct Nsret_accept ret;
                r = lwip_accept(req->accept.req_s, &ret.ret_addr,
  800662:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800666:	8b 00                	mov    (%rax),%eax
  800668:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  80066c:	48 83 c2 10          	add    $0x10,%rdx
  800670:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  800674:	48 89 ce             	mov    %rcx,%rsi
  800677:	89 c7                	mov    %eax,%edi
  800679:	48 b8 61 5f 80 00 00 	movabs $0x805f61,%rax
  800680:	00 00 00 
  800683:	ff d0                	callq  *%rax
  800685:	89 45 fc             	mov    %eax,-0x4(%rbp)
                        &ret.ret_addrlen);
                memmove(req, &ret, sizeof ret);
  800688:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  80068c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800690:	ba 14 00 00 00       	mov    $0x14,%edx
  800695:	48 89 ce             	mov    %rcx,%rsi
  800698:	48 89 c7             	mov    %rax,%rdi
  80069b:	48 b8 fb 21 80 00 00 	movabs $0x8021fb,%rax
  8006a2:	00 00 00 
  8006a5:	ff d0                	callq  *%rax
                break;
  8006a7:	90                   	nop
  8006a8:	e9 a5 01 00 00       	jmpq   800852 <serve_thread+0x244>
            }
        case NSREQ_BIND:
            r = lwip_bind(req->bind.req_s, &req->bind.req_name,
  8006ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8006b1:	8b 50 14             	mov    0x14(%rax),%edx
  8006b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8006b8:	48 8d 48 04          	lea    0x4(%rax),%rcx
  8006bc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8006c0:	8b 00                	mov    (%rax),%eax
  8006c2:	48 89 ce             	mov    %rcx,%rsi
  8006c5:	89 c7                	mov    %eax,%edi
  8006c7:	48 b8 94 62 80 00 00 	movabs $0x806294,%rax
  8006ce:	00 00 00 
  8006d1:	ff d0                	callq  *%rax
  8006d3:	89 45 fc             	mov    %eax,-0x4(%rbp)
                    req->bind.req_namelen);
            break;
  8006d6:	e9 77 01 00 00       	jmpq   800852 <serve_thread+0x244>
        case NSREQ_SHUTDOWN:
            r = lwip_shutdown(req->shutdown.req_s, req->shutdown.req_how);
  8006db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8006df:	8b 50 04             	mov    0x4(%rax),%edx
  8006e2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8006e6:	8b 00                	mov    (%rax),%eax
  8006e8:	89 d6                	mov    %edx,%esi
  8006ea:	89 c7                	mov    %eax,%edi
  8006ec:	48 b8 f8 79 80 00 00 	movabs $0x8079f8,%rax
  8006f3:	00 00 00 
  8006f6:	ff d0                	callq  *%rax
  8006f8:	89 45 fc             	mov    %eax,-0x4(%rbp)
            break;
  8006fb:	e9 52 01 00 00       	jmpq   800852 <serve_thread+0x244>
        case NSREQ_CLOSE:
            r = lwip_close(req->close.req_s);
  800700:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800704:	8b 00                	mov    (%rax),%eax
  800706:	89 c7                	mov    %eax,%edi
  800708:	48 b8 c9 63 80 00 00 	movabs $0x8063c9,%rax
  80070f:	00 00 00 
  800712:	ff d0                	callq  *%rax
  800714:	89 45 fc             	mov    %eax,-0x4(%rbp)
            break;
  800717:	e9 36 01 00 00       	jmpq   800852 <serve_thread+0x244>
        case NSREQ_CONNECT:
            r = lwip_connect(req->connect.req_s, &req->connect.req_name,
  80071c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800720:	8b 50 14             	mov    0x14(%rax),%edx
  800723:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800727:	48 8d 48 04          	lea    0x4(%rax),%rcx
  80072b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80072f:	8b 00                	mov    (%rax),%eax
  800731:	48 89 ce             	mov    %rcx,%rsi
  800734:	89 c7                	mov    %eax,%edi
  800736:	48 b8 ae 64 80 00 00 	movabs $0x8064ae,%rax
  80073d:	00 00 00 
  800740:	ff d0                	callq  *%rax
  800742:	89 45 fc             	mov    %eax,-0x4(%rbp)
                    req->connect.req_namelen);
            break;
  800745:	e9 08 01 00 00       	jmpq   800852 <serve_thread+0x244>
        case NSREQ_LISTEN:
            r = lwip_listen(req->listen.req_s, req->listen.req_backlog);
  80074a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80074e:	8b 50 04             	mov    0x4(%rax),%edx
  800751:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800755:	8b 00                	mov    (%rax),%eax
  800757:	89 d6                	mov    %edx,%esi
  800759:	89 c7                	mov    %eax,%edi
  80075b:	48 b8 0a 66 80 00 00 	movabs $0x80660a,%rax
  800762:	00 00 00 
  800765:	ff d0                	callq  *%rax
  800767:	89 45 fc             	mov    %eax,-0x4(%rbp)
            break;
  80076a:	e9 e3 00 00 00       	jmpq   800852 <serve_thread+0x244>
        case NSREQ_RECV:
            // Note that we read the request fields before we
            // overwrite it with the response data.
            r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
  80076f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800773:	8b 48 08             	mov    0x8(%rax),%ecx
  800776:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80077a:	8b 50 04             	mov    0x4(%rax),%edx
  80077d:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  800781:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800785:	8b 00                	mov    (%rax),%eax
  800787:	89 c7                	mov    %eax,%edi
  800789:	48 b8 09 6b 80 00 00 	movabs $0x806b09,%rax
  800790:	00 00 00 
  800793:	ff d0                	callq  *%rax
  800795:	89 45 fc             	mov    %eax,-0x4(%rbp)
                    req->recv.req_len, req->recv.req_flags);
            break;
  800798:	e9 b5 00 00 00       	jmpq   800852 <serve_thread+0x244>
        case NSREQ_SEND:
            r = lwip_send(req->send.req_s, &req->send.req_buf,
  80079d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007a1:	8b 48 08             	mov    0x8(%rax),%ecx
  8007a4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007a8:	8b 50 04             	mov    0x4(%rax),%edx
  8007ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007af:	48 8d 70 0c          	lea    0xc(%rax),%rsi
  8007b3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007b7:	8b 00                	mov    (%rax),%eax
  8007b9:	89 c7                	mov    %eax,%edi
  8007bb:	48 b8 47 6b 80 00 00 	movabs $0x806b47,%rax
  8007c2:	00 00 00 
  8007c5:	ff d0                	callq  *%rax
  8007c7:	89 45 fc             	mov    %eax,-0x4(%rbp)
                    req->send.req_size, req->send.req_flags);
            break;
  8007ca:	e9 83 00 00 00       	jmpq   800852 <serve_thread+0x244>
        case NSREQ_SOCKET:
            r = lwip_socket(req->socket.req_domain, req->socket.req_type,
  8007cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007d3:	8b 50 08             	mov    0x8(%rax),%edx
  8007d6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007da:	8b 48 04             	mov    0x4(%rax),%ecx
  8007dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007e1:	8b 00                	mov    (%rax),%eax
  8007e3:	89 ce                	mov    %ecx,%esi
  8007e5:	89 c7                	mov    %eax,%edi
  8007e7:	48 b8 64 6e 80 00 00 	movabs $0x806e64,%rax
  8007ee:	00 00 00 
  8007f1:	ff d0                	callq  *%rax
  8007f3:	89 45 fc             	mov    %eax,-0x4(%rbp)
                    req->socket.req_protocol);
            break;
  8007f6:	eb 5a                	jmp    800852 <serve_thread+0x244>
        case NSREQ_INPUT:
            jif_input(&nif, (void *)&req->pkt);
  8007f8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007fc:	48 89 c6             	mov    %rax,%rsi
  8007ff:	48 bf 20 75 b5 00 00 	movabs $0xb57520,%rdi
  800806:	00 00 00 
  800809:	48 b8 28 98 81 00 00 	movabs $0x819828,%rax
  800810:	00 00 00 
  800813:	ff d0                	callq  *%rax
            r = 0;
  800815:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
            break;
  80081c:	eb 34                	jmp    800852 <serve_thread+0x244>
        default:
            cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
  80081e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800822:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800826:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80082a:	8b 40 04             	mov    0x4(%rax),%eax
  80082d:	89 c6                	mov    %eax,%esi
  80082f:	48 bf 60 0b 82 00 00 	movabs $0x820b60,%rdi
  800836:	00 00 00 
  800839:	b8 00 00 00 00       	mov    $0x0,%eax
  80083e:	48 b9 22 13 80 00 00 	movabs $0x801322,%rcx
  800845:	00 00 00 
  800848:	ff d1                	callq  *%rcx
            r = -E_INVAL;
  80084a:	c7 45 fc fd ff ff ff 	movl   $0xfffffffd,-0x4(%rbp)
            break;
  800851:	90                   	nop
    }

    if (r == -1) {
  800852:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  800856:	75 49                	jne    8008a1 <serve_thread+0x293>
        char buf[100];
        snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
  800858:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80085c:	8b 10                	mov    (%rax),%edx
  80085e:	48 8d 85 60 ff ff ff 	lea    -0xa0(%rbp),%rax
  800865:	89 d1                	mov    %edx,%ecx
  800867:	48 ba 83 0b 82 00 00 	movabs $0x820b83,%rdx
  80086e:	00 00 00 
  800871:	be 64 00 00 00       	mov    $0x64,%esi
  800876:	48 89 c7             	mov    %rax,%rdi
  800879:	b8 00 00 00 00       	mov    $0x0,%eax
  80087e:	49 b8 8a 1d 80 00 00 	movabs $0x801d8a,%r8
  800885:	00 00 00 
  800888:	41 ff d0             	callq  *%r8
        perror(buf);
  80088b:	48 8d 85 60 ff ff ff 	lea    -0xa0(%rbp),%rax
  800892:	48 89 c7             	mov    %rax,%rdi
  800895:	48 b8 c2 94 81 00 00 	movabs $0x8194c2,%rax
  80089c:	00 00 00 
  80089f:	ff d0                	callq  *%rax
    }

    if (args->reqno != NSREQ_INPUT)
  8008a1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8008a5:	8b 00                	mov    (%rax),%eax
  8008a7:	83 f8 0a             	cmp    $0xa,%eax
  8008aa:	74 22                	je     8008ce <serve_thread+0x2c0>
        ipc_send(args->whom, r, 0, 0);
  8008ac:	8b 75 fc             	mov    -0x4(%rbp),%esi
  8008af:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8008b3:	8b 40 04             	mov    0x4(%rax),%eax
  8008b6:	b9 00 00 00 00       	mov    $0x0,%ecx
  8008bb:	ba 00 00 00 00       	mov    $0x0,%edx
  8008c0:	89 c7                	mov    %eax,%edi
  8008c2:	48 b8 bc 32 80 00 00 	movabs $0x8032bc,%rax
  8008c9:	00 00 00 
  8008cc:	ff d0                	callq  *%rax

    put_buffer(args->req);
  8008ce:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8008d2:	48 8b 40 08          	mov    0x8(%rax),%rax
  8008d6:	48 89 c7             	mov    %rax,%rdi
  8008d9:	48 b8 31 01 80 00 00 	movabs $0x800131,%rax
  8008e0:	00 00 00 
  8008e3:	ff d0                	callq  *%rax
    sys_page_unmap(0, (void*) args->req);
  8008e5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8008e9:	48 8b 40 08          	mov    0x8(%rax),%rax
  8008ed:	48 89 c6             	mov    %rax,%rsi
  8008f0:	bf 00 00 00 00       	mov    $0x0,%edi
  8008f5:	48 b8 b1 28 80 00 00 	movabs $0x8028b1,%rax
  8008fc:	00 00 00 
  8008ff:	ff d0                	callq  *%rax
    free(args);
  800901:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800905:	48 89 c7             	mov    %rax,%rdi
  800908:	48 b8 8d 51 80 00 00 	movabs $0x80518d,%rax
  80090f:	00 00 00 
  800912:	ff d0                	callq  *%rax
}
  800914:	c9                   	leaveq 
  800915:	c3                   	retq   

0000000000800916 <serve>:

void
serve(void) {
  800916:	55                   	push   %rbp
  800917:	48 89 e5             	mov    %rsp,%rbp
  80091a:	48 83 ec 30          	sub    $0x30,%rsp

    while (1) {
        // ipc_recv will block the entire process, so we flush
        // all pending work from other threads.  We limit the
        // number of yields in case there's a rogue thread.
        for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  80091e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800925:	eb 10                	jmp    800937 <serve+0x21>
            thread_yield();
  800927:	48 b8 0e 91 81 00 00 	movabs $0x81910e,%rax
  80092e:	00 00 00 
  800931:	ff d0                	callq  *%rax

    while (1) {
        // ipc_recv will block the entire process, so we flush
        // all pending work from other threads.  We limit the
        // number of yields in case there's a rogue thread.
        for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  800933:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800937:	48 b8 f7 8c 81 00 00 	movabs $0x818cf7,%rax
  80093e:	00 00 00 
  800941:	ff d0                	callq  *%rax
  800943:	85 c0                	test   %eax,%eax
  800945:	74 06                	je     80094d <serve+0x37>
  800947:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  80094b:	7e da                	jle    800927 <serve+0x11>
            thread_yield();

        perm = 0;
  80094d:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
        va = get_buffer();
  800954:	48 b8 99 00 80 00 00 	movabs $0x800099,%rax
  80095b:	00 00 00 
  80095e:	ff d0                	callq  *%rax
  800960:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  800964:	48 8d 55 d8          	lea    -0x28(%rbp),%rdx
  800968:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  80096c:	48 8d 45 dc          	lea    -0x24(%rbp),%rax
  800970:	48 89 ce             	mov    %rcx,%rsi
  800973:	48 89 c7             	mov    %rax,%rdi
  800976:	48 b8 fb 31 80 00 00 	movabs $0x8031fb,%rax
  80097d:	00 00 00 
  800980:	ff d0                	callq  *%rax
  800982:	89 45 ec             	mov    %eax,-0x14(%rbp)
        if (debug) {
            cprintf("ns req %d from %08x\n", reqno, whom);
        }

        // first take care of requests that do not contain an argument page
        if (reqno == NSREQ_TIMER) {
  800985:	83 7d ec 0c          	cmpl   $0xc,-0x14(%rbp)
  800989:	75 29                	jne    8009b4 <serve+0x9e>
            process_timer(whom);
  80098b:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80098e:	89 c7                	mov    %eax,%edi
  800990:	48 b8 74 05 80 00 00 	movabs $0x800574,%rax
  800997:	00 00 00 
  80099a:	ff d0                	callq  *%rax
            put_buffer(va);
  80099c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8009a0:	48 89 c7             	mov    %rax,%rdi
  8009a3:	48 b8 31 01 80 00 00 	movabs $0x800131,%rax
  8009aa:	00 00 00 
  8009ad:	ff d0                	callq  *%rax
            continue;
  8009af:	e9 d1 00 00 00       	jmpq   800a85 <serve+0x16f>
        }

        // All remaining requests must contain an argument page
        if (!(perm & PTE_P)) {
  8009b4:	8b 45 d8             	mov    -0x28(%rbp),%eax
  8009b7:	83 e0 01             	and    $0x1,%eax
  8009ba:	85 c0                	test   %eax,%eax
  8009bc:	75 25                	jne    8009e3 <serve+0xcd>
            cprintf("Invalid request from %08x: no argument page\n", whom);
  8009be:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8009c1:	89 c6                	mov    %eax,%esi
  8009c3:	48 bf f0 0b 82 00 00 	movabs $0x820bf0,%rdi
  8009ca:	00 00 00 
  8009cd:	b8 00 00 00 00       	mov    $0x0,%eax
  8009d2:	48 ba 22 13 80 00 00 	movabs $0x801322,%rdx
  8009d9:	00 00 00 
  8009dc:	ff d2                	callq  *%rdx
            continue; // just leave it hanging...
  8009de:	e9 a2 00 00 00       	jmpq   800a85 <serve+0x16f>
        }

        // Since some lwIP socket calls will block, create a thread and
        // process the rest of the request in the thread.
        struct st_args *args = malloc(sizeof(struct st_args));
  8009e3:	bf 10 00 00 00       	mov    $0x10,%edi
  8009e8:	48 b8 0f 4e 80 00 00 	movabs $0x804e0f,%rax
  8009ef:	00 00 00 
  8009f2:	ff d0                	callq  *%rax
  8009f4:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        if (!args)
  8009f8:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8009fd:	75 2a                	jne    800a29 <serve+0x113>
            panic("could not allocate thread args structure");
  8009ff:	48 ba 20 0c 82 00 00 	movabs $0x820c20,%rdx
  800a06:	00 00 00 
  800a09:	be 27 01 00 00       	mov    $0x127,%esi
  800a0e:	48 bf 54 0a 82 00 00 	movabs $0x820a54,%rdi
  800a15:	00 00 00 
  800a18:	b8 00 00 00 00       	mov    $0x0,%eax
  800a1d:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  800a24:	00 00 00 
  800a27:	ff d1                	callq  *%rcx

        args->reqno = reqno;
  800a29:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800a2d:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800a30:	89 10                	mov    %edx,(%rax)
        args->whom = whom;
  800a32:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800a35:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800a39:	89 50 04             	mov    %edx,0x4(%rax)
        args->req = va;
  800a3c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800a40:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800a44:	48 89 50 08          	mov    %rdx,0x8(%rax)

        thread_create(0, "serve_thread", serve_thread, (uint64_t)args);
  800a48:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800a4c:	48 89 c1             	mov    %rax,%rcx
  800a4f:	48 ba 0e 06 80 00 00 	movabs $0x80060e,%rdx
  800a56:	00 00 00 
  800a59:	48 be 49 0c 82 00 00 	movabs $0x820c49,%rsi
  800a60:	00 00 00 
  800a63:	bf 00 00 00 00       	mov    $0x0,%edi
  800a68:	48 b8 8e 8e 81 00 00 	movabs $0x818e8e,%rax
  800a6f:	00 00 00 
  800a72:	ff d0                	callq  *%rax
        thread_yield(); // let the thread created run
  800a74:	48 b8 0e 91 81 00 00 	movabs $0x81910e,%rax
  800a7b:	00 00 00 
  800a7e:	ff d0                	callq  *%rax
    }
  800a80:	e9 99 fe ff ff       	jmpq   80091e <serve+0x8>
  800a85:	e9 94 fe ff ff       	jmpq   80091e <serve+0x8>

0000000000800a8a <tmain>:
}

static void
tmain(uint64_t arg) {
  800a8a:	55                   	push   %rbp
  800a8b:	48 89 e5             	mov    %rsp,%rbp
  800a8e:	41 54                	push   %r12
  800a90:	53                   	push   %rbx
  800a91:	48 83 ec 10          	sub    $0x10,%rsp
  800a95:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    serve_init(inet_addr(IP),
  800a99:	48 bf 56 0c 82 00 00 	movabs $0x820c56,%rdi
  800aa0:	00 00 00 
  800aa3:	48 b8 00 2c 81 00 00 	movabs $0x812c00,%rax
  800aaa:	00 00 00 
  800aad:	ff d0                	callq  *%rax
  800aaf:	41 89 c4             	mov    %eax,%r12d
  800ab2:	48 bf 5f 0c 82 00 00 	movabs $0x820c5f,%rdi
  800ab9:	00 00 00 
  800abc:	48 b8 00 2c 81 00 00 	movabs $0x812c00,%rax
  800ac3:	00 00 00 
  800ac6:	ff d0                	callq  *%rax
  800ac8:	89 c3                	mov    %eax,%ebx
  800aca:	48 bf 6d 0c 82 00 00 	movabs $0x820c6d,%rdi
  800ad1:	00 00 00 
  800ad4:	48 b8 00 2c 81 00 00 	movabs $0x812c00,%rax
  800adb:	00 00 00 
  800ade:	ff d0                	callq  *%rax
  800ae0:	44 89 e2             	mov    %r12d,%edx
  800ae3:	89 de                	mov    %ebx,%esi
  800ae5:	89 c7                	mov    %eax,%edi
  800ae7:	48 b8 74 03 80 00 00 	movabs $0x800374,%rax
  800aee:	00 00 00 
  800af1:	ff d0                	callq  *%rax
            inet_addr(MASK),
            inet_addr(DEFAULT));
    serve();
  800af3:	48 b8 16 09 80 00 00 	movabs $0x800916,%rax
  800afa:	00 00 00 
  800afd:	ff d0                	callq  *%rax
}
  800aff:	48 83 c4 10          	add    $0x10,%rsp
  800b03:	5b                   	pop    %rbx
  800b04:	41 5c                	pop    %r12
  800b06:	5d                   	pop    %rbp
  800b07:	c3                   	retq   

0000000000800b08 <umain>:

    void
umain(int argc, char **argv)
{
  800b08:	55                   	push   %rbp
  800b09:	48 89 e5             	mov    %rsp,%rbp
  800b0c:	53                   	push   %rbx
  800b0d:	48 83 ec 28          	sub    $0x28,%rsp
  800b11:	89 7d dc             	mov    %edi,-0x24(%rbp)
  800b14:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
    envid_t ns_envid = sys_getenvid();
  800b18:	48 b8 8a 27 80 00 00 	movabs $0x80278a,%rax
  800b1f:	00 00 00 
  800b22:	ff d0                	callq  *%rax
  800b24:	89 45 ec             	mov    %eax,-0x14(%rbp)

    binaryname = "ns";
  800b27:	48 b8 00 80 82 00 00 	movabs $0x828000,%rax
  800b2e:	00 00 00 
  800b31:	48 bb 77 0c 82 00 00 	movabs $0x820c77,%rbx
  800b38:	00 00 00 
  800b3b:	48 89 18             	mov    %rbx,(%rax)

    // fork off the timer thread which will send us periodic messages
    timer_envid = fork();
  800b3e:	48 b8 86 2f 80 00 00 	movabs $0x802f86,%rax
  800b45:	00 00 00 
  800b48:	ff d0                	callq  *%rax
  800b4a:	48 ba 58 90 82 00 00 	movabs $0x829058,%rdx
  800b51:	00 00 00 
  800b54:	89 02                	mov    %eax,(%rdx)
    if (timer_envid < 0)
  800b56:	48 b8 58 90 82 00 00 	movabs $0x829058,%rax
  800b5d:	00 00 00 
  800b60:	8b 00                	mov    (%rax),%eax
  800b62:	85 c0                	test   %eax,%eax
  800b64:	79 2a                	jns    800b90 <umain+0x88>
        panic("error forking");
  800b66:	48 ba 7a 0c 82 00 00 	movabs $0x820c7a,%rdx
  800b6d:	00 00 00 
  800b70:	be 44 01 00 00       	mov    $0x144,%esi
  800b75:	48 bf 54 0a 82 00 00 	movabs $0x820a54,%rdi
  800b7c:	00 00 00 
  800b7f:	b8 00 00 00 00       	mov    $0x0,%eax
  800b84:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  800b8b:	00 00 00 
  800b8e:	ff d1                	callq  *%rcx
    else if (timer_envid == 0) {
  800b90:	48 b8 58 90 82 00 00 	movabs $0x829058,%rax
  800b97:	00 00 00 
  800b9a:	8b 00                	mov    (%rax),%eax
  800b9c:	85 c0                	test   %eax,%eax
  800b9e:	75 1b                	jne    800bbb <umain+0xb3>
        timer(ns_envid, TIMER_INTERVAL);
  800ba0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800ba3:	be fa 00 00 00       	mov    $0xfa,%esi
  800ba8:	89 c7                	mov    %eax,%edi
  800baa:	48 b8 f1 0c 80 00 00 	movabs $0x800cf1,%rax
  800bb1:	00 00 00 
  800bb4:	ff d0                	callq  *%rax
        return;
  800bb6:	e9 2f 01 00 00       	jmpq   800cea <umain+0x1e2>
    }

    // fork off the input thread which will poll the NIC driver for input
    // packets
    input_envid = fork();
  800bbb:	48 b8 86 2f 80 00 00 	movabs $0x802f86,%rax
  800bc2:	00 00 00 
  800bc5:	ff d0                	callq  *%rax
  800bc7:	48 ba 5c 90 82 00 00 	movabs $0x82905c,%rdx
  800bce:	00 00 00 
  800bd1:	89 02                	mov    %eax,(%rdx)
    if (input_envid < 0)
  800bd3:	48 b8 5c 90 82 00 00 	movabs $0x82905c,%rax
  800bda:	00 00 00 
  800bdd:	8b 00                	mov    (%rax),%eax
  800bdf:	85 c0                	test   %eax,%eax
  800be1:	79 2a                	jns    800c0d <umain+0x105>
        panic("error forking");
  800be3:	48 ba 7a 0c 82 00 00 	movabs $0x820c7a,%rdx
  800bea:	00 00 00 
  800bed:	be 4e 01 00 00       	mov    $0x14e,%esi
  800bf2:	48 bf 54 0a 82 00 00 	movabs $0x820a54,%rdi
  800bf9:	00 00 00 
  800bfc:	b8 00 00 00 00       	mov    $0x0,%eax
  800c01:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  800c08:	00 00 00 
  800c0b:	ff d1                	callq  *%rcx
    else if (input_envid == 0) {
  800c0d:	48 b8 5c 90 82 00 00 	movabs $0x82905c,%rax
  800c14:	00 00 00 
  800c17:	8b 00                	mov    (%rax),%eax
  800c19:	85 c0                	test   %eax,%eax
  800c1b:	75 16                	jne    800c33 <umain+0x12b>
        input(ns_envid);
  800c1d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800c20:	89 c7                	mov    %eax,%edi
  800c22:	48 b8 12 0e 80 00 00 	movabs $0x800e12,%rax
  800c29:	00 00 00 
  800c2c:	ff d0                	callq  *%rax
        return;
  800c2e:	e9 b7 00 00 00       	jmpq   800cea <umain+0x1e2>
    }

    // fork off the output thread that will send the packets to the NIC
    // driver
    output_envid = fork();
  800c33:	48 b8 86 2f 80 00 00 	movabs $0x802f86,%rax
  800c3a:	00 00 00 
  800c3d:	ff d0                	callq  *%rax
  800c3f:	48 ba 60 90 82 00 00 	movabs $0x829060,%rdx
  800c46:	00 00 00 
  800c49:	89 02                	mov    %eax,(%rdx)
    if (output_envid < 0)
  800c4b:	48 b8 60 90 82 00 00 	movabs $0x829060,%rax
  800c52:	00 00 00 
  800c55:	8b 00                	mov    (%rax),%eax
  800c57:	85 c0                	test   %eax,%eax
  800c59:	79 2a                	jns    800c85 <umain+0x17d>
        panic("error forking");
  800c5b:	48 ba 7a 0c 82 00 00 	movabs $0x820c7a,%rdx
  800c62:	00 00 00 
  800c65:	be 58 01 00 00       	mov    $0x158,%esi
  800c6a:	48 bf 54 0a 82 00 00 	movabs $0x820a54,%rdi
  800c71:	00 00 00 
  800c74:	b8 00 00 00 00       	mov    $0x0,%eax
  800c79:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  800c80:	00 00 00 
  800c83:	ff d1                	callq  *%rcx
    else if (output_envid == 0) {
  800c85:	48 b8 60 90 82 00 00 	movabs $0x829060,%rax
  800c8c:	00 00 00 
  800c8f:	8b 00                	mov    (%rax),%eax
  800c91:	85 c0                	test   %eax,%eax
  800c93:	75 13                	jne    800ca8 <umain+0x1a0>
        output(ns_envid);
  800c95:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800c98:	89 c7                	mov    %eax,%edi
  800c9a:	48 b8 2c 0f 80 00 00 	movabs $0x800f2c,%rax
  800ca1:	00 00 00 
  800ca4:	ff d0                	callq  *%rax
        return;
  800ca6:	eb 42                	jmp    800cea <umain+0x1e2>
    }

    // lwIP requires a user threading library; start the library and jump
    // into a thread to continue initialization.
    thread_init();
  800ca8:	48 b8 85 8b 81 00 00 	movabs $0x818b85,%rax
  800caf:	00 00 00 
  800cb2:	ff d0                	callq  *%rax
    thread_create(0, "main", tmain, 0);
  800cb4:	b9 00 00 00 00       	mov    $0x0,%ecx
  800cb9:	48 ba 8a 0a 80 00 00 	movabs $0x800a8a,%rdx
  800cc0:	00 00 00 
  800cc3:	48 be 88 0c 82 00 00 	movabs $0x820c88,%rsi
  800cca:	00 00 00 
  800ccd:	bf 00 00 00 00       	mov    $0x0,%edi
  800cd2:	48 b8 8e 8e 81 00 00 	movabs $0x818e8e,%rax
  800cd9:	00 00 00 
  800cdc:	ff d0                	callq  *%rax
    thread_yield();
  800cde:	48 b8 0e 91 81 00 00 	movabs $0x81910e,%rax
  800ce5:	00 00 00 
  800ce8:	ff d0                	callq  *%rax
    // never coming here!
}
  800cea:	48 83 c4 28          	add    $0x28,%rsp
  800cee:	5b                   	pop    %rbx
  800cef:	5d                   	pop    %rbp
  800cf0:	c3                   	retq   

0000000000800cf1 <timer>:

#include "ns.h"

void
timer(envid_t ns_envid, uint32_t initial_to) {
  800cf1:	55                   	push   %rbp
  800cf2:	48 89 e5             	mov    %rsp,%rbp
  800cf5:	53                   	push   %rbx
  800cf6:	48 83 ec 28          	sub    $0x28,%rsp
  800cfa:	89 7d dc             	mov    %edi,-0x24(%rbp)
  800cfd:	89 75 d8             	mov    %esi,-0x28(%rbp)
    int r;
    uint32_t stop = sys_time_msec() + initial_to;
  800d00:	48 b8 73 2a 80 00 00 	movabs $0x802a73,%rax
  800d07:	00 00 00 
  800d0a:	ff d0                	callq  *%rax
  800d0c:	8b 55 d8             	mov    -0x28(%rbp),%edx
  800d0f:	01 d0                	add    %edx,%eax
  800d11:	89 45 ec             	mov    %eax,-0x14(%rbp)

    binaryname = "ns_timer";
  800d14:	48 b8 00 80 82 00 00 	movabs $0x828000,%rax
  800d1b:	00 00 00 
  800d1e:	48 bb 90 0c 82 00 00 	movabs $0x820c90,%rbx
  800d25:	00 00 00 
  800d28:	48 89 18             	mov    %rbx,(%rax)

    while (1) {
        while((r = sys_time_msec()) < stop && r >= 0) {
  800d2b:	eb 0c                	jmp    800d39 <timer+0x48>
            sys_yield();
  800d2d:	48 b8 c8 27 80 00 00 	movabs $0x8027c8,%rax
  800d34:	00 00 00 
  800d37:	ff d0                	callq  *%rax
    uint32_t stop = sys_time_msec() + initial_to;

    binaryname = "ns_timer";

    while (1) {
        while((r = sys_time_msec()) < stop && r >= 0) {
  800d39:	48 b8 73 2a 80 00 00 	movabs $0x802a73,%rax
  800d40:	00 00 00 
  800d43:	ff d0                	callq  *%rax
  800d45:	89 45 e8             	mov    %eax,-0x18(%rbp)
  800d48:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800d4b:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  800d4e:	73 06                	jae    800d56 <timer+0x65>
  800d50:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  800d54:	79 d7                	jns    800d2d <timer+0x3c>
            sys_yield();
        }
        if (r < 0)
  800d56:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  800d5a:	79 30                	jns    800d8c <timer+0x9b>
            panic("sys_time_msec: %e", r);
  800d5c:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800d5f:	89 c1                	mov    %eax,%ecx
  800d61:	48 ba 99 0c 82 00 00 	movabs $0x820c99,%rdx
  800d68:	00 00 00 
  800d6b:	be 10 00 00 00       	mov    $0x10,%esi
  800d70:	48 bf ab 0c 82 00 00 	movabs $0x820cab,%rdi
  800d77:	00 00 00 
  800d7a:	b8 00 00 00 00       	mov    $0x0,%eax
  800d7f:	49 b8 e9 10 80 00 00 	movabs $0x8010e9,%r8
  800d86:	00 00 00 
  800d89:	41 ff d0             	callq  *%r8

        ipc_send(ns_envid, NSREQ_TIMER, 0, 0);
  800d8c:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800d8f:	b9 00 00 00 00       	mov    $0x0,%ecx
  800d94:	ba 00 00 00 00       	mov    $0x0,%edx
  800d99:	be 0c 00 00 00       	mov    $0xc,%esi
  800d9e:	89 c7                	mov    %eax,%edi
  800da0:	48 b8 bc 32 80 00 00 	movabs $0x8032bc,%rax
  800da7:	00 00 00 
  800daa:	ff d0                	callq  *%rax

        while (1) {
            uint32_t to, whom;
            to = ipc_recv((int32_t *) &whom, 0, 0);
  800dac:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  800db0:	ba 00 00 00 00       	mov    $0x0,%edx
  800db5:	be 00 00 00 00       	mov    $0x0,%esi
  800dba:	48 89 c7             	mov    %rax,%rdi
  800dbd:	48 b8 fb 31 80 00 00 	movabs $0x8031fb,%rax
  800dc4:	00 00 00 
  800dc7:	ff d0                	callq  *%rax
  800dc9:	89 45 e4             	mov    %eax,-0x1c(%rbp)

            if (whom != ns_envid) {
  800dcc:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800dcf:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800dd2:	39 c2                	cmp    %eax,%edx
  800dd4:	74 22                	je     800df8 <timer+0x107>
                cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
  800dd6:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800dd9:	89 c6                	mov    %eax,%esi
  800ddb:	48 bf b8 0c 82 00 00 	movabs $0x820cb8,%rdi
  800de2:	00 00 00 
  800de5:	b8 00 00 00 00       	mov    $0x0,%eax
  800dea:	48 ba 22 13 80 00 00 	movabs $0x801322,%rdx
  800df1:	00 00 00 
  800df4:	ff d2                	callq  *%rdx
                continue;
            }

            stop = sys_time_msec() + to;
            break;
        }
  800df6:	eb b4                	jmp    800dac <timer+0xbb>
            if (whom != ns_envid) {
                cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
                continue;
            }

            stop = sys_time_msec() + to;
  800df8:	48 b8 73 2a 80 00 00 	movabs $0x802a73,%rax
  800dff:	00 00 00 
  800e02:	ff d0                	callq  *%rax
  800e04:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  800e07:	01 d0                	add    %edx,%eax
  800e09:	89 45 ec             	mov    %eax,-0x14(%rbp)
            break;
        }
    }
  800e0c:	90                   	nop
    uint32_t stop = sys_time_msec() + initial_to;

    binaryname = "ns_timer";

    while (1) {
        while((r = sys_time_msec()) < stop && r >= 0) {
  800e0d:	e9 27 ff ff ff       	jmpq   800d39 <timer+0x48>

0000000000800e12 <input>:

extern union Nsipc nsipcbuf;

    void
input(envid_t ns_envid)
{
  800e12:	55                   	push   %rbp
  800e13:	48 89 e5             	mov    %rsp,%rbp
  800e16:	53                   	push   %rbx
  800e17:	48 83 ec 28          	sub    $0x28,%rsp
  800e1b:	89 7d dc             	mov    %edi,-0x24(%rbp)
    binaryname = "ns_input";
  800e1e:	48 b8 00 80 82 00 00 	movabs $0x828000,%rax
  800e25:	00 00 00 
  800e28:	48 bb f3 0c 82 00 00 	movabs $0x820cf3,%rbx
  800e2f:	00 00 00 
  800e32:	48 89 18             	mov    %rbx,(%rax)

    while (1) {
        int r;
        if ((r = sys_page_alloc(0, &nsipcbuf, PTE_P|PTE_U|PTE_W)) < 0)
  800e35:	ba 07 00 00 00       	mov    $0x7,%edx
  800e3a:	48 be 00 a0 b5 00 00 	movabs $0xb5a000,%rsi
  800e41:	00 00 00 
  800e44:	bf 00 00 00 00       	mov    $0x0,%edi
  800e49:	48 b8 06 28 80 00 00 	movabs $0x802806,%rax
  800e50:	00 00 00 
  800e53:	ff d0                	callq  *%rax
  800e55:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800e58:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800e5c:	79 30                	jns    800e8e <input+0x7c>
            panic("sys_page_alloc: %e", r);
  800e5e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800e61:	89 c1                	mov    %eax,%ecx
  800e63:	48 ba fc 0c 82 00 00 	movabs $0x820cfc,%rdx
  800e6a:	00 00 00 
  800e6d:	be 0e 00 00 00       	mov    $0xe,%esi
  800e72:	48 bf 0f 0d 82 00 00 	movabs $0x820d0f,%rdi
  800e79:	00 00 00 
  800e7c:	b8 00 00 00 00       	mov    $0x0,%eax
  800e81:	49 b8 e9 10 80 00 00 	movabs $0x8010e9,%r8
  800e88:	00 00 00 
  800e8b:	41 ff d0             	callq  *%r8
        r = sys_net_receive(nsipcbuf.pkt.jp_data, 1518);
  800e8e:	be ee 05 00 00       	mov    $0x5ee,%esi
  800e93:	48 bf 04 a0 b5 00 00 	movabs $0xb5a004,%rdi
  800e9a:	00 00 00 
  800e9d:	48 b8 f9 2a 80 00 00 	movabs $0x802af9,%rax
  800ea4:	00 00 00 
  800ea7:	ff d0                	callq  *%rax
  800ea9:	89 45 ec             	mov    %eax,-0x14(%rbp)
        if (r == 0) {
  800eac:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800eb0:	75 0e                	jne    800ec0 <input+0xae>
            sys_yield();
  800eb2:	48 b8 c8 27 80 00 00 	movabs $0x8027c8,%rax
  800eb9:	00 00 00 
  800ebc:	ff d0                	callq  *%rax
  800ebe:	eb 67                	jmp    800f27 <input+0x115>
        } else if (r < 0) {
  800ec0:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800ec4:	79 22                	jns    800ee8 <input+0xd6>
            cprintf("Failed to receive packet: %e\n", r);
  800ec6:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800ec9:	89 c6                	mov    %eax,%esi
  800ecb:	48 bf 1b 0d 82 00 00 	movabs $0x820d1b,%rdi
  800ed2:	00 00 00 
  800ed5:	b8 00 00 00 00       	mov    $0x0,%eax
  800eda:	48 ba 22 13 80 00 00 	movabs $0x801322,%rdx
  800ee1:	00 00 00 
  800ee4:	ff d2                	callq  *%rdx
  800ee6:	eb 3f                	jmp    800f27 <input+0x115>
        } else if (r > 0) {
  800ee8:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800eec:	7e 39                	jle    800f27 <input+0x115>
            nsipcbuf.pkt.jp_len = r;
  800eee:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  800ef5:	00 00 00 
  800ef8:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800efb:	89 10                	mov    %edx,(%rax)
            ipc_send(ns_envid, NSREQ_INPUT, &nsipcbuf, PTE_U|PTE_P);
  800efd:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800f00:	b9 05 00 00 00       	mov    $0x5,%ecx
  800f05:	48 ba 00 a0 b5 00 00 	movabs $0xb5a000,%rdx
  800f0c:	00 00 00 
  800f0f:	be 0a 00 00 00       	mov    $0xa,%esi
  800f14:	89 c7                	mov    %eax,%edi
  800f16:	48 b8 bc 32 80 00 00 	movabs $0x8032bc,%rax
  800f1d:	00 00 00 
  800f20:	ff d0                	callq  *%rax
        }
    }
  800f22:	e9 0e ff ff ff       	jmpq   800e35 <input+0x23>
  800f27:	e9 09 ff ff ff       	jmpq   800e35 <input+0x23>

0000000000800f2c <output>:

extern union Nsipc nsipcbuf;

    void
output(envid_t ns_envid)
{
  800f2c:	55                   	push   %rbp
  800f2d:	48 89 e5             	mov    %rsp,%rbp
  800f30:	53                   	push   %rbx
  800f31:	48 83 ec 28          	sub    $0x28,%rsp
  800f35:	89 7d dc             	mov    %edi,-0x24(%rbp)
    binaryname = "ns_output";
  800f38:	48 b8 00 80 82 00 00 	movabs $0x828000,%rax
  800f3f:	00 00 00 
  800f42:	48 bb 40 0d 82 00 00 	movabs $0x820d40,%rbx
  800f49:	00 00 00 
  800f4c:	48 89 18             	mov    %rbx,(%rax)

    int r;

    while (1) {
        int32_t req, whom;
        req = ipc_recv(&whom, &nsipcbuf, NULL);
  800f4f:	48 8d 45 e4          	lea    -0x1c(%rbp),%rax
  800f53:	ba 00 00 00 00       	mov    $0x0,%edx
  800f58:	48 be 00 a0 b5 00 00 	movabs $0xb5a000,%rsi
  800f5f:	00 00 00 
  800f62:	48 89 c7             	mov    %rax,%rdi
  800f65:	48 b8 fb 31 80 00 00 	movabs $0x8031fb,%rax
  800f6c:	00 00 00 
  800f6f:	ff d0                	callq  *%rax
  800f71:	89 45 ec             	mov    %eax,-0x14(%rbp)
        assert(whom == ns_envid);
  800f74:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800f77:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  800f7a:	74 35                	je     800fb1 <output+0x85>
  800f7c:	48 b9 4a 0d 82 00 00 	movabs $0x820d4a,%rcx
  800f83:	00 00 00 
  800f86:	48 ba 5b 0d 82 00 00 	movabs $0x820d5b,%rdx
  800f8d:	00 00 00 
  800f90:	be 11 00 00 00       	mov    $0x11,%esi
  800f95:	48 bf 70 0d 82 00 00 	movabs $0x820d70,%rdi
  800f9c:	00 00 00 
  800f9f:	b8 00 00 00 00       	mov    $0x0,%eax
  800fa4:	49 b8 e9 10 80 00 00 	movabs $0x8010e9,%r8
  800fab:	00 00 00 
  800fae:	41 ff d0             	callq  *%r8
        assert(req == NSREQ_OUTPUT);
  800fb1:	83 7d ec 0b          	cmpl   $0xb,-0x14(%rbp)
  800fb5:	74 35                	je     800fec <output+0xc0>
  800fb7:	48 b9 7d 0d 82 00 00 	movabs $0x820d7d,%rcx
  800fbe:	00 00 00 
  800fc1:	48 ba 5b 0d 82 00 00 	movabs $0x820d5b,%rdx
  800fc8:	00 00 00 
  800fcb:	be 12 00 00 00       	mov    $0x12,%esi
  800fd0:	48 bf 70 0d 82 00 00 	movabs $0x820d70,%rdi
  800fd7:	00 00 00 
  800fda:	b8 00 00 00 00       	mov    $0x0,%eax
  800fdf:	49 b8 e9 10 80 00 00 	movabs $0x8010e9,%r8
  800fe6:	00 00 00 
  800fe9:	41 ff d0             	callq  *%r8
        if ((r = sys_net_transmit(nsipcbuf.pkt.jp_data, nsipcbuf.pkt.jp_len)) < 0)
  800fec:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  800ff3:	00 00 00 
  800ff6:	8b 00                	mov    (%rax),%eax
  800ff8:	89 c6                	mov    %eax,%esi
  800ffa:	48 bf 04 a0 b5 00 00 	movabs $0xb5a004,%rdi
  801001:	00 00 00 
  801004:	48 b8 b1 2a 80 00 00 	movabs $0x802ab1,%rax
  80100b:	00 00 00 
  80100e:	ff d0                	callq  *%rax
  801010:	89 45 e8             	mov    %eax,-0x18(%rbp)
  801013:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  801017:	79 25                	jns    80103e <output+0x112>
            cprintf("Failed to transmit packet: %e\n", r);
  801019:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80101c:	89 c6                	mov    %eax,%esi
  80101e:	48 bf 98 0d 82 00 00 	movabs $0x820d98,%rdi
  801025:	00 00 00 
  801028:	b8 00 00 00 00       	mov    $0x0,%eax
  80102d:	48 ba 22 13 80 00 00 	movabs $0x801322,%rdx
  801034:	00 00 00 
  801037:	ff d2                	callq  *%rdx
    }
  801039:	e9 11 ff ff ff       	jmpq   800f4f <output+0x23>
  80103e:	e9 0c ff ff ff       	jmpq   800f4f <output+0x23>

0000000000801043 <libmain>:
const volatile struct Env *thisenv;
const char *binaryname = "<unknown>";

void
libmain(int argc, char **argv)
{
  801043:	55                   	push   %rbp
  801044:	48 89 e5             	mov    %rsp,%rbp
  801047:	48 83 ec 10          	sub    $0x10,%rsp
  80104b:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80104e:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	// set thisenv to point at our Env structure in envs[].

	thisenv = &envs[ENVX(sys_getenvid())];
  801052:	48 b8 8a 27 80 00 00 	movabs $0x80278a,%rax
  801059:	00 00 00 
  80105c:	ff d0                	callq  *%rax
  80105e:	25 ff 03 00 00       	and    $0x3ff,%eax
  801063:	48 98                	cltq   
  801065:	48 69 d0 68 01 00 00 	imul   $0x168,%rax,%rdx
  80106c:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  801073:	00 00 00 
  801076:	48 01 c2             	add    %rax,%rdx
  801079:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  801080:	00 00 00 
  801083:	48 89 10             	mov    %rdx,(%rax)


	// save the name of the program so that panic() can use it
	if (argc > 0)
  801086:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80108a:	7e 14                	jle    8010a0 <libmain+0x5d>
		binaryname = argv[0];
  80108c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801090:	48 8b 10             	mov    (%rax),%rdx
  801093:	48 b8 00 80 82 00 00 	movabs $0x828000,%rax
  80109a:	00 00 00 
  80109d:	48 89 10             	mov    %rdx,(%rax)

	// call user main routine
	umain(argc, argv);
  8010a0:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8010a4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8010a7:	48 89 d6             	mov    %rdx,%rsi
  8010aa:	89 c7                	mov    %eax,%edi
  8010ac:	48 b8 08 0b 80 00 00 	movabs $0x800b08,%rax
  8010b3:	00 00 00 
  8010b6:	ff d0                	callq  *%rax

	// exit gracefully
	exit();
  8010b8:	48 b8 c6 10 80 00 00 	movabs $0x8010c6,%rax
  8010bf:	00 00 00 
  8010c2:	ff d0                	callq  *%rax
}
  8010c4:	c9                   	leaveq 
  8010c5:	c3                   	retq   

00000000008010c6 <exit>:

#include <inc/lib.h>

void
exit(void)
{
  8010c6:	55                   	push   %rbp
  8010c7:	48 89 e5             	mov    %rsp,%rbp

	close_all();
  8010ca:	48 b8 7b 38 80 00 00 	movabs $0x80387b,%rax
  8010d1:	00 00 00 
  8010d4:	ff d0                	callq  *%rax

	sys_env_destroy(0);
  8010d6:	bf 00 00 00 00       	mov    $0x0,%edi
  8010db:	48 b8 46 27 80 00 00 	movabs $0x802746,%rax
  8010e2:	00 00 00 
  8010e5:	ff d0                	callq  *%rax
}
  8010e7:	5d                   	pop    %rbp
  8010e8:	c3                   	retq   

00000000008010e9 <_panic>:
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt, ...)
{
  8010e9:	55                   	push   %rbp
  8010ea:	48 89 e5             	mov    %rsp,%rbp
  8010ed:	53                   	push   %rbx
  8010ee:	48 81 ec f8 00 00 00 	sub    $0xf8,%rsp
  8010f5:	48 89 bd 18 ff ff ff 	mov    %rdi,-0xe8(%rbp)
  8010fc:	89 b5 14 ff ff ff    	mov    %esi,-0xec(%rbp)
  801102:	48 89 8d 58 ff ff ff 	mov    %rcx,-0xa8(%rbp)
  801109:	4c 89 85 60 ff ff ff 	mov    %r8,-0xa0(%rbp)
  801110:	4c 89 8d 68 ff ff ff 	mov    %r9,-0x98(%rbp)
  801117:	84 c0                	test   %al,%al
  801119:	74 23                	je     80113e <_panic+0x55>
  80111b:	0f 29 85 70 ff ff ff 	movaps %xmm0,-0x90(%rbp)
  801122:	0f 29 4d 80          	movaps %xmm1,-0x80(%rbp)
  801126:	0f 29 55 90          	movaps %xmm2,-0x70(%rbp)
  80112a:	0f 29 5d a0          	movaps %xmm3,-0x60(%rbp)
  80112e:	0f 29 65 b0          	movaps %xmm4,-0x50(%rbp)
  801132:	0f 29 6d c0          	movaps %xmm5,-0x40(%rbp)
  801136:	0f 29 75 d0          	movaps %xmm6,-0x30(%rbp)
  80113a:	0f 29 7d e0          	movaps %xmm7,-0x20(%rbp)
  80113e:	48 89 95 08 ff ff ff 	mov    %rdx,-0xf8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  801145:	c7 85 28 ff ff ff 18 	movl   $0x18,-0xd8(%rbp)
  80114c:	00 00 00 
  80114f:	c7 85 2c ff ff ff 30 	movl   $0x30,-0xd4(%rbp)
  801156:	00 00 00 
  801159:	48 8d 45 10          	lea    0x10(%rbp),%rax
  80115d:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
  801164:	48 8d 85 40 ff ff ff 	lea    -0xc0(%rbp),%rax
  80116b:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)

	// Print the panic message
	cprintf("[%08x] user panic in %s at %s:%d: ",
  801172:	48 b8 00 80 82 00 00 	movabs $0x828000,%rax
  801179:	00 00 00 
  80117c:	48 8b 18             	mov    (%rax),%rbx
  80117f:	48 b8 8a 27 80 00 00 	movabs $0x80278a,%rax
  801186:	00 00 00 
  801189:	ff d0                	callq  *%rax
  80118b:	8b 8d 14 ff ff ff    	mov    -0xec(%rbp),%ecx
  801191:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  801198:	41 89 c8             	mov    %ecx,%r8d
  80119b:	48 89 d1             	mov    %rdx,%rcx
  80119e:	48 89 da             	mov    %rbx,%rdx
  8011a1:	89 c6                	mov    %eax,%esi
  8011a3:	48 bf c8 0d 82 00 00 	movabs $0x820dc8,%rdi
  8011aa:	00 00 00 
  8011ad:	b8 00 00 00 00       	mov    $0x0,%eax
  8011b2:	49 b9 22 13 80 00 00 	movabs $0x801322,%r9
  8011b9:	00 00 00 
  8011bc:	41 ff d1             	callq  *%r9
		sys_getenvid(), binaryname, file, line);
	vcprintf(fmt, ap);
  8011bf:	48 8d 95 28 ff ff ff 	lea    -0xd8(%rbp),%rdx
  8011c6:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8011cd:	48 89 d6             	mov    %rdx,%rsi
  8011d0:	48 89 c7             	mov    %rax,%rdi
  8011d3:	48 b8 76 12 80 00 00 	movabs $0x801276,%rax
  8011da:	00 00 00 
  8011dd:	ff d0                	callq  *%rax
	cprintf("\n");
  8011df:	48 bf eb 0d 82 00 00 	movabs $0x820deb,%rdi
  8011e6:	00 00 00 
  8011e9:	b8 00 00 00 00       	mov    $0x0,%eax
  8011ee:	48 ba 22 13 80 00 00 	movabs $0x801322,%rdx
  8011f5:	00 00 00 
  8011f8:	ff d2                	callq  *%rdx

	// Cause a breakpoint exception
	while (1)
		asm volatile("int3");
  8011fa:	cc                   	int3   
  8011fb:	eb fd                	jmp    8011fa <_panic+0x111>

00000000008011fd <putch>:
};


    static void
putch(int ch, struct printbuf *b)
{
  8011fd:	55                   	push   %rbp
  8011fe:	48 89 e5             	mov    %rsp,%rbp
  801201:	48 83 ec 10          	sub    $0x10,%rsp
  801205:	89 7d fc             	mov    %edi,-0x4(%rbp)
  801208:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    b->buf[b->idx++] = ch;
  80120c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801210:	8b 00                	mov    (%rax),%eax
  801212:	8d 48 01             	lea    0x1(%rax),%ecx
  801215:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  801219:	89 0a                	mov    %ecx,(%rdx)
  80121b:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80121e:	89 d1                	mov    %edx,%ecx
  801220:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  801224:	48 98                	cltq   
  801226:	88 4c 02 08          	mov    %cl,0x8(%rdx,%rax,1)
    if (b->idx == 256-1) {
  80122a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80122e:	8b 00                	mov    (%rax),%eax
  801230:	3d ff 00 00 00       	cmp    $0xff,%eax
  801235:	75 2c                	jne    801263 <putch+0x66>
        sys_cputs(b->buf, b->idx);
  801237:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80123b:	8b 00                	mov    (%rax),%eax
  80123d:	48 98                	cltq   
  80123f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  801243:	48 83 c2 08          	add    $0x8,%rdx
  801247:	48 89 c6             	mov    %rax,%rsi
  80124a:	48 89 d7             	mov    %rdx,%rdi
  80124d:	48 b8 be 26 80 00 00 	movabs $0x8026be,%rax
  801254:	00 00 00 
  801257:	ff d0                	callq  *%rax
        b->idx = 0;
  801259:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80125d:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
    }
    b->cnt++;
  801263:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801267:	8b 40 04             	mov    0x4(%rax),%eax
  80126a:	8d 50 01             	lea    0x1(%rax),%edx
  80126d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801271:	89 50 04             	mov    %edx,0x4(%rax)
}
  801274:	c9                   	leaveq 
  801275:	c3                   	retq   

0000000000801276 <vcprintf>:

    int
vcprintf(const char *fmt, va_list ap)
{
  801276:	55                   	push   %rbp
  801277:	48 89 e5             	mov    %rsp,%rbp
  80127a:	48 81 ec 40 01 00 00 	sub    $0x140,%rsp
  801281:	48 89 bd c8 fe ff ff 	mov    %rdi,-0x138(%rbp)
  801288:	48 89 b5 c0 fe ff ff 	mov    %rsi,-0x140(%rbp)
    struct printbuf b;
    va_list aq;
    va_copy(aq,ap);
  80128f:	48 8d 85 d8 fe ff ff 	lea    -0x128(%rbp),%rax
  801296:	48 8b 95 c0 fe ff ff 	mov    -0x140(%rbp),%rdx
  80129d:	48 8b 0a             	mov    (%rdx),%rcx
  8012a0:	48 89 08             	mov    %rcx,(%rax)
  8012a3:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8012a7:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8012ab:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8012af:	48 89 50 10          	mov    %rdx,0x10(%rax)
    b.idx = 0;
  8012b3:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%rbp)
  8012ba:	00 00 00 
    b.cnt = 0;
  8012bd:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%rbp)
  8012c4:	00 00 00 
    vprintfmt((void*)putch, &b, fmt, aq);
  8012c7:	48 8d 8d d8 fe ff ff 	lea    -0x128(%rbp),%rcx
  8012ce:	48 8b 95 c8 fe ff ff 	mov    -0x138(%rbp),%rdx
  8012d5:	48 8d 85 f0 fe ff ff 	lea    -0x110(%rbp),%rax
  8012dc:	48 89 c6             	mov    %rax,%rsi
  8012df:	48 bf fd 11 80 00 00 	movabs $0x8011fd,%rdi
  8012e6:	00 00 00 
  8012e9:	48 b8 d5 16 80 00 00 	movabs $0x8016d5,%rax
  8012f0:	00 00 00 
  8012f3:	ff d0                	callq  *%rax
    sys_cputs(b.buf, b.idx);
  8012f5:	8b 85 f0 fe ff ff    	mov    -0x110(%rbp),%eax
  8012fb:	48 98                	cltq   
  8012fd:	48 8d 95 f0 fe ff ff 	lea    -0x110(%rbp),%rdx
  801304:	48 83 c2 08          	add    $0x8,%rdx
  801308:	48 89 c6             	mov    %rax,%rsi
  80130b:	48 89 d7             	mov    %rdx,%rdi
  80130e:	48 b8 be 26 80 00 00 	movabs $0x8026be,%rax
  801315:	00 00 00 
  801318:	ff d0                	callq  *%rax
    va_end(aq);

    return b.cnt;
  80131a:	8b 85 f4 fe ff ff    	mov    -0x10c(%rbp),%eax
}
  801320:	c9                   	leaveq 
  801321:	c3                   	retq   

0000000000801322 <cprintf>:

    int
cprintf(const char *fmt, ...)
{
  801322:	55                   	push   %rbp
  801323:	48 89 e5             	mov    %rsp,%rbp
  801326:	48 81 ec 00 01 00 00 	sub    $0x100,%rsp
  80132d:	48 89 b5 58 ff ff ff 	mov    %rsi,-0xa8(%rbp)
  801334:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
  80133b:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  801342:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  801349:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  801350:	84 c0                	test   %al,%al
  801352:	74 20                	je     801374 <cprintf+0x52>
  801354:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  801358:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  80135c:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  801360:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  801364:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  801368:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  80136c:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  801370:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  801374:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
    va_list ap;
    int cnt;
    va_list aq;
    va_start(ap, fmt);
  80137b:	c7 85 30 ff ff ff 08 	movl   $0x8,-0xd0(%rbp)
  801382:	00 00 00 
  801385:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  80138c:	00 00 00 
  80138f:	48 8d 45 10          	lea    0x10(%rbp),%rax
  801393:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  80139a:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8013a1:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
    va_copy(aq,ap);
  8013a8:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  8013af:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  8013b6:	48 8b 0a             	mov    (%rdx),%rcx
  8013b9:	48 89 08             	mov    %rcx,(%rax)
  8013bc:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8013c0:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8013c4:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8013c8:	48 89 50 10          	mov    %rdx,0x10(%rax)
    cnt = vcprintf(fmt, aq);
  8013cc:	48 8d 95 18 ff ff ff 	lea    -0xe8(%rbp),%rdx
  8013d3:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8013da:	48 89 d6             	mov    %rdx,%rsi
  8013dd:	48 89 c7             	mov    %rax,%rdi
  8013e0:	48 b8 76 12 80 00 00 	movabs $0x801276,%rax
  8013e7:	00 00 00 
  8013ea:	ff d0                	callq  *%rax
  8013ec:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
    va_end(aq);

    return cnt;
  8013f2:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  8013f8:	c9                   	leaveq 
  8013f9:	c3                   	retq   

00000000008013fa <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  8013fa:	55                   	push   %rbp
  8013fb:	48 89 e5             	mov    %rsp,%rbp
  8013fe:	53                   	push   %rbx
  8013ff:	48 83 ec 38          	sub    $0x38,%rsp
  801403:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801407:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80140b:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  80140f:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
  801412:	44 89 45 d0          	mov    %r8d,-0x30(%rbp)
  801416:	44 89 4d cc          	mov    %r9d,-0x34(%rbp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  80141a:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80141d:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  801421:	77 3b                	ja     80145e <printnum+0x64>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  801423:	8b 45 d0             	mov    -0x30(%rbp),%eax
  801426:	44 8d 40 ff          	lea    -0x1(%rax),%r8d
  80142a:	8b 5d d4             	mov    -0x2c(%rbp),%ebx
  80142d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  801431:	ba 00 00 00 00       	mov    $0x0,%edx
  801436:	48 f7 f3             	div    %rbx
  801439:	48 89 c2             	mov    %rax,%rdx
  80143c:	8b 7d cc             	mov    -0x34(%rbp),%edi
  80143f:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
  801442:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  801446:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80144a:	41 89 f9             	mov    %edi,%r9d
  80144d:	48 89 c7             	mov    %rax,%rdi
  801450:	48 b8 fa 13 80 00 00 	movabs $0x8013fa,%rax
  801457:	00 00 00 
  80145a:	ff d0                	callq  *%rax
  80145c:	eb 1e                	jmp    80147c <printnum+0x82>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  80145e:	eb 12                	jmp    801472 <printnum+0x78>
			putch(padc, putdat);
  801460:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  801464:	8b 55 cc             	mov    -0x34(%rbp),%edx
  801467:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80146b:	48 89 ce             	mov    %rcx,%rsi
  80146e:	89 d7                	mov    %edx,%edi
  801470:	ff d0                	callq  *%rax
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  801472:	83 6d d0 01          	subl   $0x1,-0x30(%rbp)
  801476:	83 7d d0 00          	cmpl   $0x0,-0x30(%rbp)
  80147a:	7f e4                	jg     801460 <printnum+0x66>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  80147c:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
  80147f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  801483:	ba 00 00 00 00       	mov    $0x0,%edx
  801488:	48 f7 f1             	div    %rcx
  80148b:	48 89 d0             	mov    %rdx,%rax
  80148e:	48 ba f0 0f 82 00 00 	movabs $0x820ff0,%rdx
  801495:	00 00 00 
  801498:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  80149c:	0f be d0             	movsbl %al,%edx
  80149f:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8014a3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8014a7:	48 89 ce             	mov    %rcx,%rsi
  8014aa:	89 d7                	mov    %edx,%edi
  8014ac:	ff d0                	callq  *%rax
}
  8014ae:	48 83 c4 38          	add    $0x38,%rsp
  8014b2:	5b                   	pop    %rbx
  8014b3:	5d                   	pop    %rbp
  8014b4:	c3                   	retq   

00000000008014b5 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  8014b5:	55                   	push   %rbp
  8014b6:	48 89 e5             	mov    %rsp,%rbp
  8014b9:	48 83 ec 1c          	sub    $0x1c,%rsp
  8014bd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8014c1:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	unsigned long long x;    
	if (lflag >= 2)
  8014c4:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  8014c8:	7e 52                	jle    80151c <getuint+0x67>
		x= va_arg(*ap, unsigned long long);
  8014ca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8014ce:	8b 00                	mov    (%rax),%eax
  8014d0:	83 f8 30             	cmp    $0x30,%eax
  8014d3:	73 24                	jae    8014f9 <getuint+0x44>
  8014d5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8014d9:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8014dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8014e1:	8b 00                	mov    (%rax),%eax
  8014e3:	89 c0                	mov    %eax,%eax
  8014e5:	48 01 d0             	add    %rdx,%rax
  8014e8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8014ec:	8b 12                	mov    (%rdx),%edx
  8014ee:	8d 4a 08             	lea    0x8(%rdx),%ecx
  8014f1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8014f5:	89 0a                	mov    %ecx,(%rdx)
  8014f7:	eb 17                	jmp    801510 <getuint+0x5b>
  8014f9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8014fd:	48 8b 50 08          	mov    0x8(%rax),%rdx
  801501:	48 89 d0             	mov    %rdx,%rax
  801504:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  801508:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80150c:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  801510:	48 8b 00             	mov    (%rax),%rax
  801513:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  801517:	e9 a3 00 00 00       	jmpq   8015bf <getuint+0x10a>
	else if (lflag)
  80151c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  801520:	74 4f                	je     801571 <getuint+0xbc>
		x= va_arg(*ap, unsigned long);
  801522:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801526:	8b 00                	mov    (%rax),%eax
  801528:	83 f8 30             	cmp    $0x30,%eax
  80152b:	73 24                	jae    801551 <getuint+0x9c>
  80152d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801531:	48 8b 50 10          	mov    0x10(%rax),%rdx
  801535:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801539:	8b 00                	mov    (%rax),%eax
  80153b:	89 c0                	mov    %eax,%eax
  80153d:	48 01 d0             	add    %rdx,%rax
  801540:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801544:	8b 12                	mov    (%rdx),%edx
  801546:	8d 4a 08             	lea    0x8(%rdx),%ecx
  801549:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80154d:	89 0a                	mov    %ecx,(%rdx)
  80154f:	eb 17                	jmp    801568 <getuint+0xb3>
  801551:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801555:	48 8b 50 08          	mov    0x8(%rax),%rdx
  801559:	48 89 d0             	mov    %rdx,%rax
  80155c:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  801560:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801564:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  801568:	48 8b 00             	mov    (%rax),%rax
  80156b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80156f:	eb 4e                	jmp    8015bf <getuint+0x10a>
	else
		x= va_arg(*ap, unsigned int);
  801571:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801575:	8b 00                	mov    (%rax),%eax
  801577:	83 f8 30             	cmp    $0x30,%eax
  80157a:	73 24                	jae    8015a0 <getuint+0xeb>
  80157c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801580:	48 8b 50 10          	mov    0x10(%rax),%rdx
  801584:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801588:	8b 00                	mov    (%rax),%eax
  80158a:	89 c0                	mov    %eax,%eax
  80158c:	48 01 d0             	add    %rdx,%rax
  80158f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801593:	8b 12                	mov    (%rdx),%edx
  801595:	8d 4a 08             	lea    0x8(%rdx),%ecx
  801598:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80159c:	89 0a                	mov    %ecx,(%rdx)
  80159e:	eb 17                	jmp    8015b7 <getuint+0x102>
  8015a0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8015a4:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8015a8:	48 89 d0             	mov    %rdx,%rax
  8015ab:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  8015af:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8015b3:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  8015b7:	8b 00                	mov    (%rax),%eax
  8015b9:	89 c0                	mov    %eax,%eax
  8015bb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  8015bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8015c3:	c9                   	leaveq 
  8015c4:	c3                   	retq   

00000000008015c5 <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
  8015c5:	55                   	push   %rbp
  8015c6:	48 89 e5             	mov    %rsp,%rbp
  8015c9:	48 83 ec 1c          	sub    $0x1c,%rsp
  8015cd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8015d1:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	long long x;
	if (lflag >= 2)
  8015d4:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  8015d8:	7e 52                	jle    80162c <getint+0x67>
		x=va_arg(*ap, long long);
  8015da:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8015de:	8b 00                	mov    (%rax),%eax
  8015e0:	83 f8 30             	cmp    $0x30,%eax
  8015e3:	73 24                	jae    801609 <getint+0x44>
  8015e5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8015e9:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8015ed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8015f1:	8b 00                	mov    (%rax),%eax
  8015f3:	89 c0                	mov    %eax,%eax
  8015f5:	48 01 d0             	add    %rdx,%rax
  8015f8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8015fc:	8b 12                	mov    (%rdx),%edx
  8015fe:	8d 4a 08             	lea    0x8(%rdx),%ecx
  801601:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801605:	89 0a                	mov    %ecx,(%rdx)
  801607:	eb 17                	jmp    801620 <getint+0x5b>
  801609:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80160d:	48 8b 50 08          	mov    0x8(%rax),%rdx
  801611:	48 89 d0             	mov    %rdx,%rax
  801614:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  801618:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80161c:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  801620:	48 8b 00             	mov    (%rax),%rax
  801623:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  801627:	e9 a3 00 00 00       	jmpq   8016cf <getint+0x10a>
	else if (lflag)
  80162c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  801630:	74 4f                	je     801681 <getint+0xbc>
		x=va_arg(*ap, long);
  801632:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801636:	8b 00                	mov    (%rax),%eax
  801638:	83 f8 30             	cmp    $0x30,%eax
  80163b:	73 24                	jae    801661 <getint+0x9c>
  80163d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801641:	48 8b 50 10          	mov    0x10(%rax),%rdx
  801645:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801649:	8b 00                	mov    (%rax),%eax
  80164b:	89 c0                	mov    %eax,%eax
  80164d:	48 01 d0             	add    %rdx,%rax
  801650:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801654:	8b 12                	mov    (%rdx),%edx
  801656:	8d 4a 08             	lea    0x8(%rdx),%ecx
  801659:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80165d:	89 0a                	mov    %ecx,(%rdx)
  80165f:	eb 17                	jmp    801678 <getint+0xb3>
  801661:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801665:	48 8b 50 08          	mov    0x8(%rax),%rdx
  801669:	48 89 d0             	mov    %rdx,%rax
  80166c:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  801670:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801674:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  801678:	48 8b 00             	mov    (%rax),%rax
  80167b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80167f:	eb 4e                	jmp    8016cf <getint+0x10a>
	else
		x=va_arg(*ap, int);
  801681:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801685:	8b 00                	mov    (%rax),%eax
  801687:	83 f8 30             	cmp    $0x30,%eax
  80168a:	73 24                	jae    8016b0 <getint+0xeb>
  80168c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801690:	48 8b 50 10          	mov    0x10(%rax),%rdx
  801694:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801698:	8b 00                	mov    (%rax),%eax
  80169a:	89 c0                	mov    %eax,%eax
  80169c:	48 01 d0             	add    %rdx,%rax
  80169f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8016a3:	8b 12                	mov    (%rdx),%edx
  8016a5:	8d 4a 08             	lea    0x8(%rdx),%ecx
  8016a8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8016ac:	89 0a                	mov    %ecx,(%rdx)
  8016ae:	eb 17                	jmp    8016c7 <getint+0x102>
  8016b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8016b4:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8016b8:	48 89 d0             	mov    %rdx,%rax
  8016bb:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  8016bf:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8016c3:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  8016c7:	8b 00                	mov    (%rax),%eax
  8016c9:	48 98                	cltq   
  8016cb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  8016cf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8016d3:	c9                   	leaveq 
  8016d4:	c3                   	retq   

00000000008016d5 <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  8016d5:	55                   	push   %rbp
  8016d6:	48 89 e5             	mov    %rsp,%rbp
  8016d9:	41 54                	push   %r12
  8016db:	53                   	push   %rbx
  8016dc:	48 83 ec 60          	sub    $0x60,%rsp
  8016e0:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8016e4:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  8016e8:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  8016ec:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
	register int ch, err;
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
  8016f0:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  8016f4:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8016f8:	48 8b 0a             	mov    (%rdx),%rcx
  8016fb:	48 89 08             	mov    %rcx,(%rax)
  8016fe:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  801702:	48 89 48 08          	mov    %rcx,0x8(%rax)
  801706:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80170a:	48 89 50 10          	mov    %rdx,0x10(%rax)
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  80170e:	eb 17                	jmp    801727 <vprintfmt+0x52>
			if (ch == '\0')
  801710:	85 db                	test   %ebx,%ebx
  801712:	0f 84 cc 04 00 00    	je     801be4 <vprintfmt+0x50f>
				return;
			putch(ch, putdat);
  801718:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80171c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801720:	48 89 d6             	mov    %rdx,%rsi
  801723:	89 df                	mov    %ebx,%edi
  801725:	ff d0                	callq  *%rax
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  801727:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80172b:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80172f:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  801733:	0f b6 00             	movzbl (%rax),%eax
  801736:	0f b6 d8             	movzbl %al,%ebx
  801739:	83 fb 25             	cmp    $0x25,%ebx
  80173c:	75 d2                	jne    801710 <vprintfmt+0x3b>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
  80173e:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
		width = -1;
  801742:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%rbp)
		precision = -1;
  801749:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
		lflag = 0;
  801750:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
		altflag = 0;
  801757:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80175e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  801762:	48 8d 50 01          	lea    0x1(%rax),%rdx
  801766:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  80176a:	0f b6 00             	movzbl (%rax),%eax
  80176d:	0f b6 d8             	movzbl %al,%ebx
  801770:	8d 43 dd             	lea    -0x23(%rbx),%eax
  801773:	83 f8 55             	cmp    $0x55,%eax
  801776:	0f 87 34 04 00 00    	ja     801bb0 <vprintfmt+0x4db>
  80177c:	89 c0                	mov    %eax,%eax
  80177e:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  801785:	00 
  801786:	48 b8 18 10 82 00 00 	movabs $0x821018,%rax
  80178d:	00 00 00 
  801790:	48 01 d0             	add    %rdx,%rax
  801793:	48 8b 00             	mov    (%rax),%rax
  801796:	ff e0                	jmpq   *%rax

			// flag to pad on the right
		case '-':
			padc = '-';
  801798:	c6 45 d3 2d          	movb   $0x2d,-0x2d(%rbp)
			goto reswitch;
  80179c:	eb c0                	jmp    80175e <vprintfmt+0x89>

			// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
  80179e:	c6 45 d3 30          	movb   $0x30,-0x2d(%rbp)
			goto reswitch;
  8017a2:	eb ba                	jmp    80175e <vprintfmt+0x89>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  8017a4:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
				precision = precision * 10 + ch - '0';
  8017ab:	8b 55 d8             	mov    -0x28(%rbp),%edx
  8017ae:	89 d0                	mov    %edx,%eax
  8017b0:	c1 e0 02             	shl    $0x2,%eax
  8017b3:	01 d0                	add    %edx,%eax
  8017b5:	01 c0                	add    %eax,%eax
  8017b7:	01 d8                	add    %ebx,%eax
  8017b9:	83 e8 30             	sub    $0x30,%eax
  8017bc:	89 45 d8             	mov    %eax,-0x28(%rbp)
				ch = *fmt;
  8017bf:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8017c3:	0f b6 00             	movzbl (%rax),%eax
  8017c6:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
  8017c9:	83 fb 2f             	cmp    $0x2f,%ebx
  8017cc:	7e 0c                	jle    8017da <vprintfmt+0x105>
  8017ce:	83 fb 39             	cmp    $0x39,%ebx
  8017d1:	7f 07                	jg     8017da <vprintfmt+0x105>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  8017d3:	48 83 45 98 01       	addq   $0x1,-0x68(%rbp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
  8017d8:	eb d1                	jmp    8017ab <vprintfmt+0xd6>
			goto process_precision;
  8017da:	eb 58                	jmp    801834 <vprintfmt+0x15f>

		case '*':
			precision = va_arg(aq, int);
  8017dc:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8017df:	83 f8 30             	cmp    $0x30,%eax
  8017e2:	73 17                	jae    8017fb <vprintfmt+0x126>
  8017e4:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8017e8:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8017eb:	89 c0                	mov    %eax,%eax
  8017ed:	48 01 d0             	add    %rdx,%rax
  8017f0:	8b 55 b8             	mov    -0x48(%rbp),%edx
  8017f3:	83 c2 08             	add    $0x8,%edx
  8017f6:	89 55 b8             	mov    %edx,-0x48(%rbp)
  8017f9:	eb 0f                	jmp    80180a <vprintfmt+0x135>
  8017fb:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8017ff:	48 89 d0             	mov    %rdx,%rax
  801802:	48 83 c2 08          	add    $0x8,%rdx
  801806:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  80180a:	8b 00                	mov    (%rax),%eax
  80180c:	89 45 d8             	mov    %eax,-0x28(%rbp)
			goto process_precision;
  80180f:	eb 23                	jmp    801834 <vprintfmt+0x15f>

		case '.':
			if (width < 0)
  801811:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  801815:	79 0c                	jns    801823 <vprintfmt+0x14e>
				width = 0;
  801817:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
			goto reswitch;
  80181e:	e9 3b ff ff ff       	jmpq   80175e <vprintfmt+0x89>
  801823:	e9 36 ff ff ff       	jmpq   80175e <vprintfmt+0x89>

		case '#':
			altflag = 1;
  801828:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%rbp)
			goto reswitch;
  80182f:	e9 2a ff ff ff       	jmpq   80175e <vprintfmt+0x89>

		process_precision:
			if (width < 0)
  801834:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  801838:	79 12                	jns    80184c <vprintfmt+0x177>
				width = precision, precision = -1;
  80183a:	8b 45 d8             	mov    -0x28(%rbp),%eax
  80183d:	89 45 dc             	mov    %eax,-0x24(%rbp)
  801840:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
			goto reswitch;
  801847:	e9 12 ff ff ff       	jmpq   80175e <vprintfmt+0x89>
  80184c:	e9 0d ff ff ff       	jmpq   80175e <vprintfmt+0x89>

			// long flag (doubled for long long)
		case 'l':
			lflag++;
  801851:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
			goto reswitch;
  801855:	e9 04 ff ff ff       	jmpq   80175e <vprintfmt+0x89>

			// character
		case 'c':
			putch(va_arg(aq, int), putdat);
  80185a:	8b 45 b8             	mov    -0x48(%rbp),%eax
  80185d:	83 f8 30             	cmp    $0x30,%eax
  801860:	73 17                	jae    801879 <vprintfmt+0x1a4>
  801862:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  801866:	8b 45 b8             	mov    -0x48(%rbp),%eax
  801869:	89 c0                	mov    %eax,%eax
  80186b:	48 01 d0             	add    %rdx,%rax
  80186e:	8b 55 b8             	mov    -0x48(%rbp),%edx
  801871:	83 c2 08             	add    $0x8,%edx
  801874:	89 55 b8             	mov    %edx,-0x48(%rbp)
  801877:	eb 0f                	jmp    801888 <vprintfmt+0x1b3>
  801879:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80187d:	48 89 d0             	mov    %rdx,%rax
  801880:	48 83 c2 08          	add    $0x8,%rdx
  801884:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  801888:	8b 10                	mov    (%rax),%edx
  80188a:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  80188e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801892:	48 89 ce             	mov    %rcx,%rsi
  801895:	89 d7                	mov    %edx,%edi
  801897:	ff d0                	callq  *%rax
			break;
  801899:	e9 40 03 00 00       	jmpq   801bde <vprintfmt+0x509>

			// error message
		case 'e':
			err = va_arg(aq, int);
  80189e:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8018a1:	83 f8 30             	cmp    $0x30,%eax
  8018a4:	73 17                	jae    8018bd <vprintfmt+0x1e8>
  8018a6:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8018aa:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8018ad:	89 c0                	mov    %eax,%eax
  8018af:	48 01 d0             	add    %rdx,%rax
  8018b2:	8b 55 b8             	mov    -0x48(%rbp),%edx
  8018b5:	83 c2 08             	add    $0x8,%edx
  8018b8:	89 55 b8             	mov    %edx,-0x48(%rbp)
  8018bb:	eb 0f                	jmp    8018cc <vprintfmt+0x1f7>
  8018bd:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8018c1:	48 89 d0             	mov    %rdx,%rax
  8018c4:	48 83 c2 08          	add    $0x8,%rdx
  8018c8:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  8018cc:	8b 18                	mov    (%rax),%ebx
			if (err < 0)
  8018ce:	85 db                	test   %ebx,%ebx
  8018d0:	79 02                	jns    8018d4 <vprintfmt+0x1ff>
				err = -err;
  8018d2:	f7 db                	neg    %ebx
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  8018d4:	83 fb 15             	cmp    $0x15,%ebx
  8018d7:	7f 16                	jg     8018ef <vprintfmt+0x21a>
  8018d9:	48 b8 40 0f 82 00 00 	movabs $0x820f40,%rax
  8018e0:	00 00 00 
  8018e3:	48 63 d3             	movslq %ebx,%rdx
  8018e6:	4c 8b 24 d0          	mov    (%rax,%rdx,8),%r12
  8018ea:	4d 85 e4             	test   %r12,%r12
  8018ed:	75 2e                	jne    80191d <vprintfmt+0x248>
				printfmt(putch, putdat, "error %d", err);
  8018ef:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  8018f3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8018f7:	89 d9                	mov    %ebx,%ecx
  8018f9:	48 ba 01 10 82 00 00 	movabs $0x821001,%rdx
  801900:	00 00 00 
  801903:	48 89 c7             	mov    %rax,%rdi
  801906:	b8 00 00 00 00       	mov    $0x0,%eax
  80190b:	49 b8 ed 1b 80 00 00 	movabs $0x801bed,%r8
  801912:	00 00 00 
  801915:	41 ff d0             	callq  *%r8
			else
				printfmt(putch, putdat, "%s", p);
			break;
  801918:	e9 c1 02 00 00       	jmpq   801bde <vprintfmt+0x509>
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
  80191d:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  801921:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801925:	4c 89 e1             	mov    %r12,%rcx
  801928:	48 ba 0a 10 82 00 00 	movabs $0x82100a,%rdx
  80192f:	00 00 00 
  801932:	48 89 c7             	mov    %rax,%rdi
  801935:	b8 00 00 00 00       	mov    $0x0,%eax
  80193a:	49 b8 ed 1b 80 00 00 	movabs $0x801bed,%r8
  801941:	00 00 00 
  801944:	41 ff d0             	callq  *%r8
			break;
  801947:	e9 92 02 00 00       	jmpq   801bde <vprintfmt+0x509>

			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
  80194c:	8b 45 b8             	mov    -0x48(%rbp),%eax
  80194f:	83 f8 30             	cmp    $0x30,%eax
  801952:	73 17                	jae    80196b <vprintfmt+0x296>
  801954:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  801958:	8b 45 b8             	mov    -0x48(%rbp),%eax
  80195b:	89 c0                	mov    %eax,%eax
  80195d:	48 01 d0             	add    %rdx,%rax
  801960:	8b 55 b8             	mov    -0x48(%rbp),%edx
  801963:	83 c2 08             	add    $0x8,%edx
  801966:	89 55 b8             	mov    %edx,-0x48(%rbp)
  801969:	eb 0f                	jmp    80197a <vprintfmt+0x2a5>
  80196b:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80196f:	48 89 d0             	mov    %rdx,%rax
  801972:	48 83 c2 08          	add    $0x8,%rdx
  801976:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  80197a:	4c 8b 20             	mov    (%rax),%r12
  80197d:	4d 85 e4             	test   %r12,%r12
  801980:	75 0a                	jne    80198c <vprintfmt+0x2b7>
				p = "(null)";
  801982:	49 bc 0d 10 82 00 00 	movabs $0x82100d,%r12
  801989:	00 00 00 
			if (width > 0 && padc != '-')
  80198c:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  801990:	7e 3f                	jle    8019d1 <vprintfmt+0x2fc>
  801992:	80 7d d3 2d          	cmpb   $0x2d,-0x2d(%rbp)
  801996:	74 39                	je     8019d1 <vprintfmt+0x2fc>
				for (width -= strnlen(p, precision); width > 0; width--)
  801998:	8b 45 d8             	mov    -0x28(%rbp),%eax
  80199b:	48 98                	cltq   
  80199d:	48 89 c6             	mov    %rax,%rsi
  8019a0:	4c 89 e7             	mov    %r12,%rdi
  8019a3:	48 b8 99 1e 80 00 00 	movabs $0x801e99,%rax
  8019aa:	00 00 00 
  8019ad:	ff d0                	callq  *%rax
  8019af:	29 45 dc             	sub    %eax,-0x24(%rbp)
  8019b2:	eb 17                	jmp    8019cb <vprintfmt+0x2f6>
					putch(padc, putdat);
  8019b4:	0f be 55 d3          	movsbl -0x2d(%rbp),%edx
  8019b8:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8019bc:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8019c0:	48 89 ce             	mov    %rcx,%rsi
  8019c3:	89 d7                	mov    %edx,%edi
  8019c5:	ff d0                	callq  *%rax
			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  8019c7:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  8019cb:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8019cf:	7f e3                	jg     8019b4 <vprintfmt+0x2df>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  8019d1:	eb 37                	jmp    801a0a <vprintfmt+0x335>
				if (altflag && (ch < ' ' || ch > '~'))
  8019d3:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  8019d7:	74 1e                	je     8019f7 <vprintfmt+0x322>
  8019d9:	83 fb 1f             	cmp    $0x1f,%ebx
  8019dc:	7e 05                	jle    8019e3 <vprintfmt+0x30e>
  8019de:	83 fb 7e             	cmp    $0x7e,%ebx
  8019e1:	7e 14                	jle    8019f7 <vprintfmt+0x322>
					putch('?', putdat);
  8019e3:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8019e7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8019eb:	48 89 d6             	mov    %rdx,%rsi
  8019ee:	bf 3f 00 00 00       	mov    $0x3f,%edi
  8019f3:	ff d0                	callq  *%rax
  8019f5:	eb 0f                	jmp    801a06 <vprintfmt+0x331>
				else
					putch(ch, putdat);
  8019f7:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8019fb:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8019ff:	48 89 d6             	mov    %rdx,%rsi
  801a02:	89 df                	mov    %ebx,%edi
  801a04:	ff d0                	callq  *%rax
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  801a06:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  801a0a:	4c 89 e0             	mov    %r12,%rax
  801a0d:	4c 8d 60 01          	lea    0x1(%rax),%r12
  801a11:	0f b6 00             	movzbl (%rax),%eax
  801a14:	0f be d8             	movsbl %al,%ebx
  801a17:	85 db                	test   %ebx,%ebx
  801a19:	74 10                	je     801a2b <vprintfmt+0x356>
  801a1b:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  801a1f:	78 b2                	js     8019d3 <vprintfmt+0x2fe>
  801a21:	83 6d d8 01          	subl   $0x1,-0x28(%rbp)
  801a25:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  801a29:	79 a8                	jns    8019d3 <vprintfmt+0x2fe>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  801a2b:	eb 16                	jmp    801a43 <vprintfmt+0x36e>
				putch(' ', putdat);
  801a2d:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  801a31:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801a35:	48 89 d6             	mov    %rdx,%rsi
  801a38:	bf 20 00 00 00       	mov    $0x20,%edi
  801a3d:	ff d0                	callq  *%rax
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  801a3f:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  801a43:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  801a47:	7f e4                	jg     801a2d <vprintfmt+0x358>
				putch(' ', putdat);
			break;
  801a49:	e9 90 01 00 00       	jmpq   801bde <vprintfmt+0x509>

			// (signed) decimal
		case 'd':
			num = getint(&aq, 3);
  801a4e:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  801a52:	be 03 00 00 00       	mov    $0x3,%esi
  801a57:	48 89 c7             	mov    %rax,%rdi
  801a5a:	48 b8 c5 15 80 00 00 	movabs $0x8015c5,%rax
  801a61:	00 00 00 
  801a64:	ff d0                	callq  *%rax
  801a66:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if ((long long) num < 0) {
  801a6a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801a6e:	48 85 c0             	test   %rax,%rax
  801a71:	79 1d                	jns    801a90 <vprintfmt+0x3bb>
				putch('-', putdat);
  801a73:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  801a77:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801a7b:	48 89 d6             	mov    %rdx,%rsi
  801a7e:	bf 2d 00 00 00       	mov    $0x2d,%edi
  801a83:	ff d0                	callq  *%rax
				num = -(long long) num;
  801a85:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801a89:	48 f7 d8             	neg    %rax
  801a8c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			}
			base = 10;
  801a90:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  801a97:	e9 d5 00 00 00       	jmpq   801b71 <vprintfmt+0x49c>

			// unsigned decimal
		case 'u':
			num = getuint(&aq, 3);
  801a9c:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  801aa0:	be 03 00 00 00       	mov    $0x3,%esi
  801aa5:	48 89 c7             	mov    %rax,%rdi
  801aa8:	48 b8 b5 14 80 00 00 	movabs $0x8014b5,%rax
  801aaf:	00 00 00 
  801ab2:	ff d0                	callq  *%rax
  801ab4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 10;
  801ab8:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  801abf:	e9 ad 00 00 00       	jmpq   801b71 <vprintfmt+0x49c>

			// (unsigned) octal
		case 'o':

			num = getuint(&aq, 3);
  801ac4:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  801ac8:	be 03 00 00 00       	mov    $0x3,%esi
  801acd:	48 89 c7             	mov    %rax,%rdi
  801ad0:	48 b8 b5 14 80 00 00 	movabs $0x8014b5,%rax
  801ad7:	00 00 00 
  801ada:	ff d0                	callq  *%rax
  801adc:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 8;
  801ae0:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%rbp)
			goto number;
  801ae7:	e9 85 00 00 00       	jmpq   801b71 <vprintfmt+0x49c>


			// pointer
		case 'p':
			putch('0', putdat);
  801aec:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  801af0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801af4:	48 89 d6             	mov    %rdx,%rsi
  801af7:	bf 30 00 00 00       	mov    $0x30,%edi
  801afc:	ff d0                	callq  *%rax
			putch('x', putdat);
  801afe:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  801b02:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801b06:	48 89 d6             	mov    %rdx,%rsi
  801b09:	bf 78 00 00 00       	mov    $0x78,%edi
  801b0e:	ff d0                	callq  *%rax
			num = (unsigned long long)
				(uintptr_t) va_arg(aq, void *);
  801b10:	8b 45 b8             	mov    -0x48(%rbp),%eax
  801b13:	83 f8 30             	cmp    $0x30,%eax
  801b16:	73 17                	jae    801b2f <vprintfmt+0x45a>
  801b18:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  801b1c:	8b 45 b8             	mov    -0x48(%rbp),%eax
  801b1f:	89 c0                	mov    %eax,%eax
  801b21:	48 01 d0             	add    %rdx,%rax
  801b24:	8b 55 b8             	mov    -0x48(%rbp),%edx
  801b27:	83 c2 08             	add    $0x8,%edx
  801b2a:	89 55 b8             	mov    %edx,-0x48(%rbp)

			// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  801b2d:	eb 0f                	jmp    801b3e <vprintfmt+0x469>
				(uintptr_t) va_arg(aq, void *);
  801b2f:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  801b33:	48 89 d0             	mov    %rdx,%rax
  801b36:	48 83 c2 08          	add    $0x8,%rdx
  801b3a:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  801b3e:	48 8b 00             	mov    (%rax),%rax

			// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  801b41:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				(uintptr_t) va_arg(aq, void *);
			base = 16;
  801b45:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
			goto number;
  801b4c:	eb 23                	jmp    801b71 <vprintfmt+0x49c>

			// (unsigned) hexadecimal
		case 'x':
			num = getuint(&aq, 3);
  801b4e:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  801b52:	be 03 00 00 00       	mov    $0x3,%esi
  801b57:	48 89 c7             	mov    %rax,%rdi
  801b5a:	48 b8 b5 14 80 00 00 	movabs $0x8014b5,%rax
  801b61:	00 00 00 
  801b64:	ff d0                	callq  *%rax
  801b66:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 16;
  801b6a:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
		number:
			printnum(putch, putdat, num, base, width, padc);
  801b71:	44 0f be 45 d3       	movsbl -0x2d(%rbp),%r8d
  801b76:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  801b79:	8b 7d dc             	mov    -0x24(%rbp),%edi
  801b7c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801b80:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  801b84:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801b88:	45 89 c1             	mov    %r8d,%r9d
  801b8b:	41 89 f8             	mov    %edi,%r8d
  801b8e:	48 89 c7             	mov    %rax,%rdi
  801b91:	48 b8 fa 13 80 00 00 	movabs $0x8013fa,%rax
  801b98:	00 00 00 
  801b9b:	ff d0                	callq  *%rax
			break;
  801b9d:	eb 3f                	jmp    801bde <vprintfmt+0x509>

			// escaped '%' character
		case '%':
			putch(ch, putdat);
  801b9f:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  801ba3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801ba7:	48 89 d6             	mov    %rdx,%rsi
  801baa:	89 df                	mov    %ebx,%edi
  801bac:	ff d0                	callq  *%rax
			break;
  801bae:	eb 2e                	jmp    801bde <vprintfmt+0x509>

			// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  801bb0:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  801bb4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801bb8:	48 89 d6             	mov    %rdx,%rsi
  801bbb:	bf 25 00 00 00       	mov    $0x25,%edi
  801bc0:	ff d0                	callq  *%rax
			for (fmt--; fmt[-1] != '%'; fmt--)
  801bc2:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  801bc7:	eb 05                	jmp    801bce <vprintfmt+0x4f9>
  801bc9:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  801bce:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  801bd2:	48 83 e8 01          	sub    $0x1,%rax
  801bd6:	0f b6 00             	movzbl (%rax),%eax
  801bd9:	3c 25                	cmp    $0x25,%al
  801bdb:	75 ec                	jne    801bc9 <vprintfmt+0x4f4>
				/* do nothing */;
			break;
  801bdd:	90                   	nop
		}
	}
  801bde:	90                   	nop
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  801bdf:	e9 43 fb ff ff       	jmpq   801727 <vprintfmt+0x52>
				/* do nothing */;
			break;
		}
	}
	va_end(aq);
}
  801be4:	48 83 c4 60          	add    $0x60,%rsp
  801be8:	5b                   	pop    %rbx
  801be9:	41 5c                	pop    %r12
  801beb:	5d                   	pop    %rbp
  801bec:	c3                   	retq   

0000000000801bed <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  801bed:	55                   	push   %rbp
  801bee:	48 89 e5             	mov    %rsp,%rbp
  801bf1:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  801bf8:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  801bff:	48 89 b5 20 ff ff ff 	mov    %rsi,-0xe0(%rbp)
  801c06:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  801c0d:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  801c14:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  801c1b:	84 c0                	test   %al,%al
  801c1d:	74 20                	je     801c3f <printfmt+0x52>
  801c1f:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  801c23:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  801c27:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  801c2b:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  801c2f:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  801c33:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  801c37:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  801c3b:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  801c3f:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  801c46:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  801c4d:	00 00 00 
  801c50:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  801c57:	00 00 00 
  801c5a:	48 8d 45 10          	lea    0x10(%rbp),%rax
  801c5e:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  801c65:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  801c6c:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	vprintfmt(putch, putdat, fmt, ap);
  801c73:	48 8d 8d 38 ff ff ff 	lea    -0xc8(%rbp),%rcx
  801c7a:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  801c81:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  801c88:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  801c8f:	48 89 c7             	mov    %rax,%rdi
  801c92:	48 b8 d5 16 80 00 00 	movabs $0x8016d5,%rax
  801c99:	00 00 00 
  801c9c:	ff d0                	callq  *%rax
	va_end(ap);
}
  801c9e:	c9                   	leaveq 
  801c9f:	c3                   	retq   

0000000000801ca0 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  801ca0:	55                   	push   %rbp
  801ca1:	48 89 e5             	mov    %rsp,%rbp
  801ca4:	48 83 ec 10          	sub    $0x10,%rsp
  801ca8:	89 7d fc             	mov    %edi,-0x4(%rbp)
  801cab:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	b->cnt++;
  801caf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801cb3:	8b 40 10             	mov    0x10(%rax),%eax
  801cb6:	8d 50 01             	lea    0x1(%rax),%edx
  801cb9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801cbd:	89 50 10             	mov    %edx,0x10(%rax)
	if (b->buf < b->ebuf)
  801cc0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801cc4:	48 8b 10             	mov    (%rax),%rdx
  801cc7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801ccb:	48 8b 40 08          	mov    0x8(%rax),%rax
  801ccf:	48 39 c2             	cmp    %rax,%rdx
  801cd2:	73 17                	jae    801ceb <sprintputch+0x4b>
		*b->buf++ = ch;
  801cd4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801cd8:	48 8b 00             	mov    (%rax),%rax
  801cdb:	48 8d 48 01          	lea    0x1(%rax),%rcx
  801cdf:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  801ce3:	48 89 0a             	mov    %rcx,(%rdx)
  801ce6:	8b 55 fc             	mov    -0x4(%rbp),%edx
  801ce9:	88 10                	mov    %dl,(%rax)
}
  801ceb:	c9                   	leaveq 
  801cec:	c3                   	retq   

0000000000801ced <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  801ced:	55                   	push   %rbp
  801cee:	48 89 e5             	mov    %rsp,%rbp
  801cf1:	48 83 ec 50          	sub    $0x50,%rsp
  801cf5:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  801cf9:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  801cfc:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  801d00:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	va_list aq;
	va_copy(aq,ap);
  801d04:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  801d08:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  801d0c:	48 8b 0a             	mov    (%rdx),%rcx
  801d0f:	48 89 08             	mov    %rcx,(%rax)
  801d12:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  801d16:	48 89 48 08          	mov    %rcx,0x8(%rax)
  801d1a:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  801d1e:	48 89 50 10          	mov    %rdx,0x10(%rax)
	struct sprintbuf b = {buf, buf+n-1, 0};
  801d22:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  801d26:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  801d2a:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  801d2d:	48 98                	cltq   
  801d2f:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  801d33:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  801d37:	48 01 d0             	add    %rdx,%rax
  801d3a:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  801d3e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)

	if (buf == NULL || n < 1)
  801d45:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  801d4a:	74 06                	je     801d52 <vsnprintf+0x65>
  801d4c:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  801d50:	7f 07                	jg     801d59 <vsnprintf+0x6c>
		return -E_INVAL;
  801d52:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  801d57:	eb 2f                	jmp    801d88 <vsnprintf+0x9b>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, aq);
  801d59:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  801d5d:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  801d61:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  801d65:	48 89 c6             	mov    %rax,%rsi
  801d68:	48 bf a0 1c 80 00 00 	movabs $0x801ca0,%rdi
  801d6f:	00 00 00 
  801d72:	48 b8 d5 16 80 00 00 	movabs $0x8016d5,%rax
  801d79:	00 00 00 
  801d7c:	ff d0                	callq  *%rax
	va_end(aq);
	// null terminate the buffer
	*b.buf = '\0';
  801d7e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  801d82:	c6 00 00             	movb   $0x0,(%rax)

	return b.cnt;
  801d85:	8b 45 e0             	mov    -0x20(%rbp),%eax
}
  801d88:	c9                   	leaveq 
  801d89:	c3                   	retq   

0000000000801d8a <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  801d8a:	55                   	push   %rbp
  801d8b:	48 89 e5             	mov    %rsp,%rbp
  801d8e:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  801d95:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
  801d9c:	89 b5 04 ff ff ff    	mov    %esi,-0xfc(%rbp)
  801da2:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  801da9:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  801db0:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  801db7:	84 c0                	test   %al,%al
  801db9:	74 20                	je     801ddb <snprintf+0x51>
  801dbb:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  801dbf:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  801dc3:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  801dc7:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  801dcb:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  801dcf:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  801dd3:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  801dd7:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  801ddb:	48 89 95 f8 fe ff ff 	mov    %rdx,-0x108(%rbp)
	va_list ap;
	int rc;
	va_list aq;
	va_start(ap, fmt);
  801de2:	c7 85 30 ff ff ff 18 	movl   $0x18,-0xd0(%rbp)
  801de9:	00 00 00 
  801dec:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  801df3:	00 00 00 
  801df6:	48 8d 45 10          	lea    0x10(%rbp),%rax
  801dfa:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  801e01:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  801e08:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_copy(aq,ap);
  801e0f:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  801e16:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  801e1d:	48 8b 0a             	mov    (%rdx),%rcx
  801e20:	48 89 08             	mov    %rcx,(%rax)
  801e23:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  801e27:	48 89 48 08          	mov    %rcx,0x8(%rax)
  801e2b:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  801e2f:	48 89 50 10          	mov    %rdx,0x10(%rax)
	rc = vsnprintf(buf, n, fmt, aq);
  801e33:	48 8d 8d 18 ff ff ff 	lea    -0xe8(%rbp),%rcx
  801e3a:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  801e41:	8b b5 04 ff ff ff    	mov    -0xfc(%rbp),%esi
  801e47:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  801e4e:	48 89 c7             	mov    %rax,%rdi
  801e51:	48 b8 ed 1c 80 00 00 	movabs $0x801ced,%rax
  801e58:	00 00 00 
  801e5b:	ff d0                	callq  *%rax
  801e5d:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return rc;
  801e63:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  801e69:	c9                   	leaveq 
  801e6a:	c3                   	retq   

0000000000801e6b <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  801e6b:	55                   	push   %rbp
  801e6c:	48 89 e5             	mov    %rsp,%rbp
  801e6f:	48 83 ec 18          	sub    $0x18,%rsp
  801e73:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int n;

	for (n = 0; *s != '\0'; s++)
  801e77:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  801e7e:	eb 09                	jmp    801e89 <strlen+0x1e>
		n++;
  801e80:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  801e84:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  801e89:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801e8d:	0f b6 00             	movzbl (%rax),%eax
  801e90:	84 c0                	test   %al,%al
  801e92:	75 ec                	jne    801e80 <strlen+0x15>
		n++;
	return n;
  801e94:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  801e97:	c9                   	leaveq 
  801e98:	c3                   	retq   

0000000000801e99 <strnlen>:

int
strnlen(const char *s, size_t size)
{
  801e99:	55                   	push   %rbp
  801e9a:	48 89 e5             	mov    %rsp,%rbp
  801e9d:	48 83 ec 20          	sub    $0x20,%rsp
  801ea1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801ea5:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  801ea9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  801eb0:	eb 0e                	jmp    801ec0 <strnlen+0x27>
		n++;
  801eb2:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  801eb6:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  801ebb:	48 83 6d e0 01       	subq   $0x1,-0x20(%rbp)
  801ec0:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  801ec5:	74 0b                	je     801ed2 <strnlen+0x39>
  801ec7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801ecb:	0f b6 00             	movzbl (%rax),%eax
  801ece:	84 c0                	test   %al,%al
  801ed0:	75 e0                	jne    801eb2 <strnlen+0x19>
		n++;
	return n;
  801ed2:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  801ed5:	c9                   	leaveq 
  801ed6:	c3                   	retq   

0000000000801ed7 <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  801ed7:	55                   	push   %rbp
  801ed8:	48 89 e5             	mov    %rsp,%rbp
  801edb:	48 83 ec 20          	sub    $0x20,%rsp
  801edf:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801ee3:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	char *ret;

	ret = dst;
  801ee7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801eeb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	while ((*dst++ = *src++) != '\0')
  801eef:	90                   	nop
  801ef0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801ef4:	48 8d 50 01          	lea    0x1(%rax),%rdx
  801ef8:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  801efc:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  801f00:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  801f04:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  801f08:	0f b6 12             	movzbl (%rdx),%edx
  801f0b:	88 10                	mov    %dl,(%rax)
  801f0d:	0f b6 00             	movzbl (%rax),%eax
  801f10:	84 c0                	test   %al,%al
  801f12:	75 dc                	jne    801ef0 <strcpy+0x19>
		/* do nothing */;
	return ret;
  801f14:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  801f18:	c9                   	leaveq 
  801f19:	c3                   	retq   

0000000000801f1a <strcat>:

char *
strcat(char *dst, const char *src)
{
  801f1a:	55                   	push   %rbp
  801f1b:	48 89 e5             	mov    %rsp,%rbp
  801f1e:	48 83 ec 20          	sub    $0x20,%rsp
  801f22:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801f26:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int len = strlen(dst);
  801f2a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801f2e:	48 89 c7             	mov    %rax,%rdi
  801f31:	48 b8 6b 1e 80 00 00 	movabs $0x801e6b,%rax
  801f38:	00 00 00 
  801f3b:	ff d0                	callq  *%rax
  801f3d:	89 45 fc             	mov    %eax,-0x4(%rbp)
	strcpy(dst + len, src);
  801f40:	8b 45 fc             	mov    -0x4(%rbp),%eax
  801f43:	48 63 d0             	movslq %eax,%rdx
  801f46:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801f4a:	48 01 c2             	add    %rax,%rdx
  801f4d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  801f51:	48 89 c6             	mov    %rax,%rsi
  801f54:	48 89 d7             	mov    %rdx,%rdi
  801f57:	48 b8 d7 1e 80 00 00 	movabs $0x801ed7,%rax
  801f5e:	00 00 00 
  801f61:	ff d0                	callq  *%rax
	return dst;
  801f63:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  801f67:	c9                   	leaveq 
  801f68:	c3                   	retq   

0000000000801f69 <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  801f69:	55                   	push   %rbp
  801f6a:	48 89 e5             	mov    %rsp,%rbp
  801f6d:	48 83 ec 28          	sub    $0x28,%rsp
  801f71:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801f75:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  801f79:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	size_t i;
	char *ret;

	ret = dst;
  801f7d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801f81:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < size; i++) {
  801f85:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  801f8c:	00 
  801f8d:	eb 2a                	jmp    801fb9 <strncpy+0x50>
		*dst++ = *src;
  801f8f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801f93:	48 8d 50 01          	lea    0x1(%rax),%rdx
  801f97:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  801f9b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  801f9f:	0f b6 12             	movzbl (%rdx),%edx
  801fa2:	88 10                	mov    %dl,(%rax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
  801fa4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  801fa8:	0f b6 00             	movzbl (%rax),%eax
  801fab:	84 c0                	test   %al,%al
  801fad:	74 05                	je     801fb4 <strncpy+0x4b>
			src++;
  801faf:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  801fb4:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  801fb9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801fbd:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  801fc1:	72 cc                	jb     801f8f <strncpy+0x26>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
  801fc3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  801fc7:	c9                   	leaveq 
  801fc8:	c3                   	retq   

0000000000801fc9 <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  801fc9:	55                   	push   %rbp
  801fca:	48 89 e5             	mov    %rsp,%rbp
  801fcd:	48 83 ec 28          	sub    $0x28,%rsp
  801fd1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801fd5:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  801fd9:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *dst_in;

	dst_in = dst;
  801fdd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801fe1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (size > 0) {
  801fe5:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  801fea:	74 3d                	je     802029 <strlcpy+0x60>
		while (--size > 0 && *src != '\0')
  801fec:	eb 1d                	jmp    80200b <strlcpy+0x42>
			*dst++ = *src++;
  801fee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801ff2:	48 8d 50 01          	lea    0x1(%rax),%rdx
  801ff6:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  801ffa:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  801ffe:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  802002:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  802006:	0f b6 12             	movzbl (%rdx),%edx
  802009:	88 10                	mov    %dl,(%rax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  80200b:	48 83 6d d8 01       	subq   $0x1,-0x28(%rbp)
  802010:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  802015:	74 0b                	je     802022 <strlcpy+0x59>
  802017:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80201b:	0f b6 00             	movzbl (%rax),%eax
  80201e:	84 c0                	test   %al,%al
  802020:	75 cc                	jne    801fee <strlcpy+0x25>
			*dst++ = *src++;
		*dst = '\0';
  802022:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  802026:	c6 00 00             	movb   $0x0,(%rax)
	}
	return dst - dst_in;
  802029:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80202d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802031:	48 29 c2             	sub    %rax,%rdx
  802034:	48 89 d0             	mov    %rdx,%rax
}
  802037:	c9                   	leaveq 
  802038:	c3                   	retq   

0000000000802039 <strcmp>:

int
strcmp(const char *p, const char *q)
{
  802039:	55                   	push   %rbp
  80203a:	48 89 e5             	mov    %rsp,%rbp
  80203d:	48 83 ec 10          	sub    $0x10,%rsp
  802041:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  802045:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	while (*p && *p == *q)
  802049:	eb 0a                	jmp    802055 <strcmp+0x1c>
		p++, q++;
  80204b:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  802050:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  802055:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802059:	0f b6 00             	movzbl (%rax),%eax
  80205c:	84 c0                	test   %al,%al
  80205e:	74 12                	je     802072 <strcmp+0x39>
  802060:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802064:	0f b6 10             	movzbl (%rax),%edx
  802067:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80206b:	0f b6 00             	movzbl (%rax),%eax
  80206e:	38 c2                	cmp    %al,%dl
  802070:	74 d9                	je     80204b <strcmp+0x12>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
  802072:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802076:	0f b6 00             	movzbl (%rax),%eax
  802079:	0f b6 d0             	movzbl %al,%edx
  80207c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802080:	0f b6 00             	movzbl (%rax),%eax
  802083:	0f b6 c0             	movzbl %al,%eax
  802086:	29 c2                	sub    %eax,%edx
  802088:	89 d0                	mov    %edx,%eax
}
  80208a:	c9                   	leaveq 
  80208b:	c3                   	retq   

000000000080208c <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  80208c:	55                   	push   %rbp
  80208d:	48 89 e5             	mov    %rsp,%rbp
  802090:	48 83 ec 18          	sub    $0x18,%rsp
  802094:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  802098:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80209c:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	while (n > 0 && *p && *p == *q)
  8020a0:	eb 0f                	jmp    8020b1 <strncmp+0x25>
		n--, p++, q++;
  8020a2:	48 83 6d e8 01       	subq   $0x1,-0x18(%rbp)
  8020a7:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8020ac:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  8020b1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8020b6:	74 1d                	je     8020d5 <strncmp+0x49>
  8020b8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8020bc:	0f b6 00             	movzbl (%rax),%eax
  8020bf:	84 c0                	test   %al,%al
  8020c1:	74 12                	je     8020d5 <strncmp+0x49>
  8020c3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8020c7:	0f b6 10             	movzbl (%rax),%edx
  8020ca:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8020ce:	0f b6 00             	movzbl (%rax),%eax
  8020d1:	38 c2                	cmp    %al,%dl
  8020d3:	74 cd                	je     8020a2 <strncmp+0x16>
		n--, p++, q++;
	if (n == 0)
  8020d5:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8020da:	75 07                	jne    8020e3 <strncmp+0x57>
		return 0;
  8020dc:	b8 00 00 00 00       	mov    $0x0,%eax
  8020e1:	eb 18                	jmp    8020fb <strncmp+0x6f>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  8020e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8020e7:	0f b6 00             	movzbl (%rax),%eax
  8020ea:	0f b6 d0             	movzbl %al,%edx
  8020ed:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8020f1:	0f b6 00             	movzbl (%rax),%eax
  8020f4:	0f b6 c0             	movzbl %al,%eax
  8020f7:	29 c2                	sub    %eax,%edx
  8020f9:	89 d0                	mov    %edx,%eax
}
  8020fb:	c9                   	leaveq 
  8020fc:	c3                   	retq   

00000000008020fd <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  8020fd:	55                   	push   %rbp
  8020fe:	48 89 e5             	mov    %rsp,%rbp
  802101:	48 83 ec 0c          	sub    $0xc,%rsp
  802105:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  802109:	89 f0                	mov    %esi,%eax
  80210b:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  80210e:	eb 17                	jmp    802127 <strchr+0x2a>
		if (*s == c)
  802110:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802114:	0f b6 00             	movzbl (%rax),%eax
  802117:	3a 45 f4             	cmp    -0xc(%rbp),%al
  80211a:	75 06                	jne    802122 <strchr+0x25>
			return (char *) s;
  80211c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802120:	eb 15                	jmp    802137 <strchr+0x3a>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  802122:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  802127:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80212b:	0f b6 00             	movzbl (%rax),%eax
  80212e:	84 c0                	test   %al,%al
  802130:	75 de                	jne    802110 <strchr+0x13>
		if (*s == c)
			return (char *) s;
	return 0;
  802132:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802137:	c9                   	leaveq 
  802138:	c3                   	retq   

0000000000802139 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  802139:	55                   	push   %rbp
  80213a:	48 89 e5             	mov    %rsp,%rbp
  80213d:	48 83 ec 0c          	sub    $0xc,%rsp
  802141:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  802145:	89 f0                	mov    %esi,%eax
  802147:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  80214a:	eb 13                	jmp    80215f <strfind+0x26>
		if (*s == c)
  80214c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802150:	0f b6 00             	movzbl (%rax),%eax
  802153:	3a 45 f4             	cmp    -0xc(%rbp),%al
  802156:	75 02                	jne    80215a <strfind+0x21>
			break;
  802158:	eb 10                	jmp    80216a <strfind+0x31>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
  80215a:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  80215f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802163:	0f b6 00             	movzbl (%rax),%eax
  802166:	84 c0                	test   %al,%al
  802168:	75 e2                	jne    80214c <strfind+0x13>
		if (*s == c)
			break;
	return (char *) s;
  80216a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80216e:	c9                   	leaveq 
  80216f:	c3                   	retq   

0000000000802170 <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  802170:	55                   	push   %rbp
  802171:	48 89 e5             	mov    %rsp,%rbp
  802174:	48 83 ec 18          	sub    $0x18,%rsp
  802178:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80217c:	89 75 f4             	mov    %esi,-0xc(%rbp)
  80217f:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	char *p;

	if (n == 0)
  802183:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  802188:	75 06                	jne    802190 <memset+0x20>
		return v;
  80218a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80218e:	eb 69                	jmp    8021f9 <memset+0x89>
	if ((int64_t)v%4 == 0 && n%4 == 0) {
  802190:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802194:	83 e0 03             	and    $0x3,%eax
  802197:	48 85 c0             	test   %rax,%rax
  80219a:	75 48                	jne    8021e4 <memset+0x74>
  80219c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8021a0:	83 e0 03             	and    $0x3,%eax
  8021a3:	48 85 c0             	test   %rax,%rax
  8021a6:	75 3c                	jne    8021e4 <memset+0x74>
		c &= 0xFF;
  8021a8:	81 65 f4 ff 00 00 00 	andl   $0xff,-0xc(%rbp)
		c = (c<<24)|(c<<16)|(c<<8)|c;
  8021af:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8021b2:	c1 e0 18             	shl    $0x18,%eax
  8021b5:	89 c2                	mov    %eax,%edx
  8021b7:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8021ba:	c1 e0 10             	shl    $0x10,%eax
  8021bd:	09 c2                	or     %eax,%edx
  8021bf:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8021c2:	c1 e0 08             	shl    $0x8,%eax
  8021c5:	09 d0                	or     %edx,%eax
  8021c7:	09 45 f4             	or     %eax,-0xc(%rbp)
		asm volatile("cld; rep stosl\n"
			     :: "D" (v), "a" (c), "c" (n/4)
  8021ca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8021ce:	48 c1 e8 02          	shr    $0x2,%rax
  8021d2:	48 89 c1             	mov    %rax,%rcx
	if (n == 0)
		return v;
	if ((int64_t)v%4 == 0 && n%4 == 0) {
		c &= 0xFF;
		c = (c<<24)|(c<<16)|(c<<8)|c;
		asm volatile("cld; rep stosl\n"
  8021d5:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8021d9:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8021dc:	48 89 d7             	mov    %rdx,%rdi
  8021df:	fc                   	cld    
  8021e0:	f3 ab                	rep stos %eax,%es:(%rdi)
  8021e2:	eb 11                	jmp    8021f5 <memset+0x85>
			     :: "D" (v), "a" (c), "c" (n/4)
			     : "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  8021e4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8021e8:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8021eb:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8021ef:	48 89 d7             	mov    %rdx,%rdi
  8021f2:	fc                   	cld    
  8021f3:	f3 aa                	rep stos %al,%es:(%rdi)
			     :: "D" (v), "a" (c), "c" (n)
			     : "cc", "memory");
	return v;
  8021f5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8021f9:	c9                   	leaveq 
  8021fa:	c3                   	retq   

00000000008021fb <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  8021fb:	55                   	push   %rbp
  8021fc:	48 89 e5             	mov    %rsp,%rbp
  8021ff:	48 83 ec 28          	sub    $0x28,%rsp
  802203:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  802207:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80220b:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const char *s;
	char *d;

	s = src;
  80220f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  802213:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	d = dst;
  802217:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80221b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (s < d && s + n > d) {
  80221f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802223:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  802227:	0f 83 88 00 00 00    	jae    8022b5 <memmove+0xba>
  80222d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802231:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  802235:	48 01 d0             	add    %rdx,%rax
  802238:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  80223c:	76 77                	jbe    8022b5 <memmove+0xba>
		s += n;
  80223e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802242:	48 01 45 f8          	add    %rax,-0x8(%rbp)
		d += n;
  802246:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80224a:	48 01 45 f0          	add    %rax,-0x10(%rbp)
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  80224e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802252:	83 e0 03             	and    $0x3,%eax
  802255:	48 85 c0             	test   %rax,%rax
  802258:	75 3b                	jne    802295 <memmove+0x9a>
  80225a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80225e:	83 e0 03             	and    $0x3,%eax
  802261:	48 85 c0             	test   %rax,%rax
  802264:	75 2f                	jne    802295 <memmove+0x9a>
  802266:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80226a:	83 e0 03             	and    $0x3,%eax
  80226d:	48 85 c0             	test   %rax,%rax
  802270:	75 23                	jne    802295 <memmove+0x9a>
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  802272:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802276:	48 83 e8 04          	sub    $0x4,%rax
  80227a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80227e:	48 83 ea 04          	sub    $0x4,%rdx
  802282:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  802286:	48 c1 e9 02          	shr    $0x2,%rcx
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
  80228a:	48 89 c7             	mov    %rax,%rdi
  80228d:	48 89 d6             	mov    %rdx,%rsi
  802290:	fd                   	std    
  802291:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  802293:	eb 1d                	jmp    8022b2 <memmove+0xb7>
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  802295:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802299:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  80229d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8022a1:	48 8d 70 ff          	lea    -0x1(%rax),%rsi
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  8022a5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8022a9:	48 89 d7             	mov    %rdx,%rdi
  8022ac:	48 89 c1             	mov    %rax,%rcx
  8022af:	fd                   	std    
  8022b0:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  8022b2:	fc                   	cld    
  8022b3:	eb 57                	jmp    80230c <memmove+0x111>
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  8022b5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8022b9:	83 e0 03             	and    $0x3,%eax
  8022bc:	48 85 c0             	test   %rax,%rax
  8022bf:	75 36                	jne    8022f7 <memmove+0xfc>
  8022c1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8022c5:	83 e0 03             	and    $0x3,%eax
  8022c8:	48 85 c0             	test   %rax,%rax
  8022cb:	75 2a                	jne    8022f7 <memmove+0xfc>
  8022cd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8022d1:	83 e0 03             	and    $0x3,%eax
  8022d4:	48 85 c0             	test   %rax,%rax
  8022d7:	75 1e                	jne    8022f7 <memmove+0xfc>
			asm volatile("cld; rep movsl\n"
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  8022d9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8022dd:	48 c1 e8 02          	shr    $0x2,%rax
  8022e1:	48 89 c1             	mov    %rax,%rcx
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("cld; rep movsl\n"
  8022e4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8022e8:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8022ec:	48 89 c7             	mov    %rax,%rdi
  8022ef:	48 89 d6             	mov    %rdx,%rsi
  8022f2:	fc                   	cld    
  8022f3:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  8022f5:	eb 15                	jmp    80230c <memmove+0x111>
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  8022f7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8022fb:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8022ff:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  802303:	48 89 c7             	mov    %rax,%rdi
  802306:	48 89 d6             	mov    %rdx,%rsi
  802309:	fc                   	cld    
  80230a:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
  80230c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  802310:	c9                   	leaveq 
  802311:	c3                   	retq   

0000000000802312 <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  802312:	55                   	push   %rbp
  802313:	48 89 e5             	mov    %rsp,%rbp
  802316:	48 83 ec 18          	sub    $0x18,%rsp
  80231a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80231e:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  802322:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return memmove(dst, src, n);
  802326:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80232a:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  80232e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802332:	48 89 ce             	mov    %rcx,%rsi
  802335:	48 89 c7             	mov    %rax,%rdi
  802338:	48 b8 fb 21 80 00 00 	movabs $0x8021fb,%rax
  80233f:	00 00 00 
  802342:	ff d0                	callq  *%rax
}
  802344:	c9                   	leaveq 
  802345:	c3                   	retq   

0000000000802346 <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  802346:	55                   	push   %rbp
  802347:	48 89 e5             	mov    %rsp,%rbp
  80234a:	48 83 ec 28          	sub    $0x28,%rsp
  80234e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  802352:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  802356:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const uint8_t *s1 = (const uint8_t *) v1;
  80235a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80235e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	const uint8_t *s2 = (const uint8_t *) v2;
  802362:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  802366:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (n-- > 0) {
  80236a:	eb 36                	jmp    8023a2 <memcmp+0x5c>
		if (*s1 != *s2)
  80236c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802370:	0f b6 10             	movzbl (%rax),%edx
  802373:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802377:	0f b6 00             	movzbl (%rax),%eax
  80237a:	38 c2                	cmp    %al,%dl
  80237c:	74 1a                	je     802398 <memcmp+0x52>
			return (int) *s1 - (int) *s2;
  80237e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802382:	0f b6 00             	movzbl (%rax),%eax
  802385:	0f b6 d0             	movzbl %al,%edx
  802388:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80238c:	0f b6 00             	movzbl (%rax),%eax
  80238f:	0f b6 c0             	movzbl %al,%eax
  802392:	29 c2                	sub    %eax,%edx
  802394:	89 d0                	mov    %edx,%eax
  802396:	eb 20                	jmp    8023b8 <memcmp+0x72>
		s1++, s2++;
  802398:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  80239d:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  8023a2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8023a6:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  8023aa:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8023ae:	48 85 c0             	test   %rax,%rax
  8023b1:	75 b9                	jne    80236c <memcmp+0x26>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
  8023b3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8023b8:	c9                   	leaveq 
  8023b9:	c3                   	retq   

00000000008023ba <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  8023ba:	55                   	push   %rbp
  8023bb:	48 89 e5             	mov    %rsp,%rbp
  8023be:	48 83 ec 28          	sub    $0x28,%rsp
  8023c2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8023c6:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  8023c9:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const void *ends = (const char *) s + n;
  8023cd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8023d1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8023d5:	48 01 d0             	add    %rdx,%rax
  8023d8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (; s < ends; s++)
  8023dc:	eb 15                	jmp    8023f3 <memfind+0x39>
		if (*(const unsigned char *) s == (unsigned char) c)
  8023de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8023e2:	0f b6 10             	movzbl (%rax),%edx
  8023e5:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8023e8:	38 c2                	cmp    %al,%dl
  8023ea:	75 02                	jne    8023ee <memfind+0x34>
			break;
  8023ec:	eb 0f                	jmp    8023fd <memfind+0x43>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  8023ee:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  8023f3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8023f7:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8023fb:	72 e1                	jb     8023de <memfind+0x24>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
	return (void *) s;
  8023fd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  802401:	c9                   	leaveq 
  802402:	c3                   	retq   

0000000000802403 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  802403:	55                   	push   %rbp
  802404:	48 89 e5             	mov    %rsp,%rbp
  802407:	48 83 ec 34          	sub    $0x34,%rsp
  80240b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80240f:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  802413:	89 55 cc             	mov    %edx,-0x34(%rbp)
	int neg = 0;
  802416:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	long val = 0;
  80241d:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  802424:	00 

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  802425:	eb 05                	jmp    80242c <strtol+0x29>
		s++;
  802427:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80242c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802430:	0f b6 00             	movzbl (%rax),%eax
  802433:	3c 20                	cmp    $0x20,%al
  802435:	74 f0                	je     802427 <strtol+0x24>
  802437:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80243b:	0f b6 00             	movzbl (%rax),%eax
  80243e:	3c 09                	cmp    $0x9,%al
  802440:	74 e5                	je     802427 <strtol+0x24>
		s++;

	// plus/minus sign
	if (*s == '+')
  802442:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802446:	0f b6 00             	movzbl (%rax),%eax
  802449:	3c 2b                	cmp    $0x2b,%al
  80244b:	75 07                	jne    802454 <strtol+0x51>
		s++;
  80244d:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  802452:	eb 17                	jmp    80246b <strtol+0x68>
	else if (*s == '-')
  802454:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802458:	0f b6 00             	movzbl (%rax),%eax
  80245b:	3c 2d                	cmp    $0x2d,%al
  80245d:	75 0c                	jne    80246b <strtol+0x68>
		s++, neg = 1;
  80245f:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  802464:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80246b:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  80246f:	74 06                	je     802477 <strtol+0x74>
  802471:	83 7d cc 10          	cmpl   $0x10,-0x34(%rbp)
  802475:	75 28                	jne    80249f <strtol+0x9c>
  802477:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80247b:	0f b6 00             	movzbl (%rax),%eax
  80247e:	3c 30                	cmp    $0x30,%al
  802480:	75 1d                	jne    80249f <strtol+0x9c>
  802482:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802486:	48 83 c0 01          	add    $0x1,%rax
  80248a:	0f b6 00             	movzbl (%rax),%eax
  80248d:	3c 78                	cmp    $0x78,%al
  80248f:	75 0e                	jne    80249f <strtol+0x9c>
		s += 2, base = 16;
  802491:	48 83 45 d8 02       	addq   $0x2,-0x28(%rbp)
  802496:	c7 45 cc 10 00 00 00 	movl   $0x10,-0x34(%rbp)
  80249d:	eb 2c                	jmp    8024cb <strtol+0xc8>
	else if (base == 0 && s[0] == '0')
  80249f:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  8024a3:	75 19                	jne    8024be <strtol+0xbb>
  8024a5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8024a9:	0f b6 00             	movzbl (%rax),%eax
  8024ac:	3c 30                	cmp    $0x30,%al
  8024ae:	75 0e                	jne    8024be <strtol+0xbb>
		s++, base = 8;
  8024b0:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  8024b5:	c7 45 cc 08 00 00 00 	movl   $0x8,-0x34(%rbp)
  8024bc:	eb 0d                	jmp    8024cb <strtol+0xc8>
	else if (base == 0)
  8024be:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  8024c2:	75 07                	jne    8024cb <strtol+0xc8>
		base = 10;
  8024c4:	c7 45 cc 0a 00 00 00 	movl   $0xa,-0x34(%rbp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  8024cb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8024cf:	0f b6 00             	movzbl (%rax),%eax
  8024d2:	3c 2f                	cmp    $0x2f,%al
  8024d4:	7e 1d                	jle    8024f3 <strtol+0xf0>
  8024d6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8024da:	0f b6 00             	movzbl (%rax),%eax
  8024dd:	3c 39                	cmp    $0x39,%al
  8024df:	7f 12                	jg     8024f3 <strtol+0xf0>
			dig = *s - '0';
  8024e1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8024e5:	0f b6 00             	movzbl (%rax),%eax
  8024e8:	0f be c0             	movsbl %al,%eax
  8024eb:	83 e8 30             	sub    $0x30,%eax
  8024ee:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8024f1:	eb 4e                	jmp    802541 <strtol+0x13e>
		else if (*s >= 'a' && *s <= 'z')
  8024f3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8024f7:	0f b6 00             	movzbl (%rax),%eax
  8024fa:	3c 60                	cmp    $0x60,%al
  8024fc:	7e 1d                	jle    80251b <strtol+0x118>
  8024fe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802502:	0f b6 00             	movzbl (%rax),%eax
  802505:	3c 7a                	cmp    $0x7a,%al
  802507:	7f 12                	jg     80251b <strtol+0x118>
			dig = *s - 'a' + 10;
  802509:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80250d:	0f b6 00             	movzbl (%rax),%eax
  802510:	0f be c0             	movsbl %al,%eax
  802513:	83 e8 57             	sub    $0x57,%eax
  802516:	89 45 ec             	mov    %eax,-0x14(%rbp)
  802519:	eb 26                	jmp    802541 <strtol+0x13e>
		else if (*s >= 'A' && *s <= 'Z')
  80251b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80251f:	0f b6 00             	movzbl (%rax),%eax
  802522:	3c 40                	cmp    $0x40,%al
  802524:	7e 48                	jle    80256e <strtol+0x16b>
  802526:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80252a:	0f b6 00             	movzbl (%rax),%eax
  80252d:	3c 5a                	cmp    $0x5a,%al
  80252f:	7f 3d                	jg     80256e <strtol+0x16b>
			dig = *s - 'A' + 10;
  802531:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802535:	0f b6 00             	movzbl (%rax),%eax
  802538:	0f be c0             	movsbl %al,%eax
  80253b:	83 e8 37             	sub    $0x37,%eax
  80253e:	89 45 ec             	mov    %eax,-0x14(%rbp)
		else
			break;
		if (dig >= base)
  802541:	8b 45 ec             	mov    -0x14(%rbp),%eax
  802544:	3b 45 cc             	cmp    -0x34(%rbp),%eax
  802547:	7c 02                	jl     80254b <strtol+0x148>
			break;
  802549:	eb 23                	jmp    80256e <strtol+0x16b>
		s++, val = (val * base) + dig;
  80254b:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  802550:	8b 45 cc             	mov    -0x34(%rbp),%eax
  802553:	48 98                	cltq   
  802555:	48 0f af 45 f0       	imul   -0x10(%rbp),%rax
  80255a:	48 89 c2             	mov    %rax,%rdx
  80255d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  802560:	48 98                	cltq   
  802562:	48 01 d0             	add    %rdx,%rax
  802565:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		// we don't properly detect overflow!
	}
  802569:	e9 5d ff ff ff       	jmpq   8024cb <strtol+0xc8>

	if (endptr)
  80256e:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  802573:	74 0b                	je     802580 <strtol+0x17d>
		*endptr = (char *) s;
  802575:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  802579:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80257d:	48 89 10             	mov    %rdx,(%rax)
	return (neg ? -val : val);
  802580:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  802584:	74 09                	je     80258f <strtol+0x18c>
  802586:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80258a:	48 f7 d8             	neg    %rax
  80258d:	eb 04                	jmp    802593 <strtol+0x190>
  80258f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  802593:	c9                   	leaveq 
  802594:	c3                   	retq   

0000000000802595 <strstr>:

char * strstr(const char *in, const char *str)
{
  802595:	55                   	push   %rbp
  802596:	48 89 e5             	mov    %rsp,%rbp
  802599:	48 83 ec 30          	sub    $0x30,%rsp
  80259d:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8025a1:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	char c;
	size_t len;

	c = *str++;
  8025a5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8025a9:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8025ad:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  8025b1:	0f b6 00             	movzbl (%rax),%eax
  8025b4:	88 45 ff             	mov    %al,-0x1(%rbp)
	if (!c)
  8025b7:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  8025bb:	75 06                	jne    8025c3 <strstr+0x2e>
		return (char *) in;	// Trivial empty string case
  8025bd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8025c1:	eb 6b                	jmp    80262e <strstr+0x99>

	len = strlen(str);
  8025c3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8025c7:	48 89 c7             	mov    %rax,%rdi
  8025ca:	48 b8 6b 1e 80 00 00 	movabs $0x801e6b,%rax
  8025d1:	00 00 00 
  8025d4:	ff d0                	callq  *%rax
  8025d6:	48 98                	cltq   
  8025d8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	do {
		char sc;

		do {
			sc = *in++;
  8025dc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8025e0:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8025e4:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8025e8:	0f b6 00             	movzbl (%rax),%eax
  8025eb:	88 45 ef             	mov    %al,-0x11(%rbp)
			if (!sc)
  8025ee:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  8025f2:	75 07                	jne    8025fb <strstr+0x66>
				return (char *) 0;
  8025f4:	b8 00 00 00 00       	mov    $0x0,%eax
  8025f9:	eb 33                	jmp    80262e <strstr+0x99>
		} while (sc != c);
  8025fb:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8025ff:	3a 45 ff             	cmp    -0x1(%rbp),%al
  802602:	75 d8                	jne    8025dc <strstr+0x47>
	} while (strncmp(in, str, len) != 0);
  802604:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802608:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  80260c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802610:	48 89 ce             	mov    %rcx,%rsi
  802613:	48 89 c7             	mov    %rax,%rdi
  802616:	48 b8 8c 20 80 00 00 	movabs $0x80208c,%rax
  80261d:	00 00 00 
  802620:	ff d0                	callq  *%rax
  802622:	85 c0                	test   %eax,%eax
  802624:	75 b6                	jne    8025dc <strstr+0x47>

	return (char *) (in - 1);
  802626:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80262a:	48 83 e8 01          	sub    $0x1,%rax
}
  80262e:	c9                   	leaveq 
  80262f:	c3                   	retq   

0000000000802630 <syscall>:
#include <inc/syscall.h>
#include <inc/lib.h>

static inline int64_t
syscall(int num, int check, uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  802630:	55                   	push   %rbp
  802631:	48 89 e5             	mov    %rsp,%rbp
  802634:	53                   	push   %rbx
  802635:	48 83 ec 48          	sub    $0x48,%rsp
  802639:	89 7d dc             	mov    %edi,-0x24(%rbp)
  80263c:	89 75 d8             	mov    %esi,-0x28(%rbp)
  80263f:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  802643:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  802647:	4c 89 45 c0          	mov    %r8,-0x40(%rbp)
  80264b:	4c 89 4d b8          	mov    %r9,-0x48(%rbp)
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80264f:	8b 45 dc             	mov    -0x24(%rbp),%eax
  802652:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  802656:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  80265a:	4c 8b 45 c0          	mov    -0x40(%rbp),%r8
  80265e:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  802662:	48 8b 75 10          	mov    0x10(%rbp),%rsi
  802666:	4c 89 c3             	mov    %r8,%rbx
  802669:	cd 30                	int    $0x30
  80266b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80266f:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  802673:	74 3e                	je     8026b3 <syscall+0x83>
  802675:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80267a:	7e 37                	jle    8026b3 <syscall+0x83>
		panic("syscall %d returned %d (> 0)", num, ret);
  80267c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  802680:	8b 45 dc             	mov    -0x24(%rbp),%eax
  802683:	49 89 d0             	mov    %rdx,%r8
  802686:	89 c1                	mov    %eax,%ecx
  802688:	48 ba c8 12 82 00 00 	movabs $0x8212c8,%rdx
  80268f:	00 00 00 
  802692:	be 24 00 00 00       	mov    $0x24,%esi
  802697:	48 bf e5 12 82 00 00 	movabs $0x8212e5,%rdi
  80269e:	00 00 00 
  8026a1:	b8 00 00 00 00       	mov    $0x0,%eax
  8026a6:	49 b9 e9 10 80 00 00 	movabs $0x8010e9,%r9
  8026ad:	00 00 00 
  8026b0:	41 ff d1             	callq  *%r9

	return ret;
  8026b3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  8026b7:	48 83 c4 48          	add    $0x48,%rsp
  8026bb:	5b                   	pop    %rbx
  8026bc:	5d                   	pop    %rbp
  8026bd:	c3                   	retq   

00000000008026be <sys_cputs>:

void
sys_cputs(const char *s, size_t len)
{
  8026be:	55                   	push   %rbp
  8026bf:	48 89 e5             	mov    %rsp,%rbp
  8026c2:	48 83 ec 20          	sub    $0x20,%rsp
  8026c6:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8026ca:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	syscall(SYS_cputs, 0, (uint64_t)s, len, 0, 0, 0);
  8026ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8026d2:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8026d6:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  8026dd:	00 
  8026de:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8026e4:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8026ea:	48 89 d1             	mov    %rdx,%rcx
  8026ed:	48 89 c2             	mov    %rax,%rdx
  8026f0:	be 00 00 00 00       	mov    $0x0,%esi
  8026f5:	bf 00 00 00 00       	mov    $0x0,%edi
  8026fa:	48 b8 30 26 80 00 00 	movabs $0x802630,%rax
  802701:	00 00 00 
  802704:	ff d0                	callq  *%rax
}
  802706:	c9                   	leaveq 
  802707:	c3                   	retq   

0000000000802708 <sys_cgetc>:

int
sys_cgetc(void)
{
  802708:	55                   	push   %rbp
  802709:	48 89 e5             	mov    %rsp,%rbp
  80270c:	48 83 ec 10          	sub    $0x10,%rsp
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
  802710:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  802717:	00 
  802718:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  80271e:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802724:	b9 00 00 00 00       	mov    $0x0,%ecx
  802729:	ba 00 00 00 00       	mov    $0x0,%edx
  80272e:	be 00 00 00 00       	mov    $0x0,%esi
  802733:	bf 01 00 00 00       	mov    $0x1,%edi
  802738:	48 b8 30 26 80 00 00 	movabs $0x802630,%rax
  80273f:	00 00 00 
  802742:	ff d0                	callq  *%rax
}
  802744:	c9                   	leaveq 
  802745:	c3                   	retq   

0000000000802746 <sys_env_destroy>:

int
sys_env_destroy(envid_t envid)
{
  802746:	55                   	push   %rbp
  802747:	48 89 e5             	mov    %rsp,%rbp
  80274a:	48 83 ec 10          	sub    $0x10,%rsp
  80274e:	89 7d fc             	mov    %edi,-0x4(%rbp)
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
  802751:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802754:	48 98                	cltq   
  802756:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  80275d:	00 
  80275e:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802764:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80276a:	b9 00 00 00 00       	mov    $0x0,%ecx
  80276f:	48 89 c2             	mov    %rax,%rdx
  802772:	be 01 00 00 00       	mov    $0x1,%esi
  802777:	bf 03 00 00 00       	mov    $0x3,%edi
  80277c:	48 b8 30 26 80 00 00 	movabs $0x802630,%rax
  802783:	00 00 00 
  802786:	ff d0                	callq  *%rax
}
  802788:	c9                   	leaveq 
  802789:	c3                   	retq   

000000000080278a <sys_getenvid>:

envid_t
sys_getenvid(void)
{
  80278a:	55                   	push   %rbp
  80278b:	48 89 e5             	mov    %rsp,%rbp
  80278e:	48 83 ec 10          	sub    $0x10,%rsp
	return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
  802792:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  802799:	00 
  80279a:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8027a0:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8027a6:	b9 00 00 00 00       	mov    $0x0,%ecx
  8027ab:	ba 00 00 00 00       	mov    $0x0,%edx
  8027b0:	be 00 00 00 00       	mov    $0x0,%esi
  8027b5:	bf 02 00 00 00       	mov    $0x2,%edi
  8027ba:	48 b8 30 26 80 00 00 	movabs $0x802630,%rax
  8027c1:	00 00 00 
  8027c4:	ff d0                	callq  *%rax
}
  8027c6:	c9                   	leaveq 
  8027c7:	c3                   	retq   

00000000008027c8 <sys_yield>:


void
sys_yield(void)
{
  8027c8:	55                   	push   %rbp
  8027c9:	48 89 e5             	mov    %rsp,%rbp
  8027cc:	48 83 ec 10          	sub    $0x10,%rsp
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
  8027d0:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  8027d7:	00 
  8027d8:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8027de:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8027e4:	b9 00 00 00 00       	mov    $0x0,%ecx
  8027e9:	ba 00 00 00 00       	mov    $0x0,%edx
  8027ee:	be 00 00 00 00       	mov    $0x0,%esi
  8027f3:	bf 0b 00 00 00       	mov    $0xb,%edi
  8027f8:	48 b8 30 26 80 00 00 	movabs $0x802630,%rax
  8027ff:	00 00 00 
  802802:	ff d0                	callq  *%rax
}
  802804:	c9                   	leaveq 
  802805:	c3                   	retq   

0000000000802806 <sys_page_alloc>:

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  802806:	55                   	push   %rbp
  802807:	48 89 e5             	mov    %rsp,%rbp
  80280a:	48 83 ec 20          	sub    $0x20,%rsp
  80280e:	89 7d fc             	mov    %edi,-0x4(%rbp)
  802811:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  802815:	89 55 f8             	mov    %edx,-0x8(%rbp)
	return syscall(SYS_page_alloc, 1, envid, (uint64_t) va, perm, 0, 0);
  802818:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80281b:	48 63 c8             	movslq %eax,%rcx
  80281e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802822:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802825:	48 98                	cltq   
  802827:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  80282e:	00 
  80282f:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802835:	49 89 c8             	mov    %rcx,%r8
  802838:	48 89 d1             	mov    %rdx,%rcx
  80283b:	48 89 c2             	mov    %rax,%rdx
  80283e:	be 01 00 00 00       	mov    $0x1,%esi
  802843:	bf 04 00 00 00       	mov    $0x4,%edi
  802848:	48 b8 30 26 80 00 00 	movabs $0x802630,%rax
  80284f:	00 00 00 
  802852:	ff d0                	callq  *%rax
}
  802854:	c9                   	leaveq 
  802855:	c3                   	retq   

0000000000802856 <sys_page_map>:

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
  802856:	55                   	push   %rbp
  802857:	48 89 e5             	mov    %rsp,%rbp
  80285a:	48 83 ec 30          	sub    $0x30,%rsp
  80285e:	89 7d fc             	mov    %edi,-0x4(%rbp)
  802861:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  802865:	89 55 f8             	mov    %edx,-0x8(%rbp)
  802868:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
  80286c:	44 89 45 e4          	mov    %r8d,-0x1c(%rbp)
	return syscall(SYS_page_map, 1, srcenv, (uint64_t) srcva, dstenv, (uint64_t) dstva, perm);
  802870:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  802873:	48 63 c8             	movslq %eax,%rcx
  802876:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  80287a:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80287d:	48 63 f0             	movslq %eax,%rsi
  802880:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802884:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802887:	48 98                	cltq   
  802889:	48 89 0c 24          	mov    %rcx,(%rsp)
  80288d:	49 89 f9             	mov    %rdi,%r9
  802890:	49 89 f0             	mov    %rsi,%r8
  802893:	48 89 d1             	mov    %rdx,%rcx
  802896:	48 89 c2             	mov    %rax,%rdx
  802899:	be 01 00 00 00       	mov    $0x1,%esi
  80289e:	bf 05 00 00 00       	mov    $0x5,%edi
  8028a3:	48 b8 30 26 80 00 00 	movabs $0x802630,%rax
  8028aa:	00 00 00 
  8028ad:	ff d0                	callq  *%rax
}
  8028af:	c9                   	leaveq 
  8028b0:	c3                   	retq   

00000000008028b1 <sys_page_unmap>:

int
sys_page_unmap(envid_t envid, void *va)
{
  8028b1:	55                   	push   %rbp
  8028b2:	48 89 e5             	mov    %rsp,%rbp
  8028b5:	48 83 ec 20          	sub    $0x20,%rsp
  8028b9:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8028bc:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	return syscall(SYS_page_unmap, 1, envid, (uint64_t) va, 0, 0, 0);
  8028c0:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8028c4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8028c7:	48 98                	cltq   
  8028c9:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  8028d0:	00 
  8028d1:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8028d7:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8028dd:	48 89 d1             	mov    %rdx,%rcx
  8028e0:	48 89 c2             	mov    %rax,%rdx
  8028e3:	be 01 00 00 00       	mov    $0x1,%esi
  8028e8:	bf 06 00 00 00       	mov    $0x6,%edi
  8028ed:	48 b8 30 26 80 00 00 	movabs $0x802630,%rax
  8028f4:	00 00 00 
  8028f7:	ff d0                	callq  *%rax
}
  8028f9:	c9                   	leaveq 
  8028fa:	c3                   	retq   

00000000008028fb <sys_env_set_status>:

// sys_exofork is inlined in lib.h

int
sys_env_set_status(envid_t envid, int status)
{
  8028fb:	55                   	push   %rbp
  8028fc:	48 89 e5             	mov    %rsp,%rbp
  8028ff:	48 83 ec 10          	sub    $0x10,%rsp
  802903:	89 7d fc             	mov    %edi,-0x4(%rbp)
  802906:	89 75 f8             	mov    %esi,-0x8(%rbp)
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
  802909:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80290c:	48 63 d0             	movslq %eax,%rdx
  80290f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802912:	48 98                	cltq   
  802914:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  80291b:	00 
  80291c:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802922:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802928:	48 89 d1             	mov    %rdx,%rcx
  80292b:	48 89 c2             	mov    %rax,%rdx
  80292e:	be 01 00 00 00       	mov    $0x1,%esi
  802933:	bf 08 00 00 00       	mov    $0x8,%edi
  802938:	48 b8 30 26 80 00 00 	movabs $0x802630,%rax
  80293f:	00 00 00 
  802942:	ff d0                	callq  *%rax
}
  802944:	c9                   	leaveq 
  802945:	c3                   	retq   

0000000000802946 <sys_env_set_trapframe>:


int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  802946:	55                   	push   %rbp
  802947:	48 89 e5             	mov    %rsp,%rbp
  80294a:	48 83 ec 20          	sub    $0x20,%rsp
  80294e:	89 7d fc             	mov    %edi,-0x4(%rbp)
  802951:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	return syscall(SYS_env_set_trapframe, 1, envid, (uint64_t) tf, 0, 0, 0);
  802955:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802959:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80295c:	48 98                	cltq   
  80295e:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  802965:	00 
  802966:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  80296c:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802972:	48 89 d1             	mov    %rdx,%rcx
  802975:	48 89 c2             	mov    %rax,%rdx
  802978:	be 01 00 00 00       	mov    $0x1,%esi
  80297d:	bf 09 00 00 00       	mov    $0x9,%edi
  802982:	48 b8 30 26 80 00 00 	movabs $0x802630,%rax
  802989:	00 00 00 
  80298c:	ff d0                	callq  *%rax
}
  80298e:	c9                   	leaveq 
  80298f:	c3                   	retq   

0000000000802990 <sys_env_set_pgfault_upcall>:


int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
  802990:	55                   	push   %rbp
  802991:	48 89 e5             	mov    %rsp,%rbp
  802994:	48 83 ec 20          	sub    $0x20,%rsp
  802998:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80299b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint64_t) upcall, 0, 0, 0);
  80299f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8029a3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8029a6:	48 98                	cltq   
  8029a8:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  8029af:	00 
  8029b0:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8029b6:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8029bc:	48 89 d1             	mov    %rdx,%rcx
  8029bf:	48 89 c2             	mov    %rax,%rdx
  8029c2:	be 01 00 00 00       	mov    $0x1,%esi
  8029c7:	bf 0a 00 00 00       	mov    $0xa,%edi
  8029cc:	48 b8 30 26 80 00 00 	movabs $0x802630,%rax
  8029d3:	00 00 00 
  8029d6:	ff d0                	callq  *%rax
}
  8029d8:	c9                   	leaveq 
  8029d9:	c3                   	retq   

00000000008029da <sys_ipc_try_send>:

int
sys_ipc_try_send(envid_t envid, uint64_t value, void *srcva, int perm)
{
  8029da:	55                   	push   %rbp
  8029db:	48 89 e5             	mov    %rsp,%rbp
  8029de:	48 83 ec 20          	sub    $0x20,%rsp
  8029e2:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8029e5:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8029e9:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8029ed:	89 4d f8             	mov    %ecx,-0x8(%rbp)
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint64_t) srcva, perm, 0);
  8029f0:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8029f3:	48 63 f0             	movslq %eax,%rsi
  8029f6:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8029fa:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8029fd:	48 98                	cltq   
  8029ff:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802a03:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  802a0a:	00 
  802a0b:	49 89 f1             	mov    %rsi,%r9
  802a0e:	49 89 c8             	mov    %rcx,%r8
  802a11:	48 89 d1             	mov    %rdx,%rcx
  802a14:	48 89 c2             	mov    %rax,%rdx
  802a17:	be 00 00 00 00       	mov    $0x0,%esi
  802a1c:	bf 0c 00 00 00       	mov    $0xc,%edi
  802a21:	48 b8 30 26 80 00 00 	movabs $0x802630,%rax
  802a28:	00 00 00 
  802a2b:	ff d0                	callq  *%rax
}
  802a2d:	c9                   	leaveq 
  802a2e:	c3                   	retq   

0000000000802a2f <sys_ipc_recv>:

int
sys_ipc_recv(void *dstva)
{
  802a2f:	55                   	push   %rbp
  802a30:	48 89 e5             	mov    %rsp,%rbp
  802a33:	48 83 ec 10          	sub    $0x10,%rsp
  802a37:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return syscall(SYS_ipc_recv, 1, (uint64_t)dstva, 0, 0, 0, 0);
  802a3b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802a3f:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  802a46:	00 
  802a47:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802a4d:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802a53:	b9 00 00 00 00       	mov    $0x0,%ecx
  802a58:	48 89 c2             	mov    %rax,%rdx
  802a5b:	be 01 00 00 00       	mov    $0x1,%esi
  802a60:	bf 0d 00 00 00       	mov    $0xd,%edi
  802a65:	48 b8 30 26 80 00 00 	movabs $0x802630,%rax
  802a6c:	00 00 00 
  802a6f:	ff d0                	callq  *%rax
}
  802a71:	c9                   	leaveq 
  802a72:	c3                   	retq   

0000000000802a73 <sys_time_msec>:


unsigned int
sys_time_msec(void)
{
  802a73:	55                   	push   %rbp
  802a74:	48 89 e5             	mov    %rsp,%rbp
  802a77:	48 83 ec 10          	sub    $0x10,%rsp
	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0, 0);
  802a7b:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  802a82:	00 
  802a83:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802a89:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802a8f:	b9 00 00 00 00       	mov    $0x0,%ecx
  802a94:	ba 00 00 00 00       	mov    $0x0,%edx
  802a99:	be 00 00 00 00       	mov    $0x0,%esi
  802a9e:	bf 0e 00 00 00       	mov    $0xe,%edi
  802aa3:	48 b8 30 26 80 00 00 	movabs $0x802630,%rax
  802aaa:	00 00 00 
  802aad:	ff d0                	callq  *%rax
}
  802aaf:	c9                   	leaveq 
  802ab0:	c3                   	retq   

0000000000802ab1 <sys_net_transmit>:


int
sys_net_transmit(const char *data, unsigned int len)
{
  802ab1:	55                   	push   %rbp
  802ab2:	48 89 e5             	mov    %rsp,%rbp
  802ab5:	48 83 ec 20          	sub    $0x20,%rsp
  802ab9:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  802abd:	89 75 f4             	mov    %esi,-0xc(%rbp)
	return syscall(SYS_net_transmit, 0, (uint64_t)data, len, 0, 0, 0);
  802ac0:	8b 55 f4             	mov    -0xc(%rbp),%edx
  802ac3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802ac7:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  802ace:	00 
  802acf:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802ad5:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802adb:	48 89 d1             	mov    %rdx,%rcx
  802ade:	48 89 c2             	mov    %rax,%rdx
  802ae1:	be 00 00 00 00       	mov    $0x0,%esi
  802ae6:	bf 0f 00 00 00       	mov    $0xf,%edi
  802aeb:	48 b8 30 26 80 00 00 	movabs $0x802630,%rax
  802af2:	00 00 00 
  802af5:	ff d0                	callq  *%rax
}
  802af7:	c9                   	leaveq 
  802af8:	c3                   	retq   

0000000000802af9 <sys_net_receive>:

int
sys_net_receive(char *buf, unsigned int len)
{
  802af9:	55                   	push   %rbp
  802afa:	48 89 e5             	mov    %rsp,%rbp
  802afd:	48 83 ec 20          	sub    $0x20,%rsp
  802b01:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  802b05:	89 75 f4             	mov    %esi,-0xc(%rbp)
	return syscall(SYS_net_receive, 0, (uint64_t)buf, len, 0, 0, 0);
  802b08:	8b 55 f4             	mov    -0xc(%rbp),%edx
  802b0b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802b0f:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  802b16:	00 
  802b17:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802b1d:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802b23:	48 89 d1             	mov    %rdx,%rcx
  802b26:	48 89 c2             	mov    %rax,%rdx
  802b29:	be 00 00 00 00       	mov    $0x0,%esi
  802b2e:	bf 10 00 00 00       	mov    $0x10,%edi
  802b33:	48 b8 30 26 80 00 00 	movabs $0x802630,%rax
  802b3a:	00 00 00 
  802b3d:	ff d0                	callq  *%rax
}
  802b3f:	c9                   	leaveq 
  802b40:	c3                   	retq   

0000000000802b41 <sys_ept_map>:



int
sys_ept_map(envid_t srcenvid, void *srcva, envid_t guest, void* guest_pa, int perm) 
{
  802b41:	55                   	push   %rbp
  802b42:	48 89 e5             	mov    %rsp,%rbp
  802b45:	48 83 ec 30          	sub    $0x30,%rsp
  802b49:	89 7d fc             	mov    %edi,-0x4(%rbp)
  802b4c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  802b50:	89 55 f8             	mov    %edx,-0x8(%rbp)
  802b53:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
  802b57:	44 89 45 e4          	mov    %r8d,-0x1c(%rbp)
	return syscall(SYS_ept_map, 0, srcenvid, 
  802b5b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  802b5e:	48 63 c8             	movslq %eax,%rcx
  802b61:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  802b65:	8b 45 f8             	mov    -0x8(%rbp),%eax
  802b68:	48 63 f0             	movslq %eax,%rsi
  802b6b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802b6f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802b72:	48 98                	cltq   
  802b74:	48 89 0c 24          	mov    %rcx,(%rsp)
  802b78:	49 89 f9             	mov    %rdi,%r9
  802b7b:	49 89 f0             	mov    %rsi,%r8
  802b7e:	48 89 d1             	mov    %rdx,%rcx
  802b81:	48 89 c2             	mov    %rax,%rdx
  802b84:	be 00 00 00 00       	mov    $0x0,%esi
  802b89:	bf 11 00 00 00       	mov    $0x11,%edi
  802b8e:	48 b8 30 26 80 00 00 	movabs $0x802630,%rax
  802b95:	00 00 00 
  802b98:	ff d0                	callq  *%rax
		       (uint64_t)srcva, guest, (uint64_t)guest_pa, perm);
}
  802b9a:	c9                   	leaveq 
  802b9b:	c3                   	retq   

0000000000802b9c <sys_env_mkguest>:

envid_t
sys_env_mkguest(uint64_t gphysz, uint64_t gRIP) {
  802b9c:	55                   	push   %rbp
  802b9d:	48 89 e5             	mov    %rsp,%rbp
  802ba0:	48 83 ec 20          	sub    $0x20,%rsp
  802ba4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  802ba8:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	return (envid_t) syscall(SYS_env_mkguest, 0, gphysz, gRIP, 0, 0, 0);
  802bac:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802bb0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802bb4:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  802bbb:	00 
  802bbc:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802bc2:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802bc8:	48 89 d1             	mov    %rdx,%rcx
  802bcb:	48 89 c2             	mov    %rax,%rdx
  802bce:	be 00 00 00 00       	mov    $0x0,%esi
  802bd3:	bf 12 00 00 00       	mov    $0x12,%edi
  802bd8:	48 b8 30 26 80 00 00 	movabs $0x802630,%rax
  802bdf:	00 00 00 
  802be2:	ff d0                	callq  *%rax
}
  802be4:	c9                   	leaveq 
  802be5:	c3                   	retq   

0000000000802be6 <pgfault>:
// Custom page fault handler - if faulting page is copy-on-write,
// map in our own private writable copy.
//
static void
pgfault(struct UTrapframe *utf)
{
  802be6:	55                   	push   %rbp
  802be7:	48 89 e5             	mov    %rsp,%rbp
  802bea:	48 83 ec 30          	sub    $0x30,%rsp
  802bee:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	void *addr = (void *) utf->utf_fault_va;
  802bf2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802bf6:	48 8b 00             	mov    (%rax),%rax
  802bf9:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	uint32_t err = utf->utf_err;
  802bfd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802c01:	48 8b 40 08          	mov    0x8(%rax),%rax
  802c05:	89 45 fc             	mov    %eax,-0x4(%rbp)


	if (debug)
		cprintf("fault %08x %08x %d from %08x\n", addr, &uvpt[PGNUM(addr)], err & 7, (&addr)[4]);

	if (!(err & FEC_WR))
  802c08:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802c0b:	83 e0 02             	and    $0x2,%eax
  802c0e:	85 c0                	test   %eax,%eax
  802c10:	75 40                	jne    802c52 <pgfault+0x6c>
		panic("read fault at %x, rip %x", addr, utf->utf_rip);
  802c12:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802c16:	48 8b 90 88 00 00 00 	mov    0x88(%rax),%rdx
  802c1d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  802c21:	49 89 d0             	mov    %rdx,%r8
  802c24:	48 89 c1             	mov    %rax,%rcx
  802c27:	48 ba f8 12 82 00 00 	movabs $0x8212f8,%rdx
  802c2e:	00 00 00 
  802c31:	be 1f 00 00 00       	mov    $0x1f,%esi
  802c36:	48 bf 11 13 82 00 00 	movabs $0x821311,%rdi
  802c3d:	00 00 00 
  802c40:	b8 00 00 00 00       	mov    $0x0,%eax
  802c45:	49 b9 e9 10 80 00 00 	movabs $0x8010e9,%r9
  802c4c:	00 00 00 
  802c4f:	41 ff d1             	callq  *%r9
	if ((uvpt[PGNUM(addr)] & (PTE_P|PTE_U|PTE_W|PTE_COW)) != (PTE_P|PTE_U|PTE_COW))
  802c52:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  802c56:	48 c1 e8 0c          	shr    $0xc,%rax
  802c5a:	48 89 c2             	mov    %rax,%rdx
  802c5d:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  802c64:	01 00 00 
  802c67:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  802c6b:	25 07 08 00 00       	and    $0x807,%eax
  802c70:	48 3d 05 08 00 00    	cmp    $0x805,%rax
  802c76:	74 4e                	je     802cc6 <pgfault+0xe0>
		panic("fault at %x with pte %x, not copy-on-write",
  802c78:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  802c7c:	48 c1 e8 0c          	shr    $0xc,%rax
  802c80:	48 89 c2             	mov    %rax,%rdx
  802c83:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  802c8a:	01 00 00 
  802c8d:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  802c91:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  802c95:	49 89 d0             	mov    %rdx,%r8
  802c98:	48 89 c1             	mov    %rax,%rcx
  802c9b:	48 ba 20 13 82 00 00 	movabs $0x821320,%rdx
  802ca2:	00 00 00 
  802ca5:	be 22 00 00 00       	mov    $0x22,%esi
  802caa:	48 bf 11 13 82 00 00 	movabs $0x821311,%rdi
  802cb1:	00 00 00 
  802cb4:	b8 00 00 00 00       	mov    $0x0,%eax
  802cb9:	49 b9 e9 10 80 00 00 	movabs $0x8010e9,%r9
  802cc0:	00 00 00 
  802cc3:	41 ff d1             	callq  *%r9
		      addr, uvpt[PGNUM(addr)]);



	// copy page
	if ((r = sys_page_alloc(0, (void*) PFTEMP, PTE_P|PTE_U|PTE_W)) < 0)
  802cc6:	ba 07 00 00 00       	mov    $0x7,%edx
  802ccb:	be 00 f0 5f 00       	mov    $0x5ff000,%esi
  802cd0:	bf 00 00 00 00       	mov    $0x0,%edi
  802cd5:	48 b8 06 28 80 00 00 	movabs $0x802806,%rax
  802cdc:	00 00 00 
  802cdf:	ff d0                	callq  *%rax
  802ce1:	89 45 f8             	mov    %eax,-0x8(%rbp)
  802ce4:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  802ce8:	79 30                	jns    802d1a <pgfault+0x134>
		panic("sys_page_alloc: %e", r);
  802cea:	8b 45 f8             	mov    -0x8(%rbp),%eax
  802ced:	89 c1                	mov    %eax,%ecx
  802cef:	48 ba 4b 13 82 00 00 	movabs $0x82134b,%rdx
  802cf6:	00 00 00 
  802cf9:	be 28 00 00 00       	mov    $0x28,%esi
  802cfe:	48 bf 11 13 82 00 00 	movabs $0x821311,%rdi
  802d05:	00 00 00 
  802d08:	b8 00 00 00 00       	mov    $0x0,%eax
  802d0d:	49 b8 e9 10 80 00 00 	movabs $0x8010e9,%r8
  802d14:	00 00 00 
  802d17:	41 ff d0             	callq  *%r8
	memmove((void*) PFTEMP, ROUNDDOWN(addr, PGSIZE), PGSIZE);
  802d1a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  802d1e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  802d22:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802d26:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  802d2c:	ba 00 10 00 00       	mov    $0x1000,%edx
  802d31:	48 89 c6             	mov    %rax,%rsi
  802d34:	bf 00 f0 5f 00       	mov    $0x5ff000,%edi
  802d39:	48 b8 fb 21 80 00 00 	movabs $0x8021fb,%rax
  802d40:	00 00 00 
  802d43:	ff d0                	callq  *%rax

	// remap over faulting page
	if ((r = sys_page_map(0, (void*) PFTEMP, 0, ROUNDDOWN(addr, PGSIZE), PTE_P|PTE_U|PTE_W)) < 0)
  802d45:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  802d49:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  802d4d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  802d51:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  802d57:	41 b8 07 00 00 00    	mov    $0x7,%r8d
  802d5d:	48 89 c1             	mov    %rax,%rcx
  802d60:	ba 00 00 00 00       	mov    $0x0,%edx
  802d65:	be 00 f0 5f 00       	mov    $0x5ff000,%esi
  802d6a:	bf 00 00 00 00       	mov    $0x0,%edi
  802d6f:	48 b8 56 28 80 00 00 	movabs $0x802856,%rax
  802d76:	00 00 00 
  802d79:	ff d0                	callq  *%rax
  802d7b:	89 45 f8             	mov    %eax,-0x8(%rbp)
  802d7e:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  802d82:	79 30                	jns    802db4 <pgfault+0x1ce>
		panic("sys_page_map: %e", r);
  802d84:	8b 45 f8             	mov    -0x8(%rbp),%eax
  802d87:	89 c1                	mov    %eax,%ecx
  802d89:	48 ba 5e 13 82 00 00 	movabs $0x82135e,%rdx
  802d90:	00 00 00 
  802d93:	be 2d 00 00 00       	mov    $0x2d,%esi
  802d98:	48 bf 11 13 82 00 00 	movabs $0x821311,%rdi
  802d9f:	00 00 00 
  802da2:	b8 00 00 00 00       	mov    $0x0,%eax
  802da7:	49 b8 e9 10 80 00 00 	movabs $0x8010e9,%r8
  802dae:	00 00 00 
  802db1:	41 ff d0             	callq  *%r8

	// unmap our work space
	if ((r = sys_page_unmap(0, (void*) PFTEMP)) < 0)
  802db4:	be 00 f0 5f 00       	mov    $0x5ff000,%esi
  802db9:	bf 00 00 00 00       	mov    $0x0,%edi
  802dbe:	48 b8 b1 28 80 00 00 	movabs $0x8028b1,%rax
  802dc5:	00 00 00 
  802dc8:	ff d0                	callq  *%rax
  802dca:	89 45 f8             	mov    %eax,-0x8(%rbp)
  802dcd:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  802dd1:	79 30                	jns    802e03 <pgfault+0x21d>
		panic("sys_page_unmap: %e", r);
  802dd3:	8b 45 f8             	mov    -0x8(%rbp),%eax
  802dd6:	89 c1                	mov    %eax,%ecx
  802dd8:	48 ba 6f 13 82 00 00 	movabs $0x82136f,%rdx
  802ddf:	00 00 00 
  802de2:	be 31 00 00 00       	mov    $0x31,%esi
  802de7:	48 bf 11 13 82 00 00 	movabs $0x821311,%rdi
  802dee:	00 00 00 
  802df1:	b8 00 00 00 00       	mov    $0x0,%eax
  802df6:	49 b8 e9 10 80 00 00 	movabs $0x8010e9,%r8
  802dfd:	00 00 00 
  802e00:	41 ff d0             	callq  *%r8

}
  802e03:	c9                   	leaveq 
  802e04:	c3                   	retq   

0000000000802e05 <duppage>:
// Returns: 0 on success, < 0 on error.
// It is also OK to panic on error.
//
static int
duppage(envid_t envid, unsigned pn)
{
  802e05:	55                   	push   %rbp
  802e06:	48 89 e5             	mov    %rsp,%rbp
  802e09:	48 83 ec 30          	sub    $0x30,%rsp
  802e0d:	89 7d dc             	mov    %edi,-0x24(%rbp)
  802e10:	89 75 d8             	mov    %esi,-0x28(%rbp)


	void *addr;
	pte_t pte;

	addr = (void*) (uint64_t)(pn << PGSHIFT);
  802e13:	8b 45 d8             	mov    -0x28(%rbp),%eax
  802e16:	c1 e0 0c             	shl    $0xc,%eax
  802e19:	89 c0                	mov    %eax,%eax
  802e1b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	pte = uvpt[pn];
  802e1f:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  802e26:	01 00 00 
  802e29:	8b 55 d8             	mov    -0x28(%rbp),%edx
  802e2c:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  802e30:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	

	// if the page is just read-only or is library-shared, map it directly.
	if (!(pte & (PTE_W|PTE_COW)) || (pte & PTE_SHARE)) {
  802e34:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802e38:	25 02 08 00 00       	and    $0x802,%eax
  802e3d:	48 85 c0             	test   %rax,%rax
  802e40:	74 0e                	je     802e50 <duppage+0x4b>
  802e42:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802e46:	25 00 04 00 00       	and    $0x400,%eax
  802e4b:	48 85 c0             	test   %rax,%rax
  802e4e:	74 70                	je     802ec0 <duppage+0xbb>
		if ((r = sys_page_map(0, addr, envid, addr, pte & PTE_SYSCALL)) < 0)
  802e50:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802e54:	25 07 0e 00 00       	and    $0xe07,%eax
  802e59:	89 c6                	mov    %eax,%esi
  802e5b:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  802e5f:	8b 55 dc             	mov    -0x24(%rbp),%edx
  802e62:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802e66:	41 89 f0             	mov    %esi,%r8d
  802e69:	48 89 c6             	mov    %rax,%rsi
  802e6c:	bf 00 00 00 00       	mov    $0x0,%edi
  802e71:	48 b8 56 28 80 00 00 	movabs $0x802856,%rax
  802e78:	00 00 00 
  802e7b:	ff d0                	callq  *%rax
  802e7d:	89 45 ec             	mov    %eax,-0x14(%rbp)
  802e80:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  802e84:	79 30                	jns    802eb6 <duppage+0xb1>
			panic("sys_page_map: %e", r);
  802e86:	8b 45 ec             	mov    -0x14(%rbp),%eax
  802e89:	89 c1                	mov    %eax,%ecx
  802e8b:	48 ba 5e 13 82 00 00 	movabs $0x82135e,%rdx
  802e92:	00 00 00 
  802e95:	be 50 00 00 00       	mov    $0x50,%esi
  802e9a:	48 bf 11 13 82 00 00 	movabs $0x821311,%rdi
  802ea1:	00 00 00 
  802ea4:	b8 00 00 00 00       	mov    $0x0,%eax
  802ea9:	49 b8 e9 10 80 00 00 	movabs $0x8010e9,%r8
  802eb0:	00 00 00 
  802eb3:	41 ff d0             	callq  *%r8
		return 0;
  802eb6:	b8 00 00 00 00       	mov    $0x0,%eax
  802ebb:	e9 c4 00 00 00       	jmpq   802f84 <duppage+0x17f>
	// Even if we think the page is already copy-on-write in our
	// address space, we need to mark it copy-on-write again after
	// the first sys_page_map, just in case a page fault has caused
	// us to copy the page in the interim.

	if ((r = sys_page_map(0, addr, envid, addr, PTE_P|PTE_U|PTE_COW)) < 0)
  802ec0:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  802ec4:	8b 55 dc             	mov    -0x24(%rbp),%edx
  802ec7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802ecb:	41 b8 05 08 00 00    	mov    $0x805,%r8d
  802ed1:	48 89 c6             	mov    %rax,%rsi
  802ed4:	bf 00 00 00 00       	mov    $0x0,%edi
  802ed9:	48 b8 56 28 80 00 00 	movabs $0x802856,%rax
  802ee0:	00 00 00 
  802ee3:	ff d0                	callq  *%rax
  802ee5:	89 45 ec             	mov    %eax,-0x14(%rbp)
  802ee8:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  802eec:	79 30                	jns    802f1e <duppage+0x119>
		panic("sys_page_map: %e", r);
  802eee:	8b 45 ec             	mov    -0x14(%rbp),%eax
  802ef1:	89 c1                	mov    %eax,%ecx
  802ef3:	48 ba 5e 13 82 00 00 	movabs $0x82135e,%rdx
  802efa:	00 00 00 
  802efd:	be 64 00 00 00       	mov    $0x64,%esi
  802f02:	48 bf 11 13 82 00 00 	movabs $0x821311,%rdi
  802f09:	00 00 00 
  802f0c:	b8 00 00 00 00       	mov    $0x0,%eax
  802f11:	49 b8 e9 10 80 00 00 	movabs $0x8010e9,%r8
  802f18:	00 00 00 
  802f1b:	41 ff d0             	callq  *%r8
	if ((r = sys_page_map(0, addr, 0, addr, PTE_P|PTE_U|PTE_COW)) < 0)
  802f1e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  802f22:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802f26:	41 b8 05 08 00 00    	mov    $0x805,%r8d
  802f2c:	48 89 d1             	mov    %rdx,%rcx
  802f2f:	ba 00 00 00 00       	mov    $0x0,%edx
  802f34:	48 89 c6             	mov    %rax,%rsi
  802f37:	bf 00 00 00 00       	mov    $0x0,%edi
  802f3c:	48 b8 56 28 80 00 00 	movabs $0x802856,%rax
  802f43:	00 00 00 
  802f46:	ff d0                	callq  *%rax
  802f48:	89 45 ec             	mov    %eax,-0x14(%rbp)
  802f4b:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  802f4f:	79 30                	jns    802f81 <duppage+0x17c>
		panic("sys_page_map: %e", r);
  802f51:	8b 45 ec             	mov    -0x14(%rbp),%eax
  802f54:	89 c1                	mov    %eax,%ecx
  802f56:	48 ba 5e 13 82 00 00 	movabs $0x82135e,%rdx
  802f5d:	00 00 00 
  802f60:	be 66 00 00 00       	mov    $0x66,%esi
  802f65:	48 bf 11 13 82 00 00 	movabs $0x821311,%rdi
  802f6c:	00 00 00 
  802f6f:	b8 00 00 00 00       	mov    $0x0,%eax
  802f74:	49 b8 e9 10 80 00 00 	movabs $0x8010e9,%r8
  802f7b:	00 00 00 
  802f7e:	41 ff d0             	callq  *%r8
	return r;
  802f81:	8b 45 ec             	mov    -0x14(%rbp),%eax

}
  802f84:	c9                   	leaveq 
  802f85:	c3                   	retq   

0000000000802f86 <fork>:
//   Neither user exception stack should ever be marked copy-on-write,
//   so you must allocate a new page for the child's user exception stack.
//
envid_t
fork(void)
{
  802f86:	55                   	push   %rbp
  802f87:	48 89 e5             	mov    %rsp,%rbp
  802f8a:	48 83 ec 20          	sub    $0x20,%rsp

	envid_t envid;
	int pn, end_pn, r;

	set_pgfault_handler(pgfault);
  802f8e:	48 bf e6 2b 80 00 00 	movabs $0x802be6,%rdi
  802f95:	00 00 00 
  802f98:	48 b8 77 5b 80 00 00 	movabs $0x805b77,%rax
  802f9f:	00 00 00 
  802fa2:	ff d0                	callq  *%rax
// This must be inlined.  Exercise for reader: why?
static __inline envid_t __attribute__((always_inline))
sys_exofork(void)
{
	envid_t ret;
	__asm __volatile("int %2"
  802fa4:	b8 07 00 00 00       	mov    $0x7,%eax
  802fa9:	cd 30                	int    $0x30
  802fab:	89 45 ec             	mov    %eax,-0x14(%rbp)
		: "=a" (ret)
		: "a" (SYS_exofork),
		  "i" (T_SYSCALL)
	);
	return ret;
  802fae:	8b 45 ec             	mov    -0x14(%rbp),%eax

	// Create a child.
	envid = sys_exofork();
  802fb1:	89 45 f8             	mov    %eax,-0x8(%rbp)
	if (envid < 0)
  802fb4:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  802fb8:	79 08                	jns    802fc2 <fork+0x3c>
		return envid;
  802fba:	8b 45 f8             	mov    -0x8(%rbp),%eax
  802fbd:	e9 09 02 00 00       	jmpq   8031cb <fork+0x245>
	if (envid == 0) {
  802fc2:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  802fc6:	75 3e                	jne    803006 <fork+0x80>
		thisenv = &envs[ENVX(sys_getenvid())];
  802fc8:	48 b8 8a 27 80 00 00 	movabs $0x80278a,%rax
  802fcf:	00 00 00 
  802fd2:	ff d0                	callq  *%rax
  802fd4:	25 ff 03 00 00       	and    $0x3ff,%eax
  802fd9:	48 98                	cltq   
  802fdb:	48 69 d0 68 01 00 00 	imul   $0x168,%rax,%rdx
  802fe2:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  802fe9:	00 00 00 
  802fec:	48 01 c2             	add    %rax,%rdx
  802fef:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  802ff6:	00 00 00 
  802ff9:	48 89 10             	mov    %rdx,(%rax)
		return 0;
  802ffc:	b8 00 00 00 00       	mov    $0x0,%eax
  803001:	e9 c5 01 00 00       	jmpq   8031cb <fork+0x245>
	}

	// Copy the address space.
	for (pn = 0; pn < PGNUM(UTOP); ) {
  803006:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80300d:	e9 a4 00 00 00       	jmpq   8030b6 <fork+0x130>
		if (!(uvpde[pn >> 18] & PTE_P && uvpd[pn >> 9] & PTE_P)) {
  803012:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803015:	c1 f8 12             	sar    $0x12,%eax
  803018:	89 c2                	mov    %eax,%edx
  80301a:	48 b8 00 00 40 80 00 	movabs $0x10080400000,%rax
  803021:	01 00 00 
  803024:	48 63 d2             	movslq %edx,%rdx
  803027:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80302b:	83 e0 01             	and    $0x1,%eax
  80302e:	48 85 c0             	test   %rax,%rax
  803031:	74 21                	je     803054 <fork+0xce>
  803033:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803036:	c1 f8 09             	sar    $0x9,%eax
  803039:	89 c2                	mov    %eax,%edx
  80303b:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  803042:	01 00 00 
  803045:	48 63 d2             	movslq %edx,%rdx
  803048:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80304c:	83 e0 01             	and    $0x1,%eax
  80304f:	48 85 c0             	test   %rax,%rax
  803052:	75 09                	jne    80305d <fork+0xd7>
			pn += NPTENTRIES;
  803054:	81 45 fc 00 02 00 00 	addl   $0x200,-0x4(%rbp)
			continue;
  80305b:	eb 59                	jmp    8030b6 <fork+0x130>
		}
		for (end_pn = pn + NPTENTRIES; pn < end_pn; pn++) {
  80305d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803060:	05 00 02 00 00       	add    $0x200,%eax
  803065:	89 45 f4             	mov    %eax,-0xc(%rbp)
  803068:	eb 44                	jmp    8030ae <fork+0x128>
			if ((uvpt[pn] & (PTE_P|PTE_U)) != (PTE_P|PTE_U))
  80306a:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  803071:	01 00 00 
  803074:	8b 55 fc             	mov    -0x4(%rbp),%edx
  803077:	48 63 d2             	movslq %edx,%rdx
  80307a:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80307e:	83 e0 05             	and    $0x5,%eax
  803081:	48 83 f8 05          	cmp    $0x5,%rax
  803085:	74 02                	je     803089 <fork+0x103>
				continue;
  803087:	eb 21                	jmp    8030aa <fork+0x124>
			if (pn == PPN(UXSTACKTOP - 1))
  803089:	81 7d fc ff f7 0e 00 	cmpl   $0xef7ff,-0x4(%rbp)
  803090:	75 02                	jne    803094 <fork+0x10e>
				continue;
  803092:	eb 16                	jmp    8030aa <fork+0x124>
			duppage(envid, pn);
  803094:	8b 55 fc             	mov    -0x4(%rbp),%edx
  803097:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80309a:	89 d6                	mov    %edx,%esi
  80309c:	89 c7                	mov    %eax,%edi
  80309e:	48 b8 05 2e 80 00 00 	movabs $0x802e05,%rax
  8030a5:	00 00 00 
  8030a8:	ff d0                	callq  *%rax
	for (pn = 0; pn < PGNUM(UTOP); ) {
		if (!(uvpde[pn >> 18] & PTE_P && uvpd[pn >> 9] & PTE_P)) {
			pn += NPTENTRIES;
			continue;
		}
		for (end_pn = pn + NPTENTRIES; pn < end_pn; pn++) {
  8030aa:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8030ae:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8030b1:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  8030b4:	7c b4                	jl     80306a <fork+0xe4>
		thisenv = &envs[ENVX(sys_getenvid())];
		return 0;
	}

	// Copy the address space.
	for (pn = 0; pn < PGNUM(UTOP); ) {
  8030b6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8030b9:	3d ff 07 00 08       	cmp    $0x80007ff,%eax
  8030be:	0f 86 4e ff ff ff    	jbe    803012 <fork+0x8c>
			duppage(envid, pn);
		}
	}

	// The child needs to start out with a valid exception stack.
	if ((r = sys_page_alloc(envid, (void*) (UXSTACKTOP - PGSIZE), PTE_P|PTE_U|PTE_W)) < 0)
  8030c4:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8030c7:	ba 07 00 00 00       	mov    $0x7,%edx
  8030cc:	be 00 f0 7f ef       	mov    $0xef7ff000,%esi
  8030d1:	89 c7                	mov    %eax,%edi
  8030d3:	48 b8 06 28 80 00 00 	movabs $0x802806,%rax
  8030da:	00 00 00 
  8030dd:	ff d0                	callq  *%rax
  8030df:	89 45 f0             	mov    %eax,-0x10(%rbp)
  8030e2:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  8030e6:	79 30                	jns    803118 <fork+0x192>
		panic("allocating exception stack: %e", r);
  8030e8:	8b 45 f0             	mov    -0x10(%rbp),%eax
  8030eb:	89 c1                	mov    %eax,%ecx
  8030ed:	48 ba 88 13 82 00 00 	movabs $0x821388,%rdx
  8030f4:	00 00 00 
  8030f7:	be 9e 00 00 00       	mov    $0x9e,%esi
  8030fc:	48 bf 11 13 82 00 00 	movabs $0x821311,%rdi
  803103:	00 00 00 
  803106:	b8 00 00 00 00       	mov    $0x0,%eax
  80310b:	49 b8 e9 10 80 00 00 	movabs $0x8010e9,%r8
  803112:	00 00 00 
  803115:	41 ff d0             	callq  *%r8

	// Copy the user-mode exception entrypoint.
	if ((r = sys_env_set_pgfault_upcall(envid, thisenv->env_pgfault_upcall)) < 0)
  803118:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  80311f:	00 00 00 
  803122:	48 8b 00             	mov    (%rax),%rax
  803125:	48 8b 90 f0 00 00 00 	mov    0xf0(%rax),%rdx
  80312c:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80312f:	48 89 d6             	mov    %rdx,%rsi
  803132:	89 c7                	mov    %eax,%edi
  803134:	48 b8 90 29 80 00 00 	movabs $0x802990,%rax
  80313b:	00 00 00 
  80313e:	ff d0                	callq  *%rax
  803140:	89 45 f0             	mov    %eax,-0x10(%rbp)
  803143:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  803147:	79 30                	jns    803179 <fork+0x1f3>
		panic("sys_env_set_pgfault_upcall: %e", r);
  803149:	8b 45 f0             	mov    -0x10(%rbp),%eax
  80314c:	89 c1                	mov    %eax,%ecx
  80314e:	48 ba a8 13 82 00 00 	movabs $0x8213a8,%rdx
  803155:	00 00 00 
  803158:	be a2 00 00 00       	mov    $0xa2,%esi
  80315d:	48 bf 11 13 82 00 00 	movabs $0x821311,%rdi
  803164:	00 00 00 
  803167:	b8 00 00 00 00       	mov    $0x0,%eax
  80316c:	49 b8 e9 10 80 00 00 	movabs $0x8010e9,%r8
  803173:	00 00 00 
  803176:	41 ff d0             	callq  *%r8


	// Okay, the child is ready for life on its own.
	if ((r = sys_env_set_status(envid, ENV_RUNNABLE)) < 0)
  803179:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80317c:	be 02 00 00 00       	mov    $0x2,%esi
  803181:	89 c7                	mov    %eax,%edi
  803183:	48 b8 fb 28 80 00 00 	movabs $0x8028fb,%rax
  80318a:	00 00 00 
  80318d:	ff d0                	callq  *%rax
  80318f:	89 45 f0             	mov    %eax,-0x10(%rbp)
  803192:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  803196:	79 30                	jns    8031c8 <fork+0x242>
		panic("sys_env_set_status: %e", r);
  803198:	8b 45 f0             	mov    -0x10(%rbp),%eax
  80319b:	89 c1                	mov    %eax,%ecx
  80319d:	48 ba c7 13 82 00 00 	movabs $0x8213c7,%rdx
  8031a4:	00 00 00 
  8031a7:	be a7 00 00 00       	mov    $0xa7,%esi
  8031ac:	48 bf 11 13 82 00 00 	movabs $0x821311,%rdi
  8031b3:	00 00 00 
  8031b6:	b8 00 00 00 00       	mov    $0x0,%eax
  8031bb:	49 b8 e9 10 80 00 00 	movabs $0x8010e9,%r8
  8031c2:	00 00 00 
  8031c5:	41 ff d0             	callq  *%r8

	return envid;
  8031c8:	8b 45 f8             	mov    -0x8(%rbp),%eax

}
  8031cb:	c9                   	leaveq 
  8031cc:	c3                   	retq   

00000000008031cd <sfork>:

// Challenge!
int
sfork(void)
{
  8031cd:	55                   	push   %rbp
  8031ce:	48 89 e5             	mov    %rsp,%rbp
	panic("sfork not implemented");
  8031d1:	48 ba de 13 82 00 00 	movabs $0x8213de,%rdx
  8031d8:	00 00 00 
  8031db:	be b1 00 00 00       	mov    $0xb1,%esi
  8031e0:	48 bf 11 13 82 00 00 	movabs $0x821311,%rdi
  8031e7:	00 00 00 
  8031ea:	b8 00 00 00 00       	mov    $0x0,%eax
  8031ef:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  8031f6:	00 00 00 
  8031f9:	ff d1                	callq  *%rcx

00000000008031fb <ipc_recv>:
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value, since that's
//   a perfectly valid place to map a page.)
int32_t
ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
{
  8031fb:	55                   	push   %rbp
  8031fc:	48 89 e5             	mov    %rsp,%rbp
  8031ff:	48 83 ec 30          	sub    $0x30,%rsp
  803203:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  803207:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80320b:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)

	int r;

	if (!pg)
  80320f:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  803214:	75 0e                	jne    803224 <ipc_recv+0x29>
		pg = (void*) UTOP;
  803216:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  80321d:	00 00 00 
  803220:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if ((r = sys_ipc_recv(pg)) < 0) {
  803224:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  803228:	48 89 c7             	mov    %rax,%rdi
  80322b:	48 b8 2f 2a 80 00 00 	movabs $0x802a2f,%rax
  803232:	00 00 00 
  803235:	ff d0                	callq  *%rax
  803237:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80323a:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80323e:	79 27                	jns    803267 <ipc_recv+0x6c>
		if (from_env_store)
  803240:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  803245:	74 0a                	je     803251 <ipc_recv+0x56>
			*from_env_store = 0;
  803247:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80324b:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
		if (perm_store)
  803251:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  803256:	74 0a                	je     803262 <ipc_recv+0x67>
			*perm_store = 0;
  803258:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80325c:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
		return r;
  803262:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803265:	eb 53                	jmp    8032ba <ipc_recv+0xbf>
	}
	if (from_env_store)
  803267:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80326c:	74 19                	je     803287 <ipc_recv+0x8c>
		*from_env_store = thisenv->env_ipc_from;
  80326e:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  803275:	00 00 00 
  803278:	48 8b 00             	mov    (%rax),%rax
  80327b:	8b 90 0c 01 00 00    	mov    0x10c(%rax),%edx
  803281:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803285:	89 10                	mov    %edx,(%rax)
	if (perm_store)
  803287:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80328c:	74 19                	je     8032a7 <ipc_recv+0xac>
		*perm_store = thisenv->env_ipc_perm;
  80328e:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  803295:	00 00 00 
  803298:	48 8b 00             	mov    (%rax),%rax
  80329b:	8b 90 10 01 00 00    	mov    0x110(%rax),%edx
  8032a1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8032a5:	89 10                	mov    %edx,(%rax)
	return thisenv->env_ipc_value;
  8032a7:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  8032ae:	00 00 00 
  8032b1:	48 8b 00             	mov    (%rax),%rax
  8032b4:	8b 80 08 01 00 00    	mov    0x108(%rax),%eax

}
  8032ba:	c9                   	leaveq 
  8032bb:	c3                   	retq   

00000000008032bc <ipc_send>:
//   Use sys_yield() to be CPU-friendly.
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value.)
void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
  8032bc:	55                   	push   %rbp
  8032bd:	48 89 e5             	mov    %rsp,%rbp
  8032c0:	48 83 ec 30          	sub    $0x30,%rsp
  8032c4:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8032c7:	89 75 e8             	mov    %esi,-0x18(%rbp)
  8032ca:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  8032ce:	89 4d dc             	mov    %ecx,-0x24(%rbp)

	int r;

	if (!pg)
  8032d1:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8032d6:	75 10                	jne    8032e8 <ipc_send+0x2c>
		pg = (void*) UTOP;
  8032d8:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  8032df:	00 00 00 
  8032e2:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	while ((r = sys_ipc_try_send(to_env, val, pg, perm)) == -E_IPC_NOT_RECV) {
  8032e6:	eb 0e                	jmp    8032f6 <ipc_send+0x3a>
  8032e8:	eb 0c                	jmp    8032f6 <ipc_send+0x3a>
		sys_yield();
  8032ea:	48 b8 c8 27 80 00 00 	movabs $0x8027c8,%rax
  8032f1:	00 00 00 
  8032f4:	ff d0                	callq  *%rax

	int r;

	if (!pg)
		pg = (void*) UTOP;
	while ((r = sys_ipc_try_send(to_env, val, pg, perm)) == -E_IPC_NOT_RECV) {
  8032f6:	8b 75 e8             	mov    -0x18(%rbp),%esi
  8032f9:	8b 4d dc             	mov    -0x24(%rbp),%ecx
  8032fc:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  803300:	8b 45 ec             	mov    -0x14(%rbp),%eax
  803303:	89 c7                	mov    %eax,%edi
  803305:	48 b8 da 29 80 00 00 	movabs $0x8029da,%rax
  80330c:	00 00 00 
  80330f:	ff d0                	callq  *%rax
  803311:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803314:	83 7d fc f8          	cmpl   $0xfffffff8,-0x4(%rbp)
  803318:	74 d0                	je     8032ea <ipc_send+0x2e>
		sys_yield();
	}
	if (r < 0)
  80331a:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80331e:	79 30                	jns    803350 <ipc_send+0x94>
		panic("error in ipc_send: %e", r);
  803320:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803323:	89 c1                	mov    %eax,%ecx
  803325:	48 ba f4 13 82 00 00 	movabs $0x8213f4,%rdx
  80332c:	00 00 00 
  80332f:	be 47 00 00 00       	mov    $0x47,%esi
  803334:	48 bf 0a 14 82 00 00 	movabs $0x82140a,%rdi
  80333b:	00 00 00 
  80333e:	b8 00 00 00 00       	mov    $0x0,%eax
  803343:	49 b8 e9 10 80 00 00 	movabs $0x8010e9,%r8
  80334a:	00 00 00 
  80334d:	41 ff d0             	callq  *%r8

}
  803350:	c9                   	leaveq 
  803351:	c3                   	retq   

0000000000803352 <ipc_host_recv>:
#ifdef VMM_GUEST

// Access to host IPC interface through VMCALL.
// Should behave similarly to ipc_recv, except replacing the system call with a vmcall.
int32_t
ipc_host_recv(void *pg) {
  803352:	55                   	push   %rbp
  803353:	48 89 e5             	mov    %rsp,%rbp
  803356:	53                   	push   %rbx
  803357:	48 83 ec 28          	sub    $0x28,%rsp
  80335b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)

	/* FIXME: This should be SOL 8 */
	int r = 0, val = 0;
  80335f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  803366:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)

	if (!pg)
  80336d:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  803372:	75 0e                	jne    803382 <ipc_host_recv+0x30>
		pg = (void*) UTOP;
  803374:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  80337b:	00 00 00 
  80337e:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	sys_page_alloc(0, pg, PTE_U|PTE_P|PTE_W);
  803382:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  803386:	ba 07 00 00 00       	mov    $0x7,%edx
  80338b:	48 89 c6             	mov    %rax,%rsi
  80338e:	bf 00 00 00 00       	mov    $0x0,%edi
  803393:	48 b8 06 28 80 00 00 	movabs $0x802806,%rax
  80339a:	00 00 00 
  80339d:	ff d0                	callq  *%rax
	physaddr_t pa = PTE_ADDR(uvpt[PGNUM(pg)]);
  80339f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8033a3:	48 c1 e8 0c          	shr    $0xc,%rax
  8033a7:	48 89 c2             	mov    %rax,%rdx
  8033aa:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  8033b1:	01 00 00 
  8033b4:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8033b8:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8033be:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	asm("vmcall": "=a"(r), "=S"(val)  : "0"(VMX_VMCALL_IPCRECV), "b"(pa));
  8033c2:	b8 03 00 00 00       	mov    $0x3,%eax
  8033c7:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8033cb:	48 89 d3             	mov    %rdx,%rbx
  8033ce:	0f 01 c1             	vmcall 
  8033d1:	89 f2                	mov    %esi,%edx
  8033d3:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8033d6:	89 55 e8             	mov    %edx,-0x18(%rbp)
	/* cprintf("Returned IPC response from host: %d %d\n", r, -val);*/
	if (r < 0) {
  8033d9:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  8033dd:	79 05                	jns    8033e4 <ipc_host_recv+0x92>
		return r;
  8033df:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8033e2:	eb 03                	jmp    8033e7 <ipc_host_recv+0x95>
	}
	return val;
  8033e4:	8b 45 e8             	mov    -0x18(%rbp),%eax

}
  8033e7:	48 83 c4 28          	add    $0x28,%rsp
  8033eb:	5b                   	pop    %rbx
  8033ec:	5d                   	pop    %rbp
  8033ed:	c3                   	retq   

00000000008033ee <ipc_host_send>:
// Access to host IPC interface through VMCALL.
// Should behave similarly to ipc_send, except replacing the system call with a vmcall.
// This function should also convert pg from guest virtual to guest physical for the IPC call
void
ipc_host_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
  8033ee:	55                   	push   %rbp
  8033ef:	48 89 e5             	mov    %rsp,%rbp
  8033f2:	53                   	push   %rbx
  8033f3:	48 83 ec 38          	sub    $0x38,%rsp
  8033f7:	89 7d dc             	mov    %edi,-0x24(%rbp)
  8033fa:	89 75 d8             	mov    %esi,-0x28(%rbp)
  8033fd:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  803401:	89 4d cc             	mov    %ecx,-0x34(%rbp)

	/* FIXME: This should be SOL 8 */
	int r = 0;
  803404:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)

	if (!pg)
  80340b:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  803410:	75 0e                	jne    803420 <ipc_host_send+0x32>
		pg = (void*) UTOP;
  803412:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  803419:	00 00 00 
  80341c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	// Convert pg from guest virtual address to guest physical address.
	physaddr_t pa = PTE_ADDR(uvpt[PGNUM(pg)]);
  803420:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  803424:	48 c1 e8 0c          	shr    $0xc,%rax
  803428:	48 89 c2             	mov    %rax,%rdx
  80342b:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  803432:	01 00 00 
  803435:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  803439:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80343f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	asm("vmcall": "=a"(r): "0"(VMX_VMCALL_IPCSEND), "b"(to_env), "c"(val), 
  803443:	b8 02 00 00 00       	mov    $0x2,%eax
  803448:	8b 7d dc             	mov    -0x24(%rbp),%edi
  80344b:	8b 4d d8             	mov    -0x28(%rbp),%ecx
  80344e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  803452:	8b 75 cc             	mov    -0x34(%rbp),%esi
  803455:	89 fb                	mov    %edi,%ebx
  803457:	0f 01 c1             	vmcall 
  80345a:	89 45 ec             	mov    %eax,-0x14(%rbp)
            "d"(pa), "S"(perm));
	while(r == -E_IPC_NOT_RECV) {
  80345d:	eb 26                	jmp    803485 <ipc_host_send+0x97>
		sys_yield();
  80345f:	48 b8 c8 27 80 00 00 	movabs $0x8027c8,%rax
  803466:	00 00 00 
  803469:	ff d0                	callq  *%rax
		asm("vmcall": "=a"(r): "0"(VMX_VMCALL_IPCSEND), "b"(to_env), "c"(val), 
  80346b:	b8 02 00 00 00       	mov    $0x2,%eax
  803470:	8b 7d dc             	mov    -0x24(%rbp),%edi
  803473:	8b 4d d8             	mov    -0x28(%rbp),%ecx
  803476:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80347a:	8b 75 cc             	mov    -0x34(%rbp),%esi
  80347d:	89 fb                	mov    %edi,%ebx
  80347f:	0f 01 c1             	vmcall 
  803482:	89 45 ec             	mov    %eax,-0x14(%rbp)
		pg = (void*) UTOP;
	// Convert pg from guest virtual address to guest physical address.
	physaddr_t pa = PTE_ADDR(uvpt[PGNUM(pg)]);
	asm("vmcall": "=a"(r): "0"(VMX_VMCALL_IPCSEND), "b"(to_env), "c"(val), 
            "d"(pa), "S"(perm));
	while(r == -E_IPC_NOT_RECV) {
  803485:	83 7d ec f8          	cmpl   $0xfffffff8,-0x14(%rbp)
  803489:	74 d4                	je     80345f <ipc_host_send+0x71>
		sys_yield();
		asm("vmcall": "=a"(r): "0"(VMX_VMCALL_IPCSEND), "b"(to_env), "c"(val), 
		    "d"(pa), "S"(perm));
	}
	if (r < 0)
  80348b:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  80348f:	79 30                	jns    8034c1 <ipc_host_send+0xd3>
		panic("error in ipc_send: %e", r);
  803491:	8b 45 ec             	mov    -0x14(%rbp),%eax
  803494:	89 c1                	mov    %eax,%ecx
  803496:	48 ba f4 13 82 00 00 	movabs $0x8213f4,%rdx
  80349d:	00 00 00 
  8034a0:	be 79 00 00 00       	mov    $0x79,%esi
  8034a5:	48 bf 0a 14 82 00 00 	movabs $0x82140a,%rdi
  8034ac:	00 00 00 
  8034af:	b8 00 00 00 00       	mov    $0x0,%eax
  8034b4:	49 b8 e9 10 80 00 00 	movabs $0x8010e9,%r8
  8034bb:	00 00 00 
  8034be:	41 ff d0             	callq  *%r8

}
  8034c1:	48 83 c4 38          	add    $0x38,%rsp
  8034c5:	5b                   	pop    %rbx
  8034c6:	5d                   	pop    %rbp
  8034c7:	c3                   	retq   

00000000008034c8 <ipc_find_env>:
// Find the first environment of the given type.  We'll use this to
// find special environments.
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
  8034c8:	55                   	push   %rbp
  8034c9:	48 89 e5             	mov    %rsp,%rbp
  8034cc:	48 83 ec 14          	sub    $0x14,%rsp
  8034d0:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int i;
	for (i = 0; i < NENV; i++) {
  8034d3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8034da:	eb 4e                	jmp    80352a <ipc_find_env+0x62>
		if (envs[i].env_type == type)
  8034dc:	48 ba 00 00 80 00 80 	movabs $0x8000800000,%rdx
  8034e3:	00 00 00 
  8034e6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8034e9:	48 98                	cltq   
  8034eb:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  8034f2:	48 01 d0             	add    %rdx,%rax
  8034f5:	48 05 d0 00 00 00    	add    $0xd0,%rax
  8034fb:	8b 00                	mov    (%rax),%eax
  8034fd:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  803500:	75 24                	jne    803526 <ipc_find_env+0x5e>
			return envs[i].env_id;
  803502:	48 ba 00 00 80 00 80 	movabs $0x8000800000,%rdx
  803509:	00 00 00 
  80350c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80350f:	48 98                	cltq   
  803511:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  803518:	48 01 d0             	add    %rdx,%rax
  80351b:	48 05 c0 00 00 00    	add    $0xc0,%rax
  803521:	8b 40 08             	mov    0x8(%rax),%eax
  803524:	eb 12                	jmp    803538 <ipc_find_env+0x70>
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
	int i;
	for (i = 0; i < NENV; i++) {
  803526:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80352a:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  803531:	7e a9                	jle    8034dc <ipc_find_env+0x14>
		if (envs[i].env_type == type)
			return envs[i].env_id;
	}
	return 0;
  803533:	b8 00 00 00 00       	mov    $0x0,%eax
}
  803538:	c9                   	leaveq 
  803539:	c3                   	retq   

000000000080353a <fd2num>:
// File descriptor manipulators
// --------------------------------------------------------------

uint64_t
fd2num(struct Fd *fd)
{
  80353a:	55                   	push   %rbp
  80353b:	48 89 e5             	mov    %rsp,%rbp
  80353e:	48 83 ec 08          	sub    $0x8,%rsp
  803542:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  803546:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80354a:	48 b8 00 00 00 30 ff 	movabs $0xffffffff30000000,%rax
  803551:	ff ff ff 
  803554:	48 01 d0             	add    %rdx,%rax
  803557:	48 c1 e8 0c          	shr    $0xc,%rax
}
  80355b:	c9                   	leaveq 
  80355c:	c3                   	retq   

000000000080355d <fd2data>:

char*
fd2data(struct Fd *fd)
{
  80355d:	55                   	push   %rbp
  80355e:	48 89 e5             	mov    %rsp,%rbp
  803561:	48 83 ec 08          	sub    $0x8,%rsp
  803565:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return INDEX2DATA(fd2num(fd));
  803569:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80356d:	48 89 c7             	mov    %rax,%rdi
  803570:	48 b8 3a 35 80 00 00 	movabs $0x80353a,%rax
  803577:	00 00 00 
  80357a:	ff d0                	callq  *%rax
  80357c:	48 05 20 00 0d 00    	add    $0xd0020,%rax
  803582:	48 c1 e0 0c          	shl    $0xc,%rax
}
  803586:	c9                   	leaveq 
  803587:	c3                   	retq   

0000000000803588 <fd_alloc>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_MAX_FD: no more file descriptors
// On error, *fd_store is set to 0.
int
fd_alloc(struct Fd **fd_store)
{
  803588:	55                   	push   %rbp
  803589:	48 89 e5             	mov    %rsp,%rbp
  80358c:	48 83 ec 18          	sub    $0x18,%rsp
  803590:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
  803594:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80359b:	eb 6b                	jmp    803608 <fd_alloc+0x80>
		fd = INDEX2FD(i);
  80359d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8035a0:	48 98                	cltq   
  8035a2:	48 05 00 00 0d 00    	add    $0xd0000,%rax
  8035a8:	48 c1 e0 0c          	shl    $0xc,%rax
  8035ac:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		if ((uvpd[VPD(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
  8035b0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8035b4:	48 c1 e8 15          	shr    $0x15,%rax
  8035b8:	48 89 c2             	mov    %rax,%rdx
  8035bb:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  8035c2:	01 00 00 
  8035c5:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8035c9:	83 e0 01             	and    $0x1,%eax
  8035cc:	48 85 c0             	test   %rax,%rax
  8035cf:	74 21                	je     8035f2 <fd_alloc+0x6a>
  8035d1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8035d5:	48 c1 e8 0c          	shr    $0xc,%rax
  8035d9:	48 89 c2             	mov    %rax,%rdx
  8035dc:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  8035e3:	01 00 00 
  8035e6:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8035ea:	83 e0 01             	and    $0x1,%eax
  8035ed:	48 85 c0             	test   %rax,%rax
  8035f0:	75 12                	jne    803604 <fd_alloc+0x7c>
			*fd_store = fd;
  8035f2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8035f6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8035fa:	48 89 10             	mov    %rdx,(%rax)
			return 0;
  8035fd:	b8 00 00 00 00       	mov    $0x0,%eax
  803602:	eb 1a                	jmp    80361e <fd_alloc+0x96>
fd_alloc(struct Fd **fd_store)
{
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
  803604:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  803608:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  80360c:	7e 8f                	jle    80359d <fd_alloc+0x15>
		if ((uvpd[VPD(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
			*fd_store = fd;
			return 0;
		}
	}
	*fd_store = 0;
  80360e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803612:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	return -E_MAX_OPEN;
  803619:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
}
  80361e:	c9                   	leaveq 
  80361f:	c3                   	retq   

0000000000803620 <fd_lookup>:
// Returns 0 on success (the page is in range and mapped), < 0 on error.
// Errors are:
//	-E_INVAL: fdnum was either not in range or not mapped.
int
fd_lookup(int fdnum, struct Fd **fd_store)
{
  803620:	55                   	push   %rbp
  803621:	48 89 e5             	mov    %rsp,%rbp
  803624:	48 83 ec 20          	sub    $0x20,%rsp
  803628:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80362b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
  80362f:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  803633:	78 06                	js     80363b <fd_lookup+0x1b>
  803635:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%rbp)
  803639:	7e 07                	jle    803642 <fd_lookup+0x22>
		if (debug)
			cprintf("[%08x] bad fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
  80363b:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  803640:	eb 6c                	jmp    8036ae <fd_lookup+0x8e>
	}
	fd = INDEX2FD(fdnum);
  803642:	8b 45 ec             	mov    -0x14(%rbp),%eax
  803645:	48 98                	cltq   
  803647:	48 05 00 00 0d 00    	add    $0xd0000,%rax
  80364d:	48 c1 e0 0c          	shl    $0xc,%rax
  803651:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (!(uvpd[VPD(fd)] & PTE_P) || !(uvpt[PGNUM(fd)] & PTE_P)) {
  803655:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  803659:	48 c1 e8 15          	shr    $0x15,%rax
  80365d:	48 89 c2             	mov    %rax,%rdx
  803660:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  803667:	01 00 00 
  80366a:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80366e:	83 e0 01             	and    $0x1,%eax
  803671:	48 85 c0             	test   %rax,%rax
  803674:	74 21                	je     803697 <fd_lookup+0x77>
  803676:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80367a:	48 c1 e8 0c          	shr    $0xc,%rax
  80367e:	48 89 c2             	mov    %rax,%rdx
  803681:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  803688:	01 00 00 
  80368b:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80368f:	83 e0 01             	and    $0x1,%eax
  803692:	48 85 c0             	test   %rax,%rax
  803695:	75 07                	jne    80369e <fd_lookup+0x7e>
		if (debug)
			cprintf("[%08x] closed fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
  803697:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80369c:	eb 10                	jmp    8036ae <fd_lookup+0x8e>
	}
	*fd_store = fd;
  80369e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8036a2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8036a6:	48 89 10             	mov    %rdx,(%rax)
	return 0;
  8036a9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8036ae:	c9                   	leaveq 
  8036af:	c3                   	retq   

00000000008036b0 <fd_close>:
// If 'must_exist' is 1, then fd_close returns -E_INVAL when passed a
// closed or nonexistent file descriptor.
// Returns 0 on success, < 0 on error.
int
fd_close(struct Fd *fd, bool must_exist)
{
  8036b0:	55                   	push   %rbp
  8036b1:	48 89 e5             	mov    %rsp,%rbp
  8036b4:	48 83 ec 30          	sub    $0x30,%rsp
  8036b8:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8036bc:	89 f0                	mov    %esi,%eax
  8036be:	88 45 d4             	mov    %al,-0x2c(%rbp)
	struct Fd *fd2;
	struct Dev *dev;
	int r;
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  8036c1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8036c5:	48 89 c7             	mov    %rax,%rdi
  8036c8:	48 b8 3a 35 80 00 00 	movabs $0x80353a,%rax
  8036cf:	00 00 00 
  8036d2:	ff d0                	callq  *%rax
  8036d4:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  8036d8:	48 89 d6             	mov    %rdx,%rsi
  8036db:	89 c7                	mov    %eax,%edi
  8036dd:	48 b8 20 36 80 00 00 	movabs $0x803620,%rax
  8036e4:	00 00 00 
  8036e7:	ff d0                	callq  *%rax
  8036e9:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8036ec:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8036f0:	78 0a                	js     8036fc <fd_close+0x4c>
	    || fd != fd2)
  8036f2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8036f6:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  8036fa:	74 12                	je     80370e <fd_close+0x5e>
		return (must_exist ? r : 0);
  8036fc:	80 7d d4 00          	cmpb   $0x0,-0x2c(%rbp)
  803700:	74 05                	je     803707 <fd_close+0x57>
  803702:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803705:	eb 05                	jmp    80370c <fd_close+0x5c>
  803707:	b8 00 00 00 00       	mov    $0x0,%eax
  80370c:	eb 69                	jmp    803777 <fd_close+0xc7>
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
  80370e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  803712:	8b 00                	mov    (%rax),%eax
  803714:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  803718:	48 89 d6             	mov    %rdx,%rsi
  80371b:	89 c7                	mov    %eax,%edi
  80371d:	48 b8 79 37 80 00 00 	movabs $0x803779,%rax
  803724:	00 00 00 
  803727:	ff d0                	callq  *%rax
  803729:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80372c:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803730:	78 2a                	js     80375c <fd_close+0xac>
		if (dev->dev_close)
  803732:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803736:	48 8b 40 20          	mov    0x20(%rax),%rax
  80373a:	48 85 c0             	test   %rax,%rax
  80373d:	74 16                	je     803755 <fd_close+0xa5>
			r = (*dev->dev_close)(fd);
  80373f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803743:	48 8b 40 20          	mov    0x20(%rax),%rax
  803747:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80374b:	48 89 d7             	mov    %rdx,%rdi
  80374e:	ff d0                	callq  *%rax
  803750:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803753:	eb 07                	jmp    80375c <fd_close+0xac>
		else
			r = 0;
  803755:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	}
	// Make sure fd is unmapped.  Might be a no-op if
	// (*dev->dev_close)(fd) already unmapped it.
	(void) sys_page_unmap(0, fd);
  80375c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  803760:	48 89 c6             	mov    %rax,%rsi
  803763:	bf 00 00 00 00       	mov    $0x0,%edi
  803768:	48 b8 b1 28 80 00 00 	movabs $0x8028b1,%rax
  80376f:	00 00 00 
  803772:	ff d0                	callq  *%rax
	return r;
  803774:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  803777:	c9                   	leaveq 
  803778:	c3                   	retq   

0000000000803779 <dev_lookup>:
	0
};

int
dev_lookup(int dev_id, struct Dev **dev)
{
  803779:	55                   	push   %rbp
  80377a:	48 89 e5             	mov    %rsp,%rbp
  80377d:	48 83 ec 20          	sub    $0x20,%rsp
  803781:	89 7d ec             	mov    %edi,-0x14(%rbp)
  803784:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int i;
	for (i = 0; devtab[i]; i++)
  803788:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80378f:	eb 41                	jmp    8037d2 <dev_lookup+0x59>
		if (devtab[i]->dev_id == dev_id) {
  803791:	48 b8 20 80 82 00 00 	movabs $0x828020,%rax
  803798:	00 00 00 
  80379b:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80379e:	48 63 d2             	movslq %edx,%rdx
  8037a1:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8037a5:	8b 00                	mov    (%rax),%eax
  8037a7:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8037aa:	75 22                	jne    8037ce <dev_lookup+0x55>
			*dev = devtab[i];
  8037ac:	48 b8 20 80 82 00 00 	movabs $0x828020,%rax
  8037b3:	00 00 00 
  8037b6:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8037b9:	48 63 d2             	movslq %edx,%rdx
  8037bc:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  8037c0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8037c4:	48 89 10             	mov    %rdx,(%rax)
			return 0;
  8037c7:	b8 00 00 00 00       	mov    $0x0,%eax
  8037cc:	eb 60                	jmp    80382e <dev_lookup+0xb5>

int
dev_lookup(int dev_id, struct Dev **dev)
{
	int i;
	for (i = 0; devtab[i]; i++)
  8037ce:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8037d2:	48 b8 20 80 82 00 00 	movabs $0x828020,%rax
  8037d9:	00 00 00 
  8037dc:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8037df:	48 63 d2             	movslq %edx,%rdx
  8037e2:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8037e6:	48 85 c0             	test   %rax,%rax
  8037e9:	75 a6                	jne    803791 <dev_lookup+0x18>
		if (devtab[i]->dev_id == dev_id) {
			*dev = devtab[i];
			return 0;
		}
	cprintf("[%08x] unknown device type %d\n", thisenv->env_id, dev_id);
  8037eb:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  8037f2:	00 00 00 
  8037f5:	48 8b 00             	mov    (%rax),%rax
  8037f8:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8037fe:	8b 55 ec             	mov    -0x14(%rbp),%edx
  803801:	89 c6                	mov    %eax,%esi
  803803:	48 bf 18 14 82 00 00 	movabs $0x821418,%rdi
  80380a:	00 00 00 
  80380d:	b8 00 00 00 00       	mov    $0x0,%eax
  803812:	48 b9 22 13 80 00 00 	movabs $0x801322,%rcx
  803819:	00 00 00 
  80381c:	ff d1                	callq  *%rcx
	*dev = 0;
  80381e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  803822:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	return -E_INVAL;
  803829:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
  80382e:	c9                   	leaveq 
  80382f:	c3                   	retq   

0000000000803830 <close>:

int
close(int fdnum)
{
  803830:	55                   	push   %rbp
  803831:	48 89 e5             	mov    %rsp,%rbp
  803834:	48 83 ec 20          	sub    $0x20,%rsp
  803838:	89 7d ec             	mov    %edi,-0x14(%rbp)
	struct Fd *fd;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  80383b:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  80383f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  803842:	48 89 d6             	mov    %rdx,%rsi
  803845:	89 c7                	mov    %eax,%edi
  803847:	48 b8 20 36 80 00 00 	movabs $0x803620,%rax
  80384e:	00 00 00 
  803851:	ff d0                	callq  *%rax
  803853:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803856:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80385a:	79 05                	jns    803861 <close+0x31>
		return r;
  80385c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80385f:	eb 18                	jmp    803879 <close+0x49>
	else
		return fd_close(fd, 1);
  803861:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803865:	be 01 00 00 00       	mov    $0x1,%esi
  80386a:	48 89 c7             	mov    %rax,%rdi
  80386d:	48 b8 b0 36 80 00 00 	movabs $0x8036b0,%rax
  803874:	00 00 00 
  803877:	ff d0                	callq  *%rax
}
  803879:	c9                   	leaveq 
  80387a:	c3                   	retq   

000000000080387b <close_all>:

void
close_all(void)
{
  80387b:	55                   	push   %rbp
  80387c:	48 89 e5             	mov    %rsp,%rbp
  80387f:	48 83 ec 10          	sub    $0x10,%rsp
	int i;
	for (i = 0; i < MAXFD; i++)
  803883:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80388a:	eb 15                	jmp    8038a1 <close_all+0x26>
		close(i);
  80388c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80388f:	89 c7                	mov    %eax,%edi
  803891:	48 b8 30 38 80 00 00 	movabs $0x803830,%rax
  803898:	00 00 00 
  80389b:	ff d0                	callq  *%rax

void
close_all(void)
{
	int i;
	for (i = 0; i < MAXFD; i++)
  80389d:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8038a1:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  8038a5:	7e e5                	jle    80388c <close_all+0x11>
		close(i);
}
  8038a7:	c9                   	leaveq 
  8038a8:	c3                   	retq   

00000000008038a9 <dup>:
// file and the file offset of the other.
// Closes any previously open file descriptor at 'newfdnum'.
// This is implemented using virtual memory tricks (of course!).
int
dup(int oldfdnum, int newfdnum)
{
  8038a9:	55                   	push   %rbp
  8038aa:	48 89 e5             	mov    %rsp,%rbp
  8038ad:	48 83 ec 40          	sub    $0x40,%rsp
  8038b1:	89 7d cc             	mov    %edi,-0x34(%rbp)
  8038b4:	89 75 c8             	mov    %esi,-0x38(%rbp)
	int r;
	char *ova, *nva;
	pte_t pte;
	struct Fd *oldfd, *newfd;

	if ((r = fd_lookup(oldfdnum, &oldfd)) < 0)
  8038b7:	48 8d 55 d8          	lea    -0x28(%rbp),%rdx
  8038bb:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8038be:	48 89 d6             	mov    %rdx,%rsi
  8038c1:	89 c7                	mov    %eax,%edi
  8038c3:	48 b8 20 36 80 00 00 	movabs $0x803620,%rax
  8038ca:	00 00 00 
  8038cd:	ff d0                	callq  *%rax
  8038cf:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8038d2:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8038d6:	79 08                	jns    8038e0 <dup+0x37>
		return r;
  8038d8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8038db:	e9 70 01 00 00       	jmpq   803a50 <dup+0x1a7>
	close(newfdnum);
  8038e0:	8b 45 c8             	mov    -0x38(%rbp),%eax
  8038e3:	89 c7                	mov    %eax,%edi
  8038e5:	48 b8 30 38 80 00 00 	movabs $0x803830,%rax
  8038ec:	00 00 00 
  8038ef:	ff d0                	callq  *%rax

	newfd = INDEX2FD(newfdnum);
  8038f1:	8b 45 c8             	mov    -0x38(%rbp),%eax
  8038f4:	48 98                	cltq   
  8038f6:	48 05 00 00 0d 00    	add    $0xd0000,%rax
  8038fc:	48 c1 e0 0c          	shl    $0xc,%rax
  803900:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	ova = fd2data(oldfd);
  803904:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  803908:	48 89 c7             	mov    %rax,%rdi
  80390b:	48 b8 5d 35 80 00 00 	movabs $0x80355d,%rax
  803912:	00 00 00 
  803915:	ff d0                	callq  *%rax
  803917:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	nva = fd2data(newfd);
  80391b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80391f:	48 89 c7             	mov    %rax,%rdi
  803922:	48 b8 5d 35 80 00 00 	movabs $0x80355d,%rax
  803929:	00 00 00 
  80392c:	ff d0                	callq  *%rax
  80392e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	if ((uvpd[VPD(ova)] & PTE_P) && (uvpt[PGNUM(ova)] & PTE_P))
  803932:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803936:	48 c1 e8 15          	shr    $0x15,%rax
  80393a:	48 89 c2             	mov    %rax,%rdx
  80393d:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  803944:	01 00 00 
  803947:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80394b:	83 e0 01             	and    $0x1,%eax
  80394e:	48 85 c0             	test   %rax,%rax
  803951:	74 73                	je     8039c6 <dup+0x11d>
  803953:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803957:	48 c1 e8 0c          	shr    $0xc,%rax
  80395b:	48 89 c2             	mov    %rax,%rdx
  80395e:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  803965:	01 00 00 
  803968:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80396c:	83 e0 01             	and    $0x1,%eax
  80396f:	48 85 c0             	test   %rax,%rax
  803972:	74 52                	je     8039c6 <dup+0x11d>
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
  803974:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803978:	48 c1 e8 0c          	shr    $0xc,%rax
  80397c:	48 89 c2             	mov    %rax,%rdx
  80397f:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  803986:	01 00 00 
  803989:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80398d:	25 07 0e 00 00       	and    $0xe07,%eax
  803992:	89 c1                	mov    %eax,%ecx
  803994:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  803998:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80399c:	41 89 c8             	mov    %ecx,%r8d
  80399f:	48 89 d1             	mov    %rdx,%rcx
  8039a2:	ba 00 00 00 00       	mov    $0x0,%edx
  8039a7:	48 89 c6             	mov    %rax,%rsi
  8039aa:	bf 00 00 00 00       	mov    $0x0,%edi
  8039af:	48 b8 56 28 80 00 00 	movabs $0x802856,%rax
  8039b6:	00 00 00 
  8039b9:	ff d0                	callq  *%rax
  8039bb:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8039be:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8039c2:	79 02                	jns    8039c6 <dup+0x11d>
			goto err;
  8039c4:	eb 57                	jmp    803a1d <dup+0x174>
	if ((r = sys_page_map(0, oldfd, 0, newfd, uvpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
  8039c6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8039ca:	48 c1 e8 0c          	shr    $0xc,%rax
  8039ce:	48 89 c2             	mov    %rax,%rdx
  8039d1:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  8039d8:	01 00 00 
  8039db:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8039df:	25 07 0e 00 00       	and    $0xe07,%eax
  8039e4:	89 c1                	mov    %eax,%ecx
  8039e6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8039ea:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8039ee:	41 89 c8             	mov    %ecx,%r8d
  8039f1:	48 89 d1             	mov    %rdx,%rcx
  8039f4:	ba 00 00 00 00       	mov    $0x0,%edx
  8039f9:	48 89 c6             	mov    %rax,%rsi
  8039fc:	bf 00 00 00 00       	mov    $0x0,%edi
  803a01:	48 b8 56 28 80 00 00 	movabs $0x802856,%rax
  803a08:	00 00 00 
  803a0b:	ff d0                	callq  *%rax
  803a0d:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803a10:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803a14:	79 02                	jns    803a18 <dup+0x16f>
		goto err;
  803a16:	eb 05                	jmp    803a1d <dup+0x174>

	return newfdnum;
  803a18:	8b 45 c8             	mov    -0x38(%rbp),%eax
  803a1b:	eb 33                	jmp    803a50 <dup+0x1a7>

err:
	sys_page_unmap(0, newfd);
  803a1d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803a21:	48 89 c6             	mov    %rax,%rsi
  803a24:	bf 00 00 00 00       	mov    $0x0,%edi
  803a29:	48 b8 b1 28 80 00 00 	movabs $0x8028b1,%rax
  803a30:	00 00 00 
  803a33:	ff d0                	callq  *%rax
	sys_page_unmap(0, nva);
  803a35:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  803a39:	48 89 c6             	mov    %rax,%rsi
  803a3c:	bf 00 00 00 00       	mov    $0x0,%edi
  803a41:	48 b8 b1 28 80 00 00 	movabs $0x8028b1,%rax
  803a48:	00 00 00 
  803a4b:	ff d0                	callq  *%rax
	return r;
  803a4d:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  803a50:	c9                   	leaveq 
  803a51:	c3                   	retq   

0000000000803a52 <read>:

ssize_t
read(int fdnum, void *buf, size_t n)
{
  803a52:	55                   	push   %rbp
  803a53:	48 89 e5             	mov    %rsp,%rbp
  803a56:	48 83 ec 40          	sub    $0x40,%rsp
  803a5a:	89 7d dc             	mov    %edi,-0x24(%rbp)
  803a5d:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  803a61:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  803a65:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  803a69:	8b 45 dc             	mov    -0x24(%rbp),%eax
  803a6c:	48 89 d6             	mov    %rdx,%rsi
  803a6f:	89 c7                	mov    %eax,%edi
  803a71:	48 b8 20 36 80 00 00 	movabs $0x803620,%rax
  803a78:	00 00 00 
  803a7b:	ff d0                	callq  *%rax
  803a7d:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803a80:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803a84:	78 24                	js     803aaa <read+0x58>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  803a86:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803a8a:	8b 00                	mov    (%rax),%eax
  803a8c:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  803a90:	48 89 d6             	mov    %rdx,%rsi
  803a93:	89 c7                	mov    %eax,%edi
  803a95:	48 b8 79 37 80 00 00 	movabs $0x803779,%rax
  803a9c:	00 00 00 
  803a9f:	ff d0                	callq  *%rax
  803aa1:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803aa4:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803aa8:	79 05                	jns    803aaf <read+0x5d>
		return r;
  803aaa:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803aad:	eb 76                	jmp    803b25 <read+0xd3>
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
  803aaf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803ab3:	8b 40 08             	mov    0x8(%rax),%eax
  803ab6:	83 e0 03             	and    $0x3,%eax
  803ab9:	83 f8 01             	cmp    $0x1,%eax
  803abc:	75 3a                	jne    803af8 <read+0xa6>
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
  803abe:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  803ac5:	00 00 00 
  803ac8:	48 8b 00             	mov    (%rax),%rax
  803acb:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  803ad1:	8b 55 dc             	mov    -0x24(%rbp),%edx
  803ad4:	89 c6                	mov    %eax,%esi
  803ad6:	48 bf 37 14 82 00 00 	movabs $0x821437,%rdi
  803add:	00 00 00 
  803ae0:	b8 00 00 00 00       	mov    $0x0,%eax
  803ae5:	48 b9 22 13 80 00 00 	movabs $0x801322,%rcx
  803aec:	00 00 00 
  803aef:	ff d1                	callq  *%rcx
		return -E_INVAL;
  803af1:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  803af6:	eb 2d                	jmp    803b25 <read+0xd3>
	}
	if (!dev->dev_read)
  803af8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803afc:	48 8b 40 10          	mov    0x10(%rax),%rax
  803b00:	48 85 c0             	test   %rax,%rax
  803b03:	75 07                	jne    803b0c <read+0xba>
		return -E_NOT_SUPP;
  803b05:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  803b0a:	eb 19                	jmp    803b25 <read+0xd3>
	return (*dev->dev_read)(fd, buf, n);
  803b0c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803b10:	48 8b 40 10          	mov    0x10(%rax),%rax
  803b14:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  803b18:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  803b1c:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  803b20:	48 89 cf             	mov    %rcx,%rdi
  803b23:	ff d0                	callq  *%rax
}
  803b25:	c9                   	leaveq 
  803b26:	c3                   	retq   

0000000000803b27 <readn>:

ssize_t
readn(int fdnum, void *buf, size_t n)
{
  803b27:	55                   	push   %rbp
  803b28:	48 89 e5             	mov    %rsp,%rbp
  803b2b:	48 83 ec 30          	sub    $0x30,%rsp
  803b2f:	89 7d ec             	mov    %edi,-0x14(%rbp)
  803b32:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  803b36:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  803b3a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  803b41:	eb 49                	jmp    803b8c <readn+0x65>
		m = read(fdnum, (char*)buf + tot, n - tot);
  803b43:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803b46:	48 98                	cltq   
  803b48:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  803b4c:	48 29 c2             	sub    %rax,%rdx
  803b4f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803b52:	48 63 c8             	movslq %eax,%rcx
  803b55:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  803b59:	48 01 c1             	add    %rax,%rcx
  803b5c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  803b5f:	48 89 ce             	mov    %rcx,%rsi
  803b62:	89 c7                	mov    %eax,%edi
  803b64:	48 b8 52 3a 80 00 00 	movabs $0x803a52,%rax
  803b6b:	00 00 00 
  803b6e:	ff d0                	callq  *%rax
  803b70:	89 45 f8             	mov    %eax,-0x8(%rbp)
		if (m < 0)
  803b73:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  803b77:	79 05                	jns    803b7e <readn+0x57>
			return m;
  803b79:	8b 45 f8             	mov    -0x8(%rbp),%eax
  803b7c:	eb 1c                	jmp    803b9a <readn+0x73>
		if (m == 0)
  803b7e:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  803b82:	75 02                	jne    803b86 <readn+0x5f>
			break;
  803b84:	eb 11                	jmp    803b97 <readn+0x70>
ssize_t
readn(int fdnum, void *buf, size_t n)
{
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  803b86:	8b 45 f8             	mov    -0x8(%rbp),%eax
  803b89:	01 45 fc             	add    %eax,-0x4(%rbp)
  803b8c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803b8f:	48 98                	cltq   
  803b91:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  803b95:	72 ac                	jb     803b43 <readn+0x1c>
		if (m < 0)
			return m;
		if (m == 0)
			break;
	}
	return tot;
  803b97:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  803b9a:	c9                   	leaveq 
  803b9b:	c3                   	retq   

0000000000803b9c <write>:

ssize_t
write(int fdnum, const void *buf, size_t n)
{
  803b9c:	55                   	push   %rbp
  803b9d:	48 89 e5             	mov    %rsp,%rbp
  803ba0:	48 83 ec 40          	sub    $0x40,%rsp
  803ba4:	89 7d dc             	mov    %edi,-0x24(%rbp)
  803ba7:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  803bab:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  803baf:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  803bb3:	8b 45 dc             	mov    -0x24(%rbp),%eax
  803bb6:	48 89 d6             	mov    %rdx,%rsi
  803bb9:	89 c7                	mov    %eax,%edi
  803bbb:	48 b8 20 36 80 00 00 	movabs $0x803620,%rax
  803bc2:	00 00 00 
  803bc5:	ff d0                	callq  *%rax
  803bc7:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803bca:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803bce:	78 24                	js     803bf4 <write+0x58>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  803bd0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803bd4:	8b 00                	mov    (%rax),%eax
  803bd6:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  803bda:	48 89 d6             	mov    %rdx,%rsi
  803bdd:	89 c7                	mov    %eax,%edi
  803bdf:	48 b8 79 37 80 00 00 	movabs $0x803779,%rax
  803be6:	00 00 00 
  803be9:	ff d0                	callq  *%rax
  803beb:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803bee:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803bf2:	79 05                	jns    803bf9 <write+0x5d>
		return r;
  803bf4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803bf7:	eb 75                	jmp    803c6e <write+0xd2>
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  803bf9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803bfd:	8b 40 08             	mov    0x8(%rax),%eax
  803c00:	83 e0 03             	and    $0x3,%eax
  803c03:	85 c0                	test   %eax,%eax
  803c05:	75 3a                	jne    803c41 <write+0xa5>
		cprintf("[%08x] write %d -- bad mode\n", thisenv->env_id, fdnum);
  803c07:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  803c0e:	00 00 00 
  803c11:	48 8b 00             	mov    (%rax),%rax
  803c14:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  803c1a:	8b 55 dc             	mov    -0x24(%rbp),%edx
  803c1d:	89 c6                	mov    %eax,%esi
  803c1f:	48 bf 53 14 82 00 00 	movabs $0x821453,%rdi
  803c26:	00 00 00 
  803c29:	b8 00 00 00 00       	mov    $0x0,%eax
  803c2e:	48 b9 22 13 80 00 00 	movabs $0x801322,%rcx
  803c35:	00 00 00 
  803c38:	ff d1                	callq  *%rcx
		return -E_INVAL;
  803c3a:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  803c3f:	eb 2d                	jmp    803c6e <write+0xd2>
	}
	if (debug)
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
	if (!dev->dev_write)
  803c41:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803c45:	48 8b 40 18          	mov    0x18(%rax),%rax
  803c49:	48 85 c0             	test   %rax,%rax
  803c4c:	75 07                	jne    803c55 <write+0xb9>
		return -E_NOT_SUPP;
  803c4e:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  803c53:	eb 19                	jmp    803c6e <write+0xd2>
	return (*dev->dev_write)(fd, buf, n);
  803c55:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803c59:	48 8b 40 18          	mov    0x18(%rax),%rax
  803c5d:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  803c61:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  803c65:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  803c69:	48 89 cf             	mov    %rcx,%rdi
  803c6c:	ff d0                	callq  *%rax
}
  803c6e:	c9                   	leaveq 
  803c6f:	c3                   	retq   

0000000000803c70 <seek>:

int
seek(int fdnum, off_t offset)
{
  803c70:	55                   	push   %rbp
  803c71:	48 89 e5             	mov    %rsp,%rbp
  803c74:	48 83 ec 18          	sub    $0x18,%rsp
  803c78:	89 7d ec             	mov    %edi,-0x14(%rbp)
  803c7b:	89 75 e8             	mov    %esi,-0x18(%rbp)
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  803c7e:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  803c82:	8b 45 ec             	mov    -0x14(%rbp),%eax
  803c85:	48 89 d6             	mov    %rdx,%rsi
  803c88:	89 c7                	mov    %eax,%edi
  803c8a:	48 b8 20 36 80 00 00 	movabs $0x803620,%rax
  803c91:	00 00 00 
  803c94:	ff d0                	callq  *%rax
  803c96:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803c99:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803c9d:	79 05                	jns    803ca4 <seek+0x34>
		return r;
  803c9f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803ca2:	eb 0f                	jmp    803cb3 <seek+0x43>
	fd->fd_offset = offset;
  803ca4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803ca8:	8b 55 e8             	mov    -0x18(%rbp),%edx
  803cab:	89 50 04             	mov    %edx,0x4(%rax)
	return 0;
  803cae:	b8 00 00 00 00       	mov    $0x0,%eax
}
  803cb3:	c9                   	leaveq 
  803cb4:	c3                   	retq   

0000000000803cb5 <ftruncate>:

int
ftruncate(int fdnum, off_t newsize)
{
  803cb5:	55                   	push   %rbp
  803cb6:	48 89 e5             	mov    %rsp,%rbp
  803cb9:	48 83 ec 30          	sub    $0x30,%rsp
  803cbd:	89 7d dc             	mov    %edi,-0x24(%rbp)
  803cc0:	89 75 d8             	mov    %esi,-0x28(%rbp)
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
  803cc3:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  803cc7:	8b 45 dc             	mov    -0x24(%rbp),%eax
  803cca:	48 89 d6             	mov    %rdx,%rsi
  803ccd:	89 c7                	mov    %eax,%edi
  803ccf:	48 b8 20 36 80 00 00 	movabs $0x803620,%rax
  803cd6:	00 00 00 
  803cd9:	ff d0                	callq  *%rax
  803cdb:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803cde:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803ce2:	78 24                	js     803d08 <ftruncate+0x53>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  803ce4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803ce8:	8b 00                	mov    (%rax),%eax
  803cea:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  803cee:	48 89 d6             	mov    %rdx,%rsi
  803cf1:	89 c7                	mov    %eax,%edi
  803cf3:	48 b8 79 37 80 00 00 	movabs $0x803779,%rax
  803cfa:	00 00 00 
  803cfd:	ff d0                	callq  *%rax
  803cff:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803d02:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803d06:	79 05                	jns    803d0d <ftruncate+0x58>
		return r;
  803d08:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803d0b:	eb 72                	jmp    803d7f <ftruncate+0xca>
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  803d0d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803d11:	8b 40 08             	mov    0x8(%rax),%eax
  803d14:	83 e0 03             	and    $0x3,%eax
  803d17:	85 c0                	test   %eax,%eax
  803d19:	75 3a                	jne    803d55 <ftruncate+0xa0>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
			thisenv->env_id, fdnum);
  803d1b:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  803d22:	00 00 00 
  803d25:	48 8b 00             	mov    (%rax),%rax
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
		cprintf("[%08x] ftruncate %d -- bad mode\n",
  803d28:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  803d2e:	8b 55 dc             	mov    -0x24(%rbp),%edx
  803d31:	89 c6                	mov    %eax,%esi
  803d33:	48 bf 70 14 82 00 00 	movabs $0x821470,%rdi
  803d3a:	00 00 00 
  803d3d:	b8 00 00 00 00       	mov    $0x0,%eax
  803d42:	48 b9 22 13 80 00 00 	movabs $0x801322,%rcx
  803d49:	00 00 00 
  803d4c:	ff d1                	callq  *%rcx
			thisenv->env_id, fdnum);
		return -E_INVAL;
  803d4e:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  803d53:	eb 2a                	jmp    803d7f <ftruncate+0xca>
	}
	if (!dev->dev_trunc)
  803d55:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803d59:	48 8b 40 30          	mov    0x30(%rax),%rax
  803d5d:	48 85 c0             	test   %rax,%rax
  803d60:	75 07                	jne    803d69 <ftruncate+0xb4>
		return -E_NOT_SUPP;
  803d62:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  803d67:	eb 16                	jmp    803d7f <ftruncate+0xca>
	return (*dev->dev_trunc)(fd, newsize);
  803d69:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803d6d:	48 8b 40 30          	mov    0x30(%rax),%rax
  803d71:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  803d75:	8b 4d d8             	mov    -0x28(%rbp),%ecx
  803d78:	89 ce                	mov    %ecx,%esi
  803d7a:	48 89 d7             	mov    %rdx,%rdi
  803d7d:	ff d0                	callq  *%rax
}
  803d7f:	c9                   	leaveq 
  803d80:	c3                   	retq   

0000000000803d81 <fstat>:

int
fstat(int fdnum, struct Stat *stat)
{
  803d81:	55                   	push   %rbp
  803d82:	48 89 e5             	mov    %rsp,%rbp
  803d85:	48 83 ec 30          	sub    $0x30,%rsp
  803d89:	89 7d dc             	mov    %edi,-0x24(%rbp)
  803d8c:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  803d90:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  803d94:	8b 45 dc             	mov    -0x24(%rbp),%eax
  803d97:	48 89 d6             	mov    %rdx,%rsi
  803d9a:	89 c7                	mov    %eax,%edi
  803d9c:	48 b8 20 36 80 00 00 	movabs $0x803620,%rax
  803da3:	00 00 00 
  803da6:	ff d0                	callq  *%rax
  803da8:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803dab:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803daf:	78 24                	js     803dd5 <fstat+0x54>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  803db1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803db5:	8b 00                	mov    (%rax),%eax
  803db7:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  803dbb:	48 89 d6             	mov    %rdx,%rsi
  803dbe:	89 c7                	mov    %eax,%edi
  803dc0:	48 b8 79 37 80 00 00 	movabs $0x803779,%rax
  803dc7:	00 00 00 
  803dca:	ff d0                	callq  *%rax
  803dcc:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803dcf:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803dd3:	79 05                	jns    803dda <fstat+0x59>
		return r;
  803dd5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803dd8:	eb 5e                	jmp    803e38 <fstat+0xb7>
	if (!dev->dev_stat)
  803dda:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803dde:	48 8b 40 28          	mov    0x28(%rax),%rax
  803de2:	48 85 c0             	test   %rax,%rax
  803de5:	75 07                	jne    803dee <fstat+0x6d>
		return -E_NOT_SUPP;
  803de7:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  803dec:	eb 4a                	jmp    803e38 <fstat+0xb7>
	stat->st_name[0] = 0;
  803dee:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  803df2:	c6 00 00             	movb   $0x0,(%rax)
	stat->st_size = 0;
  803df5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  803df9:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%rax)
  803e00:	00 00 00 
	stat->st_isdir = 0;
  803e03:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  803e07:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%rax)
  803e0e:	00 00 00 
	stat->st_dev = dev;
  803e11:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  803e15:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  803e19:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
	return (*dev->dev_stat)(fd, stat);
  803e20:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803e24:	48 8b 40 28          	mov    0x28(%rax),%rax
  803e28:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  803e2c:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  803e30:	48 89 ce             	mov    %rcx,%rsi
  803e33:	48 89 d7             	mov    %rdx,%rdi
  803e36:	ff d0                	callq  *%rax
}
  803e38:	c9                   	leaveq 
  803e39:	c3                   	retq   

0000000000803e3a <stat>:

int
stat(const char *path, struct Stat *stat)
{
  803e3a:	55                   	push   %rbp
  803e3b:	48 89 e5             	mov    %rsp,%rbp
  803e3e:	48 83 ec 20          	sub    $0x20,%rsp
  803e42:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  803e46:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int fd, r;

	if ((fd = open(path, O_RDONLY)) < 0)
  803e4a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803e4e:	be 00 00 00 00       	mov    $0x0,%esi
  803e53:	48 89 c7             	mov    %rax,%rdi
  803e56:	48 b8 28 3f 80 00 00 	movabs $0x803f28,%rax
  803e5d:	00 00 00 
  803e60:	ff d0                	callq  *%rax
  803e62:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803e65:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803e69:	79 05                	jns    803e70 <stat+0x36>
		return fd;
  803e6b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803e6e:	eb 2f                	jmp    803e9f <stat+0x65>
	r = fstat(fd, stat);
  803e70:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  803e74:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803e77:	48 89 d6             	mov    %rdx,%rsi
  803e7a:	89 c7                	mov    %eax,%edi
  803e7c:	48 b8 81 3d 80 00 00 	movabs $0x803d81,%rax
  803e83:	00 00 00 
  803e86:	ff d0                	callq  *%rax
  803e88:	89 45 f8             	mov    %eax,-0x8(%rbp)
	close(fd);
  803e8b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803e8e:	89 c7                	mov    %eax,%edi
  803e90:	48 b8 30 38 80 00 00 	movabs $0x803830,%rax
  803e97:	00 00 00 
  803e9a:	ff d0                	callq  *%rax
	return r;
  803e9c:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
  803e9f:	c9                   	leaveq 
  803ea0:	c3                   	retq   

0000000000803ea1 <fsipc>:
// type: request code, passed as the simple integer IPC value.
// dstva: virtual address at which to receive reply page, 0 if none.
// Returns result from the file server.
static int
fsipc(unsigned type, void *dstva)
{
  803ea1:	55                   	push   %rbp
  803ea2:	48 89 e5             	mov    %rsp,%rbp
  803ea5:	48 83 ec 10          	sub    $0x10,%rsp
  803ea9:	89 7d fc             	mov    %edi,-0x4(%rbp)
  803eac:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	static envid_t fsenv;
	if (fsenv == 0)
  803eb0:	48 b8 84 90 82 00 00 	movabs $0x829084,%rax
  803eb7:	00 00 00 
  803eba:	8b 00                	mov    (%rax),%eax
  803ebc:	85 c0                	test   %eax,%eax
  803ebe:	75 1d                	jne    803edd <fsipc+0x3c>
		fsenv = ipc_find_env(ENV_TYPE_FS);
  803ec0:	bf 01 00 00 00       	mov    $0x1,%edi
  803ec5:	48 b8 c8 34 80 00 00 	movabs $0x8034c8,%rax
  803ecc:	00 00 00 
  803ecf:	ff d0                	callq  *%rax
  803ed1:	48 ba 84 90 82 00 00 	movabs $0x829084,%rdx
  803ed8:	00 00 00 
  803edb:	89 02                	mov    %eax,(%rdx)
	//static_assert(sizeof(fsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] fsipc %d %08x\n", thisenv->env_id, type, *(uint32_t *)&fsipcbuf);

	ipc_send(fsenv, type, &fsipcbuf, PTE_P | PTE_W | PTE_U);
  803edd:	48 b8 84 90 82 00 00 	movabs $0x829084,%rax
  803ee4:	00 00 00 
  803ee7:	8b 00                	mov    (%rax),%eax
  803ee9:	8b 75 fc             	mov    -0x4(%rbp),%esi
  803eec:	b9 07 00 00 00       	mov    $0x7,%ecx
  803ef1:	48 ba 00 80 b5 00 00 	movabs $0xb58000,%rdx
  803ef8:	00 00 00 
  803efb:	89 c7                	mov    %eax,%edi
  803efd:	48 b8 bc 32 80 00 00 	movabs $0x8032bc,%rax
  803f04:	00 00 00 
  803f07:	ff d0                	callq  *%rax
	return ipc_recv(NULL, dstva, NULL);
  803f09:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803f0d:	ba 00 00 00 00       	mov    $0x0,%edx
  803f12:	48 89 c6             	mov    %rax,%rsi
  803f15:	bf 00 00 00 00       	mov    $0x0,%edi
  803f1a:	48 b8 fb 31 80 00 00 	movabs $0x8031fb,%rax
  803f21:	00 00 00 
  803f24:	ff d0                	callq  *%rax
}
  803f26:	c9                   	leaveq 
  803f27:	c3                   	retq   

0000000000803f28 <open>:
// 	The file descriptor index on success
// 	-E_BAD_PATH if the path is too long (>= MAXPATHLEN)
// 	< 0 for other errors.
int
open(const char *path, int mode)
{
  803f28:	55                   	push   %rbp
  803f29:	48 89 e5             	mov    %rsp,%rbp
  803f2c:	48 83 ec 20          	sub    $0x20,%rsp
  803f30:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  803f34:	89 75 e4             	mov    %esi,-0x1c(%rbp)


	int r;
	struct Fd *fd;

	if (strlen(path) >= MAXPATHLEN)
  803f37:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803f3b:	48 89 c7             	mov    %rax,%rdi
  803f3e:	48 b8 6b 1e 80 00 00 	movabs $0x801e6b,%rax
  803f45:	00 00 00 
  803f48:	ff d0                	callq  *%rax
  803f4a:	3d ff 03 00 00       	cmp    $0x3ff,%eax
  803f4f:	7e 0a                	jle    803f5b <open+0x33>
		return -E_BAD_PATH;
  803f51:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
  803f56:	e9 a5 00 00 00       	jmpq   804000 <open+0xd8>

	if ((r = fd_alloc(&fd)) < 0)
  803f5b:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  803f5f:	48 89 c7             	mov    %rax,%rdi
  803f62:	48 b8 88 35 80 00 00 	movabs $0x803588,%rax
  803f69:	00 00 00 
  803f6c:	ff d0                	callq  *%rax
  803f6e:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803f71:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803f75:	79 08                	jns    803f7f <open+0x57>
		return r;
  803f77:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803f7a:	e9 81 00 00 00       	jmpq   804000 <open+0xd8>

	strcpy(fsipcbuf.open.req_path, path);
  803f7f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803f83:	48 89 c6             	mov    %rax,%rsi
  803f86:	48 bf 00 80 b5 00 00 	movabs $0xb58000,%rdi
  803f8d:	00 00 00 
  803f90:	48 b8 d7 1e 80 00 00 	movabs $0x801ed7,%rax
  803f97:	00 00 00 
  803f9a:	ff d0                	callq  *%rax
	fsipcbuf.open.req_omode = mode;
  803f9c:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  803fa3:	00 00 00 
  803fa6:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  803fa9:	89 90 00 04 00 00    	mov    %edx,0x400(%rax)

	if ((r = fsipc(FSREQ_OPEN, fd)) < 0) {
  803faf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803fb3:	48 89 c6             	mov    %rax,%rsi
  803fb6:	bf 01 00 00 00       	mov    $0x1,%edi
  803fbb:	48 b8 a1 3e 80 00 00 	movabs $0x803ea1,%rax
  803fc2:	00 00 00 
  803fc5:	ff d0                	callq  *%rax
  803fc7:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803fca:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803fce:	79 1d                	jns    803fed <open+0xc5>
		fd_close(fd, 0);
  803fd0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803fd4:	be 00 00 00 00       	mov    $0x0,%esi
  803fd9:	48 89 c7             	mov    %rax,%rdi
  803fdc:	48 b8 b0 36 80 00 00 	movabs $0x8036b0,%rax
  803fe3:	00 00 00 
  803fe6:	ff d0                	callq  *%rax
		return r;
  803fe8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803feb:	eb 13                	jmp    804000 <open+0xd8>
	}

	return fd2num(fd);
  803fed:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803ff1:	48 89 c7             	mov    %rax,%rdi
  803ff4:	48 b8 3a 35 80 00 00 	movabs $0x80353a,%rax
  803ffb:	00 00 00 
  803ffe:	ff d0                	callq  *%rax

}
  804000:	c9                   	leaveq 
  804001:	c3                   	retq   

0000000000804002 <devfile_flush>:
// open, unmapping it is enough to free up server-side resources.
// Other than that, we just have to make sure our changes are flushed
// to disk.
static int
devfile_flush(struct Fd *fd)
{
  804002:	55                   	push   %rbp
  804003:	48 89 e5             	mov    %rsp,%rbp
  804006:	48 83 ec 10          	sub    $0x10,%rsp
  80400a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	fsipcbuf.flush.req_fileid = fd->fd_file.id;
  80400e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804012:	8b 50 0c             	mov    0xc(%rax),%edx
  804015:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  80401c:	00 00 00 
  80401f:	89 10                	mov    %edx,(%rax)
	return fsipc(FSREQ_FLUSH, NULL);
  804021:	be 00 00 00 00       	mov    $0x0,%esi
  804026:	bf 06 00 00 00       	mov    $0x6,%edi
  80402b:	48 b8 a1 3e 80 00 00 	movabs $0x803ea1,%rax
  804032:	00 00 00 
  804035:	ff d0                	callq  *%rax
}
  804037:	c9                   	leaveq 
  804038:	c3                   	retq   

0000000000804039 <devfile_read>:
// Returns:
// 	The number of bytes successfully read.
// 	< 0 on error.
static ssize_t
devfile_read(struct Fd *fd, void *buf, size_t n)
{
  804039:	55                   	push   %rbp
  80403a:	48 89 e5             	mov    %rsp,%rbp
  80403d:	48 83 ec 30          	sub    $0x30,%rsp
  804041:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  804045:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  804049:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	// bytes read will be written back to fsipcbuf by the file
	// system server.

	int r;

	fsipcbuf.read.req_fileid = fd->fd_file.id;
  80404d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804051:	8b 50 0c             	mov    0xc(%rax),%edx
  804054:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  80405b:	00 00 00 
  80405e:	89 10                	mov    %edx,(%rax)
	fsipcbuf.read.req_n = n;
  804060:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  804067:	00 00 00 
  80406a:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80406e:	48 89 50 08          	mov    %rdx,0x8(%rax)
	if ((r = fsipc(FSREQ_READ, NULL)) < 0)
  804072:	be 00 00 00 00       	mov    $0x0,%esi
  804077:	bf 03 00 00 00       	mov    $0x3,%edi
  80407c:	48 b8 a1 3e 80 00 00 	movabs $0x803ea1,%rax
  804083:	00 00 00 
  804086:	ff d0                	callq  *%rax
  804088:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80408b:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80408f:	79 08                	jns    804099 <devfile_read+0x60>
		return r;
  804091:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804094:	e9 a4 00 00 00       	jmpq   80413d <devfile_read+0x104>
	assert(r <= n);
  804099:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80409c:	48 98                	cltq   
  80409e:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8040a2:	76 35                	jbe    8040d9 <devfile_read+0xa0>
  8040a4:	48 b9 96 14 82 00 00 	movabs $0x821496,%rcx
  8040ab:	00 00 00 
  8040ae:	48 ba 9d 14 82 00 00 	movabs $0x82149d,%rdx
  8040b5:	00 00 00 
  8040b8:	be 86 00 00 00       	mov    $0x86,%esi
  8040bd:	48 bf b2 14 82 00 00 	movabs $0x8214b2,%rdi
  8040c4:	00 00 00 
  8040c7:	b8 00 00 00 00       	mov    $0x0,%eax
  8040cc:	49 b8 e9 10 80 00 00 	movabs $0x8010e9,%r8
  8040d3:	00 00 00 
  8040d6:	41 ff d0             	callq  *%r8
	assert(r <= PGSIZE);
  8040d9:	81 7d fc 00 10 00 00 	cmpl   $0x1000,-0x4(%rbp)
  8040e0:	7e 35                	jle    804117 <devfile_read+0xde>
  8040e2:	48 b9 bd 14 82 00 00 	movabs $0x8214bd,%rcx
  8040e9:	00 00 00 
  8040ec:	48 ba 9d 14 82 00 00 	movabs $0x82149d,%rdx
  8040f3:	00 00 00 
  8040f6:	be 87 00 00 00       	mov    $0x87,%esi
  8040fb:	48 bf b2 14 82 00 00 	movabs $0x8214b2,%rdi
  804102:	00 00 00 
  804105:	b8 00 00 00 00       	mov    $0x0,%eax
  80410a:	49 b8 e9 10 80 00 00 	movabs $0x8010e9,%r8
  804111:	00 00 00 
  804114:	41 ff d0             	callq  *%r8
	memmove(buf, &fsipcbuf, r);
  804117:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80411a:	48 63 d0             	movslq %eax,%rdx
  80411d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  804121:	48 be 00 80 b5 00 00 	movabs $0xb58000,%rsi
  804128:	00 00 00 
  80412b:	48 89 c7             	mov    %rax,%rdi
  80412e:	48 b8 fb 21 80 00 00 	movabs $0x8021fb,%rax
  804135:	00 00 00 
  804138:	ff d0                	callq  *%rax
	return r;
  80413a:	8b 45 fc             	mov    -0x4(%rbp),%eax

}
  80413d:	c9                   	leaveq 
  80413e:	c3                   	retq   

000000000080413f <devfile_write>:
// Returns:
//	 The number of bytes successfully written.
//	 < 0 on error.
static ssize_t
devfile_write(struct Fd *fd, const void *buf, size_t n)
{
  80413f:	55                   	push   %rbp
  804140:	48 89 e5             	mov    %rsp,%rbp
  804143:	48 83 ec 40          	sub    $0x40,%rsp
  804147:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80414b:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80414f:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	// remember that write is always allowed to write *fewer*
	// bytes than requested.

	int r;

	n = MIN(n, sizeof(fsipcbuf.write.req_buf));
  804153:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804157:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80415b:	48 c7 45 f0 f4 0f 00 	movq   $0xff4,-0x10(%rbp)
  804162:	00 
  804163:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804167:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80416b:	48 0f 46 45 f8       	cmovbe -0x8(%rbp),%rax
  804170:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	fsipcbuf.write.req_fileid = fd->fd_file.id;
  804174:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  804178:	8b 50 0c             	mov    0xc(%rax),%edx
  80417b:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  804182:	00 00 00 
  804185:	89 10                	mov    %edx,(%rax)
	fsipcbuf.write.req_n = n;
  804187:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  80418e:	00 00 00 
  804191:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  804195:	48 89 50 08          	mov    %rdx,0x8(%rax)
	memmove(fsipcbuf.write.req_buf, buf, n);
  804199:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80419d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8041a1:	48 89 c6             	mov    %rax,%rsi
  8041a4:	48 bf 10 80 b5 00 00 	movabs $0xb58010,%rdi
  8041ab:	00 00 00 
  8041ae:	48 b8 fb 21 80 00 00 	movabs $0x8021fb,%rax
  8041b5:	00 00 00 
  8041b8:	ff d0                	callq  *%rax
	if ((r = fsipc(FSREQ_WRITE, NULL)) < 0)
  8041ba:	be 00 00 00 00       	mov    $0x0,%esi
  8041bf:	bf 04 00 00 00       	mov    $0x4,%edi
  8041c4:	48 b8 a1 3e 80 00 00 	movabs $0x803ea1,%rax
  8041cb:	00 00 00 
  8041ce:	ff d0                	callq  *%rax
  8041d0:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8041d3:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  8041d7:	79 05                	jns    8041de <devfile_write+0x9f>
		return r;
  8041d9:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8041dc:	eb 43                	jmp    804221 <devfile_write+0xe2>
	assert(r <= n);
  8041de:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8041e1:	48 98                	cltq   
  8041e3:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8041e7:	76 35                	jbe    80421e <devfile_write+0xdf>
  8041e9:	48 b9 96 14 82 00 00 	movabs $0x821496,%rcx
  8041f0:	00 00 00 
  8041f3:	48 ba 9d 14 82 00 00 	movabs $0x82149d,%rdx
  8041fa:	00 00 00 
  8041fd:	be a2 00 00 00       	mov    $0xa2,%esi
  804202:	48 bf b2 14 82 00 00 	movabs $0x8214b2,%rdi
  804209:	00 00 00 
  80420c:	b8 00 00 00 00       	mov    $0x0,%eax
  804211:	49 b8 e9 10 80 00 00 	movabs $0x8010e9,%r8
  804218:	00 00 00 
  80421b:	41 ff d0             	callq  *%r8
	return r;
  80421e:	8b 45 ec             	mov    -0x14(%rbp),%eax

}
  804221:	c9                   	leaveq 
  804222:	c3                   	retq   

0000000000804223 <devfile_stat>:

static int
devfile_stat(struct Fd *fd, struct Stat *st)
{
  804223:	55                   	push   %rbp
  804224:	48 89 e5             	mov    %rsp,%rbp
  804227:	48 83 ec 20          	sub    $0x20,%rsp
  80422b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80422f:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int r;

	fsipcbuf.stat.req_fileid = fd->fd_file.id;
  804233:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804237:	8b 50 0c             	mov    0xc(%rax),%edx
  80423a:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  804241:	00 00 00 
  804244:	89 10                	mov    %edx,(%rax)
	if ((r = fsipc(FSREQ_STAT, NULL)) < 0)
  804246:	be 00 00 00 00       	mov    $0x0,%esi
  80424b:	bf 05 00 00 00       	mov    $0x5,%edi
  804250:	48 b8 a1 3e 80 00 00 	movabs $0x803ea1,%rax
  804257:	00 00 00 
  80425a:	ff d0                	callq  *%rax
  80425c:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80425f:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804263:	79 05                	jns    80426a <devfile_stat+0x47>
		return r;
  804265:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804268:	eb 56                	jmp    8042c0 <devfile_stat+0x9d>
	strcpy(st->st_name, fsipcbuf.statRet.ret_name);
  80426a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80426e:	48 be 00 80 b5 00 00 	movabs $0xb58000,%rsi
  804275:	00 00 00 
  804278:	48 89 c7             	mov    %rax,%rdi
  80427b:	48 b8 d7 1e 80 00 00 	movabs $0x801ed7,%rax
  804282:	00 00 00 
  804285:	ff d0                	callq  *%rax
	st->st_size = fsipcbuf.statRet.ret_size;
  804287:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  80428e:	00 00 00 
  804291:	8b 90 80 00 00 00    	mov    0x80(%rax),%edx
  804297:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80429b:	89 90 80 00 00 00    	mov    %edx,0x80(%rax)
	st->st_isdir = fsipcbuf.statRet.ret_isdir;
  8042a1:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  8042a8:	00 00 00 
  8042ab:	8b 90 84 00 00 00    	mov    0x84(%rax),%edx
  8042b1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8042b5:	89 90 84 00 00 00    	mov    %edx,0x84(%rax)
	return 0;
  8042bb:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8042c0:	c9                   	leaveq 
  8042c1:	c3                   	retq   

00000000008042c2 <devfile_trunc>:

// Truncate or extend an open file to 'size' bytes
static int
devfile_trunc(struct Fd *fd, off_t newsize)
{
  8042c2:	55                   	push   %rbp
  8042c3:	48 89 e5             	mov    %rsp,%rbp
  8042c6:	48 83 ec 10          	sub    $0x10,%rsp
  8042ca:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8042ce:	89 75 f4             	mov    %esi,-0xc(%rbp)
	fsipcbuf.set_size.req_fileid = fd->fd_file.id;
  8042d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8042d5:	8b 50 0c             	mov    0xc(%rax),%edx
  8042d8:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  8042df:	00 00 00 
  8042e2:	89 10                	mov    %edx,(%rax)
	fsipcbuf.set_size.req_size = newsize;
  8042e4:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  8042eb:	00 00 00 
  8042ee:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8042f1:	89 50 04             	mov    %edx,0x4(%rax)
	return fsipc(FSREQ_SET_SIZE, NULL);
  8042f4:	be 00 00 00 00       	mov    $0x0,%esi
  8042f9:	bf 02 00 00 00       	mov    $0x2,%edi
  8042fe:	48 b8 a1 3e 80 00 00 	movabs $0x803ea1,%rax
  804305:	00 00 00 
  804308:	ff d0                	callq  *%rax
}
  80430a:	c9                   	leaveq 
  80430b:	c3                   	retq   

000000000080430c <remove>:

// Delete a file
int
remove(const char *path)
{
  80430c:	55                   	push   %rbp
  80430d:	48 89 e5             	mov    %rsp,%rbp
  804310:	48 83 ec 10          	sub    $0x10,%rsp
  804314:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (strlen(path) >= MAXPATHLEN)
  804318:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80431c:	48 89 c7             	mov    %rax,%rdi
  80431f:	48 b8 6b 1e 80 00 00 	movabs $0x801e6b,%rax
  804326:	00 00 00 
  804329:	ff d0                	callq  *%rax
  80432b:	3d ff 03 00 00       	cmp    $0x3ff,%eax
  804330:	7e 07                	jle    804339 <remove+0x2d>
		return -E_BAD_PATH;
  804332:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
  804337:	eb 33                	jmp    80436c <remove+0x60>
	strcpy(fsipcbuf.remove.req_path, path);
  804339:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80433d:	48 89 c6             	mov    %rax,%rsi
  804340:	48 bf 00 80 b5 00 00 	movabs $0xb58000,%rdi
  804347:	00 00 00 
  80434a:	48 b8 d7 1e 80 00 00 	movabs $0x801ed7,%rax
  804351:	00 00 00 
  804354:	ff d0                	callq  *%rax
	return fsipc(FSREQ_REMOVE, NULL);
  804356:	be 00 00 00 00       	mov    $0x0,%esi
  80435b:	bf 07 00 00 00       	mov    $0x7,%edi
  804360:	48 b8 a1 3e 80 00 00 	movabs $0x803ea1,%rax
  804367:	00 00 00 
  80436a:	ff d0                	callq  *%rax
}
  80436c:	c9                   	leaveq 
  80436d:	c3                   	retq   

000000000080436e <sync>:

// Synchronize disk with buffer cache
int
sync(void)
{
  80436e:	55                   	push   %rbp
  80436f:	48 89 e5             	mov    %rsp,%rbp
	// Ask the file server to update the disk
	// by writing any dirty blocks in the buffer cache.

	return fsipc(FSREQ_SYNC, NULL);
  804372:	be 00 00 00 00       	mov    $0x0,%esi
  804377:	bf 08 00 00 00       	mov    $0x8,%edi
  80437c:	48 b8 a1 3e 80 00 00 	movabs $0x803ea1,%rax
  804383:	00 00 00 
  804386:	ff d0                	callq  *%rax
}
  804388:	5d                   	pop    %rbp
  804389:	c3                   	retq   

000000000080438a <copy>:

//Copy a file from src to dest
int
copy(char *src, char *dest)
{
  80438a:	55                   	push   %rbp
  80438b:	48 89 e5             	mov    %rsp,%rbp
  80438e:	48 81 ec 20 02 00 00 	sub    $0x220,%rsp
  804395:	48 89 bd e8 fd ff ff 	mov    %rdi,-0x218(%rbp)
  80439c:	48 89 b5 e0 fd ff ff 	mov    %rsi,-0x220(%rbp)
	int r;
	int fd_src, fd_dest;
	char buffer[512];	//keep this small
	ssize_t read_size;
	ssize_t write_size;
	fd_src = open(src, O_RDONLY);
  8043a3:	48 8b 85 e8 fd ff ff 	mov    -0x218(%rbp),%rax
  8043aa:	be 00 00 00 00       	mov    $0x0,%esi
  8043af:	48 89 c7             	mov    %rax,%rdi
  8043b2:	48 b8 28 3f 80 00 00 	movabs $0x803f28,%rax
  8043b9:	00 00 00 
  8043bc:	ff d0                	callq  *%rax
  8043be:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (fd_src < 0) {	//error
  8043c1:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8043c5:	79 28                	jns    8043ef <copy+0x65>
		cprintf("cp open src error:%e\n", fd_src);
  8043c7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8043ca:	89 c6                	mov    %eax,%esi
  8043cc:	48 bf c9 14 82 00 00 	movabs $0x8214c9,%rdi
  8043d3:	00 00 00 
  8043d6:	b8 00 00 00 00       	mov    $0x0,%eax
  8043db:	48 ba 22 13 80 00 00 	movabs $0x801322,%rdx
  8043e2:	00 00 00 
  8043e5:	ff d2                	callq  *%rdx
		return fd_src;
  8043e7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8043ea:	e9 74 01 00 00       	jmpq   804563 <copy+0x1d9>
	}
	
	fd_dest = open(dest, O_CREAT | O_WRONLY);
  8043ef:	48 8b 85 e0 fd ff ff 	mov    -0x220(%rbp),%rax
  8043f6:	be 01 01 00 00       	mov    $0x101,%esi
  8043fb:	48 89 c7             	mov    %rax,%rdi
  8043fe:	48 b8 28 3f 80 00 00 	movabs $0x803f28,%rax
  804405:	00 00 00 
  804408:	ff d0                	callq  *%rax
  80440a:	89 45 f8             	mov    %eax,-0x8(%rbp)
	if (fd_dest < 0) {	//error
  80440d:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  804411:	79 39                	jns    80444c <copy+0xc2>
		cprintf("cp create dest  error:%e\n", fd_dest);
  804413:	8b 45 f8             	mov    -0x8(%rbp),%eax
  804416:	89 c6                	mov    %eax,%esi
  804418:	48 bf df 14 82 00 00 	movabs $0x8214df,%rdi
  80441f:	00 00 00 
  804422:	b8 00 00 00 00       	mov    $0x0,%eax
  804427:	48 ba 22 13 80 00 00 	movabs $0x801322,%rdx
  80442e:	00 00 00 
  804431:	ff d2                	callq  *%rdx
		close(fd_src);
  804433:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804436:	89 c7                	mov    %eax,%edi
  804438:	48 b8 30 38 80 00 00 	movabs $0x803830,%rax
  80443f:	00 00 00 
  804442:	ff d0                	callq  *%rax
		return fd_dest;
  804444:	8b 45 f8             	mov    -0x8(%rbp),%eax
  804447:	e9 17 01 00 00       	jmpq   804563 <copy+0x1d9>
	}

	while ((read_size = read(fd_src, buffer, 512)) > 0) {
  80444c:	eb 74                	jmp    8044c2 <copy+0x138>
		write_size = write(fd_dest, buffer, read_size);
  80444e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  804451:	48 63 d0             	movslq %eax,%rdx
  804454:	48 8d 8d f0 fd ff ff 	lea    -0x210(%rbp),%rcx
  80445b:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80445e:	48 89 ce             	mov    %rcx,%rsi
  804461:	89 c7                	mov    %eax,%edi
  804463:	48 b8 9c 3b 80 00 00 	movabs $0x803b9c,%rax
  80446a:	00 00 00 
  80446d:	ff d0                	callq  *%rax
  80446f:	89 45 f0             	mov    %eax,-0x10(%rbp)
		if (write_size < 0) {
  804472:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  804476:	79 4a                	jns    8044c2 <copy+0x138>
			cprintf("cp write error:%e\n", write_size);
  804478:	8b 45 f0             	mov    -0x10(%rbp),%eax
  80447b:	89 c6                	mov    %eax,%esi
  80447d:	48 bf f9 14 82 00 00 	movabs $0x8214f9,%rdi
  804484:	00 00 00 
  804487:	b8 00 00 00 00       	mov    $0x0,%eax
  80448c:	48 ba 22 13 80 00 00 	movabs $0x801322,%rdx
  804493:	00 00 00 
  804496:	ff d2                	callq  *%rdx
			close(fd_src);
  804498:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80449b:	89 c7                	mov    %eax,%edi
  80449d:	48 b8 30 38 80 00 00 	movabs $0x803830,%rax
  8044a4:	00 00 00 
  8044a7:	ff d0                	callq  *%rax
			close(fd_dest);
  8044a9:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8044ac:	89 c7                	mov    %eax,%edi
  8044ae:	48 b8 30 38 80 00 00 	movabs $0x803830,%rax
  8044b5:	00 00 00 
  8044b8:	ff d0                	callq  *%rax
			return write_size;
  8044ba:	8b 45 f0             	mov    -0x10(%rbp),%eax
  8044bd:	e9 a1 00 00 00       	jmpq   804563 <copy+0x1d9>
		cprintf("cp create dest  error:%e\n", fd_dest);
		close(fd_src);
		return fd_dest;
	}

	while ((read_size = read(fd_src, buffer, 512)) > 0) {
  8044c2:	48 8d 8d f0 fd ff ff 	lea    -0x210(%rbp),%rcx
  8044c9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8044cc:	ba 00 02 00 00       	mov    $0x200,%edx
  8044d1:	48 89 ce             	mov    %rcx,%rsi
  8044d4:	89 c7                	mov    %eax,%edi
  8044d6:	48 b8 52 3a 80 00 00 	movabs $0x803a52,%rax
  8044dd:	00 00 00 
  8044e0:	ff d0                	callq  *%rax
  8044e2:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8044e5:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  8044e9:	0f 8f 5f ff ff ff    	jg     80444e <copy+0xc4>
			close(fd_src);
			close(fd_dest);
			return write_size;
		}		
	}
	if (read_size < 0) {
  8044ef:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  8044f3:	79 47                	jns    80453c <copy+0x1b2>
		cprintf("cp read src error:%e\n", read_size);
  8044f5:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8044f8:	89 c6                	mov    %eax,%esi
  8044fa:	48 bf 0c 15 82 00 00 	movabs $0x82150c,%rdi
  804501:	00 00 00 
  804504:	b8 00 00 00 00       	mov    $0x0,%eax
  804509:	48 ba 22 13 80 00 00 	movabs $0x801322,%rdx
  804510:	00 00 00 
  804513:	ff d2                	callq  *%rdx
		close(fd_src);
  804515:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804518:	89 c7                	mov    %eax,%edi
  80451a:	48 b8 30 38 80 00 00 	movabs $0x803830,%rax
  804521:	00 00 00 
  804524:	ff d0                	callq  *%rax
		close(fd_dest);
  804526:	8b 45 f8             	mov    -0x8(%rbp),%eax
  804529:	89 c7                	mov    %eax,%edi
  80452b:	48 b8 30 38 80 00 00 	movabs $0x803830,%rax
  804532:	00 00 00 
  804535:	ff d0                	callq  *%rax
		return read_size;
  804537:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80453a:	eb 27                	jmp    804563 <copy+0x1d9>
	}
	close(fd_src);
  80453c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80453f:	89 c7                	mov    %eax,%edi
  804541:	48 b8 30 38 80 00 00 	movabs $0x803830,%rax
  804548:	00 00 00 
  80454b:	ff d0                	callq  *%rax
	close(fd_dest);
  80454d:	8b 45 f8             	mov    -0x8(%rbp),%eax
  804550:	89 c7                	mov    %eax,%edi
  804552:	48 b8 30 38 80 00 00 	movabs $0x803830,%rax
  804559:	00 00 00 
  80455c:	ff d0                	callq  *%rax
	return 0;
  80455e:	b8 00 00 00 00       	mov    $0x0,%eax
	
}
  804563:	c9                   	leaveq 
  804564:	c3                   	retq   

0000000000804565 <fd2sockid>:
	.dev_stat =	devsock_stat,
};

static int
fd2sockid(int fd)
{
  804565:	55                   	push   %rbp
  804566:	48 89 e5             	mov    %rsp,%rbp
  804569:	48 83 ec 20          	sub    $0x20,%rsp
  80456d:	89 7d ec             	mov    %edi,-0x14(%rbp)
	struct Fd *sfd;
	int r;

	if ((r = fd_lookup(fd, &sfd)) < 0)
  804570:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  804574:	8b 45 ec             	mov    -0x14(%rbp),%eax
  804577:	48 89 d6             	mov    %rdx,%rsi
  80457a:	89 c7                	mov    %eax,%edi
  80457c:	48 b8 20 36 80 00 00 	movabs $0x803620,%rax
  804583:	00 00 00 
  804586:	ff d0                	callq  *%rax
  804588:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80458b:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80458f:	79 05                	jns    804596 <fd2sockid+0x31>
		return r;
  804591:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804594:	eb 24                	jmp    8045ba <fd2sockid+0x55>
	if (sfd->fd_dev_id != devsock.dev_id)
  804596:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80459a:	8b 10                	mov    (%rax),%edx
  80459c:	48 b8 a0 80 82 00 00 	movabs $0x8280a0,%rax
  8045a3:	00 00 00 
  8045a6:	8b 00                	mov    (%rax),%eax
  8045a8:	39 c2                	cmp    %eax,%edx
  8045aa:	74 07                	je     8045b3 <fd2sockid+0x4e>
		return -E_NOT_SUPP;
  8045ac:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  8045b1:	eb 07                	jmp    8045ba <fd2sockid+0x55>
	return sfd->fd_sock.sockid;
  8045b3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8045b7:	8b 40 0c             	mov    0xc(%rax),%eax
}
  8045ba:	c9                   	leaveq 
  8045bb:	c3                   	retq   

00000000008045bc <alloc_sockfd>:

static int
alloc_sockfd(int sockid)
{
  8045bc:	55                   	push   %rbp
  8045bd:	48 89 e5             	mov    %rsp,%rbp
  8045c0:	48 83 ec 20          	sub    $0x20,%rsp
  8045c4:	89 7d ec             	mov    %edi,-0x14(%rbp)
	struct Fd *sfd;
	int r;

	if ((r = fd_alloc(&sfd)) < 0
  8045c7:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  8045cb:	48 89 c7             	mov    %rax,%rdi
  8045ce:	48 b8 88 35 80 00 00 	movabs $0x803588,%rax
  8045d5:	00 00 00 
  8045d8:	ff d0                	callq  *%rax
  8045da:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8045dd:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8045e1:	78 26                	js     804609 <alloc_sockfd+0x4d>
            || (r = sys_page_alloc(0, sfd, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0) {
  8045e3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8045e7:	ba 07 04 00 00       	mov    $0x407,%edx
  8045ec:	48 89 c6             	mov    %rax,%rsi
  8045ef:	bf 00 00 00 00       	mov    $0x0,%edi
  8045f4:	48 b8 06 28 80 00 00 	movabs $0x802806,%rax
  8045fb:	00 00 00 
  8045fe:	ff d0                	callq  *%rax
  804600:	89 45 fc             	mov    %eax,-0x4(%rbp)
  804603:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804607:	79 16                	jns    80461f <alloc_sockfd+0x63>
		nsipc_close(sockid);
  804609:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80460c:	89 c7                	mov    %eax,%edi
  80460e:	48 b8 c9 4a 80 00 00 	movabs $0x804ac9,%rax
  804615:	00 00 00 
  804618:	ff d0                	callq  *%rax
		return r;
  80461a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80461d:	eb 3a                	jmp    804659 <alloc_sockfd+0x9d>
	}

	sfd->fd_dev_id = devsock.dev_id;
  80461f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804623:	48 ba a0 80 82 00 00 	movabs $0x8280a0,%rdx
  80462a:	00 00 00 
  80462d:	8b 12                	mov    (%rdx),%edx
  80462f:	89 10                	mov    %edx,(%rax)
	sfd->fd_omode = O_RDWR;
  804631:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804635:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%rax)
	sfd->fd_sock.sockid = sockid;
  80463c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804640:	8b 55 ec             	mov    -0x14(%rbp),%edx
  804643:	89 50 0c             	mov    %edx,0xc(%rax)
	return fd2num(sfd);
  804646:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80464a:	48 89 c7             	mov    %rax,%rdi
  80464d:	48 b8 3a 35 80 00 00 	movabs $0x80353a,%rax
  804654:	00 00 00 
  804657:	ff d0                	callq  *%rax
}
  804659:	c9                   	leaveq 
  80465a:	c3                   	retq   

000000000080465b <accept>:

int
accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  80465b:	55                   	push   %rbp
  80465c:	48 89 e5             	mov    %rsp,%rbp
  80465f:	48 83 ec 30          	sub    $0x30,%rsp
  804663:	89 7d ec             	mov    %edi,-0x14(%rbp)
  804666:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80466a:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int r;
	if ((r = fd2sockid(s)) < 0)
  80466e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  804671:	89 c7                	mov    %eax,%edi
  804673:	48 b8 65 45 80 00 00 	movabs $0x804565,%rax
  80467a:	00 00 00 
  80467d:	ff d0                	callq  *%rax
  80467f:	89 45 fc             	mov    %eax,-0x4(%rbp)
  804682:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804686:	79 05                	jns    80468d <accept+0x32>
		return r;
  804688:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80468b:	eb 3b                	jmp    8046c8 <accept+0x6d>
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  80468d:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  804691:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  804695:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804698:	48 89 ce             	mov    %rcx,%rsi
  80469b:	89 c7                	mov    %eax,%edi
  80469d:	48 b8 a6 49 80 00 00 	movabs $0x8049a6,%rax
  8046a4:	00 00 00 
  8046a7:	ff d0                	callq  *%rax
  8046a9:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8046ac:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8046b0:	79 05                	jns    8046b7 <accept+0x5c>
		return r;
  8046b2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8046b5:	eb 11                	jmp    8046c8 <accept+0x6d>
	return alloc_sockfd(r);
  8046b7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8046ba:	89 c7                	mov    %eax,%edi
  8046bc:	48 b8 bc 45 80 00 00 	movabs $0x8045bc,%rax
  8046c3:	00 00 00 
  8046c6:	ff d0                	callq  *%rax
}
  8046c8:	c9                   	leaveq 
  8046c9:	c3                   	retq   

00000000008046ca <bind>:

int
bind(int s, struct sockaddr *name, socklen_t namelen)
{
  8046ca:	55                   	push   %rbp
  8046cb:	48 89 e5             	mov    %rsp,%rbp
  8046ce:	48 83 ec 20          	sub    $0x20,%rsp
  8046d2:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8046d5:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8046d9:	89 55 e8             	mov    %edx,-0x18(%rbp)
	int r;
	if ((r = fd2sockid(s)) < 0)
  8046dc:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8046df:	89 c7                	mov    %eax,%edi
  8046e1:	48 b8 65 45 80 00 00 	movabs $0x804565,%rax
  8046e8:	00 00 00 
  8046eb:	ff d0                	callq  *%rax
  8046ed:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8046f0:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8046f4:	79 05                	jns    8046fb <bind+0x31>
		return r;
  8046f6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8046f9:	eb 1b                	jmp    804716 <bind+0x4c>
	return nsipc_bind(r, name, namelen);
  8046fb:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8046fe:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  804702:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804705:	48 89 ce             	mov    %rcx,%rsi
  804708:	89 c7                	mov    %eax,%edi
  80470a:	48 b8 25 4a 80 00 00 	movabs $0x804a25,%rax
  804711:	00 00 00 
  804714:	ff d0                	callq  *%rax
}
  804716:	c9                   	leaveq 
  804717:	c3                   	retq   

0000000000804718 <shutdown>:

int
shutdown(int s, int how)
{
  804718:	55                   	push   %rbp
  804719:	48 89 e5             	mov    %rsp,%rbp
  80471c:	48 83 ec 20          	sub    $0x20,%rsp
  804720:	89 7d ec             	mov    %edi,-0x14(%rbp)
  804723:	89 75 e8             	mov    %esi,-0x18(%rbp)
	int r;
	if ((r = fd2sockid(s)) < 0)
  804726:	8b 45 ec             	mov    -0x14(%rbp),%eax
  804729:	89 c7                	mov    %eax,%edi
  80472b:	48 b8 65 45 80 00 00 	movabs $0x804565,%rax
  804732:	00 00 00 
  804735:	ff d0                	callq  *%rax
  804737:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80473a:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80473e:	79 05                	jns    804745 <shutdown+0x2d>
		return r;
  804740:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804743:	eb 16                	jmp    80475b <shutdown+0x43>
	return nsipc_shutdown(r, how);
  804745:	8b 55 e8             	mov    -0x18(%rbp),%edx
  804748:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80474b:	89 d6                	mov    %edx,%esi
  80474d:	89 c7                	mov    %eax,%edi
  80474f:	48 b8 89 4a 80 00 00 	movabs $0x804a89,%rax
  804756:	00 00 00 
  804759:	ff d0                	callq  *%rax
}
  80475b:	c9                   	leaveq 
  80475c:	c3                   	retq   

000000000080475d <devsock_close>:

static int
devsock_close(struct Fd *fd)
{
  80475d:	55                   	push   %rbp
  80475e:	48 89 e5             	mov    %rsp,%rbp
  804761:	48 83 ec 10          	sub    $0x10,%rsp
  804765:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (pageref(fd) == 1)
  804769:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80476d:	48 89 c7             	mov    %rax,%rdi
  804770:	48 b8 9f 5c 80 00 00 	movabs $0x805c9f,%rax
  804777:	00 00 00 
  80477a:	ff d0                	callq  *%rax
  80477c:	83 f8 01             	cmp    $0x1,%eax
  80477f:	75 17                	jne    804798 <devsock_close+0x3b>
		return nsipc_close(fd->fd_sock.sockid);
  804781:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804785:	8b 40 0c             	mov    0xc(%rax),%eax
  804788:	89 c7                	mov    %eax,%edi
  80478a:	48 b8 c9 4a 80 00 00 	movabs $0x804ac9,%rax
  804791:	00 00 00 
  804794:	ff d0                	callq  *%rax
  804796:	eb 05                	jmp    80479d <devsock_close+0x40>
	else
		return 0;
  804798:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80479d:	c9                   	leaveq 
  80479e:	c3                   	retq   

000000000080479f <connect>:

int
connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  80479f:	55                   	push   %rbp
  8047a0:	48 89 e5             	mov    %rsp,%rbp
  8047a3:	48 83 ec 20          	sub    $0x20,%rsp
  8047a7:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8047aa:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8047ae:	89 55 e8             	mov    %edx,-0x18(%rbp)
	int r;
	if ((r = fd2sockid(s)) < 0)
  8047b1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8047b4:	89 c7                	mov    %eax,%edi
  8047b6:	48 b8 65 45 80 00 00 	movabs $0x804565,%rax
  8047bd:	00 00 00 
  8047c0:	ff d0                	callq  *%rax
  8047c2:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8047c5:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8047c9:	79 05                	jns    8047d0 <connect+0x31>
		return r;
  8047cb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8047ce:	eb 1b                	jmp    8047eb <connect+0x4c>
	return nsipc_connect(r, name, namelen);
  8047d0:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8047d3:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8047d7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8047da:	48 89 ce             	mov    %rcx,%rsi
  8047dd:	89 c7                	mov    %eax,%edi
  8047df:	48 b8 f6 4a 80 00 00 	movabs $0x804af6,%rax
  8047e6:	00 00 00 
  8047e9:	ff d0                	callq  *%rax
}
  8047eb:	c9                   	leaveq 
  8047ec:	c3                   	retq   

00000000008047ed <listen>:

int
listen(int s, int backlog)
{
  8047ed:	55                   	push   %rbp
  8047ee:	48 89 e5             	mov    %rsp,%rbp
  8047f1:	48 83 ec 20          	sub    $0x20,%rsp
  8047f5:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8047f8:	89 75 e8             	mov    %esi,-0x18(%rbp)
	int r;
	if ((r = fd2sockid(s)) < 0)
  8047fb:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8047fe:	89 c7                	mov    %eax,%edi
  804800:	48 b8 65 45 80 00 00 	movabs $0x804565,%rax
  804807:	00 00 00 
  80480a:	ff d0                	callq  *%rax
  80480c:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80480f:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804813:	79 05                	jns    80481a <listen+0x2d>
		return r;
  804815:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804818:	eb 16                	jmp    804830 <listen+0x43>
	return nsipc_listen(r, backlog);
  80481a:	8b 55 e8             	mov    -0x18(%rbp),%edx
  80481d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804820:	89 d6                	mov    %edx,%esi
  804822:	89 c7                	mov    %eax,%edi
  804824:	48 b8 5a 4b 80 00 00 	movabs $0x804b5a,%rax
  80482b:	00 00 00 
  80482e:	ff d0                	callq  *%rax
}
  804830:	c9                   	leaveq 
  804831:	c3                   	retq   

0000000000804832 <devsock_read>:

static ssize_t
devsock_read(struct Fd *fd, void *buf, size_t n)
{
  804832:	55                   	push   %rbp
  804833:	48 89 e5             	mov    %rsp,%rbp
  804836:	48 83 ec 20          	sub    $0x20,%rsp
  80483a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80483e:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  804842:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
  804846:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80484a:	89 c2                	mov    %eax,%edx
  80484c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804850:	8b 40 0c             	mov    0xc(%rax),%eax
  804853:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  804857:	b9 00 00 00 00       	mov    $0x0,%ecx
  80485c:	89 c7                	mov    %eax,%edi
  80485e:	48 b8 9a 4b 80 00 00 	movabs $0x804b9a,%rax
  804865:	00 00 00 
  804868:	ff d0                	callq  *%rax
}
  80486a:	c9                   	leaveq 
  80486b:	c3                   	retq   

000000000080486c <devsock_write>:

static ssize_t
devsock_write(struct Fd *fd, const void *buf, size_t n)
{
  80486c:	55                   	push   %rbp
  80486d:	48 89 e5             	mov    %rsp,%rbp
  804870:	48 83 ec 20          	sub    $0x20,%rsp
  804874:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  804878:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80487c:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
  804880:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804884:	89 c2                	mov    %eax,%edx
  804886:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80488a:	8b 40 0c             	mov    0xc(%rax),%eax
  80488d:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  804891:	b9 00 00 00 00       	mov    $0x0,%ecx
  804896:	89 c7                	mov    %eax,%edi
  804898:	48 b8 66 4c 80 00 00 	movabs $0x804c66,%rax
  80489f:	00 00 00 
  8048a2:	ff d0                	callq  *%rax
}
  8048a4:	c9                   	leaveq 
  8048a5:	c3                   	retq   

00000000008048a6 <devsock_stat>:

static int
devsock_stat(struct Fd *fd, struct Stat *stat)
{
  8048a6:	55                   	push   %rbp
  8048a7:	48 89 e5             	mov    %rsp,%rbp
  8048aa:	48 83 ec 10          	sub    $0x10,%rsp
  8048ae:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8048b2:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	strcpy(stat->st_name, "<sock>");
  8048b6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8048ba:	48 be 27 15 82 00 00 	movabs $0x821527,%rsi
  8048c1:	00 00 00 
  8048c4:	48 89 c7             	mov    %rax,%rdi
  8048c7:	48 b8 d7 1e 80 00 00 	movabs $0x801ed7,%rax
  8048ce:	00 00 00 
  8048d1:	ff d0                	callq  *%rax
	return 0;
  8048d3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8048d8:	c9                   	leaveq 
  8048d9:	c3                   	retq   

00000000008048da <socket>:

int
socket(int domain, int type, int protocol)
{
  8048da:	55                   	push   %rbp
  8048db:	48 89 e5             	mov    %rsp,%rbp
  8048de:	48 83 ec 20          	sub    $0x20,%rsp
  8048e2:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8048e5:	89 75 e8             	mov    %esi,-0x18(%rbp)
  8048e8:	89 55 e4             	mov    %edx,-0x1c(%rbp)
	int r;
	if ((r = nsipc_socket(domain, type, protocol)) < 0)
  8048eb:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8048ee:	8b 4d e8             	mov    -0x18(%rbp),%ecx
  8048f1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8048f4:	89 ce                	mov    %ecx,%esi
  8048f6:	89 c7                	mov    %eax,%edi
  8048f8:	48 b8 1e 4d 80 00 00 	movabs $0x804d1e,%rax
  8048ff:	00 00 00 
  804902:	ff d0                	callq  *%rax
  804904:	89 45 fc             	mov    %eax,-0x4(%rbp)
  804907:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80490b:	79 05                	jns    804912 <socket+0x38>
		return r;
  80490d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804910:	eb 11                	jmp    804923 <socket+0x49>
	return alloc_sockfd(r);
  804912:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804915:	89 c7                	mov    %eax,%edi
  804917:	48 b8 bc 45 80 00 00 	movabs $0x8045bc,%rax
  80491e:	00 00 00 
  804921:	ff d0                	callq  *%rax
}
  804923:	c9                   	leaveq 
  804924:	c3                   	retq   

0000000000804925 <nsipc>:
// may be written back to nsipcbuf.
// type: request code, passed as the simple integer IPC value.
// Returns 0 if successful, < 0 on failure.
static int
nsipc(unsigned type)
{
  804925:	55                   	push   %rbp
  804926:	48 89 e5             	mov    %rsp,%rbp
  804929:	48 83 ec 10          	sub    $0x10,%rsp
  80492d:	89 7d fc             	mov    %edi,-0x4(%rbp)
	static envid_t nsenv;
	if (nsenv == 0)
  804930:	48 b8 88 90 82 00 00 	movabs $0x829088,%rax
  804937:	00 00 00 
  80493a:	8b 00                	mov    (%rax),%eax
  80493c:	85 c0                	test   %eax,%eax
  80493e:	75 1d                	jne    80495d <nsipc+0x38>
		nsenv = ipc_find_env(ENV_TYPE_NS);
  804940:	bf 02 00 00 00       	mov    $0x2,%edi
  804945:	48 b8 c8 34 80 00 00 	movabs $0x8034c8,%rax
  80494c:	00 00 00 
  80494f:	ff d0                	callq  *%rax
  804951:	48 ba 88 90 82 00 00 	movabs $0x829088,%rdx
  804958:	00 00 00 
  80495b:	89 02                	mov    %eax,(%rdx)
	static_assert(sizeof(nsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] nsipc %d\n", thisenv->env_id, type);

	ipc_send(nsenv, type, &nsipcbuf, PTE_P|PTE_W|PTE_U);
  80495d:	48 b8 88 90 82 00 00 	movabs $0x829088,%rax
  804964:	00 00 00 
  804967:	8b 00                	mov    (%rax),%eax
  804969:	8b 75 fc             	mov    -0x4(%rbp),%esi
  80496c:	b9 07 00 00 00       	mov    $0x7,%ecx
  804971:	48 ba 00 a0 b5 00 00 	movabs $0xb5a000,%rdx
  804978:	00 00 00 
  80497b:	89 c7                	mov    %eax,%edi
  80497d:	48 b8 bc 32 80 00 00 	movabs $0x8032bc,%rax
  804984:	00 00 00 
  804987:	ff d0                	callq  *%rax
	return ipc_recv(NULL, NULL, NULL);
  804989:	ba 00 00 00 00       	mov    $0x0,%edx
  80498e:	be 00 00 00 00       	mov    $0x0,%esi
  804993:	bf 00 00 00 00       	mov    $0x0,%edi
  804998:	48 b8 fb 31 80 00 00 	movabs $0x8031fb,%rax
  80499f:	00 00 00 
  8049a2:	ff d0                	callq  *%rax
}
  8049a4:	c9                   	leaveq 
  8049a5:	c3                   	retq   

00000000008049a6 <nsipc_accept>:

int
nsipc_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  8049a6:	55                   	push   %rbp
  8049a7:	48 89 e5             	mov    %rsp,%rbp
  8049aa:	48 83 ec 30          	sub    $0x30,%rsp
  8049ae:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8049b1:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8049b5:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int r;

	nsipcbuf.accept.req_s = s;
  8049b9:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  8049c0:	00 00 00 
  8049c3:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8049c6:	89 10                	mov    %edx,(%rax)
	if ((r = nsipc(NSREQ_ACCEPT)) >= 0) {
  8049c8:	bf 01 00 00 00       	mov    $0x1,%edi
  8049cd:	48 b8 25 49 80 00 00 	movabs $0x804925,%rax
  8049d4:	00 00 00 
  8049d7:	ff d0                	callq  *%rax
  8049d9:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8049dc:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8049e0:	78 3e                	js     804a20 <nsipc_accept+0x7a>
		struct Nsret_accept *ret = &nsipcbuf.acceptRet;
  8049e2:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  8049e9:	00 00 00 
  8049ec:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
  8049f0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8049f4:	8b 40 10             	mov    0x10(%rax),%eax
  8049f7:	89 c2                	mov    %eax,%edx
  8049f9:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  8049fd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  804a01:	48 89 ce             	mov    %rcx,%rsi
  804a04:	48 89 c7             	mov    %rax,%rdi
  804a07:	48 b8 fb 21 80 00 00 	movabs $0x8021fb,%rax
  804a0e:	00 00 00 
  804a11:	ff d0                	callq  *%rax
		*addrlen = ret->ret_addrlen;
  804a13:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804a17:	8b 50 10             	mov    0x10(%rax),%edx
  804a1a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  804a1e:	89 10                	mov    %edx,(%rax)
	}
	return r;
  804a20:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  804a23:	c9                   	leaveq 
  804a24:	c3                   	retq   

0000000000804a25 <nsipc_bind>:

int
nsipc_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  804a25:	55                   	push   %rbp
  804a26:	48 89 e5             	mov    %rsp,%rbp
  804a29:	48 83 ec 10          	sub    $0x10,%rsp
  804a2d:	89 7d fc             	mov    %edi,-0x4(%rbp)
  804a30:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  804a34:	89 55 f8             	mov    %edx,-0x8(%rbp)
	nsipcbuf.bind.req_s = s;
  804a37:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804a3e:	00 00 00 
  804a41:	8b 55 fc             	mov    -0x4(%rbp),%edx
  804a44:	89 10                	mov    %edx,(%rax)
	memmove(&nsipcbuf.bind.req_name, name, namelen);
  804a46:	8b 55 f8             	mov    -0x8(%rbp),%edx
  804a49:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804a4d:	48 89 c6             	mov    %rax,%rsi
  804a50:	48 bf 04 a0 b5 00 00 	movabs $0xb5a004,%rdi
  804a57:	00 00 00 
  804a5a:	48 b8 fb 21 80 00 00 	movabs $0x8021fb,%rax
  804a61:	00 00 00 
  804a64:	ff d0                	callq  *%rax
	nsipcbuf.bind.req_namelen = namelen;
  804a66:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804a6d:	00 00 00 
  804a70:	8b 55 f8             	mov    -0x8(%rbp),%edx
  804a73:	89 50 14             	mov    %edx,0x14(%rax)
	return nsipc(NSREQ_BIND);
  804a76:	bf 02 00 00 00       	mov    $0x2,%edi
  804a7b:	48 b8 25 49 80 00 00 	movabs $0x804925,%rax
  804a82:	00 00 00 
  804a85:	ff d0                	callq  *%rax
}
  804a87:	c9                   	leaveq 
  804a88:	c3                   	retq   

0000000000804a89 <nsipc_shutdown>:

int
nsipc_shutdown(int s, int how)
{
  804a89:	55                   	push   %rbp
  804a8a:	48 89 e5             	mov    %rsp,%rbp
  804a8d:	48 83 ec 10          	sub    $0x10,%rsp
  804a91:	89 7d fc             	mov    %edi,-0x4(%rbp)
  804a94:	89 75 f8             	mov    %esi,-0x8(%rbp)
	nsipcbuf.shutdown.req_s = s;
  804a97:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804a9e:	00 00 00 
  804aa1:	8b 55 fc             	mov    -0x4(%rbp),%edx
  804aa4:	89 10                	mov    %edx,(%rax)
	nsipcbuf.shutdown.req_how = how;
  804aa6:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804aad:	00 00 00 
  804ab0:	8b 55 f8             	mov    -0x8(%rbp),%edx
  804ab3:	89 50 04             	mov    %edx,0x4(%rax)
	return nsipc(NSREQ_SHUTDOWN);
  804ab6:	bf 03 00 00 00       	mov    $0x3,%edi
  804abb:	48 b8 25 49 80 00 00 	movabs $0x804925,%rax
  804ac2:	00 00 00 
  804ac5:	ff d0                	callq  *%rax
}
  804ac7:	c9                   	leaveq 
  804ac8:	c3                   	retq   

0000000000804ac9 <nsipc_close>:

int
nsipc_close(int s)
{
  804ac9:	55                   	push   %rbp
  804aca:	48 89 e5             	mov    %rsp,%rbp
  804acd:	48 83 ec 10          	sub    $0x10,%rsp
  804ad1:	89 7d fc             	mov    %edi,-0x4(%rbp)
	nsipcbuf.close.req_s = s;
  804ad4:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804adb:	00 00 00 
  804ade:	8b 55 fc             	mov    -0x4(%rbp),%edx
  804ae1:	89 10                	mov    %edx,(%rax)
	return nsipc(NSREQ_CLOSE);
  804ae3:	bf 04 00 00 00       	mov    $0x4,%edi
  804ae8:	48 b8 25 49 80 00 00 	movabs $0x804925,%rax
  804aef:	00 00 00 
  804af2:	ff d0                	callq  *%rax
}
  804af4:	c9                   	leaveq 
  804af5:	c3                   	retq   

0000000000804af6 <nsipc_connect>:

int
nsipc_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  804af6:	55                   	push   %rbp
  804af7:	48 89 e5             	mov    %rsp,%rbp
  804afa:	48 83 ec 10          	sub    $0x10,%rsp
  804afe:	89 7d fc             	mov    %edi,-0x4(%rbp)
  804b01:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  804b05:	89 55 f8             	mov    %edx,-0x8(%rbp)
	nsipcbuf.connect.req_s = s;
  804b08:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804b0f:	00 00 00 
  804b12:	8b 55 fc             	mov    -0x4(%rbp),%edx
  804b15:	89 10                	mov    %edx,(%rax)
	memmove(&nsipcbuf.connect.req_name, name, namelen);
  804b17:	8b 55 f8             	mov    -0x8(%rbp),%edx
  804b1a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804b1e:	48 89 c6             	mov    %rax,%rsi
  804b21:	48 bf 04 a0 b5 00 00 	movabs $0xb5a004,%rdi
  804b28:	00 00 00 
  804b2b:	48 b8 fb 21 80 00 00 	movabs $0x8021fb,%rax
  804b32:	00 00 00 
  804b35:	ff d0                	callq  *%rax
	nsipcbuf.connect.req_namelen = namelen;
  804b37:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804b3e:	00 00 00 
  804b41:	8b 55 f8             	mov    -0x8(%rbp),%edx
  804b44:	89 50 14             	mov    %edx,0x14(%rax)
	return nsipc(NSREQ_CONNECT);
  804b47:	bf 05 00 00 00       	mov    $0x5,%edi
  804b4c:	48 b8 25 49 80 00 00 	movabs $0x804925,%rax
  804b53:	00 00 00 
  804b56:	ff d0                	callq  *%rax
}
  804b58:	c9                   	leaveq 
  804b59:	c3                   	retq   

0000000000804b5a <nsipc_listen>:

int
nsipc_listen(int s, int backlog)
{
  804b5a:	55                   	push   %rbp
  804b5b:	48 89 e5             	mov    %rsp,%rbp
  804b5e:	48 83 ec 10          	sub    $0x10,%rsp
  804b62:	89 7d fc             	mov    %edi,-0x4(%rbp)
  804b65:	89 75 f8             	mov    %esi,-0x8(%rbp)
	nsipcbuf.listen.req_s = s;
  804b68:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804b6f:	00 00 00 
  804b72:	8b 55 fc             	mov    -0x4(%rbp),%edx
  804b75:	89 10                	mov    %edx,(%rax)
	nsipcbuf.listen.req_backlog = backlog;
  804b77:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804b7e:	00 00 00 
  804b81:	8b 55 f8             	mov    -0x8(%rbp),%edx
  804b84:	89 50 04             	mov    %edx,0x4(%rax)
	return nsipc(NSREQ_LISTEN);
  804b87:	bf 06 00 00 00       	mov    $0x6,%edi
  804b8c:	48 b8 25 49 80 00 00 	movabs $0x804925,%rax
  804b93:	00 00 00 
  804b96:	ff d0                	callq  *%rax
}
  804b98:	c9                   	leaveq 
  804b99:	c3                   	retq   

0000000000804b9a <nsipc_recv>:

int
nsipc_recv(int s, void *mem, int len, unsigned int flags)
{
  804b9a:	55                   	push   %rbp
  804b9b:	48 89 e5             	mov    %rsp,%rbp
  804b9e:	48 83 ec 30          	sub    $0x30,%rsp
  804ba2:	89 7d ec             	mov    %edi,-0x14(%rbp)
  804ba5:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  804ba9:	89 55 e8             	mov    %edx,-0x18(%rbp)
  804bac:	89 4d dc             	mov    %ecx,-0x24(%rbp)
	int r;

	nsipcbuf.recv.req_s = s;
  804baf:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804bb6:	00 00 00 
  804bb9:	8b 55 ec             	mov    -0x14(%rbp),%edx
  804bbc:	89 10                	mov    %edx,(%rax)
	nsipcbuf.recv.req_len = len;
  804bbe:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804bc5:	00 00 00 
  804bc8:	8b 55 e8             	mov    -0x18(%rbp),%edx
  804bcb:	89 50 04             	mov    %edx,0x4(%rax)
	nsipcbuf.recv.req_flags = flags;
  804bce:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804bd5:	00 00 00 
  804bd8:	8b 55 dc             	mov    -0x24(%rbp),%edx
  804bdb:	89 50 08             	mov    %edx,0x8(%rax)

	if ((r = nsipc(NSREQ_RECV)) >= 0) {
  804bde:	bf 07 00 00 00       	mov    $0x7,%edi
  804be3:	48 b8 25 49 80 00 00 	movabs $0x804925,%rax
  804bea:	00 00 00 
  804bed:	ff d0                	callq  *%rax
  804bef:	89 45 fc             	mov    %eax,-0x4(%rbp)
  804bf2:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804bf6:	78 69                	js     804c61 <nsipc_recv+0xc7>
		assert(r < 1600 && r <= len);
  804bf8:	81 7d fc 3f 06 00 00 	cmpl   $0x63f,-0x4(%rbp)
  804bff:	7f 08                	jg     804c09 <nsipc_recv+0x6f>
  804c01:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804c04:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  804c07:	7e 35                	jle    804c3e <nsipc_recv+0xa4>
  804c09:	48 b9 2e 15 82 00 00 	movabs $0x82152e,%rcx
  804c10:	00 00 00 
  804c13:	48 ba 43 15 82 00 00 	movabs $0x821543,%rdx
  804c1a:	00 00 00 
  804c1d:	be 62 00 00 00       	mov    $0x62,%esi
  804c22:	48 bf 58 15 82 00 00 	movabs $0x821558,%rdi
  804c29:	00 00 00 
  804c2c:	b8 00 00 00 00       	mov    $0x0,%eax
  804c31:	49 b8 e9 10 80 00 00 	movabs $0x8010e9,%r8
  804c38:	00 00 00 
  804c3b:	41 ff d0             	callq  *%r8
		memmove(mem, nsipcbuf.recvRet.ret_buf, r);
  804c3e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804c41:	48 63 d0             	movslq %eax,%rdx
  804c44:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  804c48:	48 be 00 a0 b5 00 00 	movabs $0xb5a000,%rsi
  804c4f:	00 00 00 
  804c52:	48 89 c7             	mov    %rax,%rdi
  804c55:	48 b8 fb 21 80 00 00 	movabs $0x8021fb,%rax
  804c5c:	00 00 00 
  804c5f:	ff d0                	callq  *%rax
	}

	return r;
  804c61:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  804c64:	c9                   	leaveq 
  804c65:	c3                   	retq   

0000000000804c66 <nsipc_send>:

int
nsipc_send(int s, const void *buf, int size, unsigned int flags)
{
  804c66:	55                   	push   %rbp
  804c67:	48 89 e5             	mov    %rsp,%rbp
  804c6a:	48 83 ec 20          	sub    $0x20,%rsp
  804c6e:	89 7d fc             	mov    %edi,-0x4(%rbp)
  804c71:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  804c75:	89 55 f8             	mov    %edx,-0x8(%rbp)
  804c78:	89 4d ec             	mov    %ecx,-0x14(%rbp)
	nsipcbuf.send.req_s = s;
  804c7b:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804c82:	00 00 00 
  804c85:	8b 55 fc             	mov    -0x4(%rbp),%edx
  804c88:	89 10                	mov    %edx,(%rax)
	assert(size < 1600);
  804c8a:	81 7d f8 3f 06 00 00 	cmpl   $0x63f,-0x8(%rbp)
  804c91:	7e 35                	jle    804cc8 <nsipc_send+0x62>
  804c93:	48 b9 64 15 82 00 00 	movabs $0x821564,%rcx
  804c9a:	00 00 00 
  804c9d:	48 ba 43 15 82 00 00 	movabs $0x821543,%rdx
  804ca4:	00 00 00 
  804ca7:	be 6d 00 00 00       	mov    $0x6d,%esi
  804cac:	48 bf 58 15 82 00 00 	movabs $0x821558,%rdi
  804cb3:	00 00 00 
  804cb6:	b8 00 00 00 00       	mov    $0x0,%eax
  804cbb:	49 b8 e9 10 80 00 00 	movabs $0x8010e9,%r8
  804cc2:	00 00 00 
  804cc5:	41 ff d0             	callq  *%r8
	memmove(&nsipcbuf.send.req_buf, buf, size);
  804cc8:	8b 45 f8             	mov    -0x8(%rbp),%eax
  804ccb:	48 63 d0             	movslq %eax,%rdx
  804cce:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804cd2:	48 89 c6             	mov    %rax,%rsi
  804cd5:	48 bf 0c a0 b5 00 00 	movabs $0xb5a00c,%rdi
  804cdc:	00 00 00 
  804cdf:	48 b8 fb 21 80 00 00 	movabs $0x8021fb,%rax
  804ce6:	00 00 00 
  804ce9:	ff d0                	callq  *%rax
	nsipcbuf.send.req_size = size;
  804ceb:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804cf2:	00 00 00 
  804cf5:	8b 55 f8             	mov    -0x8(%rbp),%edx
  804cf8:	89 50 04             	mov    %edx,0x4(%rax)
	nsipcbuf.send.req_flags = flags;
  804cfb:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804d02:	00 00 00 
  804d05:	8b 55 ec             	mov    -0x14(%rbp),%edx
  804d08:	89 50 08             	mov    %edx,0x8(%rax)
	return nsipc(NSREQ_SEND);
  804d0b:	bf 08 00 00 00       	mov    $0x8,%edi
  804d10:	48 b8 25 49 80 00 00 	movabs $0x804925,%rax
  804d17:	00 00 00 
  804d1a:	ff d0                	callq  *%rax
}
  804d1c:	c9                   	leaveq 
  804d1d:	c3                   	retq   

0000000000804d1e <nsipc_socket>:

int
nsipc_socket(int domain, int type, int protocol)
{
  804d1e:	55                   	push   %rbp
  804d1f:	48 89 e5             	mov    %rsp,%rbp
  804d22:	48 83 ec 10          	sub    $0x10,%rsp
  804d26:	89 7d fc             	mov    %edi,-0x4(%rbp)
  804d29:	89 75 f8             	mov    %esi,-0x8(%rbp)
  804d2c:	89 55 f4             	mov    %edx,-0xc(%rbp)
	nsipcbuf.socket.req_domain = domain;
  804d2f:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804d36:	00 00 00 
  804d39:	8b 55 fc             	mov    -0x4(%rbp),%edx
  804d3c:	89 10                	mov    %edx,(%rax)
	nsipcbuf.socket.req_type = type;
  804d3e:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804d45:	00 00 00 
  804d48:	8b 55 f8             	mov    -0x8(%rbp),%edx
  804d4b:	89 50 04             	mov    %edx,0x4(%rax)
	nsipcbuf.socket.req_protocol = protocol;
  804d4e:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804d55:	00 00 00 
  804d58:	8b 55 f4             	mov    -0xc(%rbp),%edx
  804d5b:	89 50 08             	mov    %edx,0x8(%rax)
	return nsipc(NSREQ_SOCKET);
  804d5e:	bf 09 00 00 00       	mov    $0x9,%edi
  804d63:	48 b8 25 49 80 00 00 	movabs $0x804925,%rax
  804d6a:	00 00 00 
  804d6d:	ff d0                	callq  *%rax
}
  804d6f:	c9                   	leaveq 
  804d70:	c3                   	retq   

0000000000804d71 <isfree>:
static uint8_t *mend   = (uint8_t*) 0x10000000;
static uint8_t *mptr;

static int
isfree(void *v, size_t n)
{
  804d71:	55                   	push   %rbp
  804d72:	48 89 e5             	mov    %rsp,%rbp
  804d75:	48 83 ec 20          	sub    $0x20,%rsp
  804d79:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  804d7d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	uintptr_t va, end_va = (uintptr_t) v + n;
  804d81:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  804d85:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  804d89:	48 01 d0             	add    %rdx,%rax
  804d8c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  804d90:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804d94:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  804d98:	eb 64                	jmp    804dfe <isfree+0x8d>
		if (va >= (uintptr_t) mend
  804d9a:	48 b8 e0 80 82 00 00 	movabs $0x8280e0,%rax
  804da1:	00 00 00 
  804da4:	48 8b 00             	mov    (%rax),%rax
  804da7:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  804dab:	76 42                	jbe    804def <isfree+0x7e>
		    || ((uvpd[VPD(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P)))
  804dad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804db1:	48 c1 e8 15          	shr    $0x15,%rax
  804db5:	48 89 c2             	mov    %rax,%rdx
  804db8:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  804dbf:	01 00 00 
  804dc2:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  804dc6:	83 e0 01             	and    $0x1,%eax
  804dc9:	48 85 c0             	test   %rax,%rax
  804dcc:	74 28                	je     804df6 <isfree+0x85>
  804dce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804dd2:	48 c1 e8 0c          	shr    $0xc,%rax
  804dd6:	48 89 c2             	mov    %rax,%rdx
  804dd9:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  804de0:	01 00 00 
  804de3:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  804de7:	83 e0 01             	and    $0x1,%eax
  804dea:	48 85 c0             	test   %rax,%rax
  804ded:	74 07                	je     804df6 <isfree+0x85>
			return 0;
  804def:	b8 00 00 00 00       	mov    $0x0,%eax
  804df4:	eb 17                	jmp    804e0d <isfree+0x9c>
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  804df6:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  804dfd:	00 
  804dfe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804e02:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  804e06:	72 92                	jb     804d9a <isfree+0x29>
		if (va >= (uintptr_t) mend
		    || ((uvpd[VPD(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P)))
			return 0;
	return 1;
  804e08:	b8 01 00 00 00       	mov    $0x1,%eax
}
  804e0d:	c9                   	leaveq 
  804e0e:	c3                   	retq   

0000000000804e0f <malloc>:

void*
malloc(size_t n)
{
  804e0f:	55                   	push   %rbp
  804e10:	48 89 e5             	mov    %rsp,%rbp
  804e13:	48 83 ec 60          	sub    $0x60,%rsp
  804e17:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
	int i, cont;
	int nwrap;
	uint32_t *ref;
	void *v;

	if (mptr == 0)
  804e1b:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804e22:	00 00 00 
  804e25:	48 8b 00             	mov    (%rax),%rax
  804e28:	48 85 c0             	test   %rax,%rax
  804e2b:	75 1a                	jne    804e47 <malloc+0x38>
		mptr = mbegin;
  804e2d:	48 b8 d8 80 82 00 00 	movabs $0x8280d8,%rax
  804e34:	00 00 00 
  804e37:	48 8b 10             	mov    (%rax),%rdx
  804e3a:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804e41:	00 00 00 
  804e44:	48 89 10             	mov    %rdx,(%rax)

	n = ROUNDUP(n, 4);
  804e47:	48 c7 45 f0 04 00 00 	movq   $0x4,-0x10(%rbp)
  804e4e:	00 
  804e4f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804e53:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  804e57:	48 01 d0             	add    %rdx,%rax
  804e5a:	48 83 e8 01          	sub    $0x1,%rax
  804e5e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  804e62:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804e66:	ba 00 00 00 00       	mov    $0x0,%edx
  804e6b:	48 f7 75 f0          	divq   -0x10(%rbp)
  804e6f:	48 89 d0             	mov    %rdx,%rax
  804e72:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  804e76:	48 29 c2             	sub    %rax,%rdx
  804e79:	48 89 d0             	mov    %rdx,%rax
  804e7c:	48 89 45 a8          	mov    %rax,-0x58(%rbp)

	if (n >= MAXMALLOC)
  804e80:	48 81 7d a8 ff ff 0f 	cmpq   $0xfffff,-0x58(%rbp)
  804e87:	00 
  804e88:	76 0a                	jbe    804e94 <malloc+0x85>
		return 0;
  804e8a:	b8 00 00 00 00       	mov    $0x0,%eax
  804e8f:	e9 f7 02 00 00       	jmpq   80518b <malloc+0x37c>

	if ((uintptr_t) mptr % PGSIZE){
  804e94:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804e9b:	00 00 00 
  804e9e:	48 8b 00             	mov    (%rax),%rax
  804ea1:	25 ff 0f 00 00       	and    $0xfff,%eax
  804ea6:	48 85 c0             	test   %rax,%rax
  804ea9:	0f 84 15 01 00 00    	je     804fc4 <malloc+0x1b5>
		/*
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
  804eaf:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  804eb6:	00 
  804eb7:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804ebe:	00 00 00 
  804ec1:	48 8b 00             	mov    (%rax),%rax
  804ec4:	48 89 c2             	mov    %rax,%rdx
  804ec7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  804ecb:	48 01 d0             	add    %rdx,%rax
  804ece:	48 83 e8 01          	sub    $0x1,%rax
  804ed2:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  804ed6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  804eda:	ba 00 00 00 00       	mov    $0x0,%edx
  804edf:	48 f7 75 e0          	divq   -0x20(%rbp)
  804ee3:	48 89 d0             	mov    %rdx,%rax
  804ee6:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  804eea:	48 29 c2             	sub    %rax,%rdx
  804eed:	48 89 d0             	mov    %rdx,%rax
  804ef0:	48 83 e8 04          	sub    $0x4,%rax
  804ef4:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
  804ef8:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804eff:	00 00 00 
  804f02:	48 8b 00             	mov    (%rax),%rax
  804f05:	48 c1 e8 0c          	shr    $0xc,%rax
  804f09:	48 89 c1             	mov    %rax,%rcx
  804f0c:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804f13:	00 00 00 
  804f16:	48 8b 00             	mov    (%rax),%rax
  804f19:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  804f1d:	48 83 c2 03          	add    $0x3,%rdx
  804f21:	48 01 d0             	add    %rdx,%rax
  804f24:	48 c1 e8 0c          	shr    $0xc,%rax
  804f28:	48 39 c1             	cmp    %rax,%rcx
  804f2b:	75 4a                	jne    804f77 <malloc+0x168>
			(*ref)++;
  804f2d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  804f31:	8b 00                	mov    (%rax),%eax
  804f33:	8d 50 01             	lea    0x1(%rax),%edx
  804f36:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  804f3a:	89 10                	mov    %edx,(%rax)
			v = mptr;
  804f3c:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804f43:	00 00 00 
  804f46:	48 8b 00             	mov    (%rax),%rax
  804f49:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			mptr += n;
  804f4d:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804f54:	00 00 00 
  804f57:	48 8b 10             	mov    (%rax),%rdx
  804f5a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  804f5e:	48 01 c2             	add    %rax,%rdx
  804f61:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804f68:	00 00 00 
  804f6b:	48 89 10             	mov    %rdx,(%rax)
			return v;
  804f6e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804f72:	e9 14 02 00 00       	jmpq   80518b <malloc+0x37c>
		}
		/*
		 * stop working on this page and move on.
		 */
		free(mptr);	/* drop reference to this page */
  804f77:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804f7e:	00 00 00 
  804f81:	48 8b 00             	mov    (%rax),%rax
  804f84:	48 89 c7             	mov    %rax,%rdi
  804f87:	48 b8 8d 51 80 00 00 	movabs $0x80518d,%rax
  804f8e:	00 00 00 
  804f91:	ff d0                	callq  *%rax
		mptr = ROUNDDOWN(mptr + PGSIZE, PGSIZE);
  804f93:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804f9a:	00 00 00 
  804f9d:	48 8b 00             	mov    (%rax),%rax
  804fa0:	48 05 00 10 00 00    	add    $0x1000,%rax
  804fa6:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804faa:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804fae:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  804fb4:	48 89 c2             	mov    %rax,%rdx
  804fb7:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804fbe:	00 00 00 
  804fc1:	48 89 10             	mov    %rdx,(%rax)
	 * now we need to find some address space for this chunk.
	 * if it's less than a page we leave it open for allocation.
	 * runs of more than a page can't have ref counts so we
	 * flag the PTE entries instead.
	 */
	nwrap = 0;
  804fc4:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	while (1) {
		if (isfree(mptr, n + 4))
  804fcb:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  804fcf:	48 8d 50 04          	lea    0x4(%rax),%rdx
  804fd3:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804fda:	00 00 00 
  804fdd:	48 8b 00             	mov    (%rax),%rax
  804fe0:	48 89 d6             	mov    %rdx,%rsi
  804fe3:	48 89 c7             	mov    %rax,%rdi
  804fe6:	48 b8 71 4d 80 00 00 	movabs $0x804d71,%rax
  804fed:	00 00 00 
  804ff0:	ff d0                	callq  *%rax
  804ff2:	85 c0                	test   %eax,%eax
  804ff4:	74 0d                	je     805003 <malloc+0x1f4>
			break;
  804ff6:	90                   	nop
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  804ff7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  804ffe:	e9 14 01 00 00       	jmpq   805117 <malloc+0x308>
	 */
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
			break;
		mptr += PGSIZE;
  805003:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  80500a:	00 00 00 
  80500d:	48 8b 00             	mov    (%rax),%rax
  805010:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  805017:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  80501e:	00 00 00 
  805021:	48 89 10             	mov    %rdx,(%rax)
		if (mptr == mend) {
  805024:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  80502b:	00 00 00 
  80502e:	48 8b 10             	mov    (%rax),%rdx
  805031:	48 b8 e0 80 82 00 00 	movabs $0x8280e0,%rax
  805038:	00 00 00 
  80503b:	48 8b 00             	mov    (%rax),%rax
  80503e:	48 39 c2             	cmp    %rax,%rdx
  805041:	75 2e                	jne    805071 <malloc+0x262>
			mptr = mbegin;
  805043:	48 b8 d8 80 82 00 00 	movabs $0x8280d8,%rax
  80504a:	00 00 00 
  80504d:	48 8b 10             	mov    (%rax),%rdx
  805050:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  805057:	00 00 00 
  80505a:	48 89 10             	mov    %rdx,(%rax)
			if (++nwrap == 2)
  80505d:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  805061:	83 7d f8 02          	cmpl   $0x2,-0x8(%rbp)
  805065:	75 0a                	jne    805071 <malloc+0x262>
				return 0;	/* out of address space */
  805067:	b8 00 00 00 00       	mov    $0x0,%eax
  80506c:	e9 1a 01 00 00       	jmpq   80518b <malloc+0x37c>
		}
	}
  805071:	e9 55 ff ff ff       	jmpq   804fcb <malloc+0x1bc>

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  805076:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805079:	05 00 10 00 00       	add    $0x1000,%eax
  80507e:	48 98                	cltq   
  805080:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  805084:	48 83 c2 04          	add    $0x4,%rdx
  805088:	48 39 d0             	cmp    %rdx,%rax
  80508b:	73 07                	jae    805094 <malloc+0x285>
  80508d:	b8 00 04 00 00       	mov    $0x400,%eax
  805092:	eb 05                	jmp    805099 <malloc+0x28a>
  805094:	b8 00 00 00 00       	mov    $0x0,%eax
  805099:	89 45 bc             	mov    %eax,-0x44(%rbp)
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  80509c:	8b 45 bc             	mov    -0x44(%rbp),%eax
  80509f:	83 c8 07             	or     $0x7,%eax
  8050a2:	89 c2                	mov    %eax,%edx
  8050a4:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  8050ab:	00 00 00 
  8050ae:	48 8b 08             	mov    (%rax),%rcx
  8050b1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8050b4:	48 98                	cltq   
  8050b6:	48 01 c8             	add    %rcx,%rax
  8050b9:	48 89 c6             	mov    %rax,%rsi
  8050bc:	bf 00 00 00 00       	mov    $0x0,%edi
  8050c1:	48 b8 06 28 80 00 00 	movabs $0x802806,%rax
  8050c8:	00 00 00 
  8050cb:	ff d0                	callq  *%rax
  8050cd:	85 c0                	test   %eax,%eax
  8050cf:	79 3f                	jns    805110 <malloc+0x301>
			for (; i >= 0; i -= PGSIZE)
  8050d1:	eb 30                	jmp    805103 <malloc+0x2f4>
				sys_page_unmap(0, mptr + i);
  8050d3:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  8050da:	00 00 00 
  8050dd:	48 8b 10             	mov    (%rax),%rdx
  8050e0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8050e3:	48 98                	cltq   
  8050e5:	48 01 d0             	add    %rdx,%rax
  8050e8:	48 89 c6             	mov    %rax,%rsi
  8050eb:	bf 00 00 00 00       	mov    $0x0,%edi
  8050f0:	48 b8 b1 28 80 00 00 	movabs $0x8028b1,%rax
  8050f7:	00 00 00 
  8050fa:	ff d0                	callq  *%rax
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
			for (; i >= 0; i -= PGSIZE)
  8050fc:	81 6d fc 00 10 00 00 	subl   $0x1000,-0x4(%rbp)
  805103:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  805107:	79 ca                	jns    8050d3 <malloc+0x2c4>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
  805109:	b8 00 00 00 00       	mov    $0x0,%eax
  80510e:	eb 7b                	jmp    80518b <malloc+0x37c>
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  805110:	81 45 fc 00 10 00 00 	addl   $0x1000,-0x4(%rbp)
  805117:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80511a:	48 98                	cltq   
  80511c:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  805120:	48 83 c2 04          	add    $0x4,%rdx
  805124:	48 39 d0             	cmp    %rdx,%rax
  805127:	0f 82 49 ff ff ff    	jb     805076 <malloc+0x267>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
		}
	}

	ref = (uint32_t*) (mptr + i - 4);
  80512d:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  805134:	00 00 00 
  805137:	48 8b 00             	mov    (%rax),%rax
  80513a:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80513d:	48 63 d2             	movslq %edx,%rdx
  805140:	48 83 ea 04          	sub    $0x4,%rdx
  805144:	48 01 d0             	add    %rdx,%rax
  805147:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	*ref = 2;	/* reference for mptr, reference for returned block */
  80514b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80514f:	c7 00 02 00 00 00    	movl   $0x2,(%rax)
	v = mptr;
  805155:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  80515c:	00 00 00 
  80515f:	48 8b 00             	mov    (%rax),%rax
  805162:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	mptr += n;
  805166:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  80516d:	00 00 00 
  805170:	48 8b 10             	mov    (%rax),%rdx
  805173:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  805177:	48 01 c2             	add    %rax,%rdx
  80517a:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  805181:	00 00 00 
  805184:	48 89 10             	mov    %rdx,(%rax)
	return v;
  805187:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
}
  80518b:	c9                   	leaveq 
  80518c:	c3                   	retq   

000000000080518d <free>:

void
free(void *v)
{
  80518d:	55                   	push   %rbp
  80518e:	48 89 e5             	mov    %rsp,%rbp
  805191:	48 83 ec 30          	sub    $0x30,%rsp
  805195:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	uint8_t *c;
	uint32_t *ref;

	if (v == 0)
  805199:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80519e:	75 05                	jne    8051a5 <free+0x18>
		return;
  8051a0:	e9 54 01 00 00       	jmpq   8052f9 <free+0x16c>
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  8051a5:	48 b8 d8 80 82 00 00 	movabs $0x8280d8,%rax
  8051ac:	00 00 00 
  8051af:	48 8b 00             	mov    (%rax),%rax
  8051b2:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8051b6:	77 13                	ja     8051cb <free+0x3e>
  8051b8:	48 b8 e0 80 82 00 00 	movabs $0x8280e0,%rax
  8051bf:	00 00 00 
  8051c2:	48 8b 00             	mov    (%rax),%rax
  8051c5:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  8051c9:	72 35                	jb     805200 <free+0x73>
  8051cb:	48 b9 70 15 82 00 00 	movabs $0x821570,%rcx
  8051d2:	00 00 00 
  8051d5:	48 ba 9e 15 82 00 00 	movabs $0x82159e,%rdx
  8051dc:	00 00 00 
  8051df:	be 7b 00 00 00       	mov    $0x7b,%esi
  8051e4:	48 bf b3 15 82 00 00 	movabs $0x8215b3,%rdi
  8051eb:	00 00 00 
  8051ee:	b8 00 00 00 00       	mov    $0x0,%eax
  8051f3:	49 b8 e9 10 80 00 00 	movabs $0x8010e9,%r8
  8051fa:	00 00 00 
  8051fd:	41 ff d0             	callq  *%r8

	c = ROUNDDOWN(v, PGSIZE);
  805200:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805204:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  805208:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80520c:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  805212:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  805216:	eb 7b                	jmp    805293 <free+0x106>
		sys_page_unmap(0, c);
  805218:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80521c:	48 89 c6             	mov    %rax,%rsi
  80521f:	bf 00 00 00 00       	mov    $0x0,%edi
  805224:	48 b8 b1 28 80 00 00 	movabs $0x8028b1,%rax
  80522b:	00 00 00 
  80522e:	ff d0                	callq  *%rax
		c += PGSIZE;
  805230:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  805237:	00 
		assert(mbegin <= c && c < mend);
  805238:	48 b8 d8 80 82 00 00 	movabs $0x8280d8,%rax
  80523f:	00 00 00 
  805242:	48 8b 00             	mov    (%rax),%rax
  805245:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  805249:	77 13                	ja     80525e <free+0xd1>
  80524b:	48 b8 e0 80 82 00 00 	movabs $0x8280e0,%rax
  805252:	00 00 00 
  805255:	48 8b 00             	mov    (%rax),%rax
  805258:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80525c:	72 35                	jb     805293 <free+0x106>
  80525e:	48 b9 c0 15 82 00 00 	movabs $0x8215c0,%rcx
  805265:	00 00 00 
  805268:	48 ba 9e 15 82 00 00 	movabs $0x82159e,%rdx
  80526f:	00 00 00 
  805272:	be 82 00 00 00       	mov    $0x82,%esi
  805277:	48 bf b3 15 82 00 00 	movabs $0x8215b3,%rdi
  80527e:	00 00 00 
  805281:	b8 00 00 00 00       	mov    $0x0,%eax
  805286:	49 b8 e9 10 80 00 00 	movabs $0x8010e9,%r8
  80528d:	00 00 00 
  805290:	41 ff d0             	callq  *%r8
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);

	c = ROUNDDOWN(v, PGSIZE);

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  805293:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805297:	48 c1 e8 0c          	shr    $0xc,%rax
  80529b:	48 89 c2             	mov    %rax,%rdx
  80529e:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  8052a5:	01 00 00 
  8052a8:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8052ac:	25 00 04 00 00       	and    $0x400,%eax
  8052b1:	48 85 c0             	test   %rax,%rax
  8052b4:	0f 85 5e ff ff ff    	jne    805218 <free+0x8b>

	/*
	 * c is just a piece of this page, so dec the ref count
	 * and maybe free the page.
	 */
	ref = (uint32_t*) (c + PGSIZE - 4);
  8052ba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8052be:	48 05 fc 0f 00 00    	add    $0xffc,%rax
  8052c4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (--(*ref) == 0)
  8052c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8052cc:	8b 00                	mov    (%rax),%eax
  8052ce:	8d 50 ff             	lea    -0x1(%rax),%edx
  8052d1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8052d5:	89 10                	mov    %edx,(%rax)
  8052d7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8052db:	8b 00                	mov    (%rax),%eax
  8052dd:	85 c0                	test   %eax,%eax
  8052df:	75 18                	jne    8052f9 <free+0x16c>
		sys_page_unmap(0, c);
  8052e1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8052e5:	48 89 c6             	mov    %rax,%rsi
  8052e8:	bf 00 00 00 00       	mov    $0x0,%edi
  8052ed:	48 b8 b1 28 80 00 00 	movabs $0x8028b1,%rax
  8052f4:	00 00 00 
  8052f7:	ff d0                	callq  *%rax
}
  8052f9:	c9                   	leaveq 
  8052fa:	c3                   	retq   

00000000008052fb <pipe>:
	uint8_t p_buf[PIPEBUFSIZ];	// data buffer
};

int
pipe(int pfd[2])
{
  8052fb:	55                   	push   %rbp
  8052fc:	48 89 e5             	mov    %rsp,%rbp
  8052ff:	53                   	push   %rbx
  805300:	48 83 ec 38          	sub    $0x38,%rsp
  805304:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
	int r;
	struct Fd *fd0, *fd1;
	void *va;

	// allocate the file descriptor table entries
	if ((r = fd_alloc(&fd0)) < 0
  805308:	48 8d 45 d8          	lea    -0x28(%rbp),%rax
  80530c:	48 89 c7             	mov    %rax,%rdi
  80530f:	48 b8 88 35 80 00 00 	movabs $0x803588,%rax
  805316:	00 00 00 
  805319:	ff d0                	callq  *%rax
  80531b:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80531e:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  805322:	0f 88 bf 01 00 00    	js     8054e7 <pipe+0x1ec>
            || (r = sys_page_alloc(0, fd0, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  805328:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80532c:	ba 07 04 00 00       	mov    $0x407,%edx
  805331:	48 89 c6             	mov    %rax,%rsi
  805334:	bf 00 00 00 00       	mov    $0x0,%edi
  805339:	48 b8 06 28 80 00 00 	movabs $0x802806,%rax
  805340:	00 00 00 
  805343:	ff d0                	callq  *%rax
  805345:	89 45 ec             	mov    %eax,-0x14(%rbp)
  805348:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  80534c:	0f 88 95 01 00 00    	js     8054e7 <pipe+0x1ec>
		goto err;

	if ((r = fd_alloc(&fd1)) < 0
  805352:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  805356:	48 89 c7             	mov    %rax,%rdi
  805359:	48 b8 88 35 80 00 00 	movabs $0x803588,%rax
  805360:	00 00 00 
  805363:	ff d0                	callq  *%rax
  805365:	89 45 ec             	mov    %eax,-0x14(%rbp)
  805368:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  80536c:	0f 88 5d 01 00 00    	js     8054cf <pipe+0x1d4>
            || (r = sys_page_alloc(0, fd1, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  805372:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  805376:	ba 07 04 00 00       	mov    $0x407,%edx
  80537b:	48 89 c6             	mov    %rax,%rsi
  80537e:	bf 00 00 00 00       	mov    $0x0,%edi
  805383:	48 b8 06 28 80 00 00 	movabs $0x802806,%rax
  80538a:	00 00 00 
  80538d:	ff d0                	callq  *%rax
  80538f:	89 45 ec             	mov    %eax,-0x14(%rbp)
  805392:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  805396:	0f 88 33 01 00 00    	js     8054cf <pipe+0x1d4>
		goto err1;

	// allocate the pipe structure as first data page in both
	va = fd2data(fd0);
  80539c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8053a0:	48 89 c7             	mov    %rax,%rdi
  8053a3:	48 b8 5d 35 80 00 00 	movabs $0x80355d,%rax
  8053aa:	00 00 00 
  8053ad:	ff d0                	callq  *%rax
  8053af:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if ((r = sys_page_alloc(0, va, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  8053b3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8053b7:	ba 07 04 00 00       	mov    $0x407,%edx
  8053bc:	48 89 c6             	mov    %rax,%rsi
  8053bf:	bf 00 00 00 00       	mov    $0x0,%edi
  8053c4:	48 b8 06 28 80 00 00 	movabs $0x802806,%rax
  8053cb:	00 00 00 
  8053ce:	ff d0                	callq  *%rax
  8053d0:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8053d3:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  8053d7:	79 05                	jns    8053de <pipe+0xe3>
		goto err2;
  8053d9:	e9 d9 00 00 00       	jmpq   8054b7 <pipe+0x1bc>
	if ((r = sys_page_map(0, va, 0, fd2data(fd1), PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  8053de:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8053e2:	48 89 c7             	mov    %rax,%rdi
  8053e5:	48 b8 5d 35 80 00 00 	movabs $0x80355d,%rax
  8053ec:	00 00 00 
  8053ef:	ff d0                	callq  *%rax
  8053f1:	48 89 c2             	mov    %rax,%rdx
  8053f4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8053f8:	41 b8 07 04 00 00    	mov    $0x407,%r8d
  8053fe:	48 89 d1             	mov    %rdx,%rcx
  805401:	ba 00 00 00 00       	mov    $0x0,%edx
  805406:	48 89 c6             	mov    %rax,%rsi
  805409:	bf 00 00 00 00       	mov    $0x0,%edi
  80540e:	48 b8 56 28 80 00 00 	movabs $0x802856,%rax
  805415:	00 00 00 
  805418:	ff d0                	callq  *%rax
  80541a:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80541d:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  805421:	79 1b                	jns    80543e <pipe+0x143>
		goto err3;
  805423:	90                   	nop
	pfd[0] = fd2num(fd0);
	pfd[1] = fd2num(fd1);
	return 0;

err3:
	sys_page_unmap(0, va);
  805424:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805428:	48 89 c6             	mov    %rax,%rsi
  80542b:	bf 00 00 00 00       	mov    $0x0,%edi
  805430:	48 b8 b1 28 80 00 00 	movabs $0x8028b1,%rax
  805437:	00 00 00 
  80543a:	ff d0                	callq  *%rax
  80543c:	eb 79                	jmp    8054b7 <pipe+0x1bc>
		goto err2;
	if ((r = sys_page_map(0, va, 0, fd2data(fd1), PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
		goto err3;

	// set up fd structures
	fd0->fd_dev_id = devpipe.dev_id;
  80543e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805442:	48 ba 00 81 82 00 00 	movabs $0x828100,%rdx
  805449:	00 00 00 
  80544c:	8b 12                	mov    (%rdx),%edx
  80544e:	89 10                	mov    %edx,(%rax)
	fd0->fd_omode = O_RDONLY;
  805450:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805454:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)

	fd1->fd_dev_id = devpipe.dev_id;
  80545b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80545f:	48 ba 00 81 82 00 00 	movabs $0x828100,%rdx
  805466:	00 00 00 
  805469:	8b 12                	mov    (%rdx),%edx
  80546b:	89 10                	mov    %edx,(%rax)
	fd1->fd_omode = O_WRONLY;
  80546d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  805471:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%rax)

	if (debug)
		cprintf("[%08x] pipecreate %08x\n", thisenv->env_id, uvpt[PGNUM(va)]);

	pfd[0] = fd2num(fd0);
  805478:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80547c:	48 89 c7             	mov    %rax,%rdi
  80547f:	48 b8 3a 35 80 00 00 	movabs $0x80353a,%rax
  805486:	00 00 00 
  805489:	ff d0                	callq  *%rax
  80548b:	89 c2                	mov    %eax,%edx
  80548d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  805491:	89 10                	mov    %edx,(%rax)
	pfd[1] = fd2num(fd1);
  805493:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  805497:	48 8d 58 04          	lea    0x4(%rax),%rbx
  80549b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80549f:	48 89 c7             	mov    %rax,%rdi
  8054a2:	48 b8 3a 35 80 00 00 	movabs $0x80353a,%rax
  8054a9:	00 00 00 
  8054ac:	ff d0                	callq  *%rax
  8054ae:	89 03                	mov    %eax,(%rbx)
	return 0;
  8054b0:	b8 00 00 00 00       	mov    $0x0,%eax
  8054b5:	eb 33                	jmp    8054ea <pipe+0x1ef>

err3:
	sys_page_unmap(0, va);
err2:
	sys_page_unmap(0, fd1);
  8054b7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8054bb:	48 89 c6             	mov    %rax,%rsi
  8054be:	bf 00 00 00 00       	mov    $0x0,%edi
  8054c3:	48 b8 b1 28 80 00 00 	movabs $0x8028b1,%rax
  8054ca:	00 00 00 
  8054cd:	ff d0                	callq  *%rax
err1:
	sys_page_unmap(0, fd0);
  8054cf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8054d3:	48 89 c6             	mov    %rax,%rsi
  8054d6:	bf 00 00 00 00       	mov    $0x0,%edi
  8054db:	48 b8 b1 28 80 00 00 	movabs $0x8028b1,%rax
  8054e2:	00 00 00 
  8054e5:	ff d0                	callq  *%rax
err:
	return r;
  8054e7:	8b 45 ec             	mov    -0x14(%rbp),%eax
}
  8054ea:	48 83 c4 38          	add    $0x38,%rsp
  8054ee:	5b                   	pop    %rbx
  8054ef:	5d                   	pop    %rbp
  8054f0:	c3                   	retq   

00000000008054f1 <_pipeisclosed>:

static int
_pipeisclosed(struct Fd *fd, struct Pipe *p)
{
  8054f1:	55                   	push   %rbp
  8054f2:	48 89 e5             	mov    %rsp,%rbp
  8054f5:	53                   	push   %rbx
  8054f6:	48 83 ec 28          	sub    $0x28,%rsp
  8054fa:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8054fe:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)

	int n, nn, ret;

	while (1) {
		n = thisenv->env_runs;
  805502:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  805509:	00 00 00 
  80550c:	48 8b 00             	mov    (%rax),%rax
  80550f:	8b 80 d8 00 00 00    	mov    0xd8(%rax),%eax
  805515:	89 45 ec             	mov    %eax,-0x14(%rbp)
		ret = pageref(fd) == pageref(p);
  805518:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80551c:	48 89 c7             	mov    %rax,%rdi
  80551f:	48 b8 9f 5c 80 00 00 	movabs $0x805c9f,%rax
  805526:	00 00 00 
  805529:	ff d0                	callq  *%rax
  80552b:	89 c3                	mov    %eax,%ebx
  80552d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  805531:	48 89 c7             	mov    %rax,%rdi
  805534:	48 b8 9f 5c 80 00 00 	movabs $0x805c9f,%rax
  80553b:	00 00 00 
  80553e:	ff d0                	callq  *%rax
  805540:	39 c3                	cmp    %eax,%ebx
  805542:	0f 94 c0             	sete   %al
  805545:	0f b6 c0             	movzbl %al,%eax
  805548:	89 45 e8             	mov    %eax,-0x18(%rbp)
		nn = thisenv->env_runs;
  80554b:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  805552:	00 00 00 
  805555:	48 8b 00             	mov    (%rax),%rax
  805558:	8b 80 d8 00 00 00    	mov    0xd8(%rax),%eax
  80555e:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		if (n == nn)
  805561:	8b 45 ec             	mov    -0x14(%rbp),%eax
  805564:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  805567:	75 05                	jne    80556e <_pipeisclosed+0x7d>
			return ret;
  805569:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80556c:	eb 4f                	jmp    8055bd <_pipeisclosed+0xcc>
		if (n != nn && ret == 1)
  80556e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  805571:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  805574:	74 42                	je     8055b8 <_pipeisclosed+0xc7>
  805576:	83 7d e8 01          	cmpl   $0x1,-0x18(%rbp)
  80557a:	75 3c                	jne    8055b8 <_pipeisclosed+0xc7>
			cprintf("pipe race avoided\n", n, thisenv->env_runs, ret);
  80557c:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  805583:	00 00 00 
  805586:	48 8b 00             	mov    (%rax),%rax
  805589:	8b 90 d8 00 00 00    	mov    0xd8(%rax),%edx
  80558f:	8b 4d e8             	mov    -0x18(%rbp),%ecx
  805592:	8b 45 ec             	mov    -0x14(%rbp),%eax
  805595:	89 c6                	mov    %eax,%esi
  805597:	48 bf dd 15 82 00 00 	movabs $0x8215dd,%rdi
  80559e:	00 00 00 
  8055a1:	b8 00 00 00 00       	mov    $0x0,%eax
  8055a6:	49 b8 22 13 80 00 00 	movabs $0x801322,%r8
  8055ad:	00 00 00 
  8055b0:	41 ff d0             	callq  *%r8
	}
  8055b3:	e9 4a ff ff ff       	jmpq   805502 <_pipeisclosed+0x11>
  8055b8:	e9 45 ff ff ff       	jmpq   805502 <_pipeisclosed+0x11>

}
  8055bd:	48 83 c4 28          	add    $0x28,%rsp
  8055c1:	5b                   	pop    %rbx
  8055c2:	5d                   	pop    %rbp
  8055c3:	c3                   	retq   

00000000008055c4 <pipeisclosed>:

int
pipeisclosed(int fdnum)
{
  8055c4:	55                   	push   %rbp
  8055c5:	48 89 e5             	mov    %rsp,%rbp
  8055c8:	48 83 ec 30          	sub    $0x30,%rsp
  8055cc:	89 7d dc             	mov    %edi,-0x24(%rbp)
	struct Fd *fd;
	struct Pipe *p;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  8055cf:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  8055d3:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8055d6:	48 89 d6             	mov    %rdx,%rsi
  8055d9:	89 c7                	mov    %eax,%edi
  8055db:	48 b8 20 36 80 00 00 	movabs $0x803620,%rax
  8055e2:	00 00 00 
  8055e5:	ff d0                	callq  *%rax
  8055e7:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8055ea:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8055ee:	79 05                	jns    8055f5 <pipeisclosed+0x31>
		return r;
  8055f0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8055f3:	eb 31                	jmp    805626 <pipeisclosed+0x62>
	p = (struct Pipe*) fd2data(fd);
  8055f5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8055f9:	48 89 c7             	mov    %rax,%rdi
  8055fc:	48 b8 5d 35 80 00 00 	movabs $0x80355d,%rax
  805603:	00 00 00 
  805606:	ff d0                	callq  *%rax
  805608:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	return _pipeisclosed(fd, p);
  80560c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805610:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  805614:	48 89 d6             	mov    %rdx,%rsi
  805617:	48 89 c7             	mov    %rax,%rdi
  80561a:	48 b8 f1 54 80 00 00 	movabs $0x8054f1,%rax
  805621:	00 00 00 
  805624:	ff d0                	callq  *%rax
}
  805626:	c9                   	leaveq 
  805627:	c3                   	retq   

0000000000805628 <devpipe_read>:

static ssize_t
devpipe_read(struct Fd *fd, void *vbuf, size_t n)
{
  805628:	55                   	push   %rbp
  805629:	48 89 e5             	mov    %rsp,%rbp
  80562c:	48 83 ec 40          	sub    $0x40,%rsp
  805630:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  805634:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  805638:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)

	uint8_t *buf;
	size_t i;
	struct Pipe *p;

	p = (struct Pipe*)fd2data(fd);
  80563c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805640:	48 89 c7             	mov    %rax,%rdi
  805643:	48 b8 5d 35 80 00 00 	movabs $0x80355d,%rax
  80564a:	00 00 00 
  80564d:	ff d0                	callq  *%rax
  80564f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (debug)
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
  805653:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  805657:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	for (i = 0; i < n; i++) {
  80565b:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  805662:	00 
  805663:	e9 92 00 00 00       	jmpq   8056fa <devpipe_read+0xd2>
		while (p->p_rpos == p->p_wpos) {
  805668:	eb 41                	jmp    8056ab <devpipe_read+0x83>
			// pipe is empty
			// if we got any data, return it
			if (i > 0)
  80566a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80566f:	74 09                	je     80567a <devpipe_read+0x52>
				return i;
  805671:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805675:	e9 92 00 00 00       	jmpq   80570c <devpipe_read+0xe4>
			// if all the writers are gone, note eof
			if (_pipeisclosed(fd, p))
  80567a:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80567e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805682:	48 89 d6             	mov    %rdx,%rsi
  805685:	48 89 c7             	mov    %rax,%rdi
  805688:	48 b8 f1 54 80 00 00 	movabs $0x8054f1,%rax
  80568f:	00 00 00 
  805692:	ff d0                	callq  *%rax
  805694:	85 c0                	test   %eax,%eax
  805696:	74 07                	je     80569f <devpipe_read+0x77>
				return 0;
  805698:	b8 00 00 00 00       	mov    $0x0,%eax
  80569d:	eb 6d                	jmp    80570c <devpipe_read+0xe4>
			// yield and see what happens
			if (debug)
				cprintf("devpipe_read yield\n");
			sys_yield();
  80569f:	48 b8 c8 27 80 00 00 	movabs $0x8027c8,%rax
  8056a6:	00 00 00 
  8056a9:	ff d0                	callq  *%rax
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
		while (p->p_rpos == p->p_wpos) {
  8056ab:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8056af:	8b 10                	mov    (%rax),%edx
  8056b1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8056b5:	8b 40 04             	mov    0x4(%rax),%eax
  8056b8:	39 c2                	cmp    %eax,%edx
  8056ba:	74 ae                	je     80566a <devpipe_read+0x42>
				cprintf("devpipe_read yield\n");
			sys_yield();
		}
		// there's a byte.  take it.
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
  8056bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8056c0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8056c4:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  8056c8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8056cc:	8b 00                	mov    (%rax),%eax
  8056ce:	99                   	cltd   
  8056cf:	c1 ea 1b             	shr    $0x1b,%edx
  8056d2:	01 d0                	add    %edx,%eax
  8056d4:	83 e0 1f             	and    $0x1f,%eax
  8056d7:	29 d0                	sub    %edx,%eax
  8056d9:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8056dd:	48 98                	cltq   
  8056df:	0f b6 44 02 08       	movzbl 0x8(%rdx,%rax,1),%eax
  8056e4:	88 01                	mov    %al,(%rcx)
		p->p_rpos++;
  8056e6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8056ea:	8b 00                	mov    (%rax),%eax
  8056ec:	8d 50 01             	lea    0x1(%rax),%edx
  8056ef:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8056f3:	89 10                	mov    %edx,(%rax)
	if (debug)
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  8056f5:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8056fa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8056fe:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  805702:	0f 82 60 ff ff ff    	jb     805668 <devpipe_read+0x40>
		// there's a byte.  take it.
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
		p->p_rpos++;
	}
	return i;
  805708:	48 8b 45 f8          	mov    -0x8(%rbp),%rax

}
  80570c:	c9                   	leaveq 
  80570d:	c3                   	retq   

000000000080570e <devpipe_write>:

static ssize_t
devpipe_write(struct Fd *fd, const void *vbuf, size_t n)
{
  80570e:	55                   	push   %rbp
  80570f:	48 89 e5             	mov    %rsp,%rbp
  805712:	48 83 ec 40          	sub    $0x40,%rsp
  805716:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80571a:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80571e:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)

	const uint8_t *buf;
	size_t i;
	struct Pipe *p;

	p = (struct Pipe*) fd2data(fd);
  805722:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805726:	48 89 c7             	mov    %rax,%rdi
  805729:	48 b8 5d 35 80 00 00 	movabs $0x80355d,%rax
  805730:	00 00 00 
  805733:	ff d0                	callq  *%rax
  805735:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (debug)
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
  805739:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80573d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	for (i = 0; i < n; i++) {
  805741:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  805748:	00 
  805749:	e9 8e 00 00 00       	jmpq   8057dc <devpipe_write+0xce>
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
  80574e:	eb 31                	jmp    805781 <devpipe_write+0x73>
			// pipe is full
			// if all the readers are gone
			// (it's only writers like us now),
			// note eof
			if (_pipeisclosed(fd, p))
  805750:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  805754:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805758:	48 89 d6             	mov    %rdx,%rsi
  80575b:	48 89 c7             	mov    %rax,%rdi
  80575e:	48 b8 f1 54 80 00 00 	movabs $0x8054f1,%rax
  805765:	00 00 00 
  805768:	ff d0                	callq  *%rax
  80576a:	85 c0                	test   %eax,%eax
  80576c:	74 07                	je     805775 <devpipe_write+0x67>
				return 0;
  80576e:	b8 00 00 00 00       	mov    $0x0,%eax
  805773:	eb 79                	jmp    8057ee <devpipe_write+0xe0>
			// yield and see what happens
			if (debug)
				cprintf("devpipe_write yield\n");
			sys_yield();
  805775:	48 b8 c8 27 80 00 00 	movabs $0x8027c8,%rax
  80577c:	00 00 00 
  80577f:	ff d0                	callq  *%rax
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
  805781:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805785:	8b 40 04             	mov    0x4(%rax),%eax
  805788:	48 63 d0             	movslq %eax,%rdx
  80578b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80578f:	8b 00                	mov    (%rax),%eax
  805791:	48 98                	cltq   
  805793:	48 83 c0 20          	add    $0x20,%rax
  805797:	48 39 c2             	cmp    %rax,%rdx
  80579a:	73 b4                	jae    805750 <devpipe_write+0x42>
				cprintf("devpipe_write yield\n");
			sys_yield();
		}
		// there's room for a byte.  store it.
		// wait to increment wpos until the byte is stored!
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
  80579c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8057a0:	8b 40 04             	mov    0x4(%rax),%eax
  8057a3:	99                   	cltd   
  8057a4:	c1 ea 1b             	shr    $0x1b,%edx
  8057a7:	01 d0                	add    %edx,%eax
  8057a9:	83 e0 1f             	and    $0x1f,%eax
  8057ac:	29 d0                	sub    %edx,%eax
  8057ae:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8057b2:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8057b6:	48 01 ca             	add    %rcx,%rdx
  8057b9:	0f b6 0a             	movzbl (%rdx),%ecx
  8057bc:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8057c0:	48 98                	cltq   
  8057c2:	88 4c 02 08          	mov    %cl,0x8(%rdx,%rax,1)
		p->p_wpos++;
  8057c6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8057ca:	8b 40 04             	mov    0x4(%rax),%eax
  8057cd:	8d 50 01             	lea    0x1(%rax),%edx
  8057d0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8057d4:	89 50 04             	mov    %edx,0x4(%rax)
	if (debug)
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  8057d7:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8057dc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8057e0:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8057e4:	0f 82 64 ff ff ff    	jb     80574e <devpipe_write+0x40>
		// wait to increment wpos until the byte is stored!
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
		p->p_wpos++;
	}

	return i;
  8057ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax

}
  8057ee:	c9                   	leaveq 
  8057ef:	c3                   	retq   

00000000008057f0 <devpipe_stat>:

static int
devpipe_stat(struct Fd *fd, struct Stat *stat)
{
  8057f0:	55                   	push   %rbp
  8057f1:	48 89 e5             	mov    %rsp,%rbp
  8057f4:	48 83 ec 20          	sub    $0x20,%rsp
  8057f8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8057fc:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	struct Pipe *p = (struct Pipe*) fd2data(fd);
  805800:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805804:	48 89 c7             	mov    %rax,%rdi
  805807:	48 b8 5d 35 80 00 00 	movabs $0x80355d,%rax
  80580e:	00 00 00 
  805811:	ff d0                	callq  *%rax
  805813:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	strcpy(stat->st_name, "<pipe>");
  805817:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80581b:	48 be f0 15 82 00 00 	movabs $0x8215f0,%rsi
  805822:	00 00 00 
  805825:	48 89 c7             	mov    %rax,%rdi
  805828:	48 b8 d7 1e 80 00 00 	movabs $0x801ed7,%rax
  80582f:	00 00 00 
  805832:	ff d0                	callq  *%rax
	stat->st_size = p->p_wpos - p->p_rpos;
  805834:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805838:	8b 50 04             	mov    0x4(%rax),%edx
  80583b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80583f:	8b 00                	mov    (%rax),%eax
  805841:	29 c2                	sub    %eax,%edx
  805843:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805847:	89 90 80 00 00 00    	mov    %edx,0x80(%rax)
	stat->st_isdir = 0;
  80584d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805851:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%rax)
  805858:	00 00 00 
	stat->st_dev = &devpipe;
  80585b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80585f:	48 b9 00 81 82 00 00 	movabs $0x828100,%rcx
  805866:	00 00 00 
  805869:	48 89 88 88 00 00 00 	mov    %rcx,0x88(%rax)
	return 0;
  805870:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805875:	c9                   	leaveq 
  805876:	c3                   	retq   

0000000000805877 <devpipe_close>:

static int
devpipe_close(struct Fd *fd)
{
  805877:	55                   	push   %rbp
  805878:	48 89 e5             	mov    %rsp,%rbp
  80587b:	48 83 ec 10          	sub    $0x10,%rsp
  80587f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)

	(void) sys_page_unmap(0, fd);
  805883:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805887:	48 89 c6             	mov    %rax,%rsi
  80588a:	bf 00 00 00 00       	mov    $0x0,%edi
  80588f:	48 b8 b1 28 80 00 00 	movabs $0x8028b1,%rax
  805896:	00 00 00 
  805899:	ff d0                	callq  *%rax

	return sys_page_unmap(0, fd2data(fd));
  80589b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80589f:	48 89 c7             	mov    %rax,%rdi
  8058a2:	48 b8 5d 35 80 00 00 	movabs $0x80355d,%rax
  8058a9:	00 00 00 
  8058ac:	ff d0                	callq  *%rax
  8058ae:	48 89 c6             	mov    %rax,%rsi
  8058b1:	bf 00 00 00 00       	mov    $0x0,%edi
  8058b6:	48 b8 b1 28 80 00 00 	movabs $0x8028b1,%rax
  8058bd:	00 00 00 
  8058c0:	ff d0                	callq  *%rax
}
  8058c2:	c9                   	leaveq 
  8058c3:	c3                   	retq   

00000000008058c4 <cputchar>:
#include <inc/string.h>
#include <inc/lib.h>

void
cputchar(int ch)
{
  8058c4:	55                   	push   %rbp
  8058c5:	48 89 e5             	mov    %rsp,%rbp
  8058c8:	48 83 ec 20          	sub    $0x20,%rsp
  8058cc:	89 7d ec             	mov    %edi,-0x14(%rbp)
	char c = ch;
  8058cf:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8058d2:	88 45 ff             	mov    %al,-0x1(%rbp)

	// Unlike standard Unix's putchar,
	// the cputchar function _always_ outputs to the system console.
	sys_cputs(&c, 1);
  8058d5:	48 8d 45 ff          	lea    -0x1(%rbp),%rax
  8058d9:	be 01 00 00 00       	mov    $0x1,%esi
  8058de:	48 89 c7             	mov    %rax,%rdi
  8058e1:	48 b8 be 26 80 00 00 	movabs $0x8026be,%rax
  8058e8:	00 00 00 
  8058eb:	ff d0                	callq  *%rax
}
  8058ed:	c9                   	leaveq 
  8058ee:	c3                   	retq   

00000000008058ef <getchar>:

int
getchar(void)
{
  8058ef:	55                   	push   %rbp
  8058f0:	48 89 e5             	mov    %rsp,%rbp
  8058f3:	48 83 ec 10          	sub    $0x10,%rsp
	int r;

	// JOS does, however, support standard _input_ redirection,
	// allowing the user to redirect script files to the shell and such.
	// getchar() reads a character from file descriptor 0.
	r = read(0, &c, 1);
  8058f7:	48 8d 45 fb          	lea    -0x5(%rbp),%rax
  8058fb:	ba 01 00 00 00       	mov    $0x1,%edx
  805900:	48 89 c6             	mov    %rax,%rsi
  805903:	bf 00 00 00 00       	mov    $0x0,%edi
  805908:	48 b8 52 3a 80 00 00 	movabs $0x803a52,%rax
  80590f:	00 00 00 
  805912:	ff d0                	callq  *%rax
  805914:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (r < 0)
  805917:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80591b:	79 05                	jns    805922 <getchar+0x33>
		return r;
  80591d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805920:	eb 14                	jmp    805936 <getchar+0x47>
	if (r < 1)
  805922:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  805926:	7f 07                	jg     80592f <getchar+0x40>
		return -E_EOF;
  805928:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80592d:	eb 07                	jmp    805936 <getchar+0x47>
	return c;
  80592f:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  805933:	0f b6 c0             	movzbl %al,%eax

}
  805936:	c9                   	leaveq 
  805937:	c3                   	retq   

0000000000805938 <iscons>:
	.dev_stat =	devcons_stat
};

int
iscons(int fdnum)
{
  805938:	55                   	push   %rbp
  805939:	48 89 e5             	mov    %rsp,%rbp
  80593c:	48 83 ec 20          	sub    $0x20,%rsp
  805940:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  805943:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  805947:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80594a:	48 89 d6             	mov    %rdx,%rsi
  80594d:	89 c7                	mov    %eax,%edi
  80594f:	48 b8 20 36 80 00 00 	movabs $0x803620,%rax
  805956:	00 00 00 
  805959:	ff d0                	callq  *%rax
  80595b:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80595e:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  805962:	79 05                	jns    805969 <iscons+0x31>
		return r;
  805964:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805967:	eb 1a                	jmp    805983 <iscons+0x4b>
	return fd->fd_dev_id == devcons.dev_id;
  805969:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80596d:	8b 10                	mov    (%rax),%edx
  80596f:	48 b8 40 81 82 00 00 	movabs $0x828140,%rax
  805976:	00 00 00 
  805979:	8b 00                	mov    (%rax),%eax
  80597b:	39 c2                	cmp    %eax,%edx
  80597d:	0f 94 c0             	sete   %al
  805980:	0f b6 c0             	movzbl %al,%eax
}
  805983:	c9                   	leaveq 
  805984:	c3                   	retq   

0000000000805985 <opencons>:

int
opencons(void)
{
  805985:	55                   	push   %rbp
  805986:	48 89 e5             	mov    %rsp,%rbp
  805989:	48 83 ec 10          	sub    $0x10,%rsp
	int r;
	struct Fd* fd;

	if ((r = fd_alloc(&fd)) < 0)
  80598d:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  805991:	48 89 c7             	mov    %rax,%rdi
  805994:	48 b8 88 35 80 00 00 	movabs $0x803588,%rax
  80599b:	00 00 00 
  80599e:	ff d0                	callq  *%rax
  8059a0:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8059a3:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8059a7:	79 05                	jns    8059ae <opencons+0x29>
		return r;
  8059a9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8059ac:	eb 5b                	jmp    805a09 <opencons+0x84>
	if ((r = sys_page_alloc(0, fd, PTE_P|PTE_U|PTE_W|PTE_SHARE)) < 0)
  8059ae:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8059b2:	ba 07 04 00 00       	mov    $0x407,%edx
  8059b7:	48 89 c6             	mov    %rax,%rsi
  8059ba:	bf 00 00 00 00       	mov    $0x0,%edi
  8059bf:	48 b8 06 28 80 00 00 	movabs $0x802806,%rax
  8059c6:	00 00 00 
  8059c9:	ff d0                	callq  *%rax
  8059cb:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8059ce:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8059d2:	79 05                	jns    8059d9 <opencons+0x54>
		return r;
  8059d4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8059d7:	eb 30                	jmp    805a09 <opencons+0x84>
	fd->fd_dev_id = devcons.dev_id;
  8059d9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8059dd:	48 ba 40 81 82 00 00 	movabs $0x828140,%rdx
  8059e4:	00 00 00 
  8059e7:	8b 12                	mov    (%rdx),%edx
  8059e9:	89 10                	mov    %edx,(%rax)
	fd->fd_omode = O_RDWR;
  8059eb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8059ef:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%rax)
	return fd2num(fd);
  8059f6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8059fa:	48 89 c7             	mov    %rax,%rdi
  8059fd:	48 b8 3a 35 80 00 00 	movabs $0x80353a,%rax
  805a04:	00 00 00 
  805a07:	ff d0                	callq  *%rax
}
  805a09:	c9                   	leaveq 
  805a0a:	c3                   	retq   

0000000000805a0b <devcons_read>:

static ssize_t
devcons_read(struct Fd *fd, void *vbuf, size_t n)
{
  805a0b:	55                   	push   %rbp
  805a0c:	48 89 e5             	mov    %rsp,%rbp
  805a0f:	48 83 ec 30          	sub    $0x30,%rsp
  805a13:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  805a17:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  805a1b:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int c;

	if (n == 0)
  805a1f:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  805a24:	75 07                	jne    805a2d <devcons_read+0x22>
		return 0;
  805a26:	b8 00 00 00 00       	mov    $0x0,%eax
  805a2b:	eb 4b                	jmp    805a78 <devcons_read+0x6d>

	while ((c = sys_cgetc()) == 0)
  805a2d:	eb 0c                	jmp    805a3b <devcons_read+0x30>
		sys_yield();
  805a2f:	48 b8 c8 27 80 00 00 	movabs $0x8027c8,%rax
  805a36:	00 00 00 
  805a39:	ff d0                	callq  *%rax
	int c;

	if (n == 0)
		return 0;

	while ((c = sys_cgetc()) == 0)
  805a3b:	48 b8 08 27 80 00 00 	movabs $0x802708,%rax
  805a42:	00 00 00 
  805a45:	ff d0                	callq  *%rax
  805a47:	89 45 fc             	mov    %eax,-0x4(%rbp)
  805a4a:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  805a4e:	74 df                	je     805a2f <devcons_read+0x24>
		sys_yield();
	if (c < 0)
  805a50:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  805a54:	79 05                	jns    805a5b <devcons_read+0x50>
		return c;
  805a56:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805a59:	eb 1d                	jmp    805a78 <devcons_read+0x6d>
	if (c == 0x04)	// ctl-d is eof
  805a5b:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  805a5f:	75 07                	jne    805a68 <devcons_read+0x5d>
		return 0;
  805a61:	b8 00 00 00 00       	mov    $0x0,%eax
  805a66:	eb 10                	jmp    805a78 <devcons_read+0x6d>
	*(char*)vbuf = c;
  805a68:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805a6b:	89 c2                	mov    %eax,%edx
  805a6d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805a71:	88 10                	mov    %dl,(%rax)
	return 1;
  805a73:	b8 01 00 00 00       	mov    $0x1,%eax
}
  805a78:	c9                   	leaveq 
  805a79:	c3                   	retq   

0000000000805a7a <devcons_write>:

static ssize_t
devcons_write(struct Fd *fd, const void *vbuf, size_t n)
{
  805a7a:	55                   	push   %rbp
  805a7b:	48 89 e5             	mov    %rsp,%rbp
  805a7e:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  805a85:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  805a8c:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  805a93:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  805a9a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  805aa1:	eb 76                	jmp    805b19 <devcons_write+0x9f>
		m = n - tot;
  805aa3:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  805aaa:	89 c2                	mov    %eax,%edx
  805aac:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805aaf:	29 c2                	sub    %eax,%edx
  805ab1:	89 d0                	mov    %edx,%eax
  805ab3:	89 45 f8             	mov    %eax,-0x8(%rbp)
		if (m > sizeof(buf) - 1)
  805ab6:	8b 45 f8             	mov    -0x8(%rbp),%eax
  805ab9:	83 f8 7f             	cmp    $0x7f,%eax
  805abc:	76 07                	jbe    805ac5 <devcons_write+0x4b>
			m = sizeof(buf) - 1;
  805abe:	c7 45 f8 7f 00 00 00 	movl   $0x7f,-0x8(%rbp)
		memmove(buf, (char*)vbuf + tot, m);
  805ac5:	8b 45 f8             	mov    -0x8(%rbp),%eax
  805ac8:	48 63 d0             	movslq %eax,%rdx
  805acb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805ace:	48 63 c8             	movslq %eax,%rcx
  805ad1:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  805ad8:	48 01 c1             	add    %rax,%rcx
  805adb:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  805ae2:	48 89 ce             	mov    %rcx,%rsi
  805ae5:	48 89 c7             	mov    %rax,%rdi
  805ae8:	48 b8 fb 21 80 00 00 	movabs $0x8021fb,%rax
  805aef:	00 00 00 
  805af2:	ff d0                	callq  *%rax
		sys_cputs(buf, m);
  805af4:	8b 45 f8             	mov    -0x8(%rbp),%eax
  805af7:	48 63 d0             	movslq %eax,%rdx
  805afa:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  805b01:	48 89 d6             	mov    %rdx,%rsi
  805b04:	48 89 c7             	mov    %rax,%rdi
  805b07:	48 b8 be 26 80 00 00 	movabs $0x8026be,%rax
  805b0e:	00 00 00 
  805b11:	ff d0                	callq  *%rax
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  805b13:	8b 45 f8             	mov    -0x8(%rbp),%eax
  805b16:	01 45 fc             	add    %eax,-0x4(%rbp)
  805b19:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805b1c:	48 98                	cltq   
  805b1e:	48 3b 85 58 ff ff ff 	cmp    -0xa8(%rbp),%rax
  805b25:	0f 82 78 ff ff ff    	jb     805aa3 <devcons_write+0x29>
		if (m > sizeof(buf) - 1)
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
		sys_cputs(buf, m);
	}
	return tot;
  805b2b:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  805b2e:	c9                   	leaveq 
  805b2f:	c3                   	retq   

0000000000805b30 <devcons_close>:

static int
devcons_close(struct Fd *fd)
{
  805b30:	55                   	push   %rbp
  805b31:	48 89 e5             	mov    %rsp,%rbp
  805b34:	48 83 ec 08          	sub    $0x8,%rsp
  805b38:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	USED(fd);

	return 0;
  805b3c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805b41:	c9                   	leaveq 
  805b42:	c3                   	retq   

0000000000805b43 <devcons_stat>:

static int
devcons_stat(struct Fd *fd, struct Stat *stat)
{
  805b43:	55                   	push   %rbp
  805b44:	48 89 e5             	mov    %rsp,%rbp
  805b47:	48 83 ec 10          	sub    $0x10,%rsp
  805b4b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  805b4f:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	strcpy(stat->st_name, "<cons>");
  805b53:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805b57:	48 be fc 15 82 00 00 	movabs $0x8215fc,%rsi
  805b5e:	00 00 00 
  805b61:	48 89 c7             	mov    %rax,%rdi
  805b64:	48 b8 d7 1e 80 00 00 	movabs $0x801ed7,%rax
  805b6b:	00 00 00 
  805b6e:	ff d0                	callq  *%rax
	return 0;
  805b70:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805b75:	c9                   	leaveq 
  805b76:	c3                   	retq   

0000000000805b77 <set_pgfault_handler>:
// at UXSTACKTOP), and tell the kernel to call the assembly-language
// _pgfault_upcall routine when a page fault occurs.
//
void
set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
{
  805b77:	55                   	push   %rbp
  805b78:	48 89 e5             	mov    %rsp,%rbp
  805b7b:	48 83 ec 20          	sub    $0x20,%rsp
  805b7f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int r;

	if (_pgfault_handler == 0) {
  805b83:	48 b8 00 b0 b5 00 00 	movabs $0xb5b000,%rax
  805b8a:	00 00 00 
  805b8d:	48 8b 00             	mov    (%rax),%rax
  805b90:	48 85 c0             	test   %rax,%rax
  805b93:	75 6f                	jne    805c04 <set_pgfault_handler+0x8d>

		// map exception stack
		if ((r = sys_page_alloc(0, (void*) (UXSTACKTOP - PGSIZE), PTE_P|PTE_U|PTE_W)) < 0)
  805b95:	ba 07 00 00 00       	mov    $0x7,%edx
  805b9a:	be 00 f0 7f ef       	mov    $0xef7ff000,%esi
  805b9f:	bf 00 00 00 00       	mov    $0x0,%edi
  805ba4:	48 b8 06 28 80 00 00 	movabs $0x802806,%rax
  805bab:	00 00 00 
  805bae:	ff d0                	callq  *%rax
  805bb0:	89 45 fc             	mov    %eax,-0x4(%rbp)
  805bb3:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  805bb7:	79 30                	jns    805be9 <set_pgfault_handler+0x72>
			panic("allocating exception stack: %e", r);
  805bb9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805bbc:	89 c1                	mov    %eax,%ecx
  805bbe:	48 ba 08 16 82 00 00 	movabs $0x821608,%rdx
  805bc5:	00 00 00 
  805bc8:	be 22 00 00 00       	mov    $0x22,%esi
  805bcd:	48 bf 27 16 82 00 00 	movabs $0x821627,%rdi
  805bd4:	00 00 00 
  805bd7:	b8 00 00 00 00       	mov    $0x0,%eax
  805bdc:	49 b8 e9 10 80 00 00 	movabs $0x8010e9,%r8
  805be3:	00 00 00 
  805be6:	41 ff d0             	callq  *%r8

		// register assembly pgfault entrypoint with JOS kernel
		sys_env_set_pgfault_upcall(0, (void*) _pgfault_upcall);
  805be9:	48 be 17 5c 80 00 00 	movabs $0x805c17,%rsi
  805bf0:	00 00 00 
  805bf3:	bf 00 00 00 00       	mov    $0x0,%edi
  805bf8:	48 b8 90 29 80 00 00 	movabs $0x802990,%rax
  805bff:	00 00 00 
  805c02:	ff d0                	callq  *%rax

	}

	// Save handler pointer for assembly to call.
	_pgfault_handler = handler;
  805c04:	48 b8 00 b0 b5 00 00 	movabs $0xb5b000,%rax
  805c0b:	00 00 00 
  805c0e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  805c12:	48 89 10             	mov    %rdx,(%rax)
}
  805c15:	c9                   	leaveq 
  805c16:	c3                   	retq   

0000000000805c17 <_pgfault_upcall>:
.globl _pgfault_upcall
_pgfault_upcall:
// Call the C page fault handler.
// function argument: pointer to UTF

movq  %rsp,%rdi                // passing the function argument in rdi
  805c17:	48 89 e7             	mov    %rsp,%rdi
movabs _pgfault_handler, %rax
  805c1a:	48 a1 00 b0 b5 00 00 	movabs 0xb5b000,%rax
  805c21:	00 00 00 
call *%rax
  805c24:	ff d0                	callq  *%rax
// registers are available for intermediate calculations.  You
// may find that you have to rearrange your code in non-obvious
// ways as registers become unavailable as scratch space.
//
// LAB 4: Your code here.
subq $8, 152(%rsp)
  805c26:	48 83 ac 24 98 00 00 	subq   $0x8,0x98(%rsp)
  805c2d:	00 08 
    movq 152(%rsp), %rax
  805c2f:	48 8b 84 24 98 00 00 	mov    0x98(%rsp),%rax
  805c36:	00 
    movq 136(%rsp), %rbx
  805c37:	48 8b 9c 24 88 00 00 	mov    0x88(%rsp),%rbx
  805c3e:	00 
movq %rbx, (%rax)
  805c3f:	48 89 18             	mov    %rbx,(%rax)

    // Restore the trap-time registers.  After you do this, you
    // can no longer modify any general-purpose registers.
    // LAB 4: Your code here.
    addq $16, %rsp
  805c42:	48 83 c4 10          	add    $0x10,%rsp
    POPA_
  805c46:	4c 8b 3c 24          	mov    (%rsp),%r15
  805c4a:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  805c4f:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  805c54:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  805c59:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  805c5e:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  805c63:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  805c68:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  805c6d:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  805c72:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  805c77:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  805c7c:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  805c81:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  805c86:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  805c8b:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  805c90:	48 83 c4 78          	add    $0x78,%rsp

    // Restore eflags from the stack.  After you do this, you can
    // no longer use arithmetic operations or anything else that
    // modifies eflags.
    // LAB 4: Your code here.
pushq 8(%rsp)
  805c94:	ff 74 24 08          	pushq  0x8(%rsp)
    popfq
  805c98:	9d                   	popfq  

    // Switch back to the adjusted trap-time stack.
    // LAB 4: Your code here.
    movq 16(%rsp), %rsp
  805c99:	48 8b 64 24 10       	mov    0x10(%rsp),%rsp

    // Return to re-execute the instruction that faulted.
    // LAB 4: Your code here.
    retq
  805c9e:	c3                   	retq   

0000000000805c9f <pageref>:

#include <inc/lib.h>

int
pageref(void *v)
{
  805c9f:	55                   	push   %rbp
  805ca0:	48 89 e5             	mov    %rsp,%rbp
  805ca3:	48 83 ec 18          	sub    $0x18,%rsp
  805ca7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	pte_t pte;

	if (!(uvpd[VPD(v)] & PTE_P))
  805cab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805caf:	48 c1 e8 15          	shr    $0x15,%rax
  805cb3:	48 89 c2             	mov    %rax,%rdx
  805cb6:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  805cbd:	01 00 00 
  805cc0:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  805cc4:	83 e0 01             	and    $0x1,%eax
  805cc7:	48 85 c0             	test   %rax,%rax
  805cca:	75 07                	jne    805cd3 <pageref+0x34>
		return 0;
  805ccc:	b8 00 00 00 00       	mov    $0x0,%eax
  805cd1:	eb 53                	jmp    805d26 <pageref+0x87>
	pte = uvpt[PGNUM(v)];
  805cd3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805cd7:	48 c1 e8 0c          	shr    $0xc,%rax
  805cdb:	48 89 c2             	mov    %rax,%rdx
  805cde:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  805ce5:	01 00 00 
  805ce8:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  805cec:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (!(pte & PTE_P))
  805cf0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805cf4:	83 e0 01             	and    $0x1,%eax
  805cf7:	48 85 c0             	test   %rax,%rax
  805cfa:	75 07                	jne    805d03 <pageref+0x64>
		return 0;
  805cfc:	b8 00 00 00 00       	mov    $0x0,%eax
  805d01:	eb 23                	jmp    805d26 <pageref+0x87>
	return pages[PPN(pte)].pp_ref;
  805d03:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805d07:	48 c1 e8 0c          	shr    $0xc,%rax
  805d0b:	48 89 c2             	mov    %rax,%rdx
  805d0e:	48 b8 00 00 a0 00 80 	movabs $0x8000a00000,%rax
  805d15:	00 00 00 
  805d18:	48 c1 e2 04          	shl    $0x4,%rdx
  805d1c:	48 01 d0             	add    %rdx,%rax
  805d1f:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  805d23:	0f b7 c0             	movzwl %ax,%eax
}
  805d26:	c9                   	leaveq 
  805d27:	c3                   	retq   

0000000000805d28 <lwip_socket_init>:
 * Initialize this module. This function has to be called before any other
 * functions in this module!
 */
void
lwip_socket_init(void)
{
  805d28:	55                   	push   %rbp
  805d29:	48 89 e5             	mov    %rsp,%rbp
  socksem   = sys_sem_new(1);
  805d2c:	bf 01 00 00 00       	mov    $0x1,%edi
  805d31:	48 b8 cc 7d 81 00 00 	movabs $0x817dcc,%rax
  805d38:	00 00 00 
  805d3b:	ff d0                	callq  *%rax
  805d3d:	48 ba a8 94 82 00 00 	movabs $0x8294a8,%rdx
  805d44:	00 00 00 
  805d47:	89 02                	mov    %eax,(%rdx)
  selectsem = sys_sem_new(1);
  805d49:	bf 01 00 00 00       	mov    $0x1,%edi
  805d4e:	48 b8 cc 7d 81 00 00 	movabs $0x817dcc,%rax
  805d55:	00 00 00 
  805d58:	ff d0                	callq  *%rax
  805d5a:	48 ba ac 94 82 00 00 	movabs $0x8294ac,%rdx
  805d61:	00 00 00 
  805d64:	89 02                	mov    %eax,(%rdx)
}
  805d66:	5d                   	pop    %rbp
  805d67:	c3                   	retq   

0000000000805d68 <get_socket>:
 * @param s externally used socket index
 * @return struct lwip_socket for the socket or NULL if not found
 */
static struct lwip_socket *
get_socket(int s)
{
  805d68:	55                   	push   %rbp
  805d69:	48 89 e5             	mov    %rsp,%rbp
  805d6c:	48 83 ec 14          	sub    $0x14,%rsp
  805d70:	89 7d ec             	mov    %edi,-0x14(%rbp)
  struct lwip_socket *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
  805d73:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  805d77:	78 06                	js     805d7f <get_socket+0x17>
  805d79:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%rbp)
  805d7d:	7e 17                	jle    805d96 <get_socket+0x2e>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
  805d7f:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  805d86:	00 00 00 
  805d89:	c7 00 09 00 00 00    	movl   $0x9,(%rax)
    return NULL;
  805d8f:	b8 00 00 00 00       	mov    $0x0,%eax
  805d94:	eb 44                	jmp    805dda <get_socket+0x72>
  }

  sock = &sockets[s];
  805d96:	8b 45 ec             	mov    -0x14(%rbp),%eax
  805d99:	48 98                	cltq   
  805d9b:	48 c1 e0 05          	shl    $0x5,%rax
  805d9f:	48 89 c2             	mov    %rax,%rdx
  805da2:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805da9:	00 00 00 
  805dac:	48 01 d0             	add    %rdx,%rax
  805daf:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  if (!sock->conn) {
  805db3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805db7:	48 8b 00             	mov    (%rax),%rax
  805dba:	48 85 c0             	test   %rax,%rax
  805dbd:	75 17                	jne    805dd6 <get_socket+0x6e>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): not active\n", s));
    set_errno(EBADF);
  805dbf:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  805dc6:	00 00 00 
  805dc9:	c7 00 09 00 00 00    	movl   $0x9,(%rax)
    return NULL;
  805dcf:	b8 00 00 00 00       	mov    $0x0,%eax
  805dd4:	eb 04                	jmp    805dda <get_socket+0x72>
  }

  return sock;
  805dd6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  805dda:	c9                   	leaveq 
  805ddb:	c3                   	retq   

0000000000805ddc <alloc_socket>:
 * @param newconn the netconn for which to allocate a socket
 * @return the index of the new socket; -1 on error
 */
static int
alloc_socket(struct netconn *newconn)
{
  805ddc:	55                   	push   %rbp
  805ddd:	48 89 e5             	mov    %rsp,%rbp
  805de0:	48 83 ec 20          	sub    $0x20,%rsp
  805de4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  int i;

  /* Protect socket array */
  sys_sem_wait(socksem);
  805de8:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  805def:	00 00 00 
  805df2:	8b 00                	mov    (%rax),%eax
  805df4:	89 c7                	mov    %eax,%edi
  805df6:	48 b8 ec e6 80 00 00 	movabs $0x80e6ec,%rax
  805dfd:	00 00 00 
  805e00:	ff d0                	callq  *%rax

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  805e02:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  805e09:	e9 28 01 00 00       	jmpq   805f36 <alloc_socket+0x15a>
    if (!sockets[i].conn) {
  805e0e:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805e15:	00 00 00 
  805e18:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805e1b:	48 63 d2             	movslq %edx,%rdx
  805e1e:	48 c1 e2 05          	shl    $0x5,%rdx
  805e22:	48 01 d0             	add    %rdx,%rax
  805e25:	48 8b 00             	mov    (%rax),%rax
  805e28:	48 85 c0             	test   %rax,%rax
  805e2b:	0f 85 01 01 00 00    	jne    805f32 <alloc_socket+0x156>
      sockets[i].conn       = newconn;
  805e31:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805e38:	00 00 00 
  805e3b:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805e3e:	48 63 d2             	movslq %edx,%rdx
  805e41:	48 c1 e2 05          	shl    $0x5,%rdx
  805e45:	48 01 c2             	add    %rax,%rdx
  805e48:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805e4c:	48 89 02             	mov    %rax,(%rdx)
      sockets[i].lastdata   = NULL;
  805e4f:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805e56:	00 00 00 
  805e59:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805e5c:	48 63 d2             	movslq %edx,%rdx
  805e5f:	48 c1 e2 05          	shl    $0x5,%rdx
  805e63:	48 01 d0             	add    %rdx,%rax
  805e66:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  805e6d:	00 
      sockets[i].lastoffset = 0;
  805e6e:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805e75:	00 00 00 
  805e78:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805e7b:	48 63 d2             	movslq %edx,%rdx
  805e7e:	48 c1 e2 05          	shl    $0x5,%rdx
  805e82:	48 01 d0             	add    %rdx,%rax
  805e85:	48 83 c0 10          	add    $0x10,%rax
  805e89:	66 c7 00 00 00       	movw   $0x0,(%rax)
      sockets[i].rcvevent   = 0;
  805e8e:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805e95:	00 00 00 
  805e98:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805e9b:	48 63 d2             	movslq %edx,%rdx
  805e9e:	48 c1 e2 05          	shl    $0x5,%rdx
  805ea2:	48 01 d0             	add    %rdx,%rax
  805ea5:	48 83 c0 10          	add    $0x10,%rax
  805ea9:	66 c7 40 02 00 00    	movw   $0x0,0x2(%rax)
      sockets[i].sendevent  = 1; /* TCP send buf is empty */
  805eaf:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805eb6:	00 00 00 
  805eb9:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805ebc:	48 63 d2             	movslq %edx,%rdx
  805ebf:	48 c1 e2 05          	shl    $0x5,%rdx
  805ec3:	48 01 d0             	add    %rdx,%rax
  805ec6:	48 83 c0 10          	add    $0x10,%rax
  805eca:	66 c7 40 04 01 00    	movw   $0x1,0x4(%rax)
      sockets[i].flags      = 0;
  805ed0:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805ed7:	00 00 00 
  805eda:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805edd:	48 63 d2             	movslq %edx,%rdx
  805ee0:	48 c1 e2 05          	shl    $0x5,%rdx
  805ee4:	48 01 d0             	add    %rdx,%rax
  805ee7:	48 83 c0 10          	add    $0x10,%rax
  805eeb:	66 c7 40 06 00 00    	movw   $0x0,0x6(%rax)
      sockets[i].err        = 0;
  805ef1:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805ef8:	00 00 00 
  805efb:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805efe:	48 63 d2             	movslq %edx,%rdx
  805f01:	48 c1 e2 05          	shl    $0x5,%rdx
  805f05:	48 01 d0             	add    %rdx,%rax
  805f08:	48 83 c0 10          	add    $0x10,%rax
  805f0c:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
      sys_sem_signal(socksem);
  805f13:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  805f1a:	00 00 00 
  805f1d:	8b 00                	mov    (%rax),%eax
  805f1f:	89 c7                	mov    %eax,%edi
  805f21:	48 b8 4c 80 81 00 00 	movabs $0x81804c,%rax
  805f28:	00 00 00 
  805f2b:	ff d0                	callq  *%rax
      return i;
  805f2d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805f30:	eb 2d                	jmp    805f5f <alloc_socket+0x183>

  /* Protect socket array */
  sys_sem_wait(socksem);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  805f32:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  805f36:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  805f3a:	0f 8e ce fe ff ff    	jle    805e0e <alloc_socket+0x32>
      sockets[i].err        = 0;
      sys_sem_signal(socksem);
      return i;
    }
  }
  sys_sem_signal(socksem);
  805f40:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  805f47:	00 00 00 
  805f4a:	8b 00                	mov    (%rax),%eax
  805f4c:	89 c7                	mov    %eax,%edi
  805f4e:	48 b8 4c 80 81 00 00 	movabs $0x81804c,%rax
  805f55:	00 00 00 
  805f58:	ff d0                	callq  *%rax
  return -1;
  805f5a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  805f5f:	c9                   	leaveq 
  805f60:	c3                   	retq   

0000000000805f61 <lwip_accept>:
 * Exceptions are documented!
 */

int
lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  805f61:	55                   	push   %rbp
  805f62:	48 89 e5             	mov    %rsp,%rbp
  805f65:	53                   	push   %rbx
  805f66:	48 83 ec 78          	sub    $0x78,%rsp
  805f6a:	89 7d 9c             	mov    %edi,-0x64(%rbp)
  805f6d:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
  805f71:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
  int newsock;
  struct sockaddr_in sin;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  805f75:	8b 45 9c             	mov    -0x64(%rbp),%eax
  805f78:	89 c7                	mov    %eax,%edi
  805f7a:	48 b8 68 5d 80 00 00 	movabs $0x805d68,%rax
  805f81:	00 00 00 
  805f84:	ff d0                	callq  *%rax
  805f86:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if (!sock)
  805f8a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  805f8f:	75 0a                	jne    805f9b <lwip_accept+0x3a>
    return -1;
  805f91:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805f96:	e9 f2 02 00 00       	jmpq   80628d <lwip_accept+0x32c>

  newconn = netconn_accept(sock->conn);
  805f9b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805f9f:	48 8b 00             	mov    (%rax),%rax
  805fa2:	48 89 c7             	mov    %rax,%rdi
  805fa5:	48 b8 6b 9f 81 00 00 	movabs $0x819f6b,%rax
  805fac:	00 00 00 
  805faf:	ff d0                	callq  *%rax
  805fb1:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  if (!newconn) {
  805fb5:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  805fba:	75 62                	jne    80601e <lwip_accept+0xbd>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) failed, err=%d\n", s, sock->conn->err));
    sock_set_errno(sock, err_to_errno(sock->conn->err));
  805fbc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805fc0:	48 8b 00             	mov    (%rax),%rax
  805fc3:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  805fc7:	0f be c0             	movsbl %al,%eax
  805fca:	f7 d8                	neg    %eax
  805fcc:	83 f8 0e             	cmp    $0xe,%eax
  805fcf:	77 24                	ja     805ff5 <lwip_accept+0x94>
  805fd1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805fd5:	48 8b 00             	mov    (%rax),%rax
  805fd8:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  805fdc:	0f be c0             	movsbl %al,%eax
  805fdf:	f7 d8                	neg    %eax
  805fe1:	89 c2                	mov    %eax,%edx
  805fe3:	48 b8 40 16 82 00 00 	movabs $0x821640,%rax
  805fea:	00 00 00 
  805fed:	48 63 d2             	movslq %edx,%rdx
  805ff0:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  805ff3:	eb 05                	jmp    805ffa <lwip_accept+0x99>
  805ff5:	b8 05 00 00 00       	mov    $0x5,%eax
  805ffa:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  805ffe:	89 42 18             	mov    %eax,0x18(%rdx)
  806001:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  806005:	8b 50 18             	mov    0x18(%rax),%edx
  806008:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  80600f:	00 00 00 
  806012:	89 10                	mov    %edx,(%rax)
    return -1;
  806014:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806019:	e9 6f 02 00 00       	jmpq   80628d <lwip_accept+0x32c>
  }

  /* get the IP address and port of the remote host */
  err = netconn_peer(newconn, &naddr, &port);
  80601e:	48 8d 55 be          	lea    -0x42(%rbp),%rdx
  806022:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
  806026:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80602a:	b9 00 00 00 00       	mov    $0x0,%ecx
  80602f:	48 89 c7             	mov    %rax,%rdi
  806032:	48 b8 7c 9c 81 00 00 	movabs $0x819c7c,%rax
  806039:	00 00 00 
  80603c:	ff d0                	callq  *%rax
  80603e:	88 45 df             	mov    %al,-0x21(%rbp)
  if (err != ERR_OK) {
  806041:	80 7d df 00          	cmpb   $0x0,-0x21(%rbp)
  806045:	74 61                	je     8060a8 <lwip_accept+0x147>
    netconn_delete(newconn);
  806047:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80604b:	48 89 c7             	mov    %rax,%rdi
  80604e:	48 b8 ce 9b 81 00 00 	movabs $0x819bce,%rax
  806055:	00 00 00 
  806058:	ff d0                	callq  *%rax
    sock_set_errno(sock, err_to_errno(err));
  80605a:	0f be 45 df          	movsbl -0x21(%rbp),%eax
  80605e:	f7 d8                	neg    %eax
  806060:	83 f8 0e             	cmp    $0xe,%eax
  806063:	77 1a                	ja     80607f <lwip_accept+0x11e>
  806065:	0f be 45 df          	movsbl -0x21(%rbp),%eax
  806069:	f7 d8                	neg    %eax
  80606b:	89 c2                	mov    %eax,%edx
  80606d:	48 b8 40 16 82 00 00 	movabs $0x821640,%rax
  806074:	00 00 00 
  806077:	48 63 d2             	movslq %edx,%rdx
  80607a:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  80607d:	eb 05                	jmp    806084 <lwip_accept+0x123>
  80607f:	b8 05 00 00 00       	mov    $0x5,%eax
  806084:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  806088:	89 42 18             	mov    %eax,0x18(%rdx)
  80608b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80608f:	8b 50 18             	mov    0x18(%rax),%edx
  806092:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806099:	00 00 00 
  80609c:	89 10                	mov    %edx,(%rax)
    return -1;
  80609e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8060a3:	e9 e5 01 00 00       	jmpq   80628d <lwip_accept+0x32c>
  }

  memset(&sin, 0, sizeof(sin));
  8060a8:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8060ac:	ba 10 00 00 00       	mov    $0x10,%edx
  8060b1:	be 00 00 00 00       	mov    $0x0,%esi
  8060b6:	48 89 c7             	mov    %rax,%rdi
  8060b9:	48 b8 70 21 80 00 00 	movabs $0x802170,%rax
  8060c0:	00 00 00 
  8060c3:	ff d0                	callq  *%rax
  sin.sin_len = sizeof(sin);
  8060c5:	c6 45 a0 10          	movb   $0x10,-0x60(%rbp)
  sin.sin_family = AF_INET;
  8060c9:	c6 45 a1 02          	movb   $0x2,-0x5f(%rbp)
  sin.sin_port = htons(port);
  8060cd:	0f b7 45 be          	movzwl -0x42(%rbp),%eax
  8060d1:	0f b7 c0             	movzwl %ax,%eax
  8060d4:	89 c7                	mov    %eax,%edi
  8060d6:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  8060dd:	00 00 00 
  8060e0:	ff d0                	callq  *%rax
  8060e2:	66 89 45 a2          	mov    %ax,-0x5e(%rbp)
  sin.sin_addr.s_addr = naddr.addr;
  8060e6:	8b 45 c0             	mov    -0x40(%rbp),%eax
  8060e9:	89 45 a4             	mov    %eax,-0x5c(%rbp)

  if (*addrlen > sizeof(sin))
  8060ec:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8060f0:	8b 00                	mov    (%rax),%eax
  8060f2:	83 f8 10             	cmp    $0x10,%eax
  8060f5:	76 0a                	jbe    806101 <lwip_accept+0x1a0>
    *addrlen = sizeof(sin);
  8060f7:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8060fb:	c7 00 10 00 00 00    	movl   $0x10,(%rax)

  SMEMCPY(addr, &sin, *addrlen);
  806101:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  806105:	8b 00                	mov    (%rax),%eax
  806107:	89 c2                	mov    %eax,%edx
  806109:	48 8d 4d a0          	lea    -0x60(%rbp),%rcx
  80610d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  806111:	48 89 ce             	mov    %rcx,%rsi
  806114:	48 89 c7             	mov    %rax,%rdi
  806117:	48 b8 12 23 80 00 00 	movabs $0x802312,%rax
  80611e:	00 00 00 
  806121:	ff d0                	callq  *%rax

  newsock = alloc_socket(newconn);
  806123:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  806127:	48 89 c7             	mov    %rax,%rdi
  80612a:	48 b8 dc 5d 80 00 00 	movabs $0x805ddc,%rax
  806131:	00 00 00 
  806134:	ff d0                	callq  *%rax
  806136:	89 45 d8             	mov    %eax,-0x28(%rbp)
  if (newsock == -1) {
  806139:	83 7d d8 ff          	cmpl   $0xffffffff,-0x28(%rbp)
  80613d:	75 3b                	jne    80617a <lwip_accept+0x219>
    netconn_delete(newconn);
  80613f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  806143:	48 89 c7             	mov    %rax,%rdi
  806146:	48 b8 ce 9b 81 00 00 	movabs $0x819bce,%rax
  80614d:	00 00 00 
  806150:	ff d0                	callq  *%rax
    sock_set_errno(sock, ENFILE);
  806152:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  806156:	c7 40 18 17 00 00 00 	movl   $0x17,0x18(%rax)
  80615d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  806161:	8b 50 18             	mov    0x18(%rax),%edx
  806164:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  80616b:	00 00 00 
  80616e:	89 10                	mov    %edx,(%rax)
    return -1;
  806170:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806175:	e9 13 01 00 00       	jmpq   80628d <lwip_accept+0x32c>
  }
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  80617a:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  80617e:	78 06                	js     806186 <lwip_accept+0x225>
  806180:	83 7d d8 1f          	cmpl   $0x1f,-0x28(%rbp)
  806184:	7e 2a                	jle    8061b0 <lwip_accept+0x24f>
  806186:	48 ba 7c 16 82 00 00 	movabs $0x82167c,%rdx
  80618d:	00 00 00 
  806190:	be 26 01 00 00       	mov    $0x126,%esi
  806195:	48 bf 91 16 82 00 00 	movabs $0x821691,%rdi
  80619c:	00 00 00 
  80619f:	b8 00 00 00 00       	mov    $0x0,%eax
  8061a4:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  8061ab:	00 00 00 
  8061ae:	ff d1                	callq  *%rcx
  newconn->callback = event_callback;
  8061b0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8061b4:	48 bb 20 77 80 00 00 	movabs $0x807720,%rbx
  8061bb:	00 00 00 
  8061be:	48 89 58 38          	mov    %rbx,0x38(%rax)
  nsock = &sockets[newsock];
  8061c2:	8b 45 d8             	mov    -0x28(%rbp),%eax
  8061c5:	48 98                	cltq   
  8061c7:	48 c1 e0 05          	shl    $0x5,%rax
  8061cb:	48 89 c2             	mov    %rax,%rdx
  8061ce:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  8061d5:	00 00 00 
  8061d8:	48 01 d0             	add    %rdx,%rax
  8061db:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  LWIP_ASSERT("invalid socket pointer", nsock != NULL);
  8061df:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8061e4:	75 2a                	jne    806210 <lwip_accept+0x2af>
  8061e6:	48 ba a8 16 82 00 00 	movabs $0x8216a8,%rdx
  8061ed:	00 00 00 
  8061f0:	be 29 01 00 00       	mov    $0x129,%esi
  8061f5:	48 bf 91 16 82 00 00 	movabs $0x821691,%rdi
  8061fc:	00 00 00 
  8061ff:	b8 00 00 00 00       	mov    $0x0,%eax
  806204:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80620b:	00 00 00 
  80620e:	ff d1                	callq  *%rcx

  sys_sem_wait(socksem);
  806210:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  806217:	00 00 00 
  80621a:	8b 00                	mov    (%rax),%eax
  80621c:	89 c7                	mov    %eax,%edi
  80621e:	48 b8 ec e6 80 00 00 	movabs $0x80e6ec,%rax
  806225:	00 00 00 
  806228:	ff d0                	callq  *%rax
  /* See event_callback: If data comes in right away after an accept, even
   * though the server task might not have created a new socket yet.
   * In that case, newconn->socket is counted down (newconn->socket--),
   * so nsock->rcvevent is >= 1 here!
   */
  nsock->rcvevent += -1 - newconn->socket;
  80622a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80622e:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  806232:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  806236:	8b 40 20             	mov    0x20(%rax),%eax
  806239:	29 c2                	sub    %eax,%edx
  80623b:	89 d0                	mov    %edx,%eax
  80623d:	8d 50 ff             	lea    -0x1(%rax),%edx
  806240:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  806244:	66 89 50 12          	mov    %dx,0x12(%rax)
  newconn->socket = newsock;
  806248:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80624c:	8b 55 d8             	mov    -0x28(%rbp),%edx
  80624f:	89 50 20             	mov    %edx,0x20(%rax)
  sys_sem_signal(socksem);
  806252:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  806259:	00 00 00 
  80625c:	8b 00                	mov    (%rax),%eax
  80625e:	89 c7                	mov    %eax,%edi
  806260:	48 b8 4c 80 81 00 00 	movabs $0x81804c,%rax
  806267:	00 00 00 
  80626a:	ff d0                	callq  *%rax

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
  80626c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  806270:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  806277:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80627b:	8b 50 18             	mov    0x18(%rax),%edx
  80627e:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806285:	00 00 00 
  806288:	89 10                	mov    %edx,(%rax)
  return newsock;
  80628a:	8b 45 d8             	mov    -0x28(%rbp),%eax
}
  80628d:	48 83 c4 78          	add    $0x78,%rsp
  806291:	5b                   	pop    %rbx
  806292:	5d                   	pop    %rbp
  806293:	c3                   	retq   

0000000000806294 <lwip_bind>:

int
lwip_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  806294:	55                   	push   %rbp
  806295:	48 89 e5             	mov    %rsp,%rbp
  806298:	48 83 ec 20          	sub    $0x20,%rsp
  80629c:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80629f:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8062a3:	89 55 e8             	mov    %edx,-0x18(%rbp)
  struct lwip_socket *sock;
  struct ip_addr local_addr;
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
  8062a6:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8062a9:	89 c7                	mov    %eax,%edi
  8062ab:	48 b8 68 5d 80 00 00 	movabs $0x805d68,%rax
  8062b2:	00 00 00 
  8062b5:	ff d0                	callq  *%rax
  8062b7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock)
  8062bb:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8062c0:	75 0a                	jne    8062cc <lwip_bind+0x38>
    return -1;
  8062c2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8062c7:	e9 fb 00 00 00       	jmpq   8063c7 <lwip_bind+0x133>

  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  8062cc:	83 7d e8 10          	cmpl   $0x10,-0x18(%rbp)
  8062d0:	75 0c                	jne    8062de <lwip_bind+0x4a>
  8062d2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8062d6:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8062da:	3c 02                	cmp    $0x2,%al
  8062dc:	74 2a                	je     806308 <lwip_bind+0x74>
  8062de:	48 ba bf 16 82 00 00 	movabs $0x8216bf,%rdx
  8062e5:	00 00 00 
  8062e8:	be 4b 01 00 00       	mov    $0x14b,%esi
  8062ed:	48 bf 91 16 82 00 00 	movabs $0x821691,%rdi
  8062f4:	00 00 00 
  8062f7:	b8 00 00 00 00       	mov    $0x0,%eax
  8062fc:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  806303:	00 00 00 
  806306:	ff d1                	callq  *%rcx
             ((((struct sockaddr_in *)name)->sin_family) == AF_INET)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  local_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  806308:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80630c:	8b 40 04             	mov    0x4(%rax),%eax
  80630f:	89 45 f0             	mov    %eax,-0x10(%rbp)
  local_port = ((struct sockaddr_in *)name)->sin_port;
  806312:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  806316:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  80631a:	66 89 45 f6          	mov    %ax,-0xa(%rbp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &local_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(local_port)));

  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
  80631e:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  806322:	89 c7                	mov    %eax,%edi
  806324:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  80632b:	00 00 00 
  80632e:	ff d0                	callq  *%rax
  806330:	0f b7 d0             	movzwl %ax,%edx
  806333:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806337:	48 8b 00             	mov    (%rax),%rax
  80633a:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  80633e:	48 89 ce             	mov    %rcx,%rsi
  806341:	48 89 c7             	mov    %rax,%rdi
  806344:	48 b8 72 9d 81 00 00 	movabs $0x819d72,%rax
  80634b:	00 00 00 
  80634e:	ff d0                	callq  *%rax
  806350:	88 45 f5             	mov    %al,-0xb(%rbp)

  if (err != ERR_OK) {
  806353:	80 7d f5 00          	cmpb   $0x0,-0xb(%rbp)
  806357:	74 4b                	je     8063a4 <lwip_bind+0x110>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  806359:	0f be 45 f5          	movsbl -0xb(%rbp),%eax
  80635d:	f7 d8                	neg    %eax
  80635f:	83 f8 0e             	cmp    $0xe,%eax
  806362:	77 1a                	ja     80637e <lwip_bind+0xea>
  806364:	0f be 45 f5          	movsbl -0xb(%rbp),%eax
  806368:	f7 d8                	neg    %eax
  80636a:	89 c2                	mov    %eax,%edx
  80636c:	48 b8 40 16 82 00 00 	movabs $0x821640,%rax
  806373:	00 00 00 
  806376:	48 63 d2             	movslq %edx,%rdx
  806379:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  80637c:	eb 05                	jmp    806383 <lwip_bind+0xef>
  80637e:	b8 05 00 00 00       	mov    $0x5,%eax
  806383:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  806387:	89 42 18             	mov    %eax,0x18(%rdx)
  80638a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80638e:	8b 50 18             	mov    0x18(%rax),%edx
  806391:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806398:	00 00 00 
  80639b:	89 10                	mov    %edx,(%rax)
    return -1;
  80639d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8063a2:	eb 23                	jmp    8063c7 <lwip_bind+0x133>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  8063a4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8063a8:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  8063af:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8063b3:	8b 50 18             	mov    0x18(%rax),%edx
  8063b6:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8063bd:	00 00 00 
  8063c0:	89 10                	mov    %edx,(%rax)
  return 0;
  8063c2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8063c7:	c9                   	leaveq 
  8063c8:	c3                   	retq   

00000000008063c9 <lwip_close>:

int
lwip_close(int s)
{
  8063c9:	55                   	push   %rbp
  8063ca:	48 89 e5             	mov    %rsp,%rbp
  8063cd:	48 83 ec 20          	sub    $0x20,%rsp
  8063d1:	89 7d ec             	mov    %edi,-0x14(%rbp)
  struct lwip_socket *sock;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
  8063d4:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8063d7:	89 c7                	mov    %eax,%edi
  8063d9:	48 b8 68 5d 80 00 00 	movabs $0x805d68,%rax
  8063e0:	00 00 00 
  8063e3:	ff d0                	callq  *%rax
  8063e5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock) {
  8063e9:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8063ee:	75 0a                	jne    8063fa <lwip_close+0x31>
    return -1;
  8063f0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8063f5:	e9 b2 00 00 00       	jmpq   8064ac <lwip_close+0xe3>
  }

  netconn_delete(sock->conn);
  8063fa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8063fe:	48 8b 00             	mov    (%rax),%rax
  806401:	48 89 c7             	mov    %rax,%rdi
  806404:	48 b8 ce 9b 81 00 00 	movabs $0x819bce,%rax
  80640b:	00 00 00 
  80640e:	ff d0                	callq  *%rax

  sys_sem_wait(socksem);
  806410:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  806417:	00 00 00 
  80641a:	8b 00                	mov    (%rax),%eax
  80641c:	89 c7                	mov    %eax,%edi
  80641e:	48 b8 ec e6 80 00 00 	movabs $0x80e6ec,%rax
  806425:	00 00 00 
  806428:	ff d0                	callq  *%rax
  if (sock->lastdata) {
  80642a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80642e:	48 8b 40 08          	mov    0x8(%rax),%rax
  806432:	48 85 c0             	test   %rax,%rax
  806435:	74 17                	je     80644e <lwip_close+0x85>
    netbuf_delete(sock->lastdata);
  806437:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80643b:	48 8b 40 08          	mov    0x8(%rax),%rax
  80643f:	48 89 c7             	mov    %rax,%rdi
  806442:	48 b8 b5 8e 80 00 00 	movabs $0x808eb5,%rax
  806449:	00 00 00 
  80644c:	ff d0                	callq  *%rax
  }
  sock->lastdata   = NULL;
  80644e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806452:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  806459:	00 
  sock->lastoffset = 0;
  80645a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80645e:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
  sock->conn       = NULL;
  806464:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806468:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  sock_set_errno(sock, 0);
  80646f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806473:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  80647a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80647e:	8b 50 18             	mov    0x18(%rax),%edx
  806481:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806488:	00 00 00 
  80648b:	89 10                	mov    %edx,(%rax)
  sys_sem_signal(socksem);
  80648d:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  806494:	00 00 00 
  806497:	8b 00                	mov    (%rax),%eax
  806499:	89 c7                	mov    %eax,%edi
  80649b:	48 b8 4c 80 81 00 00 	movabs $0x81804c,%rax
  8064a2:	00 00 00 
  8064a5:	ff d0                	callq  *%rax
  return 0;
  8064a7:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8064ac:	c9                   	leaveq 
  8064ad:	c3                   	retq   

00000000008064ae <lwip_connect>:

int
lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  8064ae:	55                   	push   %rbp
  8064af:	48 89 e5             	mov    %rsp,%rbp
  8064b2:	48 83 ec 30          	sub    $0x30,%rsp
  8064b6:	89 7d dc             	mov    %edi,-0x24(%rbp)
  8064b9:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8064bd:	89 55 d8             	mov    %edx,-0x28(%rbp)
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
  8064c0:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8064c3:	89 c7                	mov    %eax,%edi
  8064c5:	48 b8 68 5d 80 00 00 	movabs $0x805d68,%rax
  8064cc:	00 00 00 
  8064cf:	ff d0                	callq  *%rax
  8064d1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (!sock)
  8064d5:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8064da:	75 0a                	jne    8064e6 <lwip_connect+0x38>
    return -1;
  8064dc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8064e1:	e9 22 01 00 00       	jmpq   806608 <lwip_connect+0x15a>

  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  8064e6:	83 7d d8 10          	cmpl   $0x10,-0x28(%rbp)
  8064ea:	75 0c                	jne    8064f8 <lwip_connect+0x4a>
  8064ec:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8064f0:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8064f4:	3c 02                	cmp    $0x2,%al
  8064f6:	74 2a                	je     806522 <lwip_connect+0x74>
  8064f8:	48 ba da 16 82 00 00 	movabs $0x8216da,%rdx
  8064ff:	00 00 00 
  806502:	be 87 01 00 00       	mov    $0x187,%esi
  806507:	48 bf 91 16 82 00 00 	movabs $0x821691,%rdi
  80650e:	00 00 00 
  806511:	b8 00 00 00 00       	mov    $0x0,%eax
  806516:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80651d:	00 00 00 
  806520:	ff d1                	callq  *%rcx
             ((((struct sockaddr_in *)name)->sin_family) == AF_INET)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  if (((struct sockaddr_in *)name)->sin_family == AF_UNSPEC) {
  806522:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  806526:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80652a:	84 c0                	test   %al,%al
  80652c:	75 1b                	jne    806549 <lwip_connect+0x9b>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, AF_UNSPEC)\n", s));
    err = netconn_disconnect(sock->conn);
  80652e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806532:	48 8b 00             	mov    (%rax),%rax
  806535:	48 89 c7             	mov    %rax,%rdi
  806538:	48 b8 86 9e 81 00 00 	movabs $0x819e86,%rax
  80653f:	00 00 00 
  806542:	ff d0                	callq  *%rax
  806544:	88 45 ff             	mov    %al,-0x1(%rbp)
  806547:	eb 4b                	jmp    806594 <lwip_connect+0xe6>
  } else {
    struct ip_addr remote_addr;
    u16_t remote_port;

    remote_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  806549:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80654d:	8b 40 04             	mov    0x4(%rax),%eax
  806550:	89 45 e0             	mov    %eax,-0x20(%rbp)
    remote_port = ((struct sockaddr_in *)name)->sin_port;
  806553:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  806557:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  80655b:	66 89 45 ee          	mov    %ax,-0x12(%rbp)

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
    //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(remote_port)));

    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  80655f:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  806563:	89 c7                	mov    %eax,%edi
  806565:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  80656c:	00 00 00 
  80656f:	ff d0                	callq  *%rax
  806571:	0f b7 d0             	movzwl %ax,%edx
  806574:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806578:	48 8b 00             	mov    (%rax),%rax
  80657b:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  80657f:	48 89 ce             	mov    %rcx,%rsi
  806582:	48 89 c7             	mov    %rax,%rdi
  806585:	48 b8 fc 9d 81 00 00 	movabs $0x819dfc,%rax
  80658c:	00 00 00 
  80658f:	ff d0                	callq  *%rax
  806591:	88 45 ff             	mov    %al,-0x1(%rbp)
  }

  if (err != ERR_OK) {
  806594:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  806598:	74 4b                	je     8065e5 <lwip_connect+0x137>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  80659a:	0f be 45 ff          	movsbl -0x1(%rbp),%eax
  80659e:	f7 d8                	neg    %eax
  8065a0:	83 f8 0e             	cmp    $0xe,%eax
  8065a3:	77 1a                	ja     8065bf <lwip_connect+0x111>
  8065a5:	0f be 45 ff          	movsbl -0x1(%rbp),%eax
  8065a9:	f7 d8                	neg    %eax
  8065ab:	89 c2                	mov    %eax,%edx
  8065ad:	48 b8 40 16 82 00 00 	movabs $0x821640,%rax
  8065b4:	00 00 00 
  8065b7:	48 63 d2             	movslq %edx,%rdx
  8065ba:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  8065bd:	eb 05                	jmp    8065c4 <lwip_connect+0x116>
  8065bf:	b8 05 00 00 00       	mov    $0x5,%eax
  8065c4:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8065c8:	89 42 18             	mov    %eax,0x18(%rdx)
  8065cb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8065cf:	8b 50 18             	mov    0x18(%rax),%edx
  8065d2:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8065d9:	00 00 00 
  8065dc:	89 10                	mov    %edx,(%rax)
    return -1;
  8065de:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8065e3:	eb 23                	jmp    806608 <lwip_connect+0x15a>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  8065e5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8065e9:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  8065f0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8065f4:	8b 50 18             	mov    0x18(%rax),%edx
  8065f7:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8065fe:	00 00 00 
  806601:	89 10                	mov    %edx,(%rax)
  return 0;
  806603:	b8 00 00 00 00       	mov    $0x0,%eax
}
  806608:	c9                   	leaveq 
  806609:	c3                   	retq   

000000000080660a <lwip_listen>:
 * @param backlog (ATTENTION: need TCP_LISTEN_BACKLOG=1)
 * @return 0 on success, non-zero on failure
 */
int
lwip_listen(int s, int backlog)
{
  80660a:	55                   	push   %rbp
  80660b:	48 89 e5             	mov    %rsp,%rbp
  80660e:	48 83 ec 20          	sub    $0x20,%rsp
  806612:	89 7d ec             	mov    %edi,-0x14(%rbp)
  806615:	89 75 e8             	mov    %esi,-0x18(%rbp)
  struct lwip_socket *sock;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
  806618:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80661b:	89 c7                	mov    %eax,%edi
  80661d:	48 b8 68 5d 80 00 00 	movabs $0x805d68,%rax
  806624:	00 00 00 
  806627:	ff d0                	callq  *%rax
  806629:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock)
  80662d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  806632:	75 0a                	jne    80663e <lwip_listen+0x34>
    return -1;
  806634:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806639:	e9 b2 00 00 00       	jmpq   8066f0 <lwip_listen+0xe6>

  /* limit the "backlog" parameter to fit in an u8_t */
  if (backlog < 0) {
  80663e:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  806642:	79 07                	jns    80664b <lwip_listen+0x41>
    backlog = 0;
  806644:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
  }
  if (backlog > 0xff) {
  80664b:	81 7d e8 ff 00 00 00 	cmpl   $0xff,-0x18(%rbp)
  806652:	7e 07                	jle    80665b <lwip_listen+0x51>
    backlog = 0xff;
  806654:	c7 45 e8 ff 00 00 00 	movl   $0xff,-0x18(%rbp)
  }

  err = netconn_listen_with_backlog(sock->conn, backlog);
  80665b:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80665e:	0f b6 d0             	movzbl %al,%edx
  806661:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806665:	48 8b 00             	mov    (%rax),%rax
  806668:	89 d6                	mov    %edx,%esi
  80666a:	48 89 c7             	mov    %rax,%rdi
  80666d:	48 b8 f6 9e 81 00 00 	movabs $0x819ef6,%rax
  806674:	00 00 00 
  806677:	ff d0                	callq  *%rax
  806679:	88 45 f7             	mov    %al,-0x9(%rbp)

  if (err != ERR_OK) {
  80667c:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  806680:	74 4b                	je     8066cd <lwip_listen+0xc3>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  806682:	0f be 45 f7          	movsbl -0x9(%rbp),%eax
  806686:	f7 d8                	neg    %eax
  806688:	83 f8 0e             	cmp    $0xe,%eax
  80668b:	77 1a                	ja     8066a7 <lwip_listen+0x9d>
  80668d:	0f be 45 f7          	movsbl -0x9(%rbp),%eax
  806691:	f7 d8                	neg    %eax
  806693:	89 c2                	mov    %eax,%edx
  806695:	48 b8 40 16 82 00 00 	movabs $0x821640,%rax
  80669c:	00 00 00 
  80669f:	48 63 d2             	movslq %edx,%rdx
  8066a2:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  8066a5:	eb 05                	jmp    8066ac <lwip_listen+0xa2>
  8066a7:	b8 05 00 00 00       	mov    $0x5,%eax
  8066ac:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8066b0:	89 42 18             	mov    %eax,0x18(%rdx)
  8066b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8066b7:	8b 50 18             	mov    0x18(%rax),%edx
  8066ba:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8066c1:	00 00 00 
  8066c4:	89 10                	mov    %edx,(%rax)
    return -1;
  8066c6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8066cb:	eb 23                	jmp    8066f0 <lwip_listen+0xe6>
  }

  sock_set_errno(sock, 0);
  8066cd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8066d1:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  8066d8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8066dc:	8b 50 18             	mov    0x18(%rax),%edx
  8066df:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8066e6:	00 00 00 
  8066e9:	89 10                	mov    %edx,(%rax)
  return 0;
  8066eb:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8066f0:	c9                   	leaveq 
  8066f1:	c3                   	retq   

00000000008066f2 <lwip_recvfrom>:

int
lwip_recvfrom(int s, void *mem, int len, unsigned int flags,
        struct sockaddr *from, socklen_t *fromlen)
{
  8066f2:	55                   	push   %rbp
  8066f3:	48 89 e5             	mov    %rsp,%rbp
  8066f6:	48 83 ec 70          	sub    $0x70,%rsp
  8066fa:	89 7d bc             	mov    %edi,-0x44(%rbp)
  8066fd:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  806701:	89 55 b8             	mov    %edx,-0x48(%rbp)
  806704:	89 4d ac             	mov    %ecx,-0x54(%rbp)
  806707:	4c 89 45 a0          	mov    %r8,-0x60(%rbp)
  80670b:	4c 89 4d 98          	mov    %r9,-0x68(%rbp)
  struct lwip_socket *sock;
  struct netbuf      *buf;
  u16_t               buflen, copylen, off = 0;
  80670f:	66 c7 45 f4 00 00    	movw   $0x0,-0xc(%rbp)
  struct ip_addr     *addr;
  u16_t               port;
  u8_t                done = 0;
  806715:	c6 45 e7 00          	movb   $0x0,-0x19(%rbp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  806719:	8b 45 bc             	mov    -0x44(%rbp),%eax
  80671c:	89 c7                	mov    %eax,%edi
  80671e:	48 b8 68 5d 80 00 00 	movabs $0x805d68,%rax
  806725:	00 00 00 
  806728:	ff d0                	callq  *%rax
  80672a:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (!sock)
  80672e:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  806733:	75 0a                	jne    80673f <lwip_recvfrom+0x4d>
    return -1;
  806735:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80673a:	e9 8b 03 00 00       	jmpq   806aca <lwip_recvfrom+0x3d8>

  do {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: top while sock->lastdata=%p\n", (void*)sock->lastdata));
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
  80673f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806743:	48 8b 40 08          	mov    0x8(%rax),%rax
  806747:	48 85 c0             	test   %rax,%rax
  80674a:	74 11                	je     80675d <lwip_recvfrom+0x6b>
      buf = sock->lastdata;
  80674c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806750:	48 8b 40 08          	mov    0x8(%rax),%rax
  806754:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  806758:	e9 0c 01 00 00       	jmpq   806869 <lwip_recvfrom+0x177>
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  80675d:	8b 45 ac             	mov    -0x54(%rbp),%eax
  806760:	83 e0 08             	and    $0x8,%eax
  806763:	85 c0                	test   %eax,%eax
  806765:	75 14                	jne    80677b <lwip_recvfrom+0x89>
  806767:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80676b:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  80676f:	0f b7 c0             	movzwl %ax,%eax
  806772:	25 00 08 00 00       	and    $0x800,%eax
  806777:	85 c0                	test   %eax,%eax
  806779:	74 35                	je     8067b0 <lwip_recvfrom+0xbe>
  80677b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80677f:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  806783:	66 85 c0             	test   %ax,%ax
  806786:	75 28                	jne    8067b0 <lwip_recvfrom+0xbe>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", s));
        sock_set_errno(sock, EWOULDBLOCK);
  806788:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80678c:	c7 40 18 0b 00 00 00 	movl   $0xb,0x18(%rax)
  806793:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806797:	8b 50 18             	mov    0x18(%rax),%edx
  80679a:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8067a1:	00 00 00 
  8067a4:	89 10                	mov    %edx,(%rax)
        return -1;
  8067a6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8067ab:	e9 1a 03 00 00       	jmpq   806aca <lwip_recvfrom+0x3d8>
      }

      /* No data was left from the previous operation, so we try to get
      some from the network. */
      sock->lastdata = buf = netconn_recv(sock->conn);
  8067b0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8067b4:	48 8b 00             	mov    (%rax),%rax
  8067b7:	48 89 c7             	mov    %rax,%rdi
  8067ba:	48 b8 2d a0 81 00 00 	movabs $0x81a02d,%rax
  8067c1:	00 00 00 
  8067c4:	ff d0                	callq  *%rax
  8067c6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8067ca:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8067ce:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8067d2:	48 89 50 08          	mov    %rdx,0x8(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: netconn_recv netbuf=%p\n", (void*)buf));

      if (!buf) {
  8067d6:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8067db:	0f 85 88 00 00 00    	jne    806869 <lwip_recvfrom+0x177>
        /* We should really do some error checking here. */
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): buf == NULL!\n", s));
        sock_set_errno(sock, (((sock->conn->pcb.ip!=NULL) && (sock->conn->err==ERR_OK))?ETIMEDOUT:err_to_errno(sock->conn->err)));
  8067e1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8067e5:	48 8b 00             	mov    (%rax),%rax
  8067e8:	48 8b 40 08          	mov    0x8(%rax),%rax
  8067ec:	48 85 c0             	test   %rax,%rax
  8067ef:	74 0f                	je     806800 <lwip_recvfrom+0x10e>
  8067f1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8067f5:	48 8b 00             	mov    (%rax),%rax
  8067f8:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  8067fc:	84 c0                	test   %al,%al
  8067fe:	74 40                	je     806840 <lwip_recvfrom+0x14e>
  806800:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806804:	48 8b 00             	mov    (%rax),%rax
  806807:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  80680b:	0f be c0             	movsbl %al,%eax
  80680e:	f7 d8                	neg    %eax
  806810:	83 f8 0e             	cmp    $0xe,%eax
  806813:	77 24                	ja     806839 <lwip_recvfrom+0x147>
  806815:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806819:	48 8b 00             	mov    (%rax),%rax
  80681c:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  806820:	0f be c0             	movsbl %al,%eax
  806823:	f7 d8                	neg    %eax
  806825:	89 c2                	mov    %eax,%edx
  806827:	48 b8 40 16 82 00 00 	movabs $0x821640,%rax
  80682e:	00 00 00 
  806831:	48 63 d2             	movslq %edx,%rdx
  806834:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  806837:	eb 05                	jmp    80683e <lwip_recvfrom+0x14c>
  806839:	b8 05 00 00 00       	mov    $0x5,%eax
  80683e:	eb 05                	jmp    806845 <lwip_recvfrom+0x153>
  806840:	b8 6e 00 00 00       	mov    $0x6e,%eax
  806845:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  806849:	89 42 18             	mov    %eax,0x18(%rdx)
  80684c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806850:	8b 50 18             	mov    0x18(%rax),%edx
  806853:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  80685a:	00 00 00 
  80685d:	89 10                	mov    %edx,(%rax)
        return 0;
  80685f:	b8 00 00 00 00       	mov    $0x0,%eax
  806864:	e9 61 02 00 00       	jmpq   806aca <lwip_recvfrom+0x3d8>
      }
    }

    buflen = netbuf_len(buf);
  806869:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80686d:	48 8b 00             	mov    (%rax),%rax
  806870:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  806874:	66 89 45 d6          	mov    %ax,-0x2a(%rbp)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%d len=%d off=%d sock->lastoffset=%d\n", buflen, len, off, sock->lastoffset));

    buflen -= sock->lastoffset;
  806878:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80687c:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  806880:	66 29 45 d6          	sub    %ax,-0x2a(%rbp)

    if (len > buflen) {
  806884:	0f b7 45 d6          	movzwl -0x2a(%rbp),%eax
  806888:	3b 45 b8             	cmp    -0x48(%rbp),%eax
  80688b:	7d 0a                	jge    806897 <lwip_recvfrom+0x1a5>
      copylen = buflen;
  80688d:	0f b7 45 d6          	movzwl -0x2a(%rbp),%eax
  806891:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
  806895:	eb 07                	jmp    80689e <lwip_recvfrom+0x1ac>
    } else {
      copylen = len;
  806897:	8b 45 b8             	mov    -0x48(%rbp),%eax
  80689a:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
    }

    /* copy the contents of the received buffer into
    the supplied memory pointer mem */
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);
  80689e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8068a2:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  8068a6:	0f b7 c8             	movzwl %ax,%ecx
  8068a9:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  8068ad:	0f b7 75 f4          	movzwl -0xc(%rbp),%esi
  8068b1:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8068b5:	48 01 c6             	add    %rax,%rsi
  8068b8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8068bc:	48 8b 00             	mov    (%rax),%rax
  8068bf:	48 89 c7             	mov    %rax,%rdi
  8068c2:	48 b8 4e e4 80 00 00 	movabs $0x80e44e,%rax
  8068c9:	00 00 00 
  8068cc:	ff d0                	callq  *%rax

    off += copylen;
  8068ce:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  8068d2:	66 01 45 f4          	add    %ax,-0xc(%rbp)

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  8068d6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8068da:	48 8b 00             	mov    (%rax),%rax
  8068dd:	48 89 c7             	mov    %rax,%rdi
  8068e0:	48 b8 37 9c 81 00 00 	movabs $0x819c37,%rax
  8068e7:	00 00 00 
  8068ea:	ff d0                	callq  *%rax
  8068ec:	83 f8 10             	cmp    $0x10,%eax
  8068ef:	75 35                	jne    806926 <lwip_recvfrom+0x234>
      len -= copylen;
  8068f1:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  8068f5:	29 45 b8             	sub    %eax,-0x48(%rbp)
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
  8068f8:	83 7d b8 00          	cmpl   $0x0,-0x48(%rbp)
  8068fc:	7e 22                	jle    806920 <lwip_recvfrom+0x22e>
  8068fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806902:	48 8b 00             	mov    (%rax),%rax
  806905:	0f b6 40 15          	movzbl 0x15(%rax),%eax
  806909:	0f b6 c0             	movzbl %al,%eax
  80690c:	83 e0 01             	and    $0x1,%eax
  80690f:	85 c0                	test   %eax,%eax
  806911:	75 0d                	jne    806920 <lwip_recvfrom+0x22e>
  806913:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806917:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80691b:	66 85 c0             	test   %ax,%ax
  80691e:	75 0a                	jne    80692a <lwip_recvfrom+0x238>
        done = 1;
  806920:	c6 45 e7 01          	movb   $0x1,-0x19(%rbp)
  806924:	eb 04                	jmp    80692a <lwip_recvfrom+0x238>
      }
    } else {
      done = 1;
  806926:	c6 45 e7 01          	movb   $0x1,-0x19(%rbp)
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  80692a:	8b 45 ac             	mov    -0x54(%rbp),%eax
  80692d:	83 e0 01             	and    $0x1,%eax
  806930:	85 c0                	test   %eax,%eax
  806932:	75 6e                	jne    8069a2 <lwip_recvfrom+0x2b0>
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  806934:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806938:	48 8b 00             	mov    (%rax),%rax
  80693b:	8b 00                	mov    (%rax),%eax
  80693d:	83 f8 10             	cmp    $0x10,%eax
  806940:	75 35                	jne    806977 <lwip_recvfrom+0x285>
  806942:	0f b7 55 d6          	movzwl -0x2a(%rbp),%edx
  806946:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  80694a:	29 c2                	sub    %eax,%edx
  80694c:	89 d0                	mov    %edx,%eax
  80694e:	85 c0                	test   %eax,%eax
  806950:	7e 25                	jle    806977 <lwip_recvfrom+0x285>
        sock->lastdata = buf;
  806952:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806956:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80695a:	48 89 50 08          	mov    %rdx,0x8(%rax)
        sock->lastoffset += copylen;
  80695e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806962:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  806966:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  80696a:	01 c2                	add    %eax,%edx
  80696c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806970:	66 89 50 10          	mov    %dx,0x10(%rax)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", (void*)buf));
  806974:	90                   	nop
  806975:	eb 2f                	jmp    8069a6 <lwip_recvfrom+0x2b4>
      } else {
        sock->lastdata = NULL;
  806977:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80697b:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  806982:	00 
        sock->lastoffset = 0;
  806983:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806987:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: deleting netbuf=%p\n", (void*)buf));
        netbuf_delete(buf);
  80698d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806991:	48 89 c7             	mov    %rax,%rdi
  806994:	48 b8 b5 8e 80 00 00 	movabs $0x808eb5,%rax
  80699b:	00 00 00 
  80699e:	ff d0                	callq  *%rax
  8069a0:	eb 04                	jmp    8069a6 <lwip_recvfrom+0x2b4>
      }
    } else {
      done = 1;
  8069a2:	c6 45 e7 01          	movb   $0x1,-0x19(%rbp)
    }
  } while (!done);
  8069a6:	80 7d e7 00          	cmpb   $0x0,-0x19(%rbp)
  8069aa:	0f 84 8f fd ff ff    	je     80673f <lwip_recvfrom+0x4d>

  /* Check to see from where the data was.*/
  if (from && fromlen) {
  8069b0:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  8069b5:	0f 84 ed 00 00 00    	je     806aa8 <lwip_recvfrom+0x3b6>
  8069bb:	48 83 7d 98 00       	cmpq   $0x0,-0x68(%rbp)
  8069c0:	0f 84 e2 00 00 00    	je     806aa8 <lwip_recvfrom+0x3b6>
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  8069c6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8069ca:	48 8b 00             	mov    (%rax),%rax
  8069cd:	48 89 c7             	mov    %rax,%rdi
  8069d0:	48 b8 37 9c 81 00 00 	movabs $0x819c37,%rax
  8069d7:	00 00 00 
  8069da:	ff d0                	callq  *%rax
  8069dc:	83 f8 10             	cmp    $0x10,%eax
  8069df:	75 31                	jne    806a12 <lwip_recvfrom+0x320>
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
  8069e1:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  8069e5:	48 83 c0 04          	add    $0x4,%rax
  8069e9:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      netconn_getaddr(sock->conn, addr, &port, 0);
  8069ed:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8069f1:	48 8b 00             	mov    (%rax),%rax
  8069f4:	48 8d 55 d4          	lea    -0x2c(%rbp),%rdx
  8069f8:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  8069fc:	b9 00 00 00 00       	mov    $0x0,%ecx
  806a01:	48 89 c7             	mov    %rax,%rdi
  806a04:	48 b8 7c 9c 81 00 00 	movabs $0x819c7c,%rax
  806a0b:	00 00 00 
  806a0e:	ff d0                	callq  *%rax
  806a10:	eb 18                	jmp    806a2a <lwip_recvfrom+0x338>
    } else {
      addr = netbuf_fromaddr(buf);
  806a12:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806a16:	48 8b 40 10          	mov    0x10(%rax),%rax
  806a1a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      port = netbuf_fromport(buf);
  806a1e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806a22:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  806a26:	66 89 45 d4          	mov    %ax,-0x2c(%rbp)
    }

    memset(&sin, 0, sizeof(sin));
  806a2a:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  806a2e:	ba 10 00 00 00       	mov    $0x10,%edx
  806a33:	be 00 00 00 00       	mov    $0x0,%esi
  806a38:	48 89 c7             	mov    %rax,%rdi
  806a3b:	48 b8 70 21 80 00 00 	movabs $0x802170,%rax
  806a42:	00 00 00 
  806a45:	ff d0                	callq  *%rax
    sin.sin_len = sizeof(sin);
  806a47:	c6 45 c0 10          	movb   $0x10,-0x40(%rbp)
    sin.sin_family = AF_INET;
  806a4b:	c6 45 c1 02          	movb   $0x2,-0x3f(%rbp)
    sin.sin_port = htons(port);
  806a4f:	0f b7 45 d4          	movzwl -0x2c(%rbp),%eax
  806a53:	0f b7 c0             	movzwl %ax,%eax
  806a56:	89 c7                	mov    %eax,%edi
  806a58:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  806a5f:	00 00 00 
  806a62:	ff d0                	callq  *%rax
  806a64:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)
    sin.sin_addr.s_addr = addr->addr;
  806a68:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  806a6c:	8b 00                	mov    (%rax),%eax
  806a6e:	89 45 c4             	mov    %eax,-0x3c(%rbp)

    if (*fromlen > sizeof(sin))
  806a71:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  806a75:	8b 00                	mov    (%rax),%eax
  806a77:	83 f8 10             	cmp    $0x10,%eax
  806a7a:	76 0a                	jbe    806a86 <lwip_recvfrom+0x394>
      *fromlen = sizeof(sin);
  806a7c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  806a80:	c7 00 10 00 00 00    	movl   $0x10,(%rax)

    SMEMCPY(from, &sin, *fromlen);
  806a86:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  806a8a:	8b 00                	mov    (%rax),%eax
  806a8c:	89 c2                	mov    %eax,%edx
  806a8e:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  806a92:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  806a96:	48 89 ce             	mov    %rcx,%rsi
  806a99:	48 89 c7             	mov    %rax,%rdi
  806a9c:	48 b8 12 23 80 00 00 	movabs $0x802312,%rax
  806aa3:	00 00 00 
  806aa6:	ff d0                	callq  *%rax
    //ip_addr_debug_print(SOCKETS_DEBUG, addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u len=%u\n", port, off));
#endif /*  SOCKETS_DEBUG */
  }

  sock_set_errno(sock, 0);
  806aa8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806aac:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  806ab3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806ab7:	8b 50 18             	mov    0x18(%rax),%edx
  806aba:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806ac1:	00 00 00 
  806ac4:	89 10                	mov    %edx,(%rax)
  return off;
  806ac6:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
}
  806aca:	c9                   	leaveq 
  806acb:	c3                   	retq   

0000000000806acc <lwip_read>:

int
lwip_read(int s, void *mem, int len)
{
  806acc:	55                   	push   %rbp
  806acd:	48 89 e5             	mov    %rsp,%rbp
  806ad0:	48 83 ec 10          	sub    $0x10,%rsp
  806ad4:	89 7d fc             	mov    %edi,-0x4(%rbp)
  806ad7:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  806adb:	89 55 f8             	mov    %edx,-0x8(%rbp)
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
  806ade:	8b 55 f8             	mov    -0x8(%rbp),%edx
  806ae1:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  806ae5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806ae8:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  806aee:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  806af4:	b9 00 00 00 00       	mov    $0x0,%ecx
  806af9:	89 c7                	mov    %eax,%edi
  806afb:	48 b8 f2 66 80 00 00 	movabs $0x8066f2,%rax
  806b02:	00 00 00 
  806b05:	ff d0                	callq  *%rax
}
  806b07:	c9                   	leaveq 
  806b08:	c3                   	retq   

0000000000806b09 <lwip_recv>:

int
lwip_recv(int s, void *mem, int len, unsigned int flags)
{
  806b09:	55                   	push   %rbp
  806b0a:	48 89 e5             	mov    %rsp,%rbp
  806b0d:	48 83 ec 20          	sub    $0x20,%rsp
  806b11:	89 7d fc             	mov    %edi,-0x4(%rbp)
  806b14:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  806b18:	89 55 f8             	mov    %edx,-0x8(%rbp)
  806b1b:	89 4d ec             	mov    %ecx,-0x14(%rbp)
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
  806b1e:	8b 4d ec             	mov    -0x14(%rbp),%ecx
  806b21:	8b 55 f8             	mov    -0x8(%rbp),%edx
  806b24:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  806b28:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806b2b:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  806b31:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  806b37:	89 c7                	mov    %eax,%edi
  806b39:	48 b8 f2 66 80 00 00 	movabs $0x8066f2,%rax
  806b40:	00 00 00 
  806b43:	ff d0                	callq  *%rax
}
  806b45:	c9                   	leaveq 
  806b46:	c3                   	retq   

0000000000806b47 <lwip_send>:

int
lwip_send(int s, const void *data, int size, unsigned int flags)
{
  806b47:	55                   	push   %rbp
  806b48:	48 89 e5             	mov    %rsp,%rbp
  806b4b:	48 83 ec 30          	sub    $0x30,%rsp
  806b4f:	89 7d ec             	mov    %edi,-0x14(%rbp)
  806b52:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  806b56:	89 55 e8             	mov    %edx,-0x18(%rbp)
  806b59:	89 4d dc             	mov    %ecx,-0x24(%rbp)
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
  806b5c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  806b5f:	89 c7                	mov    %eax,%edi
  806b61:	48 b8 68 5d 80 00 00 	movabs $0x805d68,%rax
  806b68:	00 00 00 
  806b6b:	ff d0                	callq  *%rax
  806b6d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock)
  806b71:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  806b76:	75 0a                	jne    806b82 <lwip_send+0x3b>
    return -1;
  806b78:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806b7d:	e9 c3 00 00 00       	jmpq   806c45 <lwip_send+0xfe>

  if (sock->conn->type!=NETCONN_TCP) {
  806b82:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806b86:	48 8b 00             	mov    (%rax),%rax
  806b89:	8b 00                	mov    (%rax),%eax
  806b8b:	83 f8 10             	cmp    $0x10,%eax
  806b8e:	74 2c                	je     806bbc <lwip_send+0x75>
#if (LWIP_UDP || LWIP_RAW)
    return lwip_sendto(s, data, size, flags, NULL, 0);
  806b90:	8b 4d dc             	mov    -0x24(%rbp),%ecx
  806b93:	8b 55 e8             	mov    -0x18(%rbp),%edx
  806b96:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  806b9a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  806b9d:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  806ba3:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  806ba9:	89 c7                	mov    %eax,%edi
  806bab:	48 b8 47 6c 80 00 00 	movabs $0x806c47,%rax
  806bb2:	00 00 00 
  806bb5:	ff d0                	callq  *%rax
  806bb7:	e9 89 00 00 00       	jmpq   806c45 <lwip_send+0xfe>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));
  806bbc:	8b 45 dc             	mov    -0x24(%rbp),%eax
  806bbf:	83 e0 10             	and    $0x10,%eax
  806bc2:	85 c0                	test   %eax,%eax
  806bc4:	74 07                	je     806bcd <lwip_send+0x86>
  806bc6:	b8 03 00 00 00       	mov    $0x3,%eax
  806bcb:	eb 05                	jmp    806bd2 <lwip_send+0x8b>
  806bcd:	b8 01 00 00 00       	mov    $0x1,%eax
  806bd2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  806bd6:	48 8b 3a             	mov    (%rdx),%rdi
  806bd9:	8b 55 e8             	mov    -0x18(%rbp),%edx
  806bdc:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  806be0:	89 c1                	mov    %eax,%ecx
  806be2:	48 b8 8b a3 81 00 00 	movabs $0x81a38b,%rax
  806be9:	00 00 00 
  806bec:	ff d0                	callq  *%rax
  806bee:	88 45 f7             	mov    %al,-0x9(%rbp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d size=%d\n", s, err, size));
  sock_set_errno(sock, err_to_errno(err));
  806bf1:	0f be 45 f7          	movsbl -0x9(%rbp),%eax
  806bf5:	f7 d8                	neg    %eax
  806bf7:	83 f8 0e             	cmp    $0xe,%eax
  806bfa:	77 1a                	ja     806c16 <lwip_send+0xcf>
  806bfc:	0f be 45 f7          	movsbl -0x9(%rbp),%eax
  806c00:	f7 d8                	neg    %eax
  806c02:	89 c2                	mov    %eax,%edx
  806c04:	48 b8 40 16 82 00 00 	movabs $0x821640,%rax
  806c0b:	00 00 00 
  806c0e:	48 63 d2             	movslq %edx,%rdx
  806c11:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  806c14:	eb 05                	jmp    806c1b <lwip_send+0xd4>
  806c16:	b8 05 00 00 00       	mov    $0x5,%eax
  806c1b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  806c1f:	89 42 18             	mov    %eax,0x18(%rdx)
  806c22:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806c26:	8b 50 18             	mov    0x18(%rax),%edx
  806c29:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806c30:	00 00 00 
  806c33:	89 10                	mov    %edx,(%rax)
  return (err==ERR_OK?size:-1);
  806c35:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  806c39:	75 05                	jne    806c40 <lwip_send+0xf9>
  806c3b:	8b 45 e8             	mov    -0x18(%rbp),%eax
  806c3e:	eb 05                	jmp    806c45 <lwip_send+0xfe>
  806c40:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  806c45:	c9                   	leaveq 
  806c46:	c3                   	retq   

0000000000806c47 <lwip_sendto>:

int
lwip_sendto(int s, const void *data, int size, unsigned int flags,
       struct sockaddr *to, socklen_t tolen)
{
  806c47:	55                   	push   %rbp
  806c48:	48 89 e5             	mov    %rsp,%rbp
  806c4b:	48 83 ec 60          	sub    $0x60,%rsp
  806c4f:	89 7d bc             	mov    %edi,-0x44(%rbp)
  806c52:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  806c56:	89 55 b8             	mov    %edx,-0x48(%rbp)
  806c59:	89 4d ac             	mov    %ecx,-0x54(%rbp)
  806c5c:	4c 89 45 a0          	mov    %r8,-0x60(%rbp)
  806c60:	44 89 4d a8          	mov    %r9d,-0x58(%rbp)
#if !LWIP_TCPIP_CORE_LOCKING
  struct netbuf buf;
  u16_t remote_port;
#endif

  sock = get_socket(s);
  806c64:	8b 45 bc             	mov    -0x44(%rbp),%eax
  806c67:	89 c7                	mov    %eax,%edi
  806c69:	48 b8 68 5d 80 00 00 	movabs $0x805d68,%rax
  806c70:	00 00 00 
  806c73:	ff d0                	callq  *%rax
  806c75:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (!sock)
  806c79:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  806c7e:	75 0a                	jne    806c8a <lwip_sendto+0x43>
    return -1;
  806c80:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806c85:	e9 d8 01 00 00       	jmpq   806e62 <lwip_sendto+0x21b>

  if (sock->conn->type==NETCONN_TCP) {
  806c8a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806c8e:	48 8b 00             	mov    (%rax),%rax
  806c91:	8b 00                	mov    (%rax),%eax
  806c93:	83 f8 10             	cmp    $0x10,%eax
  806c96:	75 20                	jne    806cb8 <lwip_sendto+0x71>
#if LWIP_TCP
    return lwip_send(s, data, size, flags);
  806c98:	8b 4d ac             	mov    -0x54(%rbp),%ecx
  806c9b:	8b 55 b8             	mov    -0x48(%rbp),%edx
  806c9e:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  806ca2:	8b 45 bc             	mov    -0x44(%rbp),%eax
  806ca5:	89 c7                	mov    %eax,%edi
  806ca7:	48 b8 47 6b 80 00 00 	movabs $0x806b47,%rax
  806cae:	00 00 00 
  806cb1:	ff d0                	callq  *%rax
  806cb3:	e9 aa 01 00 00       	jmpq   806e62 <lwip_sendto+0x21b>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* LWIP_TCP */
  }

  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  806cb8:	83 7d b8 00          	cmpl   $0x0,-0x48(%rbp)
  806cbc:	78 09                	js     806cc7 <lwip_sendto+0x80>
  806cbe:	81 7d b8 ff ff 00 00 	cmpl   $0xffff,-0x48(%rbp)
  806cc5:	7e 2a                	jle    806cf1 <lwip_sendto+0xaa>
  806cc7:	48 ba f8 16 82 00 00 	movabs $0x8216f8,%rdx
  806cce:	00 00 00 
  806cd1:	be 98 02 00 00       	mov    $0x298,%esi
  806cd6:	48 bf 91 16 82 00 00 	movabs $0x821691,%rdi
  806cdd:	00 00 00 
  806ce0:	b8 00 00 00 00       	mov    $0x0,%eax
  806ce5:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  806cec:	00 00 00 
  806cef:	ff d1                	callq  *%rcx
              ((size >= 0) && (size <= 0xffff)));
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  806cf1:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  806cf6:	75 06                	jne    806cfe <lwip_sendto+0xb7>
  806cf8:	83 7d a8 00          	cmpl   $0x0,-0x58(%rbp)
  806cfc:	74 3c                	je     806d3a <lwip_sendto+0xf3>
  806cfe:	83 7d a8 10          	cmpl   $0x10,-0x58(%rbp)
  806d02:	75 0c                	jne    806d10 <lwip_sendto+0xc9>
  806d04:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  806d08:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  806d0c:	3c 02                	cmp    $0x2,%al
  806d0e:	74 2a                	je     806d3a <lwip_sendto+0xf3>
  806d10:	48 ba 1c 17 82 00 00 	movabs $0x82171c,%rdx
  806d17:	00 00 00 
  806d1a:	be 9c 02 00 00       	mov    $0x29c,%esi
  806d1f:	48 bf 91 16 82 00 00 	movabs $0x821691,%rdi
  806d26:	00 00 00 
  806d29:	b8 00 00 00 00       	mov    $0x0,%eax
  806d2e:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  806d35:	00 00 00 
  806d38:	ff d1                	callq  *%rcx
      pbuf_free(p);
    }
  }
#else
  /* initialize a buffer */
  buf.p = buf.ptr = NULL;
  806d3a:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  806d41:	00 
  806d42:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  806d46:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  if (to) {
  806d4a:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  806d4f:	74 39                	je     806d8a <lwip_sendto+0x143>
    remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
  806d51:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  806d55:	8b 40 04             	mov    0x4(%rax),%eax
  806d58:	89 45 e0             	mov    %eax,-0x20(%rbp)
    remote_port      = ntohs(((struct sockaddr_in *)to)->sin_port);
  806d5b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  806d5f:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  806d63:	0f b7 c0             	movzwl %ax,%eax
  806d66:	89 c7                	mov    %eax,%edi
  806d68:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  806d6f:	00 00 00 
  806d72:	ff d0                	callq  *%rax
  806d74:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
    buf.addr         = &remote_addr;
  806d78:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  806d7c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    buf.port         = remote_port;
  806d80:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  806d84:	66 89 45 d8          	mov    %ax,-0x28(%rbp)
  806d88:	eb 1b                	jmp    806da5 <lwip_sendto+0x15e>
  } else {
    remote_addr.addr = 0;
  806d8a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
    remote_port      = 0;
  806d91:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
    buf.addr         = NULL;
  806d97:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  806d9e:	00 
    buf.port         = 0;
  806d9f:	66 c7 45 d8 00 00    	movw   $0x0,-0x28(%rbp)
              s, data, size, flags));
  //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", remote_port));
    
  /* make the buffer point to the data that should be sent */
  if ((err = netbuf_ref(&buf, data, size)) == ERR_OK) {
  806da5:	8b 45 b8             	mov    -0x48(%rbp),%eax
  806da8:	0f b7 d0             	movzwl %ax,%edx
  806dab:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  806daf:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  806db3:	48 89 ce             	mov    %rcx,%rsi
  806db6:	48 89 c7             	mov    %rax,%rdi
  806db9:	48 b8 8d 90 80 00 00 	movabs $0x80908d,%rax
  806dc0:	00 00 00 
  806dc3:	ff d0                	callq  *%rax
  806dc5:	0f be c0             	movsbl %al,%eax
  806dc8:	89 45 fc             	mov    %eax,-0x4(%rbp)
  806dcb:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  806dcf:	75 23                	jne    806df4 <lwip_sendto+0x1ad>
    /* send the data */
    err = netconn_send(sock->conn, &buf);
  806dd1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806dd5:	48 8b 00             	mov    (%rax),%rax
  806dd8:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
  806ddc:	48 89 d6             	mov    %rdx,%rsi
  806ddf:	48 89 c7             	mov    %rax,%rdi
  806de2:	48 b8 0f a3 81 00 00 	movabs $0x81a30f,%rax
  806de9:	00 00 00 
  806dec:	ff d0                	callq  *%rax
  806dee:	0f be c0             	movsbl %al,%eax
  806df1:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }

  /* deallocated the buffer */
  if (buf.p != NULL) {
  806df4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  806df8:	48 85 c0             	test   %rax,%rax
  806dfb:	74 13                	je     806e10 <lwip_sendto+0x1c9>
    pbuf_free(buf.p);
  806dfd:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  806e01:	48 89 c7             	mov    %rax,%rdi
  806e04:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  806e0b:	00 00 00 
  806e0e:	ff d0                	callq  *%rax
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
  806e10:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806e13:	f7 d8                	neg    %eax
  806e15:	83 f8 0e             	cmp    $0xe,%eax
  806e18:	77 19                	ja     806e33 <lwip_sendto+0x1ec>
  806e1a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806e1d:	f7 d8                	neg    %eax
  806e1f:	89 c2                	mov    %eax,%edx
  806e21:	48 b8 40 16 82 00 00 	movabs $0x821640,%rax
  806e28:	00 00 00 
  806e2b:	48 63 d2             	movslq %edx,%rdx
  806e2e:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  806e31:	eb 05                	jmp    806e38 <lwip_sendto+0x1f1>
  806e33:	b8 05 00 00 00       	mov    $0x5,%eax
  806e38:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  806e3c:	89 42 18             	mov    %eax,0x18(%rdx)
  806e3f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806e43:	8b 50 18             	mov    0x18(%rax),%edx
  806e46:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806e4d:	00 00 00 
  806e50:	89 10                	mov    %edx,(%rax)
  return (err==ERR_OK?size:-1);
  806e52:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  806e56:	75 05                	jne    806e5d <lwip_sendto+0x216>
  806e58:	8b 45 b8             	mov    -0x48(%rbp),%eax
  806e5b:	eb 05                	jmp    806e62 <lwip_sendto+0x21b>
  806e5d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  806e62:	c9                   	leaveq 
  806e63:	c3                   	retq   

0000000000806e64 <lwip_socket>:

int
lwip_socket(int domain, int type, int protocol)
{
  806e64:	55                   	push   %rbp
  806e65:	48 89 e5             	mov    %rsp,%rbp
  806e68:	48 83 ec 20          	sub    $0x20,%rsp
  806e6c:	89 7d ec             	mov    %edi,-0x14(%rbp)
  806e6f:	89 75 e8             	mov    %esi,-0x18(%rbp)
  806e72:	89 55 e4             	mov    %edx,-0x1c(%rbp)
  int i;

  LWIP_UNUSED_ARG(domain);

  /* create a netconn */
  switch (type) {
  806e75:	8b 45 e8             	mov    -0x18(%rbp),%eax
  806e78:	83 f8 02             	cmp    $0x2,%eax
  806e7b:	74 38                	je     806eb5 <lwip_socket+0x51>
  806e7d:	83 f8 03             	cmp    $0x3,%eax
  806e80:	74 0a                	je     806e8c <lwip_socket+0x28>
  806e82:	83 f8 01             	cmp    $0x1,%eax
  806e85:	74 66                	je     806eed <lwip_socket+0x89>
  806e87:	e9 87 00 00 00       	jmpq   806f13 <lwip_socket+0xaf>
  case SOCK_RAW:
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
  806e8c:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  806e8f:	0f b6 c0             	movzbl %al,%eax
  806e92:	48 ba 20 77 80 00 00 	movabs $0x807720,%rdx
  806e99:	00 00 00 
  806e9c:	89 c6                	mov    %eax,%esi
  806e9e:	bf 40 00 00 00       	mov    $0x40,%edi
  806ea3:	48 b8 2b 9a 81 00 00 	movabs $0x819a2b,%rax
  806eaa:	00 00 00 
  806ead:	ff d0                	callq  *%rax
  806eaf:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  806eb3:	eb 78                	jmp    806f2d <lwip_socket+0xc9>
  case SOCK_DGRAM:
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
  806eb5:	81 7d e4 88 00 00 00 	cmpl   $0x88,-0x1c(%rbp)
  806ebc:	75 07                	jne    806ec5 <lwip_socket+0x61>
  806ebe:	b8 21 00 00 00       	mov    $0x21,%eax
  806ec3:	eb 05                	jmp    806eca <lwip_socket+0x66>
  806ec5:	b8 20 00 00 00       	mov    $0x20,%eax
  806eca:	48 ba 20 77 80 00 00 	movabs $0x807720,%rdx
  806ed1:	00 00 00 
  806ed4:	be 00 00 00 00       	mov    $0x0,%esi
  806ed9:	89 c7                	mov    %eax,%edi
  806edb:	48 b8 2b 9a 81 00 00 	movabs $0x819a2b,%rax
  806ee2:	00 00 00 
  806ee5:	ff d0                	callq  *%rax
  806ee7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
                 NETCONN_UDPLITE : NETCONN_UDP, event_callback);
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  806eeb:	eb 40                	jmp    806f2d <lwip_socket+0xc9>
  case SOCK_STREAM:
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
  806eed:	48 ba 20 77 80 00 00 	movabs $0x807720,%rdx
  806ef4:	00 00 00 
  806ef7:	be 00 00 00 00       	mov    $0x0,%esi
  806efc:	bf 10 00 00 00       	mov    $0x10,%edi
  806f01:	48 b8 2b 9a 81 00 00 	movabs $0x819a2b,%rax
  806f08:	00 00 00 
  806f0b:	ff d0                	callq  *%rax
  806f0d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  806f11:	eb 1a                	jmp    806f2d <lwip_socket+0xc9>
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",
                                 domain, type, protocol));
    set_errno(EINVAL);
  806f13:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806f1a:	00 00 00 
  806f1d:	c7 00 16 00 00 00    	movl   $0x16,(%rax)
    return -1;
  806f23:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806f28:	e9 81 00 00 00       	jmpq   806fae <lwip_socket+0x14a>
  }

  if (!conn) {
  806f2d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  806f32:	75 17                	jne    806f4b <lwip_socket+0xe7>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
    set_errno(ENOBUFS);
  806f34:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806f3b:	00 00 00 
  806f3e:	c7 00 69 00 00 00    	movl   $0x69,(%rax)
    return -1;
  806f44:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806f49:	eb 63                	jmp    806fae <lwip_socket+0x14a>
  }

  i = alloc_socket(conn);
  806f4b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806f4f:	48 89 c7             	mov    %rax,%rdi
  806f52:	48 b8 dc 5d 80 00 00 	movabs $0x805ddc,%rax
  806f59:	00 00 00 
  806f5c:	ff d0                	callq  *%rax
  806f5e:	89 45 f4             	mov    %eax,-0xc(%rbp)

  if (i == -1) {
  806f61:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%rbp)
  806f65:	75 2a                	jne    806f91 <lwip_socket+0x12d>
    netconn_delete(conn);
  806f67:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806f6b:	48 89 c7             	mov    %rax,%rdi
  806f6e:	48 b8 ce 9b 81 00 00 	movabs $0x819bce,%rax
  806f75:	00 00 00 
  806f78:	ff d0                	callq  *%rax
    set_errno(ENFILE);
  806f7a:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806f81:	00 00 00 
  806f84:	c7 00 17 00 00 00    	movl   $0x17,(%rax)
    return -1;
  806f8a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806f8f:	eb 1d                	jmp    806fae <lwip_socket+0x14a>
  }
  conn->socket = i;
  806f91:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806f95:	8b 55 f4             	mov    -0xc(%rbp),%edx
  806f98:	89 50 20             	mov    %edx,0x20(%rax)
  LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
  set_errno(0);
  806f9b:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806fa2:	00 00 00 
  806fa5:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  return i;
  806fab:	8b 45 f4             	mov    -0xc(%rbp),%eax
}
  806fae:	c9                   	leaveq 
  806faf:	c3                   	retq   

0000000000806fb0 <lwip_write>:

int
lwip_write(int s, const void *data, int size)
{
  806fb0:	55                   	push   %rbp
  806fb1:	48 89 e5             	mov    %rsp,%rbp
  806fb4:	48 83 ec 10          	sub    $0x10,%rsp
  806fb8:	89 7d fc             	mov    %edi,-0x4(%rbp)
  806fbb:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  806fbf:	89 55 f8             	mov    %edx,-0x8(%rbp)
  return lwip_send(s, data, size, 0);
  806fc2:	8b 55 f8             	mov    -0x8(%rbp),%edx
  806fc5:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  806fc9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806fcc:	b9 00 00 00 00       	mov    $0x0,%ecx
  806fd1:	89 c7                	mov    %eax,%edi
  806fd3:	48 b8 47 6b 80 00 00 	movabs $0x806b47,%rax
  806fda:	00 00 00 
  806fdd:	ff d0                	callq  *%rax
}
  806fdf:	c9                   	leaveq 
  806fe0:	c3                   	retq   

0000000000806fe1 <lwip_selscan>:
 * @param exceptset not yet implemented
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  806fe1:	55                   	push   %rbp
  806fe2:	48 89 e5             	mov    %rsp,%rbp
  806fe5:	48 83 ec 60          	sub    $0x60,%rsp
  806fe9:	89 7d bc             	mov    %edi,-0x44(%rbp)
  806fec:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  806ff0:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  806ff4:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
  int i, nready = 0;
  806ff8:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_socket *p_sock;
  
  FD_ZERO(&lreadset);
  806fff:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  807003:	ba 04 00 00 00       	mov    $0x4,%edx
  807008:	be 00 00 00 00       	mov    $0x0,%esi
  80700d:	48 89 c7             	mov    %rax,%rdi
  807010:	48 b8 70 21 80 00 00 	movabs $0x802170,%rax
  807017:	00 00 00 
  80701a:	ff d0                	callq  *%rax
  FD_ZERO(&lwriteset);
  80701c:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  807020:	ba 04 00 00 00       	mov    $0x4,%edx
  807025:	be 00 00 00 00       	mov    $0x0,%esi
  80702a:	48 89 c7             	mov    %rax,%rdi
  80702d:	48 b8 70 21 80 00 00 	movabs $0x802170,%rax
  807034:	00 00 00 
  807037:	ff d0                	callq  *%rax
  FD_ZERO(&lexceptset);
  807039:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  80703d:	ba 04 00 00 00       	mov    $0x4,%edx
  807042:	be 00 00 00 00       	mov    $0x0,%esi
  807047:	48 89 c7             	mov    %rax,%rdi
  80704a:	48 b8 70 21 80 00 00 	movabs $0x802170,%rax
  807051:	00 00 00 
  807054:	ff d0                	callq  *%rax
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  807056:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80705d:	e9 29 01 00 00       	jmpq   80718b <lwip_selscan+0x1aa>
    if (FD_ISSET(i, readset)) {
  807062:	8b 45 fc             	mov    -0x4(%rbp),%eax
  807065:	8d 50 07             	lea    0x7(%rax),%edx
  807068:	85 c0                	test   %eax,%eax
  80706a:	0f 48 c2             	cmovs  %edx,%eax
  80706d:	c1 f8 03             	sar    $0x3,%eax
  807070:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  807074:	48 98                	cltq   
  807076:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  80707a:	0f b6 d0             	movzbl %al,%edx
  80707d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  807080:	83 e0 07             	and    $0x7,%eax
  807083:	89 c1                	mov    %eax,%ecx
  807085:	d3 fa                	sar    %cl,%edx
  807087:	89 d0                	mov    %edx,%eax
  807089:	83 e0 01             	and    $0x1,%eax
  80708c:	85 c0                	test   %eax,%eax
  80708e:	74 6b                	je     8070fb <lwip_selscan+0x11a>
      /* See if netconn of this socket is ready for read */
      p_sock = get_socket(i);
  807090:	8b 45 fc             	mov    -0x4(%rbp),%eax
  807093:	89 c7                	mov    %eax,%edi
  807095:	48 b8 68 5d 80 00 00 	movabs $0x805d68,%rax
  80709c:	00 00 00 
  80709f:	ff d0                	callq  *%rax
  8070a1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  8070a5:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8070aa:	74 4f                	je     8070fb <lwip_selscan+0x11a>
  8070ac:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8070b0:	48 8b 40 08          	mov    0x8(%rax),%rax
  8070b4:	48 85 c0             	test   %rax,%rax
  8070b7:	75 0d                	jne    8070c6 <lwip_selscan+0xe5>
  8070b9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8070bd:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8070c1:	66 85 c0             	test   %ax,%ax
  8070c4:	74 35                	je     8070fb <lwip_selscan+0x11a>
        FD_SET(i, &lreadset);
  8070c6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8070c9:	8d 50 07             	lea    0x7(%rax),%edx
  8070cc:	85 c0                	test   %eax,%eax
  8070ce:	0f 48 c2             	cmovs  %edx,%eax
  8070d1:	c1 f8 03             	sar    $0x3,%eax
  8070d4:	48 63 d0             	movslq %eax,%rdx
  8070d7:	0f b6 54 15 e0       	movzbl -0x20(%rbp,%rdx,1),%edx
  8070dc:	89 d6                	mov    %edx,%esi
  8070de:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8070e1:	83 e2 07             	and    $0x7,%edx
  8070e4:	bf 01 00 00 00       	mov    $0x1,%edi
  8070e9:	89 d1                	mov    %edx,%ecx
  8070eb:	d3 e7                	shl    %cl,%edi
  8070ed:	89 fa                	mov    %edi,%edx
  8070ef:	09 f2                	or     %esi,%edx
  8070f1:	48 98                	cltq   
  8070f3:	88 54 05 e0          	mov    %dl,-0x20(%rbp,%rax,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
        nready++;
  8070f7:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
      }
    }
    if (FD_ISSET(i, writeset)) {
  8070fb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8070fe:	8d 50 07             	lea    0x7(%rax),%edx
  807101:	85 c0                	test   %eax,%eax
  807103:	0f 48 c2             	cmovs  %edx,%eax
  807106:	c1 f8 03             	sar    $0x3,%eax
  807109:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  80710d:	48 98                	cltq   
  80710f:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  807113:	0f b6 d0             	movzbl %al,%edx
  807116:	8b 45 fc             	mov    -0x4(%rbp),%eax
  807119:	83 e0 07             	and    $0x7,%eax
  80711c:	89 c1                	mov    %eax,%ecx
  80711e:	d3 fa                	sar    %cl,%edx
  807120:	89 d0                	mov    %edx,%eax
  807122:	83 e0 01             	and    $0x1,%eax
  807125:	85 c0                	test   %eax,%eax
  807127:	74 5e                	je     807187 <lwip_selscan+0x1a6>
      /* See if netconn of this socket is ready for write */
      p_sock = get_socket(i);
  807129:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80712c:	89 c7                	mov    %eax,%edi
  80712e:	48 b8 68 5d 80 00 00 	movabs $0x805d68,%rax
  807135:	00 00 00 
  807138:	ff d0                	callq  *%rax
  80713a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      if (p_sock && p_sock->sendevent) {
  80713e:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  807143:	74 42                	je     807187 <lwip_selscan+0x1a6>
  807145:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807149:	0f b7 40 14          	movzwl 0x14(%rax),%eax
  80714d:	66 85 c0             	test   %ax,%ax
  807150:	74 35                	je     807187 <lwip_selscan+0x1a6>
        FD_SET(i, &lwriteset);
  807152:	8b 45 fc             	mov    -0x4(%rbp),%eax
  807155:	8d 50 07             	lea    0x7(%rax),%edx
  807158:	85 c0                	test   %eax,%eax
  80715a:	0f 48 c2             	cmovs  %edx,%eax
  80715d:	c1 f8 03             	sar    $0x3,%eax
  807160:	48 63 d0             	movslq %eax,%rdx
  807163:	0f b6 54 15 d0       	movzbl -0x30(%rbp,%rdx,1),%edx
  807168:	89 d6                	mov    %edx,%esi
  80716a:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80716d:	83 e2 07             	and    $0x7,%edx
  807170:	bf 01 00 00 00       	mov    $0x1,%edi
  807175:	89 d1                	mov    %edx,%ecx
  807177:	d3 e7                	shl    %cl,%edi
  807179:	89 fa                	mov    %edi,%edx
  80717b:	09 f2                	or     %esi,%edx
  80717d:	48 98                	cltq   
  80717f:	88 54 05 d0          	mov    %dl,-0x30(%rbp,%rax,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
  807183:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  807187:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80718b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80718e:	3b 45 bc             	cmp    -0x44(%rbp),%eax
  807191:	0f 8c cb fe ff ff    	jl     807062 <lwip_selscan+0x81>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
      }
    }
  }
  *readset = lreadset;
  807197:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80719b:	8b 55 e0             	mov    -0x20(%rbp),%edx
  80719e:	89 10                	mov    %edx,(%rax)
  *writeset = lwriteset;
  8071a0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8071a4:	8b 55 d0             	mov    -0x30(%rbp),%edx
  8071a7:	89 10                	mov    %edx,(%rax)
  FD_ZERO(exceptset);
  8071a9:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8071ad:	ba 04 00 00 00       	mov    $0x4,%edx
  8071b2:	be 00 00 00 00       	mov    $0x0,%esi
  8071b7:	48 89 c7             	mov    %rax,%rdi
  8071ba:	48 b8 70 21 80 00 00 	movabs $0x802170,%rax
  8071c1:	00 00 00 
  8071c4:	ff d0                	callq  *%rax
  
  return nready;
  8071c6:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
  8071c9:	c9                   	leaveq 
  8071ca:	c3                   	retq   

00000000008071cb <lwip_select>:
 * Processing exceptset is not yet implemented.
 */
int
lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
               struct timeval *timeout)
{
  8071cb:	55                   	push   %rbp
  8071cc:	48 89 e5             	mov    %rsp,%rbp
  8071cf:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  8071d6:	89 7d 8c             	mov    %edi,-0x74(%rbp)
  8071d9:	48 89 75 80          	mov    %rsi,-0x80(%rbp)
  8071dd:	48 89 95 78 ff ff ff 	mov    %rdx,-0x88(%rbp)
  8071e4:	48 89 8d 70 ff ff ff 	mov    %rcx,-0x90(%rbp)
  8071eb:	4c 89 85 68 ff ff ff 	mov    %r8,-0x98(%rbp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select(%d, %p, %p, %p, tvsec=%ld tvusec=%ld)\n",
                  maxfdp1, (void *)readset, (void *) writeset, (void *) exceptset,
                  timeout ? timeout->tv_sec : -1L, timeout ? timeout->tv_usec : -1L));

  select_cb.next = 0;
  8071f2:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
  8071f9:	00 
  select_cb.readset = readset;
  8071fa:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8071fe:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  select_cb.writeset = writeset;
  807202:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  807209:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  select_cb.exceptset = exceptset;
  80720d:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  807214:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  select_cb.sem_signalled = 0;
  807218:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)

  /* Protect ourselves searching through the list */
  sys_sem_wait(selectsem);
  80721f:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  807226:	00 00 00 
  807229:	8b 00                	mov    (%rax),%eax
  80722b:	89 c7                	mov    %eax,%edi
  80722d:	48 b8 ec e6 80 00 00 	movabs $0x80e6ec,%rax
  807234:	00 00 00 
  807237:	ff d0                	callq  *%rax

  if (readset)
  807239:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
  80723e:	74 0b                	je     80724b <lwip_select+0x80>
    lreadset = *readset;
  807240:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  807244:	8b 00                	mov    (%rax),%eax
  807246:	89 45 e0             	mov    %eax,-0x20(%rbp)
  807249:	eb 1d                	jmp    807268 <lwip_select+0x9d>
  else
    FD_ZERO(&lreadset);
  80724b:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  80724f:	ba 04 00 00 00       	mov    $0x4,%edx
  807254:	be 00 00 00 00       	mov    $0x0,%esi
  807259:	48 89 c7             	mov    %rax,%rdi
  80725c:	48 b8 70 21 80 00 00 	movabs $0x802170,%rax
  807263:	00 00 00 
  807266:	ff d0                	callq  *%rax
  if (writeset)
  807268:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  80726f:	00 
  807270:	74 0e                	je     807280 <lwip_select+0xb5>
    lwriteset = *writeset;
  807272:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  807279:	8b 00                	mov    (%rax),%eax
  80727b:	89 45 d0             	mov    %eax,-0x30(%rbp)
  80727e:	eb 1d                	jmp    80729d <lwip_select+0xd2>
  else
    FD_ZERO(&lwriteset);
  807280:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  807284:	ba 04 00 00 00       	mov    $0x4,%edx
  807289:	be 00 00 00 00       	mov    $0x0,%esi
  80728e:	48 89 c7             	mov    %rax,%rdi
  807291:	48 b8 70 21 80 00 00 	movabs $0x802170,%rax
  807298:	00 00 00 
  80729b:	ff d0                	callq  *%rax
  if (exceptset)
  80729d:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  8072a4:	00 
  8072a5:	74 0e                	je     8072b5 <lwip_select+0xea>
    lexceptset = *exceptset;
  8072a7:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8072ae:	8b 00                	mov    (%rax),%eax
  8072b0:	89 45 c0             	mov    %eax,-0x40(%rbp)
  8072b3:	eb 1d                	jmp    8072d2 <lwip_select+0x107>
  else
    FD_ZERO(&lexceptset);
  8072b5:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  8072b9:	ba 04 00 00 00       	mov    $0x4,%edx
  8072be:	be 00 00 00 00       	mov    $0x0,%esi
  8072c3:	48 89 c7             	mov    %rax,%rdi
  8072c6:	48 b8 70 21 80 00 00 	movabs $0x802170,%rax
  8072cd:	00 00 00 
  8072d0:	ff d0                	callq  *%rax

  /* Go through each socket in each list to count number of sockets which
     currently match */
  nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  8072d2:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  8072d6:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  8072da:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  8072de:	8b 45 8c             	mov    -0x74(%rbp),%eax
  8072e1:	89 c7                	mov    %eax,%edi
  8072e3:	48 b8 e1 6f 80 00 00 	movabs $0x806fe1,%rax
  8072ea:	00 00 00 
  8072ed:	ff d0                	callq  *%rax
  8072ef:	89 45 fc             	mov    %eax,-0x4(%rbp)

  /* If we don't have any current events, then suspend if we are supposed to */
  if (!nready) {
  8072f2:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8072f6:	0f 85 b9 03 00 00    	jne    8076b5 <lwip_select+0x4ea>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
  8072fc:	48 83 bd 68 ff ff ff 	cmpq   $0x0,-0x98(%rbp)
  807303:	00 
  807304:	0f 84 d3 00 00 00    	je     8073dd <lwip_select+0x212>
  80730a:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  807311:	48 8b 00             	mov    (%rax),%rax
  807314:	48 85 c0             	test   %rax,%rax
  807317:	0f 85 c0 00 00 00    	jne    8073dd <lwip_select+0x212>
  80731d:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  807324:	48 8b 40 08          	mov    0x8(%rax),%rax
  807328:	48 85 c0             	test   %rax,%rax
  80732b:	0f 85 ac 00 00 00    	jne    8073dd <lwip_select+0x212>
      sys_sem_signal(selectsem);
  807331:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  807338:	00 00 00 
  80733b:	8b 00                	mov    (%rax),%eax
  80733d:	89 c7                	mov    %eax,%edi
  80733f:	48 b8 4c 80 81 00 00 	movabs $0x81804c,%rax
  807346:	00 00 00 
  807349:	ff d0                	callq  *%rax
      if (readset)
  80734b:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
  807350:	74 1d                	je     80736f <lwip_select+0x1a4>
        FD_ZERO(readset);
  807352:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  807356:	ba 04 00 00 00       	mov    $0x4,%edx
  80735b:	be 00 00 00 00       	mov    $0x0,%esi
  807360:	48 89 c7             	mov    %rax,%rdi
  807363:	48 b8 70 21 80 00 00 	movabs $0x802170,%rax
  80736a:	00 00 00 
  80736d:	ff d0                	callq  *%rax
      if (writeset)
  80736f:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  807376:	00 
  807377:	74 20                	je     807399 <lwip_select+0x1ce>
        FD_ZERO(writeset);
  807379:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  807380:	ba 04 00 00 00       	mov    $0x4,%edx
  807385:	be 00 00 00 00       	mov    $0x0,%esi
  80738a:	48 89 c7             	mov    %rax,%rdi
  80738d:	48 b8 70 21 80 00 00 	movabs $0x802170,%rax
  807394:	00 00 00 
  807397:	ff d0                	callq  *%rax
      if (exceptset)
  807399:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  8073a0:	00 
  8073a1:	74 20                	je     8073c3 <lwip_select+0x1f8>
        FD_ZERO(exceptset);
  8073a3:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8073aa:	ba 04 00 00 00       	mov    $0x4,%edx
  8073af:	be 00 00 00 00       	mov    $0x0,%esi
  8073b4:	48 89 c7             	mov    %rax,%rdi
  8073b7:	48 b8 70 21 80 00 00 	movabs $0x802170,%rax
  8073be:	00 00 00 
  8073c1:	ff d0                	callq  *%rax
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: no timeout, returning 0\n"));
      set_errno(0);
  8073c3:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8073ca:	00 00 00 
  8073cd:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  
      return 0;
  8073d3:	b8 00 00 00 00       	mov    $0x0,%eax
  8073d8:	e9 41 03 00 00       	jmpq   80771e <lwip_select+0x553>
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  8073dd:	bf 00 00 00 00       	mov    $0x0,%edi
  8073e2:	48 b8 cc 7d 81 00 00 	movabs $0x817dcc,%rax
  8073e9:	00 00 00 
  8073ec:	ff d0                	callq  *%rax
  8073ee:	89 45 b4             	mov    %eax,-0x4c(%rbp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  8073f1:	48 b8 a0 94 82 00 00 	movabs $0x8294a0,%rax
  8073f8:	00 00 00 
  8073fb:	48 8b 00             	mov    (%rax),%rax
  8073fe:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    select_cb_list = &select_cb;
  807402:	48 b8 a0 94 82 00 00 	movabs $0x8294a0,%rax
  807409:	00 00 00 
  80740c:	48 8d 55 90          	lea    -0x70(%rbp),%rdx
  807410:	48 89 10             	mov    %rdx,(%rax)
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  807413:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  80741a:	00 00 00 
  80741d:	8b 00                	mov    (%rax),%eax
  80741f:	89 c7                	mov    %eax,%edi
  807421:	48 b8 4c 80 81 00 00 	movabs $0x81804c,%rax
  807428:	00 00 00 
  80742b:	ff d0                	callq  *%rax
    
    /* Now just wait to be woken */
    if (timeout == 0)
  80742d:	48 83 bd 68 ff ff ff 	cmpq   $0x0,-0x98(%rbp)
  807434:	00 
  807435:	75 09                	jne    807440 <lwip_select+0x275>
      /* Wait forever */
      msectimeout = 0;
  807437:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  80743e:	eb 55                	jmp    807495 <lwip_select+0x2ca>
    else {
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
  807440:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  807447:	48 8b 00             	mov    (%rax),%rax
  80744a:	69 f0 e8 03 00 00    	imul   $0x3e8,%eax,%esi
  807450:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  807457:	48 8b 40 08          	mov    0x8(%rax),%rax
  80745b:	48 8d 88 f4 01 00 00 	lea    0x1f4(%rax),%rcx
  807462:	48 ba cf f7 53 e3 a5 	movabs $0x20c49ba5e353f7cf,%rdx
  807469:	9b c4 20 
  80746c:	48 89 c8             	mov    %rcx,%rax
  80746f:	48 f7 ea             	imul   %rdx
  807472:	48 c1 fa 07          	sar    $0x7,%rdx
  807476:	48 89 c8             	mov    %rcx,%rax
  807479:	48 c1 f8 3f          	sar    $0x3f,%rax
  80747d:	48 29 c2             	sub    %rax,%rdx
  807480:	48 89 d0             	mov    %rdx,%rax
  807483:	01 f0                	add    %esi,%eax
  807485:	89 45 f8             	mov    %eax,-0x8(%rbp)
      if(msectimeout == 0)
  807488:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  80748c:	75 07                	jne    807495 <lwip_select+0x2ca>
        msectimeout = 1;
  80748e:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%rbp)
    }
    
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
  807495:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  807498:	8b 55 f8             	mov    -0x8(%rbp),%edx
  80749b:	89 d6                	mov    %edx,%esi
  80749d:	89 c7                	mov    %eax,%edi
  80749f:	48 b8 5a eb 80 00 00 	movabs $0x80eb5a,%rax
  8074a6:	00 00 00 
  8074a9:	ff d0                	callq  *%rax
  8074ab:	89 45 ec             	mov    %eax,-0x14(%rbp)
    
    /* Take us off the list */
    sys_sem_wait(selectsem);
  8074ae:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  8074b5:	00 00 00 
  8074b8:	8b 00                	mov    (%rax),%eax
  8074ba:	89 c7                	mov    %eax,%edi
  8074bc:	48 b8 ec e6 80 00 00 	movabs $0x80e6ec,%rax
  8074c3:	00 00 00 
  8074c6:	ff d0                	callq  *%rax
    if (select_cb_list == &select_cb)
  8074c8:	48 b8 a0 94 82 00 00 	movabs $0x8294a0,%rax
  8074cf:	00 00 00 
  8074d2:	48 8b 10             	mov    (%rax),%rdx
  8074d5:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  8074d9:	48 39 c2             	cmp    %rax,%rdx
  8074dc:	75 13                	jne    8074f1 <lwip_select+0x326>
      select_cb_list = select_cb.next;
  8074de:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8074e2:	48 b8 a0 94 82 00 00 	movabs $0x8294a0,%rax
  8074e9:	00 00 00 
  8074ec:	48 89 10             	mov    %rdx,(%rax)
  8074ef:	eb 42                	jmp    807533 <lwip_select+0x368>
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  8074f1:	48 b8 a0 94 82 00 00 	movabs $0x8294a0,%rax
  8074f8:	00 00 00 
  8074fb:	48 8b 00             	mov    (%rax),%rax
  8074fe:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  807502:	eb 28                	jmp    80752c <lwip_select+0x361>
        if (p_selcb->next == &select_cb) {
  807504:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807508:	48 8b 10             	mov    (%rax),%rdx
  80750b:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  80750f:	48 39 c2             	cmp    %rax,%rdx
  807512:	75 0d                	jne    807521 <lwip_select+0x356>
          p_selcb->next = select_cb.next;
  807514:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  807518:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80751c:	48 89 10             	mov    %rdx,(%rax)
          break;
  80751f:	eb 12                	jmp    807533 <lwip_select+0x368>
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  807521:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807525:	48 8b 00             	mov    (%rax),%rax
  807528:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80752c:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  807531:	75 d1                	jne    807504 <lwip_select+0x339>
          p_selcb->next = select_cb.next;
          break;
        }
      }
    
    sys_sem_signal(selectsem);
  807533:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  80753a:	00 00 00 
  80753d:	8b 00                	mov    (%rax),%eax
  80753f:	89 c7                	mov    %eax,%edi
  807541:	48 b8 4c 80 81 00 00 	movabs $0x81804c,%rax
  807548:	00 00 00 
  80754b:	ff d0                	callq  *%rax
    
    sys_sem_free(select_cb.sem);
  80754d:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  807550:	89 c7                	mov    %eax,%edi
  807552:	48 b8 ca 7e 81 00 00 	movabs $0x817eca,%rax
  807559:	00 00 00 
  80755c:	ff d0                	callq  *%rax
    if (i == 0)  {
  80755e:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  807562:	0f 85 92 00 00 00    	jne    8075fa <lwip_select+0x42f>
      /* Timeout */
      if (readset)
  807568:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
  80756d:	74 1d                	je     80758c <lwip_select+0x3c1>
        FD_ZERO(readset);
  80756f:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  807573:	ba 04 00 00 00       	mov    $0x4,%edx
  807578:	be 00 00 00 00       	mov    $0x0,%esi
  80757d:	48 89 c7             	mov    %rax,%rdi
  807580:	48 b8 70 21 80 00 00 	movabs $0x802170,%rax
  807587:	00 00 00 
  80758a:	ff d0                	callq  *%rax
      if (writeset)
  80758c:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  807593:	00 
  807594:	74 20                	je     8075b6 <lwip_select+0x3eb>
        FD_ZERO(writeset);
  807596:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80759d:	ba 04 00 00 00       	mov    $0x4,%edx
  8075a2:	be 00 00 00 00       	mov    $0x0,%esi
  8075a7:	48 89 c7             	mov    %rax,%rdi
  8075aa:	48 b8 70 21 80 00 00 	movabs $0x802170,%rax
  8075b1:	00 00 00 
  8075b4:	ff d0                	callq  *%rax
      if (exceptset)
  8075b6:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  8075bd:	00 
  8075be:	74 20                	je     8075e0 <lwip_select+0x415>
        FD_ZERO(exceptset);
  8075c0:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8075c7:	ba 04 00 00 00       	mov    $0x4,%edx
  8075cc:	be 00 00 00 00       	mov    $0x0,%esi
  8075d1:	48 89 c7             	mov    %rax,%rdi
  8075d4:	48 b8 70 21 80 00 00 	movabs $0x802170,%rax
  8075db:	00 00 00 
  8075de:	ff d0                	callq  *%rax
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: timeout expired\n"));
      set_errno(0);
  8075e0:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8075e7:	00 00 00 
  8075ea:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  
      return 0;
  8075f0:	b8 00 00 00 00       	mov    $0x0,%eax
  8075f5:	e9 24 01 00 00       	jmpq   80771e <lwip_select+0x553>
    }
    
    if (readset)
  8075fa:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
  8075ff:	74 0b                	je     80760c <lwip_select+0x441>
      lreadset = *readset;
  807601:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  807605:	8b 00                	mov    (%rax),%eax
  807607:	89 45 e0             	mov    %eax,-0x20(%rbp)
  80760a:	eb 1d                	jmp    807629 <lwip_select+0x45e>
    else
      FD_ZERO(&lreadset);
  80760c:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  807610:	ba 04 00 00 00       	mov    $0x4,%edx
  807615:	be 00 00 00 00       	mov    $0x0,%esi
  80761a:	48 89 c7             	mov    %rax,%rdi
  80761d:	48 b8 70 21 80 00 00 	movabs $0x802170,%rax
  807624:	00 00 00 
  807627:	ff d0                	callq  *%rax
    if (writeset)
  807629:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  807630:	00 
  807631:	74 0e                	je     807641 <lwip_select+0x476>
      lwriteset = *writeset;
  807633:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80763a:	8b 00                	mov    (%rax),%eax
  80763c:	89 45 d0             	mov    %eax,-0x30(%rbp)
  80763f:	eb 1d                	jmp    80765e <lwip_select+0x493>
    else
      FD_ZERO(&lwriteset);
  807641:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  807645:	ba 04 00 00 00       	mov    $0x4,%edx
  80764a:	be 00 00 00 00       	mov    $0x0,%esi
  80764f:	48 89 c7             	mov    %rax,%rdi
  807652:	48 b8 70 21 80 00 00 	movabs $0x802170,%rax
  807659:	00 00 00 
  80765c:	ff d0                	callq  *%rax
    if (exceptset)
  80765e:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  807665:	00 
  807666:	74 0e                	je     807676 <lwip_select+0x4ab>
      lexceptset = *exceptset;
  807668:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80766f:	8b 00                	mov    (%rax),%eax
  807671:	89 45 c0             	mov    %eax,-0x40(%rbp)
  807674:	eb 1d                	jmp    807693 <lwip_select+0x4c8>
    else
      FD_ZERO(&lexceptset);
  807676:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  80767a:	ba 04 00 00 00       	mov    $0x4,%edx
  80767f:	be 00 00 00 00       	mov    $0x0,%esi
  807684:	48 89 c7             	mov    %rax,%rdi
  807687:	48 b8 70 21 80 00 00 	movabs $0x802170,%rax
  80768e:	00 00 00 
  807691:	ff d0                	callq  *%rax
    
    /* See what's set */
    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  807693:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  807697:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  80769b:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  80769f:	8b 45 8c             	mov    -0x74(%rbp),%eax
  8076a2:	89 c7                	mov    %eax,%edi
  8076a4:	48 b8 e1 6f 80 00 00 	movabs $0x806fe1,%rax
  8076ab:	00 00 00 
  8076ae:	ff d0                	callq  *%rax
  8076b0:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8076b3:	eb 1a                	jmp    8076cf <lwip_select+0x504>
  } else
    sys_sem_signal(selectsem);
  8076b5:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  8076bc:	00 00 00 
  8076bf:	8b 00                	mov    (%rax),%eax
  8076c1:	89 c7                	mov    %eax,%edi
  8076c3:	48 b8 4c 80 81 00 00 	movabs $0x81804c,%rax
  8076ca:	00 00 00 
  8076cd:	ff d0                	callq  *%rax
  
  if (readset)
  8076cf:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
  8076d4:	74 09                	je     8076df <lwip_select+0x514>
    *readset = lreadset;
  8076d6:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8076da:	8b 55 e0             	mov    -0x20(%rbp),%edx
  8076dd:	89 10                	mov    %edx,(%rax)
  if (writeset)
  8076df:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  8076e6:	00 
  8076e7:	74 0c                	je     8076f5 <lwip_select+0x52a>
    *writeset = lwriteset;
  8076e9:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8076f0:	8b 55 d0             	mov    -0x30(%rbp),%edx
  8076f3:	89 10                	mov    %edx,(%rax)
  if (exceptset)
  8076f5:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  8076fc:	00 
  8076fd:	74 0c                	je     80770b <lwip_select+0x540>
    *exceptset = lexceptset;
  8076ff:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  807706:	8b 55 c0             	mov    -0x40(%rbp),%edx
  807709:	89 10                	mov    %edx,(%rax)
  
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
  set_errno(0);
  80770b:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  807712:	00 00 00 
  807715:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  
  return nready;
  80771b:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80771e:	c9                   	leaveq 
  80771f:	c3                   	retq   

0000000000807720 <event_callback>:
 * Callback registered in the netconn layer for each socket-netconn.
 * Processes recvevent (data available) and wakes up tasks waiting for select.
 */
static void
event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
  807720:	55                   	push   %rbp
  807721:	48 89 e5             	mov    %rsp,%rbp
  807724:	48 83 ec 30          	sub    $0x30,%rsp
  807728:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80772c:	89 75 d4             	mov    %esi,-0x2c(%rbp)
  80772f:	89 d0                	mov    %edx,%eax
  807731:	66 89 45 d0          	mov    %ax,-0x30(%rbp)
  struct lwip_select_cb *scb;

  LWIP_UNUSED_ARG(len);

  /* Get socket */
  if (conn) {
  807735:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80773a:	0f 84 a6 00 00 00    	je     8077e6 <event_callback+0xc6>
    s = conn->socket;
  807740:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807744:	8b 40 20             	mov    0x20(%rax),%eax
  807747:	89 45 f4             	mov    %eax,-0xc(%rbp)
    if (s < 0) {
  80774a:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  80774e:	79 75                	jns    8077c5 <event_callback+0xa5>
      /* Data comes in right away after an accept, even though
       * the server task might not have created a new socket yet.
       * Just count down (or up) if that's the case and we
       * will use the data later. Note that only receive events
       * can happen before the new socket is set up. */
      sys_sem_wait(socksem);
  807750:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  807757:	00 00 00 
  80775a:	8b 00                	mov    (%rax),%eax
  80775c:	89 c7                	mov    %eax,%edi
  80775e:	48 b8 ec e6 80 00 00 	movabs $0x80e6ec,%rax
  807765:	00 00 00 
  807768:	ff d0                	callq  *%rax
      if (conn->socket < 0) {
  80776a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80776e:	8b 40 20             	mov    0x20(%rax),%eax
  807771:	85 c0                	test   %eax,%eax
  807773:	79 36                	jns    8077ab <event_callback+0x8b>
        if (evt == NETCONN_EVT_RCVPLUS) {
  807775:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  807779:	75 11                	jne    80778c <event_callback+0x6c>
          conn->socket--;
  80777b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80777f:	8b 40 20             	mov    0x20(%rax),%eax
  807782:	8d 50 ff             	lea    -0x1(%rax),%edx
  807785:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807789:	89 50 20             	mov    %edx,0x20(%rax)
        }
        sys_sem_signal(socksem);
  80778c:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  807793:	00 00 00 
  807796:	8b 00                	mov    (%rax),%eax
  807798:	89 c7                	mov    %eax,%edi
  80779a:	48 b8 4c 80 81 00 00 	movabs $0x81804c,%rax
  8077a1:	00 00 00 
  8077a4:	ff d0                	callq  *%rax
        return;
  8077a6:	e9 4b 02 00 00       	jmpq   8079f6 <event_callback+0x2d6>
      }
      sys_sem_signal(socksem);
  8077ab:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  8077b2:	00 00 00 
  8077b5:	8b 00                	mov    (%rax),%eax
  8077b7:	89 c7                	mov    %eax,%edi
  8077b9:	48 b8 4c 80 81 00 00 	movabs $0x81804c,%rax
  8077c0:	00 00 00 
  8077c3:	ff d0                	callq  *%rax
    }

    sock = get_socket(s);
  8077c5:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8077c8:	89 c7                	mov    %eax,%edi
  8077ca:	48 b8 68 5d 80 00 00 	movabs $0x805d68,%rax
  8077d1:	00 00 00 
  8077d4:	ff d0                	callq  *%rax
  8077d6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if (!sock) {
  8077da:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8077df:	75 0a                	jne    8077eb <event_callback+0xcb>
      return;
  8077e1:	e9 10 02 00 00       	jmpq   8079f6 <event_callback+0x2d6>
    }
  } else {
    return;
  8077e6:	e9 0b 02 00 00       	jmpq   8079f6 <event_callback+0x2d6>
  }

  sys_sem_wait(selectsem);
  8077eb:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  8077f2:	00 00 00 
  8077f5:	8b 00                	mov    (%rax),%eax
  8077f7:	89 c7                	mov    %eax,%edi
  8077f9:	48 b8 ec e6 80 00 00 	movabs $0x80e6ec,%rax
  807800:	00 00 00 
  807803:	ff d0                	callq  *%rax
  /* Set event as required */
  switch (evt) {
  807805:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  807808:	83 f8 01             	cmp    $0x1,%eax
  80780b:	74 26                	je     807833 <event_callback+0x113>
  80780d:	83 f8 01             	cmp    $0x1,%eax
  807810:	72 0c                	jb     80781e <event_callback+0xfe>
  807812:	83 f8 02             	cmp    $0x2,%eax
  807815:	74 31                	je     807848 <event_callback+0x128>
  807817:	83 f8 03             	cmp    $0x3,%eax
  80781a:	74 38                	je     807854 <event_callback+0x134>
  80781c:	eb 42                	jmp    807860 <event_callback+0x140>
    case NETCONN_EVT_RCVPLUS:
      sock->rcvevent++;
  80781e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  807822:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  807826:	8d 50 01             	lea    0x1(%rax),%edx
  807829:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80782d:	66 89 50 12          	mov    %dx,0x12(%rax)
      break;
  807831:	eb 57                	jmp    80788a <event_callback+0x16a>
    case NETCONN_EVT_RCVMINUS:
      sock->rcvevent--;
  807833:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  807837:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80783b:	8d 50 ff             	lea    -0x1(%rax),%edx
  80783e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  807842:	66 89 50 12          	mov    %dx,0x12(%rax)
      break;
  807846:	eb 42                	jmp    80788a <event_callback+0x16a>
    case NETCONN_EVT_SENDPLUS:
      sock->sendevent = 1;
  807848:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80784c:	66 c7 40 14 01 00    	movw   $0x1,0x14(%rax)
      break;
  807852:	eb 36                	jmp    80788a <event_callback+0x16a>
    case NETCONN_EVT_SENDMINUS:
      sock->sendevent = 0;
  807854:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  807858:	66 c7 40 14 00 00    	movw   $0x0,0x14(%rax)
      break;
  80785e:	eb 2a                	jmp    80788a <event_callback+0x16a>
    default:
      LWIP_ASSERT("unknown event", 0);
  807860:	48 ba 39 17 82 00 00 	movabs $0x821739,%rdx
  807867:	00 00 00 
  80786a:	be 18 04 00 00       	mov    $0x418,%esi
  80786f:	48 bf 91 16 82 00 00 	movabs $0x821691,%rdi
  807876:	00 00 00 
  807879:	b8 00 00 00 00       	mov    $0x0,%eax
  80787e:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  807885:	00 00 00 
  807888:	ff d1                	callq  *%rcx
      break;
  }
  sys_sem_signal(selectsem);
  80788a:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  807891:	00 00 00 
  807894:	8b 00                	mov    (%rax),%eax
  807896:	89 c7                	mov    %eax,%edi
  807898:	48 b8 4c 80 81 00 00 	movabs $0x81804c,%rax
  80789f:	00 00 00 
  8078a2:	ff d0                	callq  *%rax
     signalling for the select. This means we need to go through the list
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
  8078a4:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  8078ab:	00 00 00 
  8078ae:	8b 00                	mov    (%rax),%eax
  8078b0:	89 c7                	mov    %eax,%edi
  8078b2:	48 b8 ec e6 80 00 00 	movabs $0x80e6ec,%rax
  8078b9:	00 00 00 
  8078bc:	ff d0                	callq  *%rax
    for (scb = select_cb_list; scb; scb = scb->next) {
  8078be:	48 b8 a0 94 82 00 00 	movabs $0x8294a0,%rax
  8078c5:	00 00 00 
  8078c8:	48 8b 00             	mov    (%rax),%rax
  8078cb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8078cf:	e9 b6 00 00 00       	jmpq   80798a <event_callback+0x26a>
      if (scb->sem_signalled == 0) {
  8078d4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8078d8:	8b 40 20             	mov    0x20(%rax),%eax
  8078db:	85 c0                	test   %eax,%eax
  8078dd:	0f 85 9c 00 00 00    	jne    80797f <event_callback+0x25f>
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  8078e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8078e7:	48 8b 40 08          	mov    0x8(%rax),%rax
  8078eb:	48 85 c0             	test   %rax,%rax
  8078ee:	74 41                	je     807931 <event_callback+0x211>
  8078f0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8078f4:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8078f8:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8078fb:	8d 48 07             	lea    0x7(%rax),%ecx
  8078fe:	85 c0                	test   %eax,%eax
  807900:	0f 48 c1             	cmovs  %ecx,%eax
  807903:	c1 f8 03             	sar    $0x3,%eax
  807906:	48 98                	cltq   
  807908:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  80790c:	0f b6 d0             	movzbl %al,%edx
  80790f:	8b 45 f4             	mov    -0xc(%rbp),%eax
  807912:	83 e0 07             	and    $0x7,%eax
  807915:	89 c1                	mov    %eax,%ecx
  807917:	d3 fa                	sar    %cl,%edx
  807919:	89 d0                	mov    %edx,%eax
  80791b:	83 e0 01             	and    $0x1,%eax
  80791e:	85 c0                	test   %eax,%eax
  807920:	74 0f                	je     807931 <event_callback+0x211>
          if (sock->rcvevent)
  807922:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  807926:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80792a:	66 85 c0             	test   %ax,%ax
  80792d:	74 02                	je     807931 <event_callback+0x211>
            break;
  80792f:	eb 64                	jmp    807995 <event_callback+0x275>
        if (scb->writeset && FD_ISSET(s, scb->writeset))
  807931:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807935:	48 8b 40 10          	mov    0x10(%rax),%rax
  807939:	48 85 c0             	test   %rax,%rax
  80793c:	74 41                	je     80797f <event_callback+0x25f>
  80793e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807942:	48 8b 50 10          	mov    0x10(%rax),%rdx
  807946:	8b 45 f4             	mov    -0xc(%rbp),%eax
  807949:	8d 48 07             	lea    0x7(%rax),%ecx
  80794c:	85 c0                	test   %eax,%eax
  80794e:	0f 48 c1             	cmovs  %ecx,%eax
  807951:	c1 f8 03             	sar    $0x3,%eax
  807954:	48 98                	cltq   
  807956:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  80795a:	0f b6 d0             	movzbl %al,%edx
  80795d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  807960:	83 e0 07             	and    $0x7,%eax
  807963:	89 c1                	mov    %eax,%ecx
  807965:	d3 fa                	sar    %cl,%edx
  807967:	89 d0                	mov    %edx,%eax
  807969:	83 e0 01             	and    $0x1,%eax
  80796c:	85 c0                	test   %eax,%eax
  80796e:	74 0f                	je     80797f <event_callback+0x25f>
          if (sock->sendevent)
  807970:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  807974:	0f b7 40 14          	movzwl 0x14(%rax),%eax
  807978:	66 85 c0             	test   %ax,%ax
  80797b:	74 02                	je     80797f <event_callback+0x25f>
            break;
  80797d:	eb 16                	jmp    807995 <event_callback+0x275>
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
  80797f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807983:	48 8b 00             	mov    (%rax),%rax
  807986:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80798a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80798f:	0f 85 3f ff ff ff    	jne    8078d4 <event_callback+0x1b4>
        if (scb->writeset && FD_ISSET(s, scb->writeset))
          if (sock->sendevent)
            break;
      }
    }
    if (scb) {
  807995:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80799a:	74 3f                	je     8079db <event_callback+0x2bb>
      scb->sem_signalled = 1;
  80799c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8079a0:	c7 40 20 01 00 00 00 	movl   $0x1,0x20(%rax)
      sys_sem_signal(selectsem);
  8079a7:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  8079ae:	00 00 00 
  8079b1:	8b 00                	mov    (%rax),%eax
  8079b3:	89 c7                	mov    %eax,%edi
  8079b5:	48 b8 4c 80 81 00 00 	movabs $0x81804c,%rax
  8079bc:	00 00 00 
  8079bf:	ff d0                	callq  *%rax
      sys_sem_signal(scb->sem);
  8079c1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8079c5:	8b 40 24             	mov    0x24(%rax),%eax
  8079c8:	89 c7                	mov    %eax,%edi
  8079ca:	48 b8 4c 80 81 00 00 	movabs $0x81804c,%rax
  8079d1:	00 00 00 
  8079d4:	ff d0                	callq  *%rax
    } else {
      sys_sem_signal(selectsem);
      break;
    }
  }
  8079d6:	e9 c9 fe ff ff       	jmpq   8078a4 <event_callback+0x184>
    if (scb) {
      scb->sem_signalled = 1;
      sys_sem_signal(selectsem);
      sys_sem_signal(scb->sem);
    } else {
      sys_sem_signal(selectsem);
  8079db:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  8079e2:	00 00 00 
  8079e5:	8b 00                	mov    (%rax),%eax
  8079e7:	89 c7                	mov    %eax,%edi
  8079e9:	48 b8 4c 80 81 00 00 	movabs $0x81804c,%rax
  8079f0:	00 00 00 
  8079f3:	ff d0                	callq  *%rax
      break;
  8079f5:	90                   	nop
    }
  }
}
  8079f6:	c9                   	leaveq 
  8079f7:	c3                   	retq   

00000000008079f8 <lwip_shutdown>:
 * Unimplemented: Close one end of a full-duplex connection.
 * Currently, the full connection is closed.
 */
int
lwip_shutdown(int s, int how)
{
  8079f8:	55                   	push   %rbp
  8079f9:	48 89 e5             	mov    %rsp,%rbp
  8079fc:	48 83 ec 10          	sub    $0x10,%rsp
  807a00:	89 7d fc             	mov    %edi,-0x4(%rbp)
  807a03:	89 75 f8             	mov    %esi,-0x8(%rbp)
  LWIP_UNUSED_ARG(how);
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));
  return lwip_close(s); /* XXX temporary hack until proper implementation */
  807a06:	8b 45 fc             	mov    -0x4(%rbp),%eax
  807a09:	89 c7                	mov    %eax,%edi
  807a0b:	48 b8 c9 63 80 00 00 	movabs $0x8063c9,%rax
  807a12:	00 00 00 
  807a15:	ff d0                	callq  *%rax
}
  807a17:	c9                   	leaveq 
  807a18:	c3                   	retq   

0000000000807a19 <lwip_getaddrname>:

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
  807a19:	55                   	push   %rbp
  807a1a:	48 89 e5             	mov    %rsp,%rbp
  807a1d:	48 83 ec 50          	sub    $0x50,%rsp
  807a21:	89 7d cc             	mov    %edi,-0x34(%rbp)
  807a24:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  807a28:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  807a2c:	89 c8                	mov    %ecx,%eax
  807a2e:	88 45 c8             	mov    %al,-0x38(%rbp)
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  807a31:	8b 45 cc             	mov    -0x34(%rbp),%eax
  807a34:	89 c7                	mov    %eax,%edi
  807a36:	48 b8 68 5d 80 00 00 	movabs $0x805d68,%rax
  807a3d:	00 00 00 
  807a40:	ff d0                	callq  *%rax
  807a42:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock)
  807a46:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  807a4b:	75 0a                	jne    807a57 <lwip_getaddrname+0x3e>
    return -1;
  807a4d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807a52:	e9 c9 00 00 00       	jmpq   807b20 <lwip_getaddrname+0x107>

  memset(&sin, 0, sizeof(sin));
  807a57:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  807a5b:	ba 10 00 00 00       	mov    $0x10,%edx
  807a60:	be 00 00 00 00       	mov    $0x0,%esi
  807a65:	48 89 c7             	mov    %rax,%rdi
  807a68:	48 b8 70 21 80 00 00 	movabs $0x802170,%rax
  807a6f:	00 00 00 
  807a72:	ff d0                	callq  *%rax
  sin.sin_len = sizeof(sin);
  807a74:	c6 45 e0 10          	movb   $0x10,-0x20(%rbp)
  sin.sin_family = AF_INET;
  807a78:	c6 45 e1 02          	movb   $0x2,-0x1f(%rbp)

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
  807a7c:	0f b6 55 c8          	movzbl -0x38(%rbp),%edx
  807a80:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807a84:	48 8b 00             	mov    (%rax),%rax
  807a87:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  807a8b:	48 8d 79 02          	lea    0x2(%rcx),%rdi
  807a8f:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  807a93:	89 d1                	mov    %edx,%ecx
  807a95:	48 89 fa             	mov    %rdi,%rdx
  807a98:	48 89 c7             	mov    %rax,%rdi
  807a9b:	48 b8 7c 9c 81 00 00 	movabs $0x819c7c,%rax
  807aa2:	00 00 00 
  807aa5:	ff d0                	callq  *%rax

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  807aa7:	0f b7 45 e2          	movzwl -0x1e(%rbp),%eax
  807aab:	0f b7 c0             	movzwl %ax,%eax
  807aae:	89 c7                	mov    %eax,%edi
  807ab0:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  807ab7:	00 00 00 
  807aba:	ff d0                	callq  *%rax
  807abc:	66 89 45 e2          	mov    %ax,-0x1e(%rbp)
  sin.sin_addr.s_addr = naddr.addr;
  807ac0:	8b 45 d0             	mov    -0x30(%rbp),%eax
  807ac3:	89 45 e4             	mov    %eax,-0x1c(%rbp)

  if (*namelen > sizeof(sin))
  807ac6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  807aca:	8b 00                	mov    (%rax),%eax
  807acc:	83 f8 10             	cmp    $0x10,%eax
  807acf:	76 0a                	jbe    807adb <lwip_getaddrname+0xc2>
    *namelen = sizeof(sin);
  807ad1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  807ad5:	c7 00 10 00 00 00    	movl   $0x10,(%rax)

  SMEMCPY(name, &sin, *namelen);
  807adb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  807adf:	8b 00                	mov    (%rax),%eax
  807ae1:	89 c2                	mov    %eax,%edx
  807ae3:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  807ae7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  807aeb:	48 89 ce             	mov    %rcx,%rsi
  807aee:	48 89 c7             	mov    %rax,%rdi
  807af1:	48 b8 12 23 80 00 00 	movabs $0x802312,%rax
  807af8:	00 00 00 
  807afb:	ff d0                	callq  *%rax
  sock_set_errno(sock, 0);
  807afd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807b01:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  807b08:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807b0c:	8b 50 18             	mov    0x18(%rax),%edx
  807b0f:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  807b16:	00 00 00 
  807b19:	89 10                	mov    %edx,(%rax)
  return 0;
  807b1b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  807b20:	c9                   	leaveq 
  807b21:	c3                   	retq   

0000000000807b22 <lwip_getpeername>:

int
lwip_getpeername(int s, struct sockaddr *name, socklen_t *namelen)
{
  807b22:	55                   	push   %rbp
  807b23:	48 89 e5             	mov    %rsp,%rbp
  807b26:	48 83 ec 20          	sub    $0x20,%rsp
  807b2a:	89 7d fc             	mov    %edi,-0x4(%rbp)
  807b2d:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  807b31:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  return lwip_getaddrname(s, name, namelen, 0);
  807b35:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  807b39:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  807b3d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  807b40:	b9 00 00 00 00       	mov    $0x0,%ecx
  807b45:	89 c7                	mov    %eax,%edi
  807b47:	48 b8 19 7a 80 00 00 	movabs $0x807a19,%rax
  807b4e:	00 00 00 
  807b51:	ff d0                	callq  *%rax
}
  807b53:	c9                   	leaveq 
  807b54:	c3                   	retq   

0000000000807b55 <lwip_getsockname>:

int
lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
{
  807b55:	55                   	push   %rbp
  807b56:	48 89 e5             	mov    %rsp,%rbp
  807b59:	48 83 ec 20          	sub    $0x20,%rsp
  807b5d:	89 7d fc             	mov    %edi,-0x4(%rbp)
  807b60:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  807b64:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  return lwip_getaddrname(s, name, namelen, 1);
  807b68:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  807b6c:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  807b70:	8b 45 fc             	mov    -0x4(%rbp),%eax
  807b73:	b9 01 00 00 00       	mov    $0x1,%ecx
  807b78:	89 c7                	mov    %eax,%edi
  807b7a:	48 b8 19 7a 80 00 00 	movabs $0x807a19,%rax
  807b81:	00 00 00 
  807b84:	ff d0                	callq  *%rax
}
  807b86:	c9                   	leaveq 
  807b87:	c3                   	retq   

0000000000807b88 <lwip_getsockopt>:

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  807b88:	55                   	push   %rbp
  807b89:	48 89 e5             	mov    %rsp,%rbp
  807b8c:	48 83 ec 60          	sub    $0x60,%rsp
  807b90:	89 7d bc             	mov    %edi,-0x44(%rbp)
  807b93:	89 75 b8             	mov    %esi,-0x48(%rbp)
  807b96:	89 55 b4             	mov    %edx,-0x4c(%rbp)
  807b99:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
  807b9d:	4c 89 45 a0          	mov    %r8,-0x60(%rbp)
  err_t err = ERR_OK;
  807ba1:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  struct lwip_socket *sock = get_socket(s);
  807ba5:	8b 45 bc             	mov    -0x44(%rbp),%eax
  807ba8:	89 c7                	mov    %eax,%edi
  807baa:	48 b8 68 5d 80 00 00 	movabs $0x805d68,%rax
  807bb1:	00 00 00 
  807bb4:	ff d0                	callq  *%rax
  807bb6:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  struct lwip_setgetsockopt_data data;

  if (!sock)
  807bba:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  807bbf:	75 0a                	jne    807bcb <lwip_getsockopt+0x43>
    return -1;
  807bc1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807bc6:	e9 15 02 00 00       	jmpq   807de0 <lwip_getsockopt+0x258>

  if ((NULL == optval) || (NULL == optlen)) {
  807bcb:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  807bd0:	74 07                	je     807bd9 <lwip_getsockopt+0x51>
  807bd2:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  807bd7:	75 28                	jne    807c01 <lwip_getsockopt+0x79>
    sock_set_errno(sock, EFAULT);
  807bd9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807bdd:	c7 40 18 0e 00 00 00 	movl   $0xe,0x18(%rax)
  807be4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807be8:	8b 50 18             	mov    0x18(%rax),%edx
  807beb:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  807bf2:	00 00 00 
  807bf5:	89 10                	mov    %edx,(%rax)
    return -1;
  807bf7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807bfc:	e9 df 01 00 00       	jmpq   807de0 <lwip_getsockopt+0x258>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  807c01:	8b 45 b8             	mov    -0x48(%rbp),%eax
  807c04:	83 f8 06             	cmp    $0x6,%eax
  807c07:	0f 84 c3 00 00 00    	je     807cd0 <lwip_getsockopt+0x148>
  807c0d:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  807c12:	74 0d                	je     807c21 <lwip_getsockopt+0x99>
  807c14:	85 c0                	test   %eax,%eax
  807c16:	0f 84 8e 00 00 00    	je     807caa <lwip_getsockopt+0x122>
  807c1c:	e9 ec 00 00 00       	jmpq   807d0d <lwip_getsockopt+0x185>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  807c21:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  807c24:	83 f8 20             	cmp    $0x20,%eax
  807c27:	74 28                	je     807c51 <lwip_getsockopt+0xc9>
  807c29:	83 f8 20             	cmp    $0x20,%eax
  807c2c:	7f 0c                	jg     807c3a <lwip_getsockopt+0xb2>
  807c2e:	83 f8 02             	cmp    $0x2,%eax
  807c31:	74 1e                	je     807c51 <lwip_getsockopt+0xc9>
  807c33:	83 f8 08             	cmp    $0x8,%eax
  807c36:	74 19                	je     807c51 <lwip_getsockopt+0xc9>
  807c38:	eb 68                	jmp    807ca2 <lwip_getsockopt+0x11a>
  807c3a:	3d 07 10 00 00       	cmp    $0x1007,%eax
  807c3f:	7c 61                	jl     807ca2 <lwip_getsockopt+0x11a>
  807c41:	3d 08 10 00 00       	cmp    $0x1008,%eax
  807c46:	7e 09                	jle    807c51 <lwip_getsockopt+0xc9>
  807c48:	3d 0a 10 00 00       	cmp    $0x100a,%eax
  807c4d:	74 15                	je     807c64 <lwip_getsockopt+0xdc>
  807c4f:	eb 51                	jmp    807ca2 <lwip_getsockopt+0x11a>
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
  807c51:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  807c55:	8b 00                	mov    (%rax),%eax
  807c57:	83 f8 03             	cmp    $0x3,%eax
  807c5a:	77 06                	ja     807c62 <lwip_getsockopt+0xda>
        err = EINVAL;
  807c5c:	c6 45 ff 16          	movb   $0x16,-0x1(%rbp)
      }
      break;
  807c60:	eb 46                	jmp    807ca8 <lwip_getsockopt+0x120>
  807c62:	eb 44                	jmp    807ca8 <lwip_getsockopt+0x120>

    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
  807c64:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  807c68:	8b 00                	mov    (%rax),%eax
  807c6a:	83 f8 03             	cmp    $0x3,%eax
  807c6d:	77 04                	ja     807c73 <lwip_getsockopt+0xeb>
        err = EINVAL;
  807c6f:	c6 45 ff 16          	movb   $0x16,-0x1(%rbp)
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  807c73:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807c77:	48 8b 00             	mov    (%rax),%rax
  807c7a:	8b 00                	mov    (%rax),%eax
  807c7c:	83 f8 20             	cmp    $0x20,%eax
  807c7f:	75 19                	jne    807c9a <lwip_getsockopt+0x112>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  807c81:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807c85:	48 8b 00             	mov    (%rax),%rax
  807c88:	48 8b 40 08          	mov    0x8(%rax),%rax
  807c8c:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  807c90:	0f b6 c0             	movzbl %al,%eax
  807c93:	83 e0 02             	and    $0x2,%eax
    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  807c96:	85 c0                	test   %eax,%eax
  807c98:	74 06                	je     807ca0 <lwip_getsockopt+0x118>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
  807c9a:	c6 45 ff 61          	movb   $0x61,-0x1(%rbp)
      }
#endif /* LWIP_UDP */
      break;
  807c9e:	eb 08                	jmp    807ca8 <lwip_getsockopt+0x120>
  807ca0:	eb 06                	jmp    807ca8 <lwip_getsockopt+0x120>

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  807ca2:	c6 45 ff 5c          	movb   $0x5c,-0x1(%rbp)
    }  /* switch (optname) */
    break;
  807ca6:	eb 69                	jmp    807d11 <lwip_getsockopt+0x189>
  807ca8:	eb 67                	jmp    807d11 <lwip_getsockopt+0x189>
                     
/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  807caa:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  807cad:	83 e8 01             	sub    $0x1,%eax
  807cb0:	83 f8 01             	cmp    $0x1,%eax
  807cb3:	77 13                	ja     807cc8 <lwip_getsockopt+0x140>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
  807cb5:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  807cb9:	8b 00                	mov    (%rax),%eax
  807cbb:	83 f8 03             	cmp    $0x3,%eax
  807cbe:	77 06                	ja     807cc6 <lwip_getsockopt+0x13e>
        err = EINVAL;
  807cc0:	c6 45 ff 16          	movb   $0x16,-0x1(%rbp)
      }
      break;
  807cc4:	eb 08                	jmp    807cce <lwip_getsockopt+0x146>
  807cc6:	eb 06                	jmp    807cce <lwip_getsockopt+0x146>
#endif /* LWIP_IGMP */

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  807cc8:	c6 45 ff 5c          	movb   $0x5c,-0x1(%rbp)
    }  /* switch (optname) */
    break;
  807ccc:	eb 43                	jmp    807d11 <lwip_getsockopt+0x189>
  807cce:	eb 41                	jmp    807d11 <lwip_getsockopt+0x189>
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
  807cd0:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  807cd4:	8b 00                	mov    (%rax),%eax
  807cd6:	83 f8 03             	cmp    $0x3,%eax
  807cd9:	77 06                	ja     807ce1 <lwip_getsockopt+0x159>
      err = EINVAL;
  807cdb:	c6 45 ff 16          	movb   $0x16,-0x1(%rbp)
      break;
  807cdf:	eb 30                	jmp    807d11 <lwip_getsockopt+0x189>
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  807ce1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807ce5:	48 8b 00             	mov    (%rax),%rax
  807ce8:	8b 00                	mov    (%rax),%eax
  807cea:	83 f8 10             	cmp    $0x10,%eax
  807ced:	74 0a                	je     807cf9 <lwip_getsockopt+0x171>
      return 0;
  807cef:	b8 00 00 00 00       	mov    $0x0,%eax
  807cf4:	e9 e7 00 00 00       	jmpq   807de0 <lwip_getsockopt+0x258>

    switch (optname) {
  807cf9:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  807cfc:	83 e8 01             	sub    $0x1,%eax
  807cff:	83 f8 01             	cmp    $0x1,%eax
  807d02:	76 06                	jbe    807d0a <lwip_getsockopt+0x182>
      break;
       
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  807d04:	c6 45 ff 5c          	movb   $0x5c,-0x1(%rbp)
    }  /* switch (optname) */
    break;
  807d08:	eb 07                	jmp    807d11 <lwip_getsockopt+0x189>
#if LWIP_TCP_KEEPALIVE
    case TCP_KEEPIDLE:
    case TCP_KEEPINTVL:
    case TCP_KEEPCNT:
#endif /* LWIP_TCP_KEEPALIVE */
      break;
  807d0a:	90                   	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
  807d0b:	eb 04                	jmp    807d11 <lwip_getsockopt+0x189>
#endif /* LWIP_UDP && LWIP_UDPLITE*/
/* UNDEFINED LEVEL */
  default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                                  s, level, optname));
      err = ENOPROTOOPT;
  807d0d:	c6 45 ff 5c          	movb   $0x5c,-0x1(%rbp)
  }  /* switch */

   
  if (err != ERR_OK) {
  807d11:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  807d15:	74 28                	je     807d3f <lwip_getsockopt+0x1b7>
    sock_set_errno(sock, err);
  807d17:	0f be 55 ff          	movsbl -0x1(%rbp),%edx
  807d1b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807d1f:	89 50 18             	mov    %edx,0x18(%rax)
  807d22:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807d26:	8b 50 18             	mov    0x18(%rax),%edx
  807d29:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  807d30:	00 00 00 
  807d33:	89 10                	mov    %edx,(%rax)
    return -1;
  807d35:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807d3a:	e9 a1 00 00 00       	jmpq   807de0 <lwip_getsockopt+0x258>
  }

  /* Now do the actual option processing */
  data.sock = sock;
  807d3f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807d43:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  data.level = level;
  807d47:	8b 45 b8             	mov    -0x48(%rbp),%eax
  807d4a:	89 45 cc             	mov    %eax,-0x34(%rbp)
  data.optname = optname;
  807d4d:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  807d50:	89 45 d0             	mov    %eax,-0x30(%rbp)
  data.optval = optval;
  807d53:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  807d57:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  data.optlen = optlen;
  807d5b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  807d5f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  data.err = err;
  807d63:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  807d67:	88 45 e8             	mov    %al,-0x18(%rbp)
  tcpip_callback(lwip_getsockopt_internal, &data);
  807d6a:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  807d6e:	ba 01 00 00 00       	mov    $0x1,%edx
  807d73:	48 89 c6             	mov    %rax,%rsi
  807d76:	48 bf e2 7d 80 00 00 	movabs $0x807de2,%rdi
  807d7d:	00 00 00 
  807d80:	48 b8 43 8b 80 00 00 	movabs $0x808b43,%rax
  807d87:	00 00 00 
  807d8a:	ff d0                	callq  *%rax
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  807d8c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807d90:	48 8b 00             	mov    (%rax),%rax
  807d93:	8b 40 14             	mov    0x14(%rax),%eax
  807d96:	be 00 00 00 00       	mov    $0x0,%esi
  807d9b:	89 c7                	mov    %eax,%edi
  807d9d:	48 b8 4d 81 81 00 00 	movabs $0x81814d,%rax
  807da4:	00 00 00 
  807da7:	ff d0                	callq  *%rax
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;
  807da9:	0f b6 45 e8          	movzbl -0x18(%rbp),%eax
  807dad:	88 45 ff             	mov    %al,-0x1(%rbp)

  sock_set_errno(sock, err);
  807db0:	0f be 55 ff          	movsbl -0x1(%rbp),%edx
  807db4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807db8:	89 50 18             	mov    %edx,0x18(%rax)
  807dbb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807dbf:	8b 50 18             	mov    0x18(%rax),%edx
  807dc2:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  807dc9:	00 00 00 
  807dcc:	89 10                	mov    %edx,(%rax)
  return err ? -1 : 0;
  807dce:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  807dd2:	74 07                	je     807ddb <lwip_getsockopt+0x253>
  807dd4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807dd9:	eb 05                	jmp    807de0 <lwip_getsockopt+0x258>
  807ddb:	b8 00 00 00 00       	mov    $0x0,%eax
}
  807de0:	c9                   	leaveq 
  807de1:	c3                   	retq   

0000000000807de2 <lwip_getsockopt_internal>:

static void
lwip_getsockopt_internal(void *arg)
{
  807de2:	55                   	push   %rbp
  807de3:	48 89 e5             	mov    %rsp,%rbp
  807de6:	48 83 ec 40          	sub    $0x40,%rsp
  807dea:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
#endif /* LWIP_DEBUG */
  int level, optname;
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  807dee:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  807df3:	75 2a                	jne    807e1f <lwip_getsockopt_internal+0x3d>
  807df5:	48 ba 47 17 82 00 00 	movabs $0x821747,%rdx
  807dfc:	00 00 00 
  807dff:	be 39 05 00 00       	mov    $0x539,%esi
  807e04:	48 bf 91 16 82 00 00 	movabs $0x821691,%rdi
  807e0b:	00 00 00 
  807e0e:	b8 00 00 00 00       	mov    $0x0,%eax
  807e13:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  807e1a:	00 00 00 
  807e1d:	ff d1                	callq  *%rcx

  data = (struct lwip_setgetsockopt_data*)arg;
  807e1f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  807e23:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  sock = data->sock;
  807e27:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807e2b:	48 8b 00             	mov    (%rax),%rax
  807e2e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
#ifdef LWIP_DEBUG
  s = data->s;
  807e32:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807e36:	8b 40 08             	mov    0x8(%rax),%eax
  807e39:	89 45 ec             	mov    %eax,-0x14(%rbp)
#endif /* LWIP_DEBUG */
  level = data->level;
  807e3c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807e40:	8b 40 0c             	mov    0xc(%rax),%eax
  807e43:	89 45 e8             	mov    %eax,-0x18(%rbp)
  optname = data->optname;
  807e46:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807e4a:	8b 40 10             	mov    0x10(%rax),%eax
  807e4d:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  optval = data->optval;
  807e50:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807e54:	48 8b 40 18          	mov    0x18(%rax),%rax
  807e58:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

  switch (level) {
  807e5c:	8b 45 e8             	mov    -0x18(%rbp),%eax
  807e5f:	83 f8 06             	cmp    $0x6,%eax
  807e62:	0f 84 b7 01 00 00    	je     80801f <lwip_getsockopt_internal+0x23d>
  807e68:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  807e6d:	74 0d                	je     807e7c <lwip_getsockopt_internal+0x9a>
  807e6f:	85 c0                	test   %eax,%eax
  807e71:	0f 84 64 01 00 00    	je     807fdb <lwip_getsockopt_internal+0x1f9>
  807e77:	e9 ec 01 00 00       	jmpq   808068 <lwip_getsockopt_internal+0x286>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  807e7c:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  807e7f:	83 f8 20             	cmp    $0x20,%eax
  807e82:	74 36                	je     807eba <lwip_getsockopt_internal+0xd8>
  807e84:	83 f8 20             	cmp    $0x20,%eax
  807e87:	7f 0f                	jg     807e98 <lwip_getsockopt_internal+0xb6>
  807e89:	83 f8 02             	cmp    $0x2,%eax
  807e8c:	74 2c                	je     807eba <lwip_getsockopt_internal+0xd8>
  807e8e:	83 f8 08             	cmp    $0x8,%eax
  807e91:	74 27                	je     807eba <lwip_getsockopt_internal+0xd8>
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
      break;
#endif /* LWIP_UDP*/
    }  /* switch (optname) */
    break;
  807e93:	e9 d0 01 00 00       	jmpq   808068 <lwip_getsockopt_internal+0x286>

  switch (level) {
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  807e98:	3d 08 10 00 00       	cmp    $0x1008,%eax
  807e9d:	74 3d                	je     807edc <lwip_getsockopt_internal+0xfa>
  807e9f:	3d 0a 10 00 00       	cmp    $0x100a,%eax
  807ea4:	0f 84 08 01 00 00    	je     807fb2 <lwip_getsockopt_internal+0x1d0>
  807eaa:	3d 07 10 00 00       	cmp    $0x1007,%eax
  807eaf:	0f 84 80 00 00 00    	je     807f35 <lwip_getsockopt_internal+0x153>
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
      break;
#endif /* LWIP_UDP*/
    }  /* switch (optname) */
    break;
  807eb5:	e9 ae 01 00 00       	jmpq   808068 <lwip_getsockopt_internal+0x286>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /*case SO_USELOOPBACK: UNIMPL */
      *(int*)optval = sock->conn->pcb.ip->so_options & optname;
  807eba:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807ebe:	48 8b 00             	mov    (%rax),%rax
  807ec1:	48 8b 40 08          	mov    0x8(%rax),%rax
  807ec5:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  807ec9:	0f b7 c0             	movzwl %ax,%eax
  807ecc:	23 45 e4             	and    -0x1c(%rbp),%eax
  807ecf:	89 c2                	mov    %eax,%edx
  807ed1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807ed5:	89 10                	mov    %edx,(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",
                                  s, optname, (*(int*)optval?"on":"off")));
      break;
  807ed7:	e9 fa 00 00 00       	jmpq   807fd6 <lwip_getsockopt_internal+0x1f4>

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
  807edc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807ee0:	48 8b 00             	mov    (%rax),%rax
  807ee3:	8b 00                	mov    (%rax),%eax
  807ee5:	25 f0 00 00 00       	and    $0xf0,%eax
  807eea:	83 f8 20             	cmp    $0x20,%eax
  807eed:	74 24                	je     807f13 <lwip_getsockopt_internal+0x131>
  807eef:	83 f8 40             	cmp    $0x40,%eax
  807ef2:	74 07                	je     807efb <lwip_getsockopt_internal+0x119>
  807ef4:	83 f8 10             	cmp    $0x10,%eax
  807ef7:	74 0e                	je     807f07 <lwip_getsockopt_internal+0x125>
  807ef9:	eb 24                	jmp    807f1f <lwip_getsockopt_internal+0x13d>
      case NETCONN_RAW:
        *(int*)optval = SOCK_RAW;
  807efb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807eff:	c7 00 03 00 00 00    	movl   $0x3,(%rax)
        break;
  807f05:	eb 29                	jmp    807f30 <lwip_getsockopt_internal+0x14e>
      case NETCONN_TCP:
        *(int*)optval = SOCK_STREAM;
  807f07:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807f0b:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
        break;
  807f11:	eb 1d                	jmp    807f30 <lwip_getsockopt_internal+0x14e>
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
  807f13:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807f17:	c7 00 02 00 00 00    	movl   $0x2,(%rax)
        break;
  807f1d:	eb 11                	jmp    807f30 <lwip_getsockopt_internal+0x14e>
      default: /* unrecognized socket type */
        *(int*)optval = sock->conn->type;
  807f1f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807f23:	48 8b 00             	mov    (%rax),%rax
  807f26:	8b 00                	mov    (%rax),%eax
  807f28:	89 c2                	mov    %eax,%edx
  807f2a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807f2e:	89 10                	mov    %edx,(%rax)
                    ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE): unrecognized socket type %d\n",
                    s, *(int *)optval));
      }  /* switch (sock->conn->type) */
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n",
                  s, *(int *)optval));
      break;
  807f30:	e9 a1 00 00 00       	jmpq   807fd6 <lwip_getsockopt_internal+0x1f4>

    case SO_ERROR:
      if (sock->err == 0) {
  807f35:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807f39:	8b 40 18             	mov    0x18(%rax),%eax
  807f3c:	85 c0                	test   %eax,%eax
  807f3e:	75 58                	jne    807f98 <lwip_getsockopt_internal+0x1b6>
        sock_set_errno(sock, err_to_errno(sock->conn->err));
  807f40:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807f44:	48 8b 00             	mov    (%rax),%rax
  807f47:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  807f4b:	0f be c0             	movsbl %al,%eax
  807f4e:	f7 d8                	neg    %eax
  807f50:	83 f8 0e             	cmp    $0xe,%eax
  807f53:	77 24                	ja     807f79 <lwip_getsockopt_internal+0x197>
  807f55:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807f59:	48 8b 00             	mov    (%rax),%rax
  807f5c:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  807f60:	0f be c0             	movsbl %al,%eax
  807f63:	f7 d8                	neg    %eax
  807f65:	89 c2                	mov    %eax,%edx
  807f67:	48 b8 40 16 82 00 00 	movabs $0x821640,%rax
  807f6e:	00 00 00 
  807f71:	48 63 d2             	movslq %edx,%rdx
  807f74:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  807f77:	eb 05                	jmp    807f7e <lwip_getsockopt_internal+0x19c>
  807f79:	b8 05 00 00 00       	mov    $0x5,%eax
  807f7e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  807f82:	89 42 18             	mov    %eax,0x18(%rdx)
  807f85:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807f89:	8b 50 18             	mov    0x18(%rax),%edx
  807f8c:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  807f93:	00 00 00 
  807f96:	89 10                	mov    %edx,(%rax)
      } 
      *(int *)optval = sock->err;
  807f98:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807f9c:	8b 50 18             	mov    0x18(%rax),%edx
  807f9f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807fa3:	89 10                	mov    %edx,(%rax)
      sock->err = 0;
  807fa5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807fa9:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n",
                  s, *(int *)optval));
      break;
  807fb0:	eb 24                	jmp    807fd6 <lwip_getsockopt_internal+0x1f4>
      *(int *)optval = sock->conn->recv_bufsize;
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
  807fb2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807fb6:	48 8b 00             	mov    (%rax),%rax
  807fb9:	48 8b 40 08          	mov    0x8(%rax),%rax
  807fbd:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  807fc1:	0f b6 c0             	movzbl %al,%eax
  807fc4:	83 e0 01             	and    $0x1,%eax
  807fc7:	85 c0                	test   %eax,%eax
  807fc9:	0f 95 c0             	setne  %al
  807fcc:	0f b6 d0             	movzbl %al,%edx
  807fcf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807fd3:	89 10                	mov    %edx,(%rax)
      break;
  807fd5:	90                   	nop
#endif /* LWIP_UDP*/
    }  /* switch (optname) */
    break;
  807fd6:	e9 8d 00 00 00       	jmpq   808068 <lwip_getsockopt_internal+0x286>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  807fdb:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  807fde:	83 f8 01             	cmp    $0x1,%eax
  807fe1:	74 21                	je     808004 <lwip_getsockopt_internal+0x222>
  807fe3:	83 f8 02             	cmp    $0x2,%eax
  807fe6:	74 02                	je     807fea <lwip_getsockopt_internal+0x208>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_IF) = 0x%x\n",
                  s, *(u32_t *)optval));
      break;
#endif /* LWIP_IGMP */
    }  /* switch (optname) */
    break;
  807fe8:	eb 7e                	jmp    808068 <lwip_getsockopt_internal+0x286>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
    case IP_TTL:
      *(int*)optval = sock->conn->pcb.ip->ttl;
  807fea:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807fee:	48 8b 00             	mov    (%rax),%rax
  807ff1:	48 8b 40 08          	mov    0x8(%rax),%rax
  807ff5:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  807ff9:	0f b6 d0             	movzbl %al,%edx
  807ffc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  808000:	89 10                	mov    %edx,(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
                  s, *(int *)optval));
      break;
  808002:	eb 19                	jmp    80801d <lwip_getsockopt_internal+0x23b>
    case IP_TOS:
      *(int*)optval = sock->conn->pcb.ip->tos;
  808004:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808008:	48 8b 00             	mov    (%rax),%rax
  80800b:	48 8b 40 08          	mov    0x8(%rax),%rax
  80800f:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  808013:	0f b6 d0             	movzbl %al,%edx
  808016:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80801a:	89 10                	mov    %edx,(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TOS) = %d\n",
                  s, *(int *)optval));
      break;
  80801c:	90                   	nop
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_IF) = 0x%x\n",
                  s, *(u32_t *)optval));
      break;
#endif /* LWIP_IGMP */
    }  /* switch (optname) */
    break;
  80801d:	eb 49                	jmp    808068 <lwip_getsockopt_internal+0x286>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  80801f:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  808022:	83 f8 01             	cmp    $0x1,%eax
  808025:	74 07                	je     80802e <lwip_getsockopt_internal+0x24c>
  808027:	83 f8 02             	cmp    $0x2,%eax
  80802a:	74 21                	je     80804d <lwip_getsockopt_internal+0x26b>
                  s, *(int *)optval));
      break;
#endif /* LWIP_TCP_KEEPALIVE */

    }  /* switch (optname) */
    break;
  80802c:	eb 39                	jmp    808067 <lwip_getsockopt_internal+0x285>
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
    case TCP_NODELAY:
      *(int*)optval = (sock->conn->pcb.tcp->flags & TF_NODELAY);
  80802e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808032:	48 8b 00             	mov    (%rax),%rax
  808035:	48 8b 40 08          	mov    0x8(%rax),%rax
  808039:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80803d:	0f b6 c0             	movzbl %al,%eax
  808040:	83 e0 40             	and    $0x40,%eax
  808043:	89 c2                	mov    %eax,%edx
  808045:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  808049:	89 10                	mov    %edx,(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",
                  s, (*(int*)optval)?"on":"off") );
      break;
  80804b:	eb 1a                	jmp    808067 <lwip_getsockopt_internal+0x285>
    case TCP_KEEPALIVE:
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
  80804d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808051:	48 8b 00             	mov    (%rax),%rax
  808054:	48 8b 40 08          	mov    0x8(%rax),%rax
  808058:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  80805e:	89 c2                	mov    %eax,%edx
  808060:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  808064:	89 10                	mov    %edx,(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPALIVE) = %d\n",
                  s, *(int *)optval));
      break;
  808066:	90                   	nop
                  s, *(int *)optval));
      break;
#endif /* LWIP_TCP_KEEPALIVE */

    }  /* switch (optname) */
    break;
  808067:	90                   	nop
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  } /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  808068:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80806c:	48 8b 00             	mov    (%rax),%rax
  80806f:	8b 40 14             	mov    0x14(%rax),%eax
  808072:	89 c7                	mov    %eax,%edi
  808074:	48 b8 4c 80 81 00 00 	movabs $0x81804c,%rax
  80807b:	00 00 00 
  80807e:	ff d0                	callq  *%rax
}
  808080:	c9                   	leaveq 
  808081:	c3                   	retq   

0000000000808082 <lwip_setsockopt>:

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  808082:	55                   	push   %rbp
  808083:	48 89 e5             	mov    %rsp,%rbp
  808086:	48 83 ec 60          	sub    $0x60,%rsp
  80808a:	89 7d bc             	mov    %edi,-0x44(%rbp)
  80808d:	89 75 b8             	mov    %esi,-0x48(%rbp)
  808090:	89 55 b4             	mov    %edx,-0x4c(%rbp)
  808093:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
  808097:	44 89 45 b0          	mov    %r8d,-0x50(%rbp)
  struct lwip_socket *sock = get_socket(s);
  80809b:	8b 45 bc             	mov    -0x44(%rbp),%eax
  80809e:	89 c7                	mov    %eax,%edi
  8080a0:	48 b8 68 5d 80 00 00 	movabs $0x805d68,%rax
  8080a7:	00 00 00 
  8080aa:	ff d0                	callq  *%rax
  8080ac:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  int err = ERR_OK;
  8080b0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  struct lwip_setgetsockopt_data data;

  if (!sock)
  8080b7:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8080bc:	75 0a                	jne    8080c8 <lwip_setsockopt+0x46>
    return -1;
  8080be:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8080c3:	e9 fd 01 00 00       	jmpq   8082c5 <lwip_setsockopt+0x243>

  if (NULL == optval) {
  8080c8:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  8080cd:	75 28                	jne    8080f7 <lwip_setsockopt+0x75>
    sock_set_errno(sock, EFAULT);
  8080cf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8080d3:	c7 40 18 0e 00 00 00 	movl   $0xe,0x18(%rax)
  8080da:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8080de:	8b 50 18             	mov    0x18(%rax),%edx
  8080e1:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8080e8:	00 00 00 
  8080eb:	89 10                	mov    %edx,(%rax)
    return -1;
  8080ed:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8080f2:	e9 ce 01 00 00       	jmpq   8082c5 <lwip_setsockopt+0x243>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  8080f7:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8080fa:	83 f8 06             	cmp    $0x6,%eax
  8080fd:	0f 84 ac 00 00 00    	je     8081af <lwip_setsockopt+0x12d>
  808103:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  808108:	74 09                	je     808113 <lwip_setsockopt+0x91>
  80810a:	85 c0                	test   %eax,%eax
  80810c:	74 78                	je     808186 <lwip_setsockopt+0x104>
  80810e:	e9 dc 00 00 00       	jmpq   8081ef <lwip_setsockopt+0x16d>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  808113:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  808116:	83 f8 20             	cmp    $0x20,%eax
  808119:	74 0c                	je     808127 <lwip_setsockopt+0xa5>
  80811b:	3d 0a 10 00 00       	cmp    $0x100a,%eax
  808120:	74 18                	je     80813a <lwip_setsockopt+0xb8>
  808122:	83 f8 08             	cmp    $0x8,%eax
  808125:	75 54                	jne    80817b <lwip_setsockopt+0xf9>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
  808127:	8b 45 b0             	mov    -0x50(%rbp),%eax
  80812a:	83 f8 03             	cmp    $0x3,%eax
  80812d:	77 09                	ja     808138 <lwip_setsockopt+0xb6>
        err = EINVAL;
  80812f:	c7 45 fc 16 00 00 00 	movl   $0x16,-0x4(%rbp)
      }
      break;
  808136:	eb 4c                	jmp    808184 <lwip_setsockopt+0x102>
  808138:	eb 4a                	jmp    808184 <lwip_setsockopt+0x102>
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
  80813a:	8b 45 b0             	mov    -0x50(%rbp),%eax
  80813d:	83 f8 03             	cmp    $0x3,%eax
  808140:	77 07                	ja     808149 <lwip_setsockopt+0xc7>
        err = EINVAL;
  808142:	c7 45 fc 16 00 00 00 	movl   $0x16,-0x4(%rbp)
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  808149:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80814d:	48 8b 00             	mov    (%rax),%rax
  808150:	8b 00                	mov    (%rax),%eax
  808152:	83 f8 20             	cmp    $0x20,%eax
  808155:	75 19                	jne    808170 <lwip_setsockopt+0xee>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  808157:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80815b:	48 8b 00             	mov    (%rax),%rax
  80815e:	48 8b 40 08          	mov    0x8(%rax),%rax
  808162:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  808166:	0f b6 c0             	movzbl %al,%eax
  808169:	83 e0 02             	and    $0x2,%eax
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  80816c:	85 c0                	test   %eax,%eax
  80816e:	74 09                	je     808179 <lwip_setsockopt+0xf7>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
  808170:	c7 45 fc 61 00 00 00 	movl   $0x61,-0x4(%rbp)
      }
#endif /* LWIP_UDP */
      break;
  808177:	eb 0b                	jmp    808184 <lwip_setsockopt+0x102>
  808179:	eb 09                	jmp    808184 <lwip_setsockopt+0x102>
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  80817b:	c7 45 fc 5c 00 00 00 	movl   $0x5c,-0x4(%rbp)
    }  /* switch (optname) */
    break;
  808182:	eb 72                	jmp    8081f6 <lwip_setsockopt+0x174>
  808184:	eb 70                	jmp    8081f6 <lwip_setsockopt+0x174>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  808186:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  808189:	83 e8 01             	sub    $0x1,%eax
  80818c:	83 f8 01             	cmp    $0x1,%eax
  80818f:	77 13                	ja     8081a4 <lwip_setsockopt+0x122>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
  808191:	8b 45 b0             	mov    -0x50(%rbp),%eax
  808194:	83 f8 03             	cmp    $0x3,%eax
  808197:	77 09                	ja     8081a2 <lwip_setsockopt+0x120>
        err = EINVAL;
  808199:	c7 45 fc 16 00 00 00 	movl   $0x16,-0x4(%rbp)
      }
      break;
  8081a0:	eb 0b                	jmp    8081ad <lwip_setsockopt+0x12b>
  8081a2:	eb 09                	jmp    8081ad <lwip_setsockopt+0x12b>
      break;
#endif /* LWIP_IGMP */
      default:
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                    s, optname));
        err = ENOPROTOOPT;
  8081a4:	c7 45 fc 5c 00 00 00 	movl   $0x5c,-0x4(%rbp)
    }  /* switch (optname) */
    break;
  8081ab:	eb 49                	jmp    8081f6 <lwip_setsockopt+0x174>
  8081ad:	eb 47                	jmp    8081f6 <lwip_setsockopt+0x174>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
  8081af:	8b 45 b0             	mov    -0x50(%rbp),%eax
  8081b2:	83 f8 03             	cmp    $0x3,%eax
  8081b5:	77 09                	ja     8081c0 <lwip_setsockopt+0x13e>
      err = EINVAL;
  8081b7:	c7 45 fc 16 00 00 00 	movl   $0x16,-0x4(%rbp)
      break;
  8081be:	eb 36                	jmp    8081f6 <lwip_setsockopt+0x174>
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  8081c0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8081c4:	48 8b 00             	mov    (%rax),%rax
  8081c7:	8b 00                	mov    (%rax),%eax
  8081c9:	83 f8 10             	cmp    $0x10,%eax
  8081cc:	74 0a                	je     8081d8 <lwip_setsockopt+0x156>
      return 0;
  8081ce:	b8 00 00 00 00       	mov    $0x0,%eax
  8081d3:	e9 ed 00 00 00       	jmpq   8082c5 <lwip_setsockopt+0x243>

    switch (optname) {
  8081d8:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8081db:	83 e8 01             	sub    $0x1,%eax
  8081de:	83 f8 01             	cmp    $0x1,%eax
  8081e1:	76 09                	jbe    8081ec <lwip_setsockopt+0x16a>
      break;

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  8081e3:	c7 45 fc 5c 00 00 00 	movl   $0x5c,-0x4(%rbp)
    }  /* switch (optname) */
    break;
  8081ea:	eb 0a                	jmp    8081f6 <lwip_setsockopt+0x174>
#if LWIP_TCP_KEEPALIVE
    case TCP_KEEPIDLE:
    case TCP_KEEPINTVL:
    case TCP_KEEPCNT:
#endif /* LWIP_TCP_KEEPALIVE */
      break;
  8081ec:	90                   	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
  8081ed:	eb 07                	jmp    8081f6 <lwip_setsockopt+0x174>
#endif /* LWIP_UDP && LWIP_UDPLITE */
/* UNDEFINED LEVEL */
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                s, level, optname));
    err = ENOPROTOOPT;
  8081ef:	c7 45 fc 5c 00 00 00 	movl   $0x5c,-0x4(%rbp)
  }  /* switch (level) */


  if (err != ERR_OK) {
  8081f6:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8081fa:	74 27                	je     808223 <lwip_setsockopt+0x1a1>
    sock_set_errno(sock, err);
  8081fc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808200:	8b 55 fc             	mov    -0x4(%rbp),%edx
  808203:	89 50 18             	mov    %edx,0x18(%rax)
  808206:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80820a:	8b 50 18             	mov    0x18(%rax),%edx
  80820d:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  808214:	00 00 00 
  808217:	89 10                	mov    %edx,(%rax)
    return -1;
  808219:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80821e:	e9 a2 00 00 00       	jmpq   8082c5 <lwip_setsockopt+0x243>
  }


  /* Now do the actual option processing */
  data.sock = sock;
  808223:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808227:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  data.level = level;
  80822b:	8b 45 b8             	mov    -0x48(%rbp),%eax
  80822e:	89 45 cc             	mov    %eax,-0x34(%rbp)
  data.optname = optname;
  808231:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  808234:	89 45 d0             	mov    %eax,-0x30(%rbp)
  data.optval = (void*)optval;
  808237:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80823b:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  data.optlen = &optlen;
  80823f:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
  808243:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  data.err = err;
  808247:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80824a:	88 45 e8             	mov    %al,-0x18(%rbp)
  tcpip_callback(lwip_setsockopt_internal, &data);
  80824d:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  808251:	ba 01 00 00 00       	mov    $0x1,%edx
  808256:	48 89 c6             	mov    %rax,%rsi
  808259:	48 bf c7 82 80 00 00 	movabs $0x8082c7,%rdi
  808260:	00 00 00 
  808263:	48 b8 43 8b 80 00 00 	movabs $0x808b43,%rax
  80826a:	00 00 00 
  80826d:	ff d0                	callq  *%rax
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  80826f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808273:	48 8b 00             	mov    (%rax),%rax
  808276:	8b 40 14             	mov    0x14(%rax),%eax
  808279:	be 00 00 00 00       	mov    $0x0,%esi
  80827e:	89 c7                	mov    %eax,%edi
  808280:	48 b8 4d 81 81 00 00 	movabs $0x81814d,%rax
  808287:	00 00 00 
  80828a:	ff d0                	callq  *%rax
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;
  80828c:	0f b6 45 e8          	movzbl -0x18(%rbp),%eax
  808290:	0f be c0             	movsbl %al,%eax
  808293:	89 45 fc             	mov    %eax,-0x4(%rbp)

  sock_set_errno(sock, err);
  808296:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80829a:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80829d:	89 50 18             	mov    %edx,0x18(%rax)
  8082a0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8082a4:	8b 50 18             	mov    0x18(%rax),%edx
  8082a7:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8082ae:	00 00 00 
  8082b1:	89 10                	mov    %edx,(%rax)
  return err ? -1 : 0;
  8082b3:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8082b7:	74 07                	je     8082c0 <lwip_setsockopt+0x23e>
  8082b9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8082be:	eb 05                	jmp    8082c5 <lwip_setsockopt+0x243>
  8082c0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8082c5:	c9                   	leaveq 
  8082c6:	c3                   	retq   

00000000008082c7 <lwip_setsockopt_internal>:

static void
lwip_setsockopt_internal(void *arg)
{
  8082c7:	55                   	push   %rbp
  8082c8:	48 89 e5             	mov    %rsp,%rbp
  8082cb:	48 83 ec 40          	sub    $0x40,%rsp
  8082cf:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
#endif /* LWIP_DEBUG */
  int level, optname;
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  8082d3:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8082d8:	75 2a                	jne    808304 <lwip_setsockopt_internal+0x3d>
  8082da:	48 ba 47 17 82 00 00 	movabs $0x821747,%rdx
  8082e1:	00 00 00 
  8082e4:	be af 06 00 00       	mov    $0x6af,%esi
  8082e9:	48 bf 91 16 82 00 00 	movabs $0x821691,%rdi
  8082f0:	00 00 00 
  8082f3:	b8 00 00 00 00       	mov    $0x0,%eax
  8082f8:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  8082ff:	00 00 00 
  808302:	ff d1                	callq  *%rcx

  data = (struct lwip_setgetsockopt_data*)arg;
  808304:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  808308:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  sock = data->sock;
  80830c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808310:	48 8b 00             	mov    (%rax),%rax
  808313:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
#ifdef LWIP_DEBUG
  s = data->s;
  808317:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80831b:	8b 40 08             	mov    0x8(%rax),%eax
  80831e:	89 45 ec             	mov    %eax,-0x14(%rbp)
#endif /* LWIP_DEBUG */
  level = data->level;
  808321:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808325:	8b 40 0c             	mov    0xc(%rax),%eax
  808328:	89 45 e8             	mov    %eax,-0x18(%rbp)
  optname = data->optname;
  80832b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80832f:	8b 40 10             	mov    0x10(%rax),%eax
  808332:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  optval = data->optval;
  808335:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808339:	48 8b 40 18          	mov    0x18(%rax),%rax
  80833d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

  switch (level) {
  808341:	8b 45 e8             	mov    -0x18(%rbp),%eax
  808344:	83 f8 06             	cmp    $0x6,%eax
  808347:	0f 84 16 01 00 00    	je     808463 <lwip_setsockopt_internal+0x19c>
  80834d:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  808352:	74 0d                	je     808361 <lwip_setsockopt_internal+0x9a>
  808354:	85 c0                	test   %eax,%eax
  808356:	0f 84 c8 00 00 00    	je     808424 <lwip_setsockopt_internal+0x15d>
  80835c:	e9 78 01 00 00       	jmpq   8084d9 <lwip_setsockopt_internal+0x212>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  808361:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  808364:	83 f8 20             	cmp    $0x20,%eax
  808367:	74 11                	je     80837a <lwip_setsockopt_internal+0xb3>
  808369:	3d 0a 10 00 00       	cmp    $0x100a,%eax
  80836e:	74 62                	je     8083d2 <lwip_setsockopt_internal+0x10b>
  808370:	83 f8 08             	cmp    $0x8,%eax
  808373:	74 05                	je     80837a <lwip_setsockopt_internal+0xb3>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
      }
      break;
#endif /* LWIP_UDP */
    }  /* switch (optname) */
    break;
  808375:	e9 5f 01 00 00       	jmpq   8084d9 <lwip_setsockopt_internal+0x212>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
  80837a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80837e:	8b 00                	mov    (%rax),%eax
  808380:	85 c0                	test   %eax,%eax
  808382:	74 27                	je     8083ab <lwip_setsockopt_internal+0xe4>
        sock->conn->pcb.ip->so_options |= optname;
  808384:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808388:	48 8b 00             	mov    (%rax),%rax
  80838b:	48 8b 40 08          	mov    0x8(%rax),%rax
  80838f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  808393:	48 8b 12             	mov    (%rdx),%rdx
  808396:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  80839a:	0f b7 52 08          	movzwl 0x8(%rdx),%edx
  80839e:	89 d1                	mov    %edx,%ecx
  8083a0:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8083a3:	09 ca                	or     %ecx,%edx
  8083a5:	66 89 50 08          	mov    %dx,0x8(%rax)
      } else {
        sock->conn->pcb.ip->so_options &= ~optname;
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, optname=0x%x, ..) -> %s\n",
                  s, optname, (*(int*)optval?"on":"off")));
      break;
  8083a9:	eb 74                	jmp    80841f <lwip_setsockopt_internal+0x158>
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
        sock->conn->pcb.ip->so_options |= optname;
      } else {
        sock->conn->pcb.ip->so_options &= ~optname;
  8083ab:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8083af:	48 8b 00             	mov    (%rax),%rax
  8083b2:	48 8b 40 08          	mov    0x8(%rax),%rax
  8083b6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8083ba:	48 8b 12             	mov    (%rdx),%rdx
  8083bd:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8083c1:	0f b7 52 08          	movzwl 0x8(%rdx),%edx
  8083c5:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8083c8:	f7 d1                	not    %ecx
  8083ca:	21 ca                	and    %ecx,%edx
  8083cc:	66 89 50 08          	mov    %dx,0x8(%rax)
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, optname=0x%x, ..) -> %s\n",
                  s, optname, (*(int*)optval?"on":"off")));
      break;
  8083d0:	eb 4d                	jmp    80841f <lwip_setsockopt_internal+0x158>
      sock->conn->recv_bufsize = ( *(int*)optval );
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
  8083d2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8083d6:	8b 00                	mov    (%rax),%eax
  8083d8:	85 c0                	test   %eax,%eax
  8083da:	74 22                	je     8083fe <lwip_setsockopt_internal+0x137>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
  8083dc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8083e0:	48 8b 00             	mov    (%rax),%rax
  8083e3:	48 8b 40 08          	mov    0x8(%rax),%rax
  8083e7:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8083eb:	48 8b 12             	mov    (%rdx),%rdx
  8083ee:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8083f2:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
  8083f6:	83 ca 01             	or     $0x1,%edx
  8083f9:	88 50 18             	mov    %dl,0x18(%rax)
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
      }
      break;
  8083fc:	eb 20                	jmp    80841e <lwip_setsockopt_internal+0x157>
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
  8083fe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808402:	48 8b 00             	mov    (%rax),%rax
  808405:	48 8b 40 08          	mov    0x8(%rax),%rax
  808409:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80840d:	48 8b 12             	mov    (%rdx),%rdx
  808410:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  808414:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
  808418:	83 e2 fe             	and    $0xfffffffe,%edx
  80841b:	88 50 18             	mov    %dl,0x18(%rax)
      }
      break;
  80841e:	90                   	nop
#endif /* LWIP_UDP */
    }  /* switch (optname) */
    break;
  80841f:	e9 b5 00 00 00       	jmpq   8084d9 <lwip_setsockopt_internal+0x212>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  808424:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  808427:	83 f8 01             	cmp    $0x1,%eax
  80842a:	74 20                	je     80844c <lwip_setsockopt_internal+0x185>
  80842c:	83 f8 02             	cmp    $0x2,%eax
  80842f:	74 05                	je     808436 <lwip_setsockopt_internal+0x16f>
        }
      }
      break;
#endif /* LWIP_IGMP */
    }  /* switch (optname) */
    break;
  808431:	e9 a3 00 00 00       	jmpq   8084d9 <lwip_setsockopt_internal+0x212>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
    case IP_TTL:
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
  808436:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80843a:	48 8b 00             	mov    (%rax),%rax
  80843d:	48 8b 40 08          	mov    0x8(%rax),%rax
  808441:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  808445:	8b 12                	mov    (%rdx),%edx
  808447:	88 50 0b             	mov    %dl,0xb(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %u\n",
                  s, sock->conn->pcb.ip->ttl));
      break;
  80844a:	eb 15                	jmp    808461 <lwip_setsockopt_internal+0x19a>
    case IP_TOS:
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
  80844c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808450:	48 8b 00             	mov    (%rax),%rax
  808453:	48 8b 40 08          	mov    0x8(%rax),%rax
  808457:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80845b:	8b 12                	mov    (%rdx),%edx
  80845d:	88 50 0a             	mov    %dl,0xa(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TOS, ..)-> %u\n",
                  s, sock->conn->pcb.ip->tos));
      break;
  808460:	90                   	nop
        }
      }
      break;
#endif /* LWIP_IGMP */
    }  /* switch (optname) */
    break;
  808461:	eb 76                	jmp    8084d9 <lwip_setsockopt_internal+0x212>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  808463:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  808466:	83 f8 01             	cmp    $0x1,%eax
  808469:	74 07                	je     808472 <lwip_setsockopt_internal+0x1ab>
  80846b:	83 f8 02             	cmp    $0x2,%eax
  80846e:	74 50                	je     8084c0 <lwip_setsockopt_internal+0x1f9>
                  s, sock->conn->pcb.tcp->keep_cnt));
      break;
#endif /* LWIP_TCP_KEEPALIVE */

    }  /* switch (optname) */
    break;
  808470:	eb 66                	jmp    8084d8 <lwip_setsockopt_internal+0x211>
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
    case TCP_NODELAY:
      if (*(int*)optval) {
  808472:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  808476:	8b 00                	mov    (%rax),%eax
  808478:	85 c0                	test   %eax,%eax
  80847a:	74 22                	je     80849e <lwip_setsockopt_internal+0x1d7>
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
  80847c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808480:	48 8b 00             	mov    (%rax),%rax
  808483:	48 8b 40 08          	mov    0x8(%rax),%rax
  808487:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80848b:	48 8b 12             	mov    (%rdx),%rdx
  80848e:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  808492:	0f b6 52 2c          	movzbl 0x2c(%rdx),%edx
  808496:	83 ca 40             	or     $0x40,%edx
  808499:	88 50 2c             	mov    %dl,0x2c(%rax)
      } else {
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
  80849c:	eb 3a                	jmp    8084d8 <lwip_setsockopt_internal+0x211>
    switch (optname) {
    case TCP_NODELAY:
      if (*(int*)optval) {
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
      } else {
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
  80849e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8084a2:	48 8b 00             	mov    (%rax),%rax
  8084a5:	48 8b 40 08          	mov    0x8(%rax),%rax
  8084a9:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8084ad:	48 8b 12             	mov    (%rdx),%rdx
  8084b0:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8084b4:	0f b6 52 2c          	movzbl 0x2c(%rdx),%edx
  8084b8:	83 e2 bf             	and    $0xffffffbf,%edx
  8084bb:	88 50 2c             	mov    %dl,0x2c(%rax)
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
  8084be:	eb 18                	jmp    8084d8 <lwip_setsockopt_internal+0x211>
    case TCP_KEEPALIVE:
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
  8084c0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8084c4:	48 8b 00             	mov    (%rax),%rax
  8084c7:	48 8b 40 08          	mov    0x8(%rax),%rax
  8084cb:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8084cf:	8b 12                	mov    (%rdx),%edx
  8084d1:	89 90 d0 00 00 00    	mov    %edx,0xd0(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPALIVE) -> %lu\n",
                  s, sock->conn->pcb.tcp->keep_idle));
      break;
  8084d7:	90                   	nop
                  s, sock->conn->pcb.tcp->keep_cnt));
      break;
#endif /* LWIP_TCP_KEEPALIVE */

    }  /* switch (optname) */
    break;
  8084d8:	90                   	nop
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  }  /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  8084d9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8084dd:	48 8b 00             	mov    (%rax),%rax
  8084e0:	8b 40 14             	mov    0x14(%rax),%eax
  8084e3:	89 c7                	mov    %eax,%edi
  8084e5:	48 b8 4c 80 81 00 00 	movabs $0x81804c,%rax
  8084ec:	00 00 00 
  8084ef:	ff d0                	callq  *%rax
}
  8084f1:	c9                   	leaveq 
  8084f2:	c3                   	retq   

00000000008084f3 <lwip_ioctl>:

int
lwip_ioctl(int s, long cmd, void *argp)
{
  8084f3:	55                   	push   %rbp
  8084f4:	48 89 e5             	mov    %rsp,%rbp
  8084f7:	48 83 ec 28          	sub    $0x28,%rsp
  8084fb:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8084fe:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  808502:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  struct lwip_socket *sock = get_socket(s);
  808506:	8b 45 ec             	mov    -0x14(%rbp),%eax
  808509:	89 c7                	mov    %eax,%edi
  80850b:	48 b8 68 5d 80 00 00 	movabs $0x805d68,%rax
  808512:	00 00 00 
  808515:	ff d0                	callq  *%rax
  808517:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  u16_t buflen = 0;
  80851b:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%rbp)

  if (!sock)
  808521:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808526:	75 0a                	jne    808532 <lwip_ioctl+0x3f>
    return -1;
  808528:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80852d:	e9 4d 01 00 00       	jmpq   80867f <lwip_ioctl+0x18c>

  switch (cmd) {
  808532:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  808536:	48 3d 7f 66 08 40    	cmp    $0x4008667f,%rax
  80853c:	74 13                	je     808551 <lwip_ioctl+0x5e>
  80853e:	ba 7e 66 08 80       	mov    $0x8008667e,%edx
  808543:	48 39 d0             	cmp    %rdx,%rax
  808546:	0f 84 ae 00 00 00    	je     8085fa <lwip_ioctl+0x107>
  80854c:	e9 0b 01 00 00       	jmpq   80865c <lwip_ioctl+0x169>
  case FIONREAD:
    if (!argp) {
  808551:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  808556:	75 28                	jne    808580 <lwip_ioctl+0x8d>
      sock_set_errno(sock, EINVAL);
  808558:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80855c:	c7 40 18 16 00 00 00 	movl   $0x16,0x18(%rax)
  808563:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808567:	8b 50 18             	mov    0x18(%rax),%edx
  80856a:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  808571:	00 00 00 
  808574:	89 10                	mov    %edx,(%rax)
      return -1;
  808576:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80857b:	e9 ff 00 00 00       	jmpq   80867f <lwip_ioctl+0x18c>
    }

    SYS_ARCH_GET(sock->conn->recv_avail, *((u16_t*)argp));
  808580:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808584:	48 8b 00             	mov    (%rax),%rax
  808587:	0f b7 50 24          	movzwl 0x24(%rax),%edx
  80858b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80858f:	66 89 10             	mov    %dx,(%rax)

    /* Check if there is data left from the last recv operation. /maq 041215 */
    if (sock->lastdata) {
  808592:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808596:	48 8b 40 08          	mov    0x8(%rax),%rax
  80859a:	48 85 c0             	test   %rax,%rax
  80859d:	74 33                	je     8085d2 <lwip_ioctl+0xdf>
      buflen = netbuf_len(sock->lastdata);
  80859f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8085a3:	48 8b 40 08          	mov    0x8(%rax),%rax
  8085a7:	48 8b 00             	mov    (%rax),%rax
  8085aa:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  8085ae:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
      buflen -= sock->lastoffset;
  8085b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8085b6:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  8085ba:	66 29 45 f6          	sub    %ax,-0xa(%rbp)

      *((u16_t*)argp) += buflen;
  8085be:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8085c2:	0f b7 10             	movzwl (%rax),%edx
  8085c5:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  8085c9:	01 c2                	add    %eax,%edx
  8085cb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8085cf:	66 89 10             	mov    %dx,(%rax)
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
  8085d2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8085d6:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  8085dd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8085e1:	8b 50 18             	mov    0x18(%rax),%edx
  8085e4:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8085eb:	00 00 00 
  8085ee:	89 10                	mov    %edx,(%rax)
    return 0;
  8085f0:	b8 00 00 00 00       	mov    $0x0,%eax
  8085f5:	e9 85 00 00 00       	jmpq   80867f <lwip_ioctl+0x18c>

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  8085fa:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8085ff:	74 21                	je     808622 <lwip_ioctl+0x12f>
  808601:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  808605:	8b 00                	mov    (%rax),%eax
  808607:	85 c0                	test   %eax,%eax
  808609:	74 17                	je     808622 <lwip_ioctl+0x12f>
      sock->flags |= O_NONBLOCK;
  80860b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80860f:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  808613:	80 cc 08             	or     $0x8,%ah
  808616:	89 c2                	mov    %eax,%edx
  808618:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80861c:	66 89 50 16          	mov    %dx,0x16(%rax)
  808620:	eb 15                	jmp    808637 <lwip_ioctl+0x144>
    else
      sock->flags &= ~O_NONBLOCK;
  808622:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808626:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  80862a:	80 e4 f7             	and    $0xf7,%ah
  80862d:	89 c2                	mov    %eax,%edx
  80862f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808633:	66 89 50 16          	mov    %dx,0x16(%rax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, !!(sock->flags & O_NONBLOCK)));
    sock_set_errno(sock, 0);
  808637:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80863b:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  808642:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808646:	8b 50 18             	mov    0x18(%rax),%edx
  808649:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  808650:	00 00 00 
  808653:	89 10                	mov    %edx,(%rax)
    return 0;
  808655:	b8 00 00 00 00       	mov    $0x0,%eax
  80865a:	eb 23                	jmp    80867f <lwip_ioctl+0x18c>

  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
  80865c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808660:	c7 40 18 26 00 00 00 	movl   $0x26,0x18(%rax)
  808667:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80866b:	8b 50 18             	mov    0x18(%rax),%edx
  80866e:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  808675:	00 00 00 
  808678:	89 10                	mov    %edx,(%rax)
    return -1;
  80867a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  } /* switch (cmd) */
}
  80867f:	c9                   	leaveq 
  808680:	c3                   	retq   

0000000000808681 <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
  808681:	55                   	push   %rbp
  808682:	48 89 e5             	mov    %rsp,%rbp
  808685:	48 83 ec 10          	sub    $0x10,%rsp
  808689:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  80868d:	48 b8 28 ec 80 00 00 	movabs $0x80ec28,%rax
  808694:	00 00 00 
  808697:	ff d0                	callq  *%rax
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  808699:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  8086a0:	00 00 00 
  8086a3:	48 8b 00             	mov    (%rax),%rax
  8086a6:	48 85 c0             	test   %rax,%rax
  8086a9:	75 12                	jne    8086bd <tcpip_tcp_timer+0x3c>
  8086ab:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  8086b2:	00 00 00 
  8086b5:	48 8b 00             	mov    (%rax),%rax
  8086b8:	48 85 c0             	test   %rax,%rax
  8086bb:	74 22                	je     8086df <tcpip_tcp_timer+0x5e>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  8086bd:	ba 00 00 00 00       	mov    $0x0,%edx
  8086c2:	48 be 81 86 80 00 00 	movabs $0x808681,%rsi
  8086c9:	00 00 00 
  8086cc:	bf fa 00 00 00       	mov    $0xfa,%edi
  8086d1:	48 b8 13 e8 80 00 00 	movabs $0x80e813,%rax
  8086d8:	00 00 00 
  8086db:	ff d0                	callq  *%rax
  8086dd:	eb 10                	jmp    8086ef <tcpip_tcp_timer+0x6e>
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
  8086df:	48 b8 c0 94 82 00 00 	movabs $0x8294c0,%rax
  8086e6:	00 00 00 
  8086e9:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  }
}
  8086ef:	c9                   	leaveq 
  8086f0:	c3                   	retq   

00000000008086f1 <tcp_timer_needed>:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
  8086f1:	55                   	push   %rbp
  8086f2:	48 89 e5             	mov    %rsp,%rbp
  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  8086f5:	48 b8 c0 94 82 00 00 	movabs $0x8294c0,%rax
  8086fc:	00 00 00 
  8086ff:	8b 00                	mov    (%rax),%eax
  808701:	85 c0                	test   %eax,%eax
  808703:	75 54                	jne    808759 <tcp_timer_needed+0x68>
  808705:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80870c:	00 00 00 
  80870f:	48 8b 00             	mov    (%rax),%rax
  808712:	48 85 c0             	test   %rax,%rax
  808715:	75 12                	jne    808729 <tcp_timer_needed+0x38>
  808717:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  80871e:	00 00 00 
  808721:	48 8b 00             	mov    (%rax),%rax
  808724:	48 85 c0             	test   %rax,%rax
  808727:	74 30                	je     808759 <tcp_timer_needed+0x68>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
  808729:	48 b8 c0 94 82 00 00 	movabs $0x8294c0,%rax
  808730:	00 00 00 
  808733:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  808739:	ba 00 00 00 00       	mov    $0x0,%edx
  80873e:	48 be 81 86 80 00 00 	movabs $0x808681,%rsi
  808745:	00 00 00 
  808748:	bf fa 00 00 00       	mov    $0xfa,%edi
  80874d:	48 b8 13 e8 80 00 00 	movabs $0x80e813,%rax
  808754:	00 00 00 
  808757:	ff d0                	callq  *%rax
  }
}
  808759:	5d                   	pop    %rbp
  80875a:	c3                   	retq   

000000000080875b <ip_reass_timer>:
 *
 * @param arg unused argument
 */
static void
ip_reass_timer(void *arg)
{
  80875b:	55                   	push   %rbp
  80875c:	48 89 e5             	mov    %rsp,%rbp
  80875f:	48 83 ec 10          	sub    $0x10,%rsp
  808763:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: ip_reass_tmr()\n"));
  ip_reass_tmr();
  808767:	48 b8 46 16 81 00 00 	movabs $0x811646,%rax
  80876e:	00 00 00 
  808771:	ff d0                	callq  *%rax
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  808773:	ba 00 00 00 00       	mov    $0x0,%edx
  808778:	48 be 5b 87 80 00 00 	movabs $0x80875b,%rsi
  80877f:	00 00 00 
  808782:	bf e8 03 00 00       	mov    $0x3e8,%edi
  808787:	48 b8 13 e8 80 00 00 	movabs $0x80e813,%rax
  80878e:	00 00 00 
  808791:	ff d0                	callq  *%rax
}
  808793:	c9                   	leaveq 
  808794:	c3                   	retq   

0000000000808795 <arp_timer>:
 *
 * @param arg unused argument
 */
static void
arp_timer(void *arg)
{
  808795:	55                   	push   %rbp
  808796:	48 89 e5             	mov    %rsp,%rbp
  808799:	48 83 ec 10          	sub    $0x10,%rsp
  80879d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: etharp_tmr()\n"));
  etharp_tmr();
  8087a1:	48 b8 8d 5a 81 00 00 	movabs $0x815a8d,%rax
  8087a8:	00 00 00 
  8087ab:	ff d0                	callq  *%rax
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  8087ad:	ba 00 00 00 00       	mov    $0x0,%edx
  8087b2:	48 be 95 87 80 00 00 	movabs $0x808795,%rsi
  8087b9:	00 00 00 
  8087bc:	bf 88 13 00 00       	mov    $0x1388,%edi
  8087c1:	48 b8 13 e8 80 00 00 	movabs $0x80e813,%rax
  8087c8:	00 00 00 
  8087cb:	ff d0                	callq  *%rax
}
  8087cd:	c9                   	leaveq 
  8087ce:	c3                   	retq   

00000000008087cf <dhcp_timer_coarse>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_coarse(void *arg)
{
  8087cf:	55                   	push   %rbp
  8087d0:	48 89 e5             	mov    %rsp,%rbp
  8087d3:	48 83 ec 10          	sub    $0x10,%rsp
  8087d7:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_coarse_tmr()\n"));
  dhcp_coarse_tmr();
  8087db:	48 b8 00 99 80 00 00 	movabs $0x809900,%rax
  8087e2:	00 00 00 
  8087e5:	ff d0                	callq  *%rax
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  8087e7:	ba 00 00 00 00       	mov    $0x0,%edx
  8087ec:	48 be cf 87 80 00 00 	movabs $0x8087cf,%rsi
  8087f3:	00 00 00 
  8087f6:	bf 60 ea 00 00       	mov    $0xea60,%edi
  8087fb:	48 b8 13 e8 80 00 00 	movabs $0x80e813,%rax
  808802:	00 00 00 
  808805:	ff d0                	callq  *%rax
}
  808807:	c9                   	leaveq 
  808808:	c3                   	retq   

0000000000808809 <dhcp_timer_fine>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_fine(void *arg)
{
  808809:	55                   	push   %rbp
  80880a:	48 89 e5             	mov    %rsp,%rbp
  80880d:	48 83 ec 10          	sub    $0x10,%rsp
  808811:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_fine_tmr()\n"));
  dhcp_fine_tmr();
  808815:	48 b8 96 99 80 00 00 	movabs $0x809996,%rax
  80881c:	00 00 00 
  80881f:	ff d0                	callq  *%rax
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  808821:	ba 00 00 00 00       	mov    $0x0,%edx
  808826:	48 be 09 88 80 00 00 	movabs $0x808809,%rsi
  80882d:	00 00 00 
  808830:	bf f4 01 00 00       	mov    $0x1f4,%edi
  808835:	48 b8 13 e8 80 00 00 	movabs $0x80e813,%rax
  80883c:	00 00 00 
  80883f:	ff d0                	callq  *%rax
}
  808841:	c9                   	leaveq 
  808842:	c3                   	retq   

0000000000808843 <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
  808843:	55                   	push   %rbp
  808844:	48 89 e5             	mov    %rsp,%rbp
  808847:	48 83 ec 20          	sub    $0x20,%rsp
  80884b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  80884f:	ba 00 00 00 00       	mov    $0x0,%edx
  808854:	48 be 5b 87 80 00 00 	movabs $0x80875b,%rsi
  80885b:	00 00 00 
  80885e:	bf e8 03 00 00       	mov    $0x3e8,%edi
  808863:	48 b8 13 e8 80 00 00 	movabs $0x80e813,%rax
  80886a:	00 00 00 
  80886d:	ff d0                	callq  *%rax
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  80886f:	ba 00 00 00 00       	mov    $0x0,%edx
  808874:	48 be 95 87 80 00 00 	movabs $0x808795,%rsi
  80887b:	00 00 00 
  80887e:	bf 88 13 00 00       	mov    $0x1388,%edi
  808883:	48 b8 13 e8 80 00 00 	movabs $0x80e813,%rax
  80888a:	00 00 00 
  80888d:	ff d0                	callq  *%rax
#endif /* LWIP_ARP */
#if LWIP_DHCP
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  80888f:	ba 00 00 00 00       	mov    $0x0,%edx
  808894:	48 be cf 87 80 00 00 	movabs $0x8087cf,%rsi
  80889b:	00 00 00 
  80889e:	bf 60 ea 00 00       	mov    $0xea60,%edi
  8088a3:	48 b8 13 e8 80 00 00 	movabs $0x80e813,%rax
  8088aa:	00 00 00 
  8088ad:	ff d0                	callq  *%rax
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  8088af:	ba 00 00 00 00       	mov    $0x0,%edx
  8088b4:	48 be 09 88 80 00 00 	movabs $0x808809,%rsi
  8088bb:	00 00 00 
  8088be:	bf f4 01 00 00       	mov    $0x1f4,%edi
  8088c3:	48 b8 13 e8 80 00 00 	movabs $0x80e813,%rax
  8088ca:	00 00 00 
  8088cd:	ff d0                	callq  *%rax
#endif /* LWIP_IGMP */
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
  8088cf:	48 b8 b0 94 82 00 00 	movabs $0x8294b0,%rax
  8088d6:	00 00 00 
  8088d9:	48 8b 00             	mov    (%rax),%rax
  8088dc:	48 85 c0             	test   %rax,%rax
  8088df:	74 1f                	je     808900 <tcpip_thread+0xbd>
    tcpip_init_done(tcpip_init_done_arg);
  8088e1:	48 b8 b0 94 82 00 00 	movabs $0x8294b0,%rax
  8088e8:	00 00 00 
  8088eb:	48 8b 00             	mov    (%rax),%rax
  8088ee:	48 ba b8 94 82 00 00 	movabs $0x8294b8,%rdx
  8088f5:	00 00 00 
  8088f8:	48 8b 12             	mov    (%rdx),%rdx
  8088fb:	48 89 d7             	mov    %rdx,%rdi
  8088fe:	ff d0                	callq  *%rax
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
  808900:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808907:	00 00 00 
  80890a:	8b 00                	mov    (%rax),%eax
  80890c:	48 8d 55 f8          	lea    -0x8(%rbp),%rdx
  808910:	48 89 d6             	mov    %rdx,%rsi
  808913:	89 c7                	mov    %eax,%edi
  808915:	48 b8 b2 e5 80 00 00 	movabs $0x80e5b2,%rax
  80891c:	00 00 00 
  80891f:	ff d0                	callq  *%rax
    switch (msg->type) {
  808921:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808925:	8b 00                	mov    (%rax),%eax
  808927:	83 f8 01             	cmp    $0x1,%eax
  80892a:	74 3d                	je     808969 <tcpip_thread+0x126>
  80892c:	83 f8 01             	cmp    $0x1,%eax
  80892f:	72 17                	jb     808948 <tcpip_thread+0x105>
  808931:	83 f8 02             	cmp    $0x2,%eax
  808934:	0f 84 a8 00 00 00    	je     8089e2 <tcpip_thread+0x19f>
  80893a:	83 f8 03             	cmp    $0x3,%eax
  80893d:	0f 84 ce 00 00 00    	je     808a11 <tcpip_thread+0x1ce>
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
      memp_free(MEMP_TCPIP_MSG_API, msg);
      break;

    default:
      break;
  808943:	e9 3a 01 00 00       	jmpq   808a82 <tcpip_thread+0x23f>
    sys_mbox_fetch(mbox, (void *)&msg);
    switch (msg->type) {
#if LWIP_NETCONN
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
  808948:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80894c:	48 8b 40 10          	mov    0x10(%rax),%rax
  808950:	48 8b 00             	mov    (%rax),%rax
  808953:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  808957:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80895b:	48 83 c2 08          	add    $0x8,%rdx
  80895f:	48 89 d7             	mov    %rdx,%rdi
  808962:	ff d0                	callq  *%rax
      break;
  808964:	e9 19 01 00 00       	jmpq   808a82 <tcpip_thread+0x23f>
#endif /* LWIP_NETCONN */

    case TCPIP_MSG_INPKT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
#if LWIP_ARP
      if (msg->msg.inp.netif->flags & NETIF_FLAG_ETHARP) {
  808969:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80896d:	48 8b 40 18          	mov    0x18(%rax),%rax
  808971:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  808975:	0f b6 c0             	movzbl %al,%eax
  808978:	83 e0 20             	and    $0x20,%eax
  80897b:	85 c0                	test   %eax,%eax
  80897d:	74 24                	je     8089a3 <tcpip_thread+0x160>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
  80897f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808983:	48 8b 50 18          	mov    0x18(%rax),%rdx
  808987:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80898b:	48 8b 40 10          	mov    0x10(%rax),%rax
  80898f:	48 89 d6             	mov    %rdx,%rsi
  808992:	48 89 c7             	mov    %rax,%rdi
  808995:	48 b8 33 73 81 00 00 	movabs $0x817333,%rax
  80899c:	00 00 00 
  80899f:	ff d0                	callq  *%rax
  8089a1:	eb 22                	jmp    8089c5 <tcpip_thread+0x182>
      } else
#endif /* LWIP_ARP */
      { ip_input(msg->msg.inp.p, msg->msg.inp.netif);
  8089a3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8089a7:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8089ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8089af:	48 8b 40 10          	mov    0x10(%rax),%rax
  8089b3:	48 89 d6             	mov    %rdx,%rsi
  8089b6:	48 89 c7             	mov    %rax,%rdi
  8089b9:	48 b8 90 0e 81 00 00 	movabs $0x810e90,%rax
  8089c0:	00 00 00 
  8089c3:	ff d0                	callq  *%rax
      }
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  8089c5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8089c9:	48 89 c6             	mov    %rax,%rsi
  8089cc:	bf 09 00 00 00       	mov    $0x9,%edi
  8089d1:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  8089d8:	00 00 00 
  8089db:	ff d0                	callq  *%rax
      break;
  8089dd:	e9 a0 00 00 00       	jmpq   808a82 <tcpip_thread+0x23f>
      break;
#endif /* LWIP_NETIF_API */

    case TCPIP_MSG_CALLBACK:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
      msg->msg.cb.f(msg->msg.cb.ctx);
  8089e2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8089e6:	48 8b 40 10          	mov    0x10(%rax),%rax
  8089ea:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8089ee:	48 8b 52 18          	mov    0x18(%rdx),%rdx
  8089f2:	48 89 d7             	mov    %rdx,%rdi
  8089f5:	ff d0                	callq  *%rax
      memp_free(MEMP_TCPIP_MSG_API, msg);
  8089f7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8089fb:	48 89 c6             	mov    %rax,%rsi
  8089fe:	bf 08 00 00 00       	mov    $0x8,%edi
  808a03:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  808a0a:	00 00 00 
  808a0d:	ff d0                	callq  *%rax
      break;
  808a0f:	eb 71                	jmp    808a82 <tcpip_thread+0x23f>

    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));

      if(msg->msg.tmo.msecs != 0xffffffff)
  808a11:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808a15:	8b 40 10             	mov    0x10(%rax),%eax
  808a18:	83 f8 ff             	cmp    $0xffffffff,%eax
  808a1b:	74 2a                	je     808a47 <tcpip_thread+0x204>
        sys_timeout (msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
  808a1d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808a21:	48 8b 50 20          	mov    0x20(%rax),%rdx
  808a25:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808a29:	48 8b 48 18          	mov    0x18(%rax),%rcx
  808a2d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808a31:	8b 40 10             	mov    0x10(%rax),%eax
  808a34:	48 89 ce             	mov    %rcx,%rsi
  808a37:	89 c7                	mov    %eax,%edi
  808a39:	48 b8 13 e8 80 00 00 	movabs $0x80e813,%rax
  808a40:	00 00 00 
  808a43:	ff d0                	callq  *%rax
  808a45:	eb 22                	jmp    808a69 <tcpip_thread+0x226>
      else
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
  808a47:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808a4b:	48 8b 50 20          	mov    0x20(%rax),%rdx
  808a4f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808a53:	48 8b 40 18          	mov    0x18(%rax),%rax
  808a57:	48 89 d6             	mov    %rdx,%rsi
  808a5a:	48 89 c7             	mov    %rax,%rdi
  808a5d:	48 b8 f8 e9 80 00 00 	movabs $0x80e9f8,%rax
  808a64:	00 00 00 
  808a67:	ff d0                	callq  *%rax
      memp_free(MEMP_TCPIP_MSG_API, msg);
  808a69:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808a6d:	48 89 c6             	mov    %rax,%rsi
  808a70:	bf 08 00 00 00       	mov    $0x8,%edi
  808a75:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  808a7c:	00 00 00 
  808a7f:	ff d0                	callq  *%rax
      break;
  808a81:	90                   	nop

    default:
      break;
    }
  }
  808a82:	e9 79 fe ff ff       	jmpq   808900 <tcpip_thread+0xbd>

0000000000808a87 <tcpip_input>:
 *          to an IP header (if netif doesn't got NETIF_FLAG_ETHARP flag)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
  808a87:	55                   	push   %rbp
  808a88:	48 89 e5             	mov    %rsp,%rbp
  808a8b:	48 83 ec 20          	sub    $0x20,%rsp
  808a8f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  808a93:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  808a97:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808a9e:	00 00 00 
  808aa1:	8b 00                	mov    (%rax),%eax
  808aa3:	83 f8 ff             	cmp    $0xffffffff,%eax
  808aa6:	0f 84 90 00 00 00    	je     808b3c <tcpip_input+0xb5>
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
  808aac:	bf 09 00 00 00       	mov    $0x9,%edi
  808ab1:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  808ab8:	00 00 00 
  808abb:	ff d0                	callq  *%rax
  808abd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (msg == NULL) {
  808ac1:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808ac6:	75 07                	jne    808acf <tcpip_input+0x48>
      return ERR_MEM;
  808ac8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808acd:	eb 72                	jmp    808b41 <tcpip_input+0xba>
    }

    msg->type = TCPIP_MSG_INPKT;
  808acf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808ad3:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
    msg->msg.inp.p = p;
  808ad9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808add:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  808ae1:	48 89 50 10          	mov    %rdx,0x10(%rax)
    msg->msg.inp.netif = inp;
  808ae5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808ae9:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  808aed:	48 89 50 18          	mov    %rdx,0x18(%rax)
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  808af1:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808af8:	00 00 00 
  808afb:	8b 00                	mov    (%rax),%eax
  808afd:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  808b01:	48 89 d6             	mov    %rdx,%rsi
  808b04:	89 c7                	mov    %eax,%edi
  808b06:	48 b8 66 7b 81 00 00 	movabs $0x817b66,%rax
  808b0d:	00 00 00 
  808b10:	ff d0                	callq  *%rax
  808b12:	84 c0                	test   %al,%al
  808b14:	74 1f                	je     808b35 <tcpip_input+0xae>
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  808b16:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808b1a:	48 89 c6             	mov    %rax,%rsi
  808b1d:	bf 09 00 00 00       	mov    $0x9,%edi
  808b22:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  808b29:	00 00 00 
  808b2c:	ff d0                	callq  *%rax
      return ERR_MEM;
  808b2e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808b33:	eb 0c                	jmp    808b41 <tcpip_input+0xba>
    }
    return ERR_OK;
  808b35:	b8 00 00 00 00       	mov    $0x0,%eax
  808b3a:	eb 05                	jmp    808b41 <tcpip_input+0xba>
  }
  return ERR_VAL;
  808b3c:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  808b41:	c9                   	leaveq 
  808b42:	c3                   	retq   

0000000000808b43 <tcpip_callback_with_block>:
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_callback_with_block(void (*f)(void *ctx), void *ctx, u8_t block)
{
  808b43:	55                   	push   %rbp
  808b44:	48 89 e5             	mov    %rsp,%rbp
  808b47:	48 83 ec 30          	sub    $0x30,%rsp
  808b4b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  808b4f:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  808b53:	89 d0                	mov    %edx,%eax
  808b55:	88 45 dc             	mov    %al,-0x24(%rbp)
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  808b58:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808b5f:	00 00 00 
  808b62:	8b 00                	mov    (%rax),%eax
  808b64:	83 f8 ff             	cmp    $0xffffffff,%eax
  808b67:	0f 84 bc 00 00 00    	je     808c29 <tcpip_callback_with_block+0xe6>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  808b6d:	bf 08 00 00 00       	mov    $0x8,%edi
  808b72:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  808b79:	00 00 00 
  808b7c:	ff d0                	callq  *%rax
  808b7e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (msg == NULL) {
  808b82:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808b87:	75 0a                	jne    808b93 <tcpip_callback_with_block+0x50>
      return ERR_MEM;
  808b89:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808b8e:	e9 9b 00 00 00       	jmpq   808c2e <tcpip_callback_with_block+0xeb>
    }

    msg->type = TCPIP_MSG_CALLBACK;
  808b93:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808b97:	c7 00 02 00 00 00    	movl   $0x2,(%rax)
    msg->msg.cb.f = f;
  808b9d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808ba1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  808ba5:	48 89 50 10          	mov    %rdx,0x10(%rax)
    msg->msg.cb.ctx = ctx;
  808ba9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808bad:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  808bb1:	48 89 50 18          	mov    %rdx,0x18(%rax)
    if (block) {
  808bb5:	80 7d dc 00          	cmpb   $0x0,-0x24(%rbp)
  808bb9:	74 23                	je     808bde <tcpip_callback_with_block+0x9b>
      sys_mbox_post(mbox, msg);
  808bbb:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808bc2:	00 00 00 
  808bc5:	8b 00                	mov    (%rax),%eax
  808bc7:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  808bcb:	48 89 d6             	mov    %rdx,%rsi
  808bce:	89 c7                	mov    %eax,%edi
  808bd0:	48 b8 04 7b 81 00 00 	movabs $0x817b04,%rax
  808bd7:	00 00 00 
  808bda:	ff d0                	callq  *%rax
  808bdc:	eb 44                	jmp    808c22 <tcpip_callback_with_block+0xdf>
    } else {
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  808bde:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808be5:	00 00 00 
  808be8:	8b 00                	mov    (%rax),%eax
  808bea:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  808bee:	48 89 d6             	mov    %rdx,%rsi
  808bf1:	89 c7                	mov    %eax,%edi
  808bf3:	48 b8 66 7b 81 00 00 	movabs $0x817b66,%rax
  808bfa:	00 00 00 
  808bfd:	ff d0                	callq  *%rax
  808bff:	84 c0                	test   %al,%al
  808c01:	74 1f                	je     808c22 <tcpip_callback_with_block+0xdf>
        memp_free(MEMP_TCPIP_MSG_API, msg);
  808c03:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808c07:	48 89 c6             	mov    %rax,%rsi
  808c0a:	bf 08 00 00 00       	mov    $0x8,%edi
  808c0f:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  808c16:	00 00 00 
  808c19:	ff d0                	callq  *%rax
        return ERR_MEM;
  808c1b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808c20:	eb 0c                	jmp    808c2e <tcpip_callback_with_block+0xeb>
      }
    }
    return ERR_OK;
  808c22:	b8 00 00 00 00       	mov    $0x0,%eax
  808c27:	eb 05                	jmp    808c2e <tcpip_callback_with_block+0xeb>
  }
  return ERR_VAL;
  808c29:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  808c2e:	c9                   	leaveq 
  808c2f:	c3                   	retq   

0000000000808c30 <tcpip_timeout>:

err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  808c30:	55                   	push   %rbp
  808c31:	48 89 e5             	mov    %rsp,%rbp
  808c34:	48 83 ec 30          	sub    $0x30,%rsp
  808c38:	89 7d ec             	mov    %edi,-0x14(%rbp)
  808c3b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  808c3f:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  808c43:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808c4a:	00 00 00 
  808c4d:	8b 00                	mov    (%rax),%eax
  808c4f:	83 f8 ff             	cmp    $0xffffffff,%eax
  808c52:	74 77                	je     808ccb <tcpip_timeout+0x9b>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  808c54:	bf 08 00 00 00       	mov    $0x8,%edi
  808c59:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  808c60:	00 00 00 
  808c63:	ff d0                	callq  *%rax
  808c65:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (msg == NULL) {
  808c69:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808c6e:	75 07                	jne    808c77 <tcpip_timeout+0x47>
      return ERR_MEM;
  808c70:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808c75:	eb 59                	jmp    808cd0 <tcpip_timeout+0xa0>
    }

    msg->type = TCPIP_MSG_TIMEOUT;
  808c77:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808c7b:	c7 00 03 00 00 00    	movl   $0x3,(%rax)
    msg->msg.tmo.msecs = msecs;
  808c81:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808c85:	8b 55 ec             	mov    -0x14(%rbp),%edx
  808c88:	89 50 10             	mov    %edx,0x10(%rax)
    msg->msg.tmo.h = h;
  808c8b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808c8f:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  808c93:	48 89 50 18          	mov    %rdx,0x18(%rax)
    msg->msg.tmo.arg = arg;
  808c97:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808c9b:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  808c9f:	48 89 50 20          	mov    %rdx,0x20(%rax)
    sys_mbox_post(mbox, msg);
  808ca3:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808caa:	00 00 00 
  808cad:	8b 00                	mov    (%rax),%eax
  808caf:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  808cb3:	48 89 d6             	mov    %rdx,%rsi
  808cb6:	89 c7                	mov    %eax,%edi
  808cb8:	48 b8 04 7b 81 00 00 	movabs $0x817b04,%rax
  808cbf:	00 00 00 
  808cc2:	ff d0                	callq  *%rax
    return ERR_OK;
  808cc4:	b8 00 00 00 00       	mov    $0x0,%eax
  808cc9:	eb 05                	jmp    808cd0 <tcpip_timeout+0xa0>
  }
  return ERR_VAL;
  808ccb:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  808cd0:	c9                   	leaveq 
  808cd1:	c3                   	retq   

0000000000808cd2 <tcpip_apimsg>:
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_apimsg(struct api_msg *apimsg)
{
  808cd2:	55                   	push   %rbp
  808cd3:	48 89 e5             	mov    %rsp,%rbp
  808cd6:	48 83 ec 40          	sub    $0x40,%rsp
  808cda:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  struct tcpip_msg msg;
  
  if (mbox != SYS_MBOX_NULL) {
  808cde:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808ce5:	00 00 00 
  808ce8:	8b 00                	mov    (%rax),%eax
  808cea:	83 f8 ff             	cmp    $0xffffffff,%eax
  808ced:	74 55                	je     808d44 <tcpip_apimsg+0x72>
    msg.type = TCPIP_MSG_API;
  808cef:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%rbp)
    msg.msg.apimsg = apimsg;
  808cf6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  808cfa:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    sys_mbox_post(mbox, &msg);
  808cfe:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808d05:	00 00 00 
  808d08:	8b 00                	mov    (%rax),%eax
  808d0a:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  808d0e:	48 89 d6             	mov    %rdx,%rsi
  808d11:	89 c7                	mov    %eax,%edi
  808d13:	48 b8 04 7b 81 00 00 	movabs $0x817b04,%rax
  808d1a:	00 00 00 
  808d1d:	ff d0                	callq  *%rax
    sys_arch_sem_wait(apimsg->msg.conn->op_completed, 0);
  808d1f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  808d23:	48 8b 40 08          	mov    0x8(%rax),%rax
  808d27:	8b 40 14             	mov    0x14(%rax),%eax
  808d2a:	be 00 00 00 00       	mov    $0x0,%esi
  808d2f:	89 c7                	mov    %eax,%edi
  808d31:	48 b8 4d 81 81 00 00 	movabs $0x81814d,%rax
  808d38:	00 00 00 
  808d3b:	ff d0                	callq  *%rax
    return ERR_OK;
  808d3d:	b8 00 00 00 00       	mov    $0x0,%eax
  808d42:	eb 05                	jmp    808d49 <tcpip_apimsg+0x77>
  }
  return ERR_VAL;
  808d44:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  808d49:	c9                   	leaveq 
  808d4a:	c3                   	retq   

0000000000808d4b <tcpip_init>:
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(void (* initfunc)(void *), void *arg)
{
  808d4b:	55                   	push   %rbp
  808d4c:	48 89 e5             	mov    %rsp,%rbp
  808d4f:	48 83 ec 10          	sub    $0x10,%rsp
  808d53:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  808d57:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  lwip_init();
  808d5b:	48 b8 f6 93 80 00 00 	movabs $0x8093f6,%rax
  808d62:	00 00 00 
  808d65:	ff d0                	callq  *%rax

  tcpip_init_done = initfunc;
  808d67:	48 b8 b0 94 82 00 00 	movabs $0x8294b0,%rax
  808d6e:	00 00 00 
  808d71:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  808d75:	48 89 10             	mov    %rdx,(%rax)
  tcpip_init_done_arg = arg;
  808d78:	48 b8 b8 94 82 00 00 	movabs $0x8294b8,%rax
  808d7f:	00 00 00 
  808d82:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  808d86:	48 89 10             	mov    %rdx,(%rax)
  mbox = sys_mbox_new(TCPIP_MBOX_SIZE);
  808d89:	bf 00 00 00 00       	mov    $0x0,%edi
  808d8e:	48 b8 d5 76 81 00 00 	movabs $0x8176d5,%rax
  808d95:	00 00 00 
  808d98:	ff d0                	callq  *%rax
  808d9a:	48 ba 78 81 82 00 00 	movabs $0x828178,%rdx
  808da1:	00 00 00 
  808da4:	89 02                	mov    %eax,(%rdx)
#if LWIP_TCPIP_CORE_LOCKING
  lock_tcpip_core = sys_sem_new(1);
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
  808da6:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  808dac:	b9 00 00 00 00       	mov    $0x0,%ecx
  808db1:	ba 00 00 00 00       	mov    $0x0,%edx
  808db6:	48 be 43 88 80 00 00 	movabs $0x808843,%rsi
  808dbd:	00 00 00 
  808dc0:	48 bf 53 17 82 00 00 	movabs $0x821753,%rdi
  808dc7:	00 00 00 
  808dca:	48 b8 6e 86 81 00 00 	movabs $0x81866e,%rax
  808dd1:	00 00 00 
  808dd4:	ff d0                	callq  *%rax
}
  808dd6:	c9                   	leaveq 
  808dd7:	c3                   	retq   

0000000000808dd8 <pbuf_free_int>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
  808dd8:	55                   	push   %rbp
  808dd9:	48 89 e5             	mov    %rsp,%rbp
  808ddc:	48 83 ec 20          	sub    $0x20,%rsp
  808de0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct pbuf *q = p;
  808de4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  808de8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  pbuf_free(q);
  808dec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808df0:	48 89 c7             	mov    %rax,%rdi
  808df3:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  808dfa:	00 00 00 
  808dfd:	ff d0                	callq  *%rax
}
  808dff:	c9                   	leaveq 
  808e00:	c3                   	retq   

0000000000808e01 <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
  808e01:	55                   	push   %rbp
  808e02:	48 89 e5             	mov    %rsp,%rbp
  808e05:	48 83 ec 10          	sub    $0x10,%rsp
  808e09:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
  808e0d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808e11:	ba 00 00 00 00       	mov    $0x0,%edx
  808e16:	48 89 c6             	mov    %rax,%rsi
  808e19:	48 bf d8 8d 80 00 00 	movabs $0x808dd8,%rdi
  808e20:	00 00 00 
  808e23:	48 b8 43 8b 80 00 00 	movabs $0x808b43,%rax
  808e2a:	00 00 00 
  808e2d:	ff d0                	callq  *%rax
}
  808e2f:	c9                   	leaveq 
  808e30:	c3                   	retq   

0000000000808e31 <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
  808e31:	55                   	push   %rbp
  808e32:	48 89 e5             	mov    %rsp,%rbp
  808e35:	48 83 ec 10          	sub    $0x10,%rsp
  808e39:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  return tcpip_callback_with_block(mem_free, m, 0);
  808e3d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808e41:	ba 00 00 00 00       	mov    $0x0,%edx
  808e46:	48 89 c6             	mov    %rax,%rsi
  808e49:	48 bf fa c4 80 00 00 	movabs $0x80c4fa,%rdi
  808e50:	00 00 00 
  808e53:	48 b8 43 8b 80 00 00 	movabs $0x808b43,%rax
  808e5a:	00 00 00 
  808e5d:	ff d0                	callq  *%rax
}
  808e5f:	c9                   	leaveq 
  808e60:	c3                   	retq   

0000000000808e61 <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
  808e61:	55                   	push   %rbp
  808e62:	48 89 e5             	mov    %rsp,%rbp
  808e65:	48 83 ec 10          	sub    $0x10,%rsp
  struct netbuf *buf;

  buf = memp_malloc(MEMP_NETBUF);
  808e69:	bf 06 00 00 00       	mov    $0x6,%edi
  808e6e:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  808e75:	00 00 00 
  808e78:	ff d0                	callq  *%rax
  808e7a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (buf != NULL) {
  808e7e:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808e83:	74 29                	je     808eae <netbuf_new+0x4d>
    buf->p = NULL;
  808e85:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808e89:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    buf->ptr = NULL;
  808e90:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808e94:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  808e9b:	00 
    buf->addr = NULL;
  808e9c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808ea0:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  808ea7:	00 
    return buf;
  808ea8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808eac:	eb 05                	jmp    808eb3 <netbuf_new+0x52>
  } else {
    return NULL;
  808eae:	b8 00 00 00 00       	mov    $0x0,%eax
  }
}
  808eb3:	c9                   	leaveq 
  808eb4:	c3                   	retq   

0000000000808eb5 <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  808eb5:	55                   	push   %rbp
  808eb6:	48 89 e5             	mov    %rsp,%rbp
  808eb9:	48 83 ec 10          	sub    $0x10,%rsp
  808ebd:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (buf != NULL) {
  808ec1:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808ec6:	74 55                	je     808f1d <netbuf_delete+0x68>
    if (buf->p != NULL) {
  808ec8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808ecc:	48 8b 00             	mov    (%rax),%rax
  808ecf:	48 85 c0             	test   %rax,%rax
  808ed2:	74 31                	je     808f05 <netbuf_delete+0x50>
      pbuf_free(buf->p);
  808ed4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808ed8:	48 8b 00             	mov    (%rax),%rax
  808edb:	48 89 c7             	mov    %rax,%rdi
  808ede:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  808ee5:	00 00 00 
  808ee8:	ff d0                	callq  *%rax
      buf->p = buf->ptr = NULL;
  808eea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808eee:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  808ef5:	00 
  808ef6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808efa:	48 8b 50 08          	mov    0x8(%rax),%rdx
  808efe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808f02:	48 89 10             	mov    %rdx,(%rax)
    }
    memp_free(MEMP_NETBUF, buf);
  808f05:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808f09:	48 89 c6             	mov    %rax,%rsi
  808f0c:	bf 06 00 00 00       	mov    $0x6,%edi
  808f11:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  808f18:	00 00 00 
  808f1b:	ff d0                	callq  *%rax
  }
}
  808f1d:	c9                   	leaveq 
  808f1e:	c3                   	retq   

0000000000808f1f <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  808f1f:	55                   	push   %rbp
  808f20:	48 89 e5             	mov    %rsp,%rbp
  808f23:	48 83 ec 10          	sub    $0x10,%rsp
  808f27:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  808f2b:	89 f0                	mov    %esi,%eax
  808f2d:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  808f31:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808f36:	75 2a                	jne    808f62 <netbuf_alloc+0x43>
  808f38:	48 ba 60 17 82 00 00 	movabs $0x821760,%rdx
  808f3f:	00 00 00 
  808f42:	be 64 00 00 00       	mov    $0x64,%esi
  808f47:	48 bf 7a 17 82 00 00 	movabs $0x82177a,%rdi
  808f4e:	00 00 00 
  808f51:	b8 00 00 00 00       	mov    $0x0,%eax
  808f56:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  808f5d:	00 00 00 
  808f60:	ff d1                	callq  *%rcx

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
  808f62:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808f66:	48 8b 00             	mov    (%rax),%rax
  808f69:	48 85 c0             	test   %rax,%rax
  808f6c:	74 16                	je     808f84 <netbuf_alloc+0x65>
    pbuf_free(buf->p);
  808f6e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808f72:	48 8b 00             	mov    (%rax),%rax
  808f75:	48 89 c7             	mov    %rax,%rdi
  808f78:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  808f7f:	00 00 00 
  808f82:	ff d0                	callq  *%rax
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  808f84:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  808f88:	ba 00 00 00 00       	mov    $0x0,%edx
  808f8d:	89 c6                	mov    %eax,%esi
  808f8f:	bf 00 00 00 00       	mov    $0x0,%edi
  808f94:	48 b8 61 d4 80 00 00 	movabs $0x80d461,%rax
  808f9b:	00 00 00 
  808f9e:	ff d0                	callq  *%rax
  808fa0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  808fa4:	48 89 02             	mov    %rax,(%rdx)
  if (buf->p == NULL) {
  808fa7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808fab:	48 8b 00             	mov    (%rax),%rax
  808fae:	48 85 c0             	test   %rax,%rax
  808fb1:	75 07                	jne    808fba <netbuf_alloc+0x9b>
     return NULL;
  808fb3:	b8 00 00 00 00       	mov    $0x0,%eax
  808fb8:	eb 55                	jmp    80900f <netbuf_alloc+0xf0>
  }
  LWIP_ASSERT("check that first pbuf can hold size",
  808fba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808fbe:	48 8b 00             	mov    (%rax),%rax
  808fc1:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  808fc5:	66 3b 45 f4          	cmp    -0xc(%rbp),%ax
  808fc9:	73 2a                	jae    808ff5 <netbuf_alloc+0xd6>
  808fcb:	48 ba 90 17 82 00 00 	movabs $0x821790,%rdx
  808fd2:	00 00 00 
  808fd5:	be 6f 00 00 00       	mov    $0x6f,%esi
  808fda:	48 bf 7a 17 82 00 00 	movabs $0x82177a,%rdi
  808fe1:	00 00 00 
  808fe4:	b8 00 00 00 00       	mov    $0x0,%eax
  808fe9:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  808ff0:	00 00 00 
  808ff3:	ff d1                	callq  *%rcx
             (buf->p->len >= size));
  buf->ptr = buf->p;
  808ff5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808ff9:	48 8b 10             	mov    (%rax),%rdx
  808ffc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809000:	48 89 50 08          	mov    %rdx,0x8(%rax)
  return buf->p->payload;
  809004:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809008:	48 8b 00             	mov    (%rax),%rax
  80900b:	48 8b 40 08          	mov    0x8(%rax),%rax
}
  80900f:	c9                   	leaveq 
  809010:	c3                   	retq   

0000000000809011 <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
  809011:	55                   	push   %rbp
  809012:	48 89 e5             	mov    %rsp,%rbp
  809015:	48 83 ec 10          	sub    $0x10,%rsp
  809019:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  80901d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  809022:	75 2a                	jne    80904e <netbuf_free+0x3d>
  809024:	48 ba b4 17 82 00 00 	movabs $0x8217b4,%rdx
  80902b:	00 00 00 
  80902e:	be 7c 00 00 00       	mov    $0x7c,%esi
  809033:	48 bf 7a 17 82 00 00 	movabs $0x82177a,%rdi
  80903a:	00 00 00 
  80903d:	b8 00 00 00 00       	mov    $0x0,%eax
  809042:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  809049:	00 00 00 
  80904c:	ff d1                	callq  *%rcx
  if (buf->p != NULL) {
  80904e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809052:	48 8b 00             	mov    (%rax),%rax
  809055:	48 85 c0             	test   %rax,%rax
  809058:	74 16                	je     809070 <netbuf_free+0x5f>
    pbuf_free(buf->p);
  80905a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80905e:	48 8b 00             	mov    (%rax),%rax
  809061:	48 89 c7             	mov    %rax,%rdi
  809064:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  80906b:	00 00 00 
  80906e:	ff d0                	callq  *%rax
  }
  buf->p = buf->ptr = NULL;
  809070:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809074:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  80907b:	00 
  80907c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809080:	48 8b 50 08          	mov    0x8(%rax),%rdx
  809084:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809088:	48 89 10             	mov    %rdx,(%rax)
}
  80908b:	c9                   	leaveq 
  80908c:	c3                   	retq   

000000000080908d <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
  80908d:	55                   	push   %rbp
  80908e:	48 89 e5             	mov    %rsp,%rbp
  809091:	48 83 ec 20          	sub    $0x20,%rsp
  809095:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  809099:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80909d:	89 d0                	mov    %edx,%eax
  80909f:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  8090a3:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8090a8:	75 2a                	jne    8090d4 <netbuf_ref+0x47>
  8090aa:	48 ba cd 17 82 00 00 	movabs $0x8217cd,%rdx
  8090b1:	00 00 00 
  8090b4:	be 8f 00 00 00       	mov    $0x8f,%esi
  8090b9:	48 bf 7a 17 82 00 00 	movabs $0x82177a,%rdi
  8090c0:	00 00 00 
  8090c3:	b8 00 00 00 00       	mov    $0x0,%eax
  8090c8:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  8090cf:	00 00 00 
  8090d2:	ff d1                	callq  *%rcx
  if (buf->p != NULL) {
  8090d4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8090d8:	48 8b 00             	mov    (%rax),%rax
  8090db:	48 85 c0             	test   %rax,%rax
  8090de:	74 16                	je     8090f6 <netbuf_ref+0x69>
    pbuf_free(buf->p);
  8090e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8090e4:	48 8b 00             	mov    (%rax),%rax
  8090e7:	48 89 c7             	mov    %rax,%rdi
  8090ea:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  8090f1:	00 00 00 
  8090f4:	ff d0                	callq  *%rax
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  8090f6:	ba 02 00 00 00       	mov    $0x2,%edx
  8090fb:	be 00 00 00 00       	mov    $0x0,%esi
  809100:	bf 00 00 00 00       	mov    $0x0,%edi
  809105:	48 b8 61 d4 80 00 00 	movabs $0x80d461,%rax
  80910c:	00 00 00 
  80910f:	ff d0                	callq  *%rax
  809111:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  809115:	48 89 02             	mov    %rax,(%rdx)
  if (buf->p == NULL) {
  809118:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80911c:	48 8b 00             	mov    (%rax),%rax
  80911f:	48 85 c0             	test   %rax,%rax
  809122:	75 13                	jne    809137 <netbuf_ref+0xaa>
    buf->ptr = NULL;
  809124:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809128:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  80912f:	00 
    return ERR_MEM;
  809130:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809135:	eb 41                	jmp    809178 <netbuf_ref+0xeb>
  }
  buf->p->payload = (void*)dataptr;
  809137:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80913b:	48 8b 00             	mov    (%rax),%rax
  80913e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  809142:	48 89 50 08          	mov    %rdx,0x8(%rax)
  buf->p->len = buf->p->tot_len = size;
  809146:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80914a:	48 8b 10             	mov    (%rax),%rdx
  80914d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809151:	48 8b 00             	mov    (%rax),%rax
  809154:	0f b7 4d ec          	movzwl -0x14(%rbp),%ecx
  809158:	66 89 48 10          	mov    %cx,0x10(%rax)
  80915c:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  809160:	66 89 42 12          	mov    %ax,0x12(%rdx)
  buf->ptr = buf->p;
  809164:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809168:	48 8b 10             	mov    (%rax),%rdx
  80916b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80916f:	48 89 50 08          	mov    %rdx,0x8(%rax)
  return ERR_OK;
  809173:	b8 00 00 00 00       	mov    $0x0,%eax
}
  809178:	c9                   	leaveq 
  809179:	c3                   	retq   

000000000080917a <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  80917a:	55                   	push   %rbp
  80917b:	48 89 e5             	mov    %rsp,%rbp
  80917e:	48 83 ec 10          	sub    $0x10,%rsp
  809182:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  809186:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  80918a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80918f:	75 2a                	jne    8091bb <netbuf_chain+0x41>
  809191:	48 ba e5 17 82 00 00 	movabs $0x8217e5,%rdx
  809198:	00 00 00 
  80919b:	be a7 00 00 00       	mov    $0xa7,%esi
  8091a0:	48 bf 7a 17 82 00 00 	movabs $0x82177a,%rdi
  8091a7:	00 00 00 
  8091aa:	b8 00 00 00 00       	mov    $0x0,%eax
  8091af:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  8091b6:	00 00 00 
  8091b9:	ff d1                	callq  *%rcx
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  8091bb:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8091c0:	75 2a                	jne    8091ec <netbuf_chain+0x72>
  8091c2:	48 ba fe 17 82 00 00 	movabs $0x8217fe,%rdx
  8091c9:	00 00 00 
  8091cc:	be a8 00 00 00       	mov    $0xa8,%esi
  8091d1:	48 bf 7a 17 82 00 00 	movabs $0x82177a,%rdi
  8091d8:	00 00 00 
  8091db:	b8 00 00 00 00       	mov    $0x0,%eax
  8091e0:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  8091e7:	00 00 00 
  8091ea:	ff d1                	callq  *%rcx
  pbuf_chain(head->p, tail->p);
  8091ec:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8091f0:	48 8b 10             	mov    (%rax),%rdx
  8091f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8091f7:	48 8b 00             	mov    (%rax),%rax
  8091fa:	48 89 d6             	mov    %rdx,%rsi
  8091fd:	48 89 c7             	mov    %rax,%rdi
  809200:	48 b8 6a e0 80 00 00 	movabs $0x80e06a,%rax
  809207:	00 00 00 
  80920a:	ff d0                	callq  *%rax
  head->ptr = head->p;
  80920c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809210:	48 8b 10             	mov    (%rax),%rdx
  809213:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809217:	48 89 50 08          	mov    %rdx,0x8(%rax)
  memp_free(MEMP_NETBUF, tail);
  80921b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80921f:	48 89 c6             	mov    %rax,%rsi
  809222:	bf 06 00 00 00       	mov    $0x6,%edi
  809227:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  80922e:	00 00 00 
  809231:	ff d0                	callq  *%rax
}
  809233:	c9                   	leaveq 
  809234:	c3                   	retq   

0000000000809235 <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  809235:	55                   	push   %rbp
  809236:	48 89 e5             	mov    %rsp,%rbp
  809239:	48 83 ec 20          	sub    $0x20,%rsp
  80923d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  809241:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  809245:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  809249:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80924e:	75 2a                	jne    80927a <netbuf_data+0x45>
  809250:	48 ba 19 18 82 00 00 	movabs $0x821819,%rdx
  809257:	00 00 00 
  80925a:	be ba 00 00 00       	mov    $0xba,%esi
  80925f:	48 bf 7a 17 82 00 00 	movabs $0x82177a,%rdi
  809266:	00 00 00 
  809269:	b8 00 00 00 00       	mov    $0x0,%eax
  80926e:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  809275:	00 00 00 
  809278:	ff d1                	callq  *%rcx
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  80927a:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80927f:	75 2a                	jne    8092ab <netbuf_data+0x76>
  809281:	48 ba 32 18 82 00 00 	movabs $0x821832,%rdx
  809288:	00 00 00 
  80928b:	be bb 00 00 00       	mov    $0xbb,%esi
  809290:	48 bf 7a 17 82 00 00 	movabs $0x82177a,%rdi
  809297:	00 00 00 
  80929a:	b8 00 00 00 00       	mov    $0x0,%eax
  80929f:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  8092a6:	00 00 00 
  8092a9:	ff d1                	callq  *%rcx
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  8092ab:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8092b0:	75 2a                	jne    8092dc <netbuf_data+0xa7>
  8092b2:	48 ba 4f 18 82 00 00 	movabs $0x82184f,%rdx
  8092b9:	00 00 00 
  8092bc:	be bc 00 00 00       	mov    $0xbc,%esi
  8092c1:	48 bf 7a 17 82 00 00 	movabs $0x82177a,%rdi
  8092c8:	00 00 00 
  8092cb:	b8 00 00 00 00       	mov    $0x0,%eax
  8092d0:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  8092d7:	00 00 00 
  8092da:	ff d1                	callq  *%rcx

  if (buf->ptr == NULL) {
  8092dc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8092e0:	48 8b 40 08          	mov    0x8(%rax),%rax
  8092e4:	48 85 c0             	test   %rax,%rax
  8092e7:	75 07                	jne    8092f0 <netbuf_data+0xbb>
    return ERR_BUF;
  8092e9:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8092ee:	eb 2b                	jmp    80931b <netbuf_data+0xe6>
  }
  *dataptr = buf->ptr->payload;
  8092f0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8092f4:	48 8b 40 08          	mov    0x8(%rax),%rax
  8092f8:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8092fc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  809300:	48 89 10             	mov    %rdx,(%rax)
  *len = buf->ptr->len;
  809303:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809307:	48 8b 40 08          	mov    0x8(%rax),%rax
  80930b:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80930f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809313:	66 89 10             	mov    %dx,(%rax)
  return ERR_OK;
  809316:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80931b:	c9                   	leaveq 
  80931c:	c3                   	retq   

000000000080931d <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  80931d:	55                   	push   %rbp
  80931e:	48 89 e5             	mov    %rsp,%rbp
  809321:	48 83 ec 10          	sub    $0x10,%rsp
  809325:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  809329:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80932e:	75 2a                	jne    80935a <netbuf_next+0x3d>
  809330:	48 ba b4 17 82 00 00 	movabs $0x8217b4,%rdx
  809337:	00 00 00 
  80933a:	be d3 00 00 00       	mov    $0xd3,%esi
  80933f:	48 bf 7a 17 82 00 00 	movabs $0x82177a,%rdi
  809346:	00 00 00 
  809349:	b8 00 00 00 00       	mov    $0x0,%eax
  80934e:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  809355:	00 00 00 
  809358:	ff d1                	callq  *%rcx
  if (buf->ptr->next == NULL) {
  80935a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80935e:	48 8b 40 08          	mov    0x8(%rax),%rax
  809362:	48 8b 00             	mov    (%rax),%rax
  809365:	48 85 c0             	test   %rax,%rax
  809368:	75 07                	jne    809371 <netbuf_next+0x54>
    return -1;
  80936a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80936f:	eb 2f                	jmp    8093a0 <netbuf_next+0x83>
  }
  buf->ptr = buf->ptr->next;
  809371:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809375:	48 8b 40 08          	mov    0x8(%rax),%rax
  809379:	48 8b 10             	mov    (%rax),%rdx
  80937c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809380:	48 89 50 08          	mov    %rdx,0x8(%rax)
  if (buf->ptr->next == NULL) {
  809384:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809388:	48 8b 40 08          	mov    0x8(%rax),%rax
  80938c:	48 8b 00             	mov    (%rax),%rax
  80938f:	48 85 c0             	test   %rax,%rax
  809392:	75 07                	jne    80939b <netbuf_next+0x7e>
    return 1;
  809394:	b8 01 00 00 00       	mov    $0x1,%eax
  809399:	eb 05                	jmp    8093a0 <netbuf_next+0x83>
  }
  return 0;
  80939b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8093a0:	c9                   	leaveq 
  8093a1:	c3                   	retq   

00000000008093a2 <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
  8093a2:	55                   	push   %rbp
  8093a3:	48 89 e5             	mov    %rsp,%rbp
  8093a6:	48 83 ec 10          	sub    $0x10,%rsp
  8093aa:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  8093ae:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8093b3:	75 2a                	jne    8093df <netbuf_first+0x3d>
  8093b5:	48 ba b4 17 82 00 00 	movabs $0x8217b4,%rdx
  8093bc:	00 00 00 
  8093bf:	be e8 00 00 00       	mov    $0xe8,%esi
  8093c4:	48 bf 7a 17 82 00 00 	movabs $0x82177a,%rdi
  8093cb:	00 00 00 
  8093ce:	b8 00 00 00 00       	mov    $0x0,%eax
  8093d3:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  8093da:	00 00 00 
  8093dd:	ff d1                	callq  *%rcx
  buf->ptr = buf->p;
  8093df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8093e3:	48 8b 10             	mov    (%rax),%rdx
  8093e6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8093ea:	48 89 50 08          	mov    %rdx,0x8(%rax)
}
  8093ee:	c9                   	leaveq 
  8093ef:	c3                   	retq   

00000000008093f0 <lwip_sanity_check>:
#endif

#ifdef LWIP_DEBUG
static void
lwip_sanity_check(void)
{
  8093f0:	55                   	push   %rbp
  8093f1:	48 89 e5             	mov    %rsp,%rbp
  if (TCP_WND > (PBUF_POOL_SIZE*PBUF_POOL_BUFSIZE))
    LWIP_PLATFORM_DIAG(("lwip_sanity_check: WARNING: TCP_WND is larger than space provided by PBUF_POOL_SIZE*PBUF_POOL_BUFSIZE\n"));
  if (TCP_WND < TCP_MSS)
    LWIP_PLATFORM_DIAG(("lwip_sanity_check: WARNING: TCP_WND is smaller than MSS\n"));
#endif /* LWIP_TCP */
}
  8093f4:	5d                   	pop    %rbp
  8093f5:	c3                   	retq   

00000000008093f6 <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
  8093f6:	55                   	push   %rbp
  8093f7:	48 89 e5             	mov    %rsp,%rbp
  /* Sanity check user-configurable values */
  lwip_sanity_check();
  8093fa:	48 b8 f0 93 80 00 00 	movabs $0x8093f0,%rax
  809401:	00 00 00 
  809404:	ff d0                	callq  *%rax

  /* Modules initialization */
  stats_init();
  sys_init();
  809406:	48 b8 45 74 81 00 00 	movabs $0x817445,%rax
  80940d:	00 00 00 
  809410:	ff d0                	callq  *%rax
  mem_init();
  809412:	48 b8 10 c4 80 00 00 	movabs $0x80c410,%rax
  809419:	00 00 00 
  80941c:	ff d0                	callq  *%rax
  memp_init();
  80941e:	48 b8 73 cd 80 00 00 	movabs $0x80cd73,%rax
  809425:	00 00 00 
  809428:	ff d0                	callq  *%rax
  pbuf_init();
  netif_init();
#if LWIP_SOCKET
  lwip_socket_init();
  80942a:	48 b8 28 5d 80 00 00 	movabs $0x805d28,%rax
  809431:	00 00 00 
  809434:	ff d0                	callq  *%rax
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */
}
  809436:	5d                   	pop    %rbp
  809437:	c3                   	retq   

0000000000809438 <dhcp_handle_nak>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_nak(struct netif *netif)
{
  809438:	55                   	push   %rbp
  809439:	48 89 e5             	mov    %rsp,%rbp
  80943c:	48 83 ec 20          	sub    $0x20,%rsp
  809440:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  809444:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809448:	48 8b 40 38          	mov    0x38(%rax),%rax
  80944c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n", 
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Set the interface down since the address must no longer be used, as per RFC2131 */
  netif_set_down(netif);
  809450:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809454:	48 89 c7             	mov    %rax,%rdi
  809457:	48 b8 0c d4 80 00 00 	movabs $0x80d40c,%rax
  80945e:	00 00 00 
  809461:	ff d0                	callq  *%rax
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  809463:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809467:	48 be 68 26 82 00 00 	movabs $0x822668,%rsi
  80946e:	00 00 00 
  809471:	48 89 c7             	mov    %rax,%rdi
  809474:	48 b8 24 d2 80 00 00 	movabs $0x80d224,%rax
  80947b:	00 00 00 
  80947e:	ff d0                	callq  *%rax
  netif_set_gw(netif, IP_ADDR_ANY);
  809480:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809484:	48 be 68 26 82 00 00 	movabs $0x822668,%rsi
  80948b:	00 00 00 
  80948e:	48 89 c7             	mov    %rax,%rdi
  809491:	48 b8 2a d3 80 00 00 	movabs $0x80d32a,%rax
  809498:	00 00 00 
  80949b:	ff d0                	callq  *%rax
  netif_set_netmask(netif, IP_ADDR_ANY); 
  80949d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8094a1:	48 be 68 26 82 00 00 	movabs $0x822668,%rsi
  8094a8:	00 00 00 
  8094ab:	48 89 c7             	mov    %rax,%rdi
  8094ae:	48 b8 57 d3 80 00 00 	movabs $0x80d357,%rax
  8094b5:	00 00 00 
  8094b8:	ff d0                	callq  *%rax
  /* Change to a defined state */
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  8094ba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8094be:	be 0c 00 00 00       	mov    $0xc,%esi
  8094c3:	48 89 c7             	mov    %rax,%rdi
  8094c6:	48 b8 cf b1 80 00 00 	movabs $0x80b1cf,%rax
  8094cd:	00 00 00 
  8094d0:	ff d0                	callq  *%rax
  /* We can immediately restart discovery */
  dhcp_discover(netif);
  8094d2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8094d6:	48 89 c7             	mov    %rax,%rdi
  8094d9:	48 b8 e6 a5 80 00 00 	movabs $0x80a5e6,%rax
  8094e0:	00 00 00 
  8094e3:	ff d0                	callq  *%rax
}
  8094e5:	c9                   	leaveq 
  8094e6:	c3                   	retq   

00000000008094e7 <dhcp_check>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
  8094e7:	55                   	push   %rbp
  8094e8:	48 89 e5             	mov    %rsp,%rbp
  8094eb:	48 83 ec 20          	sub    $0x20,%rsp
  8094ef:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  8094f3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8094f7:	48 8b 40 38          	mov    0x38(%rax),%rax
  8094fb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
    (s16_t)netif->name[1]));
  /* create an ARP query for the offered IP address, expecting that no host
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
  8094ff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809503:	48 8d 48 4c          	lea    0x4c(%rax),%rcx
  809507:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80950b:	ba 00 00 00 00       	mov    $0x0,%edx
  809510:	48 89 ce             	mov    %rcx,%rsi
  809513:	48 89 c7             	mov    %rax,%rdi
  809516:	48 b8 e7 6b 81 00 00 	movabs $0x816be7,%rax
  80951d:	00 00 00 
  809520:	ff d0                	callq  *%rax
  809522:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_check: could not perform ARP query\n"));
  }
  dhcp->tries++;
  809525:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809529:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80952d:	8d 50 01             	lea    0x1(%rax),%edx
  809530:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809534:	88 50 01             	mov    %dl,0x1(%rax)
  msecs = 500;
  809537:	66 c7 45 f4 f4 01    	movw   $0x1f4,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80953d:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  809541:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  809547:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80954c:	89 c8                	mov    %ecx,%eax
  80954e:	f7 ea                	imul   %edx
  809550:	c1 fa 05             	sar    $0x5,%edx
  809553:	89 c8                	mov    %ecx,%eax
  809555:	c1 f8 1f             	sar    $0x1f,%eax
  809558:	29 c2                	sub    %eax,%edx
  80955a:	89 d0                	mov    %edx,%eax
  80955c:	89 c2                	mov    %eax,%edx
  80955e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809562:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
  dhcp_set_state(dhcp, DHCP_CHECKING);
  809566:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80956a:	be 08 00 00 00       	mov    $0x8,%esi
  80956f:	48 89 c7             	mov    %rax,%rdi
  809572:	48 b8 cf b1 80 00 00 	movabs $0x80b1cf,%rax
  809579:	00 00 00 
  80957c:	ff d0                	callq  *%rax
}
  80957e:	c9                   	leaveq 
  80957f:	c3                   	retq   

0000000000809580 <dhcp_handle_offer>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_offer(struct netif *netif)
{
  809580:	55                   	push   %rbp
  809581:	48 89 e5             	mov    %rsp,%rbp
  809584:	48 83 ec 20          	sub    $0x20,%rsp
  809588:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80958c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809590:	48 8b 40 38          	mov    0x38(%rax),%rax
  809594:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* obtain the server address */
  u8_t *option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SERVER_ID);
  809598:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80959c:	be 36 00 00 00       	mov    $0x36,%esi
  8095a1:	48 89 c7             	mov    %rax,%rdi
  8095a4:	48 b8 96 bf 80 00 00 	movabs $0x80bf96,%rax
  8095ab:	00 00 00 
  8095ae:	ff d0                	callq  *%rax
  8095b0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  if (option_ptr != NULL) {
  8095b4:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8095b9:	74 69                	je     809624 <dhcp_handle_offer+0xa4>
    dhcp->server_ip_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8095bb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8095bf:	48 83 c0 02          	add    $0x2,%rax
  8095c3:	48 89 c7             	mov    %rax,%rdi
  8095c6:	48 b8 6d c1 80 00 00 	movabs $0x80c16d,%rax
  8095cd:	00 00 00 
  8095d0:	ff d0                	callq  *%rax
  8095d2:	89 c7                	mov    %eax,%edi
  8095d4:	48 b8 54 30 81 00 00 	movabs $0x813054,%rax
  8095db:	00 00 00 
  8095de:	ff d0                	callq  *%rax
  8095e0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8095e4:	89 42 48             	mov    %eax,0x48(%rdx)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n", dhcp->server_ip_addr.addr));
    /* remember offered address */
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  8095e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8095eb:	48 8b 40 18          	mov    0x18(%rax),%rax
  8095ef:	48 83 c0 10          	add    $0x10,%rax
  8095f3:	48 85 c0             	test   %rax,%rax
  8095f6:	74 0d                	je     809605 <dhcp_handle_offer+0x85>
  8095f8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8095fc:	48 8b 40 18          	mov    0x18(%rax),%rax
  809600:	8b 40 10             	mov    0x10(%rax),%eax
  809603:	eb 05                	jmp    80960a <dhcp_handle_offer+0x8a>
  809605:	b8 00 00 00 00       	mov    $0x0,%eax
  80960a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80960e:	89 42 4c             	mov    %eax,0x4c(%rdx)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));

    dhcp_select(netif);
  809611:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809615:	48 89 c7             	mov    %rax,%rdi
  809618:	48 b8 26 96 80 00 00 	movabs $0x809626,%rax
  80961f:	00 00 00 
  809622:	ff d0                	callq  *%rax
  }
}
  809624:	c9                   	leaveq 
  809625:	c3                   	retq   

0000000000809626 <dhcp_select>:
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
  809626:	55                   	push   %rbp
  809627:	48 89 e5             	mov    %rsp,%rbp
  80962a:	48 83 ec 20          	sub    $0x20,%rsp
  80962e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  809632:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809636:	48 8b 40 38          	mov    0x38(%rax),%rax
  80963a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
#endif /* LWIP_NETIF_HOSTNAME */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80963e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809642:	48 89 c7             	mov    %rax,%rdi
  809645:	48 b8 c3 b9 80 00 00 	movabs $0x80b9c3,%rax
  80964c:	00 00 00 
  80964f:	ff d0                	callq  *%rax
  809651:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  809654:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  809658:	0f 85 3a 02 00 00    	jne    809898 <dhcp_select+0x272>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80965e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809662:	ba 01 00 00 00       	mov    $0x1,%edx
  809667:	be 35 00 00 00       	mov    $0x35,%esi
  80966c:	48 89 c7             	mov    %rax,%rdi
  80966f:	48 b8 00 b2 80 00 00 	movabs $0x80b200,%rax
  809676:	00 00 00 
  809679:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  80967b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80967f:	be 03 00 00 00       	mov    $0x3,%esi
  809684:	48 89 c7             	mov    %rax,%rdi
  809687:	48 b8 b1 b2 80 00 00 	movabs $0x80b2b1,%rax
  80968e:	00 00 00 
  809691:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  809693:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809697:	ba 02 00 00 00       	mov    $0x2,%edx
  80969c:	be 39 00 00 00       	mov    $0x39,%esi
  8096a1:	48 89 c7             	mov    %rax,%rdi
  8096a4:	48 b8 00 b2 80 00 00 	movabs $0x80b200,%rax
  8096ab:	00 00 00 
  8096ae:	ff d0                	callq  *%rax
    dhcp_option_short(dhcp, 576);
  8096b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8096b4:	be 40 02 00 00       	mov    $0x240,%esi
  8096b9:	48 89 c7             	mov    %rax,%rdi
  8096bc:	48 b8 27 b3 80 00 00 	movabs $0x80b327,%rax
  8096c3:	00 00 00 
  8096c6:	ff d0                	callq  *%rax

    /* MUST request the offered IP address */
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  8096c8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8096cc:	ba 04 00 00 00       	mov    $0x4,%edx
  8096d1:	be 32 00 00 00       	mov    $0x32,%esi
  8096d6:	48 89 c7             	mov    %rax,%rdi
  8096d9:	48 b8 00 b2 80 00 00 	movabs $0x80b200,%rax
  8096e0:	00 00 00 
  8096e3:	ff d0                	callq  *%rax
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  8096e5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8096e9:	8b 40 4c             	mov    0x4c(%rax),%eax
  8096ec:	89 c7                	mov    %eax,%edi
  8096ee:	48 b8 8c 30 81 00 00 	movabs $0x81308c,%rax
  8096f5:	00 00 00 
  8096f8:	ff d0                	callq  *%rax
  8096fa:	89 c2                	mov    %eax,%edx
  8096fc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809700:	89 d6                	mov    %edx,%esi
  809702:	48 89 c7             	mov    %rax,%rdi
  809705:	48 b8 d2 b3 80 00 00 	movabs $0x80b3d2,%rax
  80970c:	00 00 00 
  80970f:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
  809711:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809715:	ba 04 00 00 00       	mov    $0x4,%edx
  80971a:	be 36 00 00 00       	mov    $0x36,%esi
  80971f:	48 89 c7             	mov    %rax,%rdi
  809722:	48 b8 00 b2 80 00 00 	movabs $0x80b200,%rax
  809729:	00 00 00 
  80972c:	ff d0                	callq  *%rax
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
  80972e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809732:	8b 40 48             	mov    0x48(%rax),%eax
  809735:	89 c7                	mov    %eax,%edi
  809737:	48 b8 8c 30 81 00 00 	movabs $0x81308c,%rax
  80973e:	00 00 00 
  809741:	ff d0                	callq  *%rax
  809743:	89 c2                	mov    %eax,%edx
  809745:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809749:	89 d6                	mov    %edx,%esi
  80974b:	48 89 c7             	mov    %rax,%rdi
  80974e:	48 b8 d2 b3 80 00 00 	movabs $0x80b3d2,%rax
  809755:	00 00 00 
  809758:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  80975a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80975e:	ba 04 00 00 00       	mov    $0x4,%edx
  809763:	be 37 00 00 00       	mov    $0x37,%esi
  809768:	48 89 c7             	mov    %rax,%rdi
  80976b:	48 b8 00 b2 80 00 00 	movabs $0x80b200,%rax
  809772:	00 00 00 
  809775:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  809777:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80977b:	be 01 00 00 00       	mov    $0x1,%esi
  809780:	48 89 c7             	mov    %rax,%rdi
  809783:	48 b8 b1 b2 80 00 00 	movabs $0x80b2b1,%rax
  80978a:	00 00 00 
  80978d:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  80978f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809793:	be 03 00 00 00       	mov    $0x3,%esi
  809798:	48 89 c7             	mov    %rax,%rdi
  80979b:	48 b8 b1 b2 80 00 00 	movabs $0x80b2b1,%rax
  8097a2:	00 00 00 
  8097a5:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  8097a7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8097ab:	be 1c 00 00 00       	mov    $0x1c,%esi
  8097b0:	48 89 c7             	mov    %rax,%rdi
  8097b3:	48 b8 b1 b2 80 00 00 	movabs $0x80b2b1,%rax
  8097ba:	00 00 00 
  8097bd:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  8097bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8097c3:	be 06 00 00 00       	mov    $0x6,%esi
  8097c8:	48 89 c7             	mov    %rax,%rdi
  8097cb:	48 b8 b1 b2 80 00 00 	movabs $0x80b2b1,%rax
  8097d2:	00 00 00 
  8097d5:	ff d0                	callq  *%rax
        dhcp_option_byte(dhcp, *p++);
      }
    }
#endif /* LWIP_NETIF_HOSTNAME */

    dhcp_option_trailer(dhcp);
  8097d7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8097db:	48 89 c7             	mov    %rax,%rdi
  8097de:	48 b8 3e be 80 00 00 	movabs $0x80be3e,%rax
  8097e5:	00 00 00 
  8097e8:	ff d0                	callq  *%rax
    /* shrink the pbuf to the actual content length */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8097ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8097ee:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  8097f2:	66 05 f0 00          	add    $0xf0,%ax
  8097f6:	0f b7 d0             	movzwl %ax,%edx
  8097f9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8097fd:	48 8b 40 30          	mov    0x30(%rax),%rax
  809801:	89 d6                	mov    %edx,%esi
  809803:	48 89 c7             	mov    %rax,%rdi
  809806:	48 b8 36 d9 80 00 00 	movabs $0x80d936,%rax
  80980d:	00 00 00 
  809810:	ff d0                	callq  *%rax

    /* TODO: we really should bind to a specific local interface here
       but we cannot specify an unconfigured netif as it is addressless */
    /* send broadcast to any DHCP server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  809812:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809816:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80981a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80981e:	48 8b 40 08          	mov    0x8(%rax),%rax
  809822:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  809826:	49 89 d0             	mov    %rdx,%r8
  809829:	b9 43 00 00 00       	mov    $0x43,%ecx
  80982e:	48 ba 6c 26 82 00 00 	movabs $0x82266c,%rdx
  809835:	00 00 00 
  809838:	48 89 c7             	mov    %rax,%rdi
  80983b:	48 b8 39 53 81 00 00 	movabs $0x815339,%rax
  809842:	00 00 00 
  809845:	ff d0                	callq  *%rax
    /* reconnect to any (or to server here?!) */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  809847:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80984b:	48 8b 40 08          	mov    0x8(%rax),%rax
  80984f:	ba 43 00 00 00       	mov    $0x43,%edx
  809854:	48 be 68 26 82 00 00 	movabs $0x822668,%rsi
  80985b:	00 00 00 
  80985e:	48 89 c7             	mov    %rax,%rdi
  809861:	48 b8 36 57 81 00 00 	movabs $0x815736,%rax
  809868:	00 00 00 
  80986b:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  80986d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809871:	48 89 c7             	mov    %rax,%rdi
  809874:	48 b8 18 bd 80 00 00 	movabs $0x80bd18,%rax
  80987b:	00 00 00 
  80987e:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
    dhcp_set_state(dhcp, DHCP_REQUESTING);
  809880:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809884:	be 01 00 00 00       	mov    $0x1,%esi
  809889:	48 89 c7             	mov    %rax,%rdi
  80988c:	48 b8 cf b1 80 00 00 	movabs $0x80b1cf,%rax
  809893:	00 00 00 
  809896:	ff d0                	callq  *%rax
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  809898:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80989c:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8098a0:	8d 50 01             	lea    0x1(%rax),%edx
  8098a3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8098a7:	88 50 01             	mov    %dl,0x1(%rax)
  msecs = dhcp->tries < 4 ? dhcp->tries * 1000 : 4 * 1000;
  8098aa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8098ae:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8098b2:	3c 03                	cmp    $0x3,%al
  8098b4:	77 12                	ja     8098c8 <dhcp_select+0x2a2>
  8098b6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8098ba:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8098be:	0f b6 c0             	movzbl %al,%eax
  8098c1:	66 69 c0 e8 03       	imul   $0x3e8,%ax,%ax
  8098c6:	eb 05                	jmp    8098cd <dhcp_select+0x2a7>
  8098c8:	b8 a0 0f 00 00       	mov    $0xfa0,%eax
  8098cd:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8098d1:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  8098d5:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  8098db:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  8098e0:	89 c8                	mov    %ecx,%eax
  8098e2:	f7 ea                	imul   %edx
  8098e4:	c1 fa 05             	sar    $0x5,%edx
  8098e7:	89 c8                	mov    %ecx,%eax
  8098e9:	c1 f8 1f             	sar    $0x1f,%eax
  8098ec:	29 c2                	sub    %eax,%edx
  8098ee:	89 d0                	mov    %edx,%eax
  8098f0:	89 c2                	mov    %eax,%edx
  8098f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8098f6:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  8098fa:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  8098fe:	c9                   	leaveq 
  8098ff:	c3                   	retq   

0000000000809900 <dhcp_coarse_tmr>:
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 *
 */
void
dhcp_coarse_tmr()
{
  809900:	55                   	push   %rbp
  809901:	48 89 e5             	mov    %rsp,%rbp
  809904:	48 83 ec 10          	sub    $0x10,%rsp
  struct netif *netif = netif_list;
  809908:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80990f:	00 00 00 
  809912:	48 8b 00             	mov    (%rax),%rax
  809915:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  809919:	eb 72                	jmp    80998d <dhcp_coarse_tmr+0x8d>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  80991b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80991f:	48 8b 40 38          	mov    0x38(%rax),%rax
  809923:	48 85 c0             	test   %rax,%rax
  809926:	74 5a                	je     809982 <dhcp_coarse_tmr+0x82>
      /* timer is active (non zero), and triggers (zeroes) now? */
      if (netif->dhcp->t2_timeout-- == 1) {
  809928:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80992c:	48 8b 40 38          	mov    0x38(%rax),%rax
  809930:	0f b7 50 46          	movzwl 0x46(%rax),%edx
  809934:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  809937:	66 89 48 46          	mov    %cx,0x46(%rax)
  80993b:	66 83 fa 01          	cmp    $0x1,%dx
  80993f:	75 15                	jne    809956 <dhcp_coarse_tmr+0x56>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
        /* this clients' rebind timeout triggered */
        dhcp_t2_timeout(netif);
  809941:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809945:	48 89 c7             	mov    %rax,%rdi
  809948:	48 b8 d7 9b 80 00 00 	movabs $0x809bd7,%rax
  80994f:	00 00 00 
  809952:	ff d0                	callq  *%rax
  809954:	eb 2c                	jmp    809982 <dhcp_coarse_tmr+0x82>
      /* timer is active (non zero), and triggers (zeroes) now */
      } else if (netif->dhcp->t1_timeout-- == 1) {
  809956:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80995a:	48 8b 40 38          	mov    0x38(%rax),%rax
  80995e:	0f b7 50 44          	movzwl 0x44(%rax),%edx
  809962:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  809965:	66 89 48 44          	mov    %cx,0x44(%rax)
  809969:	66 83 fa 01          	cmp    $0x1,%dx
  80996d:	75 13                	jne    809982 <dhcp_coarse_tmr+0x82>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t1 timeout\n"));
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
  80996f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809973:	48 89 c7             	mov    %rax,%rdi
  809976:	48 b8 89 9b 80 00 00 	movabs $0x809b89,%rax
  80997d:	00 00 00 
  809980:	ff d0                	callq  *%rax
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  809982:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809986:	48 8b 00             	mov    (%rax),%rax
  809989:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
dhcp_coarse_tmr()
{
  struct netif *netif = netif_list;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  80998d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  809992:	75 87                	jne    80991b <dhcp_coarse_tmr+0x1b>
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  }
}
  809994:	c9                   	leaveq 
  809995:	c3                   	retq   

0000000000809996 <dhcp_fine_tmr>:
 * This timer checks whether an outstanding DHCP request is timed out.
 * 
 */
void
dhcp_fine_tmr()
{
  809996:	55                   	push   %rbp
  809997:	48 89 e5             	mov    %rsp,%rbp
  80999a:	48 83 ec 10          	sub    $0x10,%rsp
  struct netif *netif = netif_list;
  80999e:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  8099a5:	00 00 00 
  8099a8:	48 8b 00             	mov    (%rax),%rax
  8099ab:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* loop through netif's */
  while (netif != NULL) {
  8099af:	eb 77                	jmp    809a28 <dhcp_fine_tmr+0x92>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  8099b1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8099b5:	48 8b 40 38          	mov    0x38(%rax),%rax
  8099b9:	48 85 c0             	test   %rax,%rax
  8099bc:	74 5f                	je     809a1d <dhcp_fine_tmr+0x87>
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
  8099be:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8099c2:	48 8b 40 38          	mov    0x38(%rax),%rax
  8099c6:	0f b7 40 42          	movzwl 0x42(%rax),%eax
  8099ca:	66 83 f8 01          	cmp    $0x1,%ax
  8099ce:	76 15                	jbe    8099e5 <dhcp_fine_tmr+0x4f>
        netif->dhcp->request_timeout--;
  8099d0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8099d4:	48 8b 40 38          	mov    0x38(%rax),%rax
  8099d8:	0f b7 50 42          	movzwl 0x42(%rax),%edx
  8099dc:	83 ea 01             	sub    $0x1,%edx
  8099df:	66 89 50 42          	mov    %dx,0x42(%rax)
  8099e3:	eb 38                	jmp    809a1d <dhcp_fine_tmr+0x87>
      }
      else if (netif->dhcp->request_timeout == 1) {
  8099e5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8099e9:	48 8b 40 38          	mov    0x38(%rax),%rax
  8099ed:	0f b7 40 42          	movzwl 0x42(%rax),%eax
  8099f1:	66 83 f8 01          	cmp    $0x1,%ax
  8099f5:	75 26                	jne    809a1d <dhcp_fine_tmr+0x87>
        netif->dhcp->request_timeout--;
  8099f7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8099fb:	48 8b 40 38          	mov    0x38(%rax),%rax
  8099ff:	0f b7 50 42          	movzwl 0x42(%rax),%edx
  809a03:	83 ea 01             	sub    $0x1,%edx
  809a06:	66 89 50 42          	mov    %dx,0x42(%rax)
        /* { netif->dhcp->request_timeout == 0 } */
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_fine_tmr(): request timeout\n"));
        /* this clients' request timeout triggered */
        dhcp_timeout(netif);
  809a0a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809a0e:	48 89 c7             	mov    %rax,%rdi
  809a11:	48 b8 31 9a 80 00 00 	movabs $0x809a31,%rax
  809a18:	00 00 00 
  809a1b:	ff d0                	callq  *%rax
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  809a1d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809a21:	48 8b 00             	mov    (%rax),%rax
  809a24:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
void
dhcp_fine_tmr()
{
  struct netif *netif = netif_list;
  /* loop through netif's */
  while (netif != NULL) {
  809a28:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  809a2d:	75 82                	jne    8099b1 <dhcp_fine_tmr+0x1b>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  }
}
  809a2f:	c9                   	leaveq 
  809a30:	c3                   	retq   

0000000000809a31 <dhcp_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_timeout(struct netif *netif)
{
  809a31:	55                   	push   %rbp
  809a32:	48 89 e5             	mov    %rsp,%rbp
  809a35:	48 83 ec 20          	sub    $0x20,%rsp
  809a39:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  809a3d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809a41:	48 8b 40 38          	mov    0x38(%rax),%rax
  809a45:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
  809a49:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809a4d:	0f b6 00             	movzbl (%rax),%eax
  809a50:	3c 0c                	cmp    $0xc,%al
  809a52:	74 0b                	je     809a5f <dhcp_timeout+0x2e>
  809a54:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809a58:	0f b6 00             	movzbl (%rax),%eax
  809a5b:	3c 06                	cmp    $0x6,%al
  809a5d:	75 18                	jne    809a77 <dhcp_timeout+0x46>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
  809a5f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809a63:	48 89 c7             	mov    %rax,%rdi
  809a66:	48 b8 e6 a5 80 00 00 	movabs $0x80a5e6,%rax
  809a6d:	00 00 00 
  809a70:	ff d0                	callq  *%rax
  809a72:	e9 10 01 00 00       	jmpq   809b87 <dhcp_timeout+0x156>
  /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_REQUESTING) {
  809a77:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809a7b:	0f b6 00             	movzbl (%rax),%eax
  809a7e:	3c 01                	cmp    $0x1,%al
  809a80:	75 4f                	jne    809ad1 <dhcp_timeout+0xa0>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
  809a82:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809a86:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  809a8a:	3c 05                	cmp    $0x5,%al
  809a8c:	77 18                	ja     809aa6 <dhcp_timeout+0x75>
      dhcp_select(netif);
  809a8e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809a92:	48 89 c7             	mov    %rax,%rdi
  809a95:	48 b8 26 96 80 00 00 	movabs $0x809626,%rax
  809a9c:	00 00 00 
  809a9f:	ff d0                	callq  *%rax
  809aa1:	e9 e1 00 00 00       	jmpq   809b87 <dhcp_timeout+0x156>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));
      dhcp_release(netif);
  809aa6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809aaa:	48 89 c7             	mov    %rax,%rdi
  809aad:	48 b8 65 ae 80 00 00 	movabs $0x80ae65,%rax
  809ab4:	00 00 00 
  809ab7:	ff d0                	callq  *%rax
      dhcp_discover(netif);
  809ab9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809abd:	48 89 c7             	mov    %rax,%rdi
  809ac0:	48 b8 e6 a5 80 00 00 	movabs $0x80a5e6,%rax
  809ac7:	00 00 00 
  809aca:	ff d0                	callq  *%rax
  809acc:	e9 b6 00 00 00       	jmpq   809b87 <dhcp_timeout+0x156>
    }
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
  809ad1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809ad5:	0f b6 00             	movzbl (%rax),%eax
  809ad8:	3c 08                	cmp    $0x8,%al
  809ada:	75 39                	jne    809b15 <dhcp_timeout+0xe4>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
    if (dhcp->tries <= 1) {
  809adc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809ae0:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  809ae4:	3c 01                	cmp    $0x1,%al
  809ae6:	77 18                	ja     809b00 <dhcp_timeout+0xcf>
      dhcp_check(netif);
  809ae8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809aec:	48 89 c7             	mov    %rax,%rdi
  809aef:	48 b8 e7 94 80 00 00 	movabs $0x8094e7,%rax
  809af6:	00 00 00 
  809af9:	ff d0                	callq  *%rax
  809afb:	e9 87 00 00 00       	jmpq   809b87 <dhcp_timeout+0x156>
    /* no ARP replies on the offered address,
       looks like the IP address is indeed free */
    } else {
      /* bind the interface to the offered address */
      dhcp_bind(netif);
  809b00:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809b04:	48 89 c7             	mov    %rax,%rdi
  809b07:	48 b8 48 a8 80 00 00 	movabs $0x80a848,%rax
  809b0e:	00 00 00 
  809b11:	ff d0                	callq  *%rax
  809b13:	eb 72                	jmp    809b87 <dhcp_timeout+0x156>
    }
  }
  /* did not get response to renew request? */
  else if (dhcp->state == DHCP_RENEWING) {
  809b15:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809b19:	0f b6 00             	movzbl (%rax),%eax
  809b1c:	3c 05                	cmp    $0x5,%al
  809b1e:	75 15                	jne    809b35 <dhcp_timeout+0x104>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
  809b20:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809b24:	48 89 c7             	mov    %rax,%rdi
  809b27:	48 b8 d0 aa 80 00 00 	movabs $0x80aad0,%rax
  809b2e:	00 00 00 
  809b31:	ff d0                	callq  *%rax
  809b33:	eb 52                	jmp    809b87 <dhcp_timeout+0x156>
  /* did not get response to rebind request? */
  } else if (dhcp->state == DHCP_REBINDING) {
  809b35:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809b39:	0f b6 00             	movzbl (%rax),%eax
  809b3c:	3c 04                	cmp    $0x4,%al
  809b3e:	75 47                	jne    809b87 <dhcp_timeout+0x156>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
  809b40:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809b44:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  809b48:	3c 08                	cmp    $0x8,%al
  809b4a:	77 15                	ja     809b61 <dhcp_timeout+0x130>
      dhcp_rebind(netif);
  809b4c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809b50:	48 89 c7             	mov    %rax,%rdi
  809b53:	48 b8 9a ac 80 00 00 	movabs $0x80ac9a,%rax
  809b5a:	00 00 00 
  809b5d:	ff d0                	callq  *%rax
  809b5f:	eb 26                	jmp    809b87 <dhcp_timeout+0x156>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
  809b61:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809b65:	48 89 c7             	mov    %rax,%rdi
  809b68:	48 b8 65 ae 80 00 00 	movabs $0x80ae65,%rax
  809b6f:	00 00 00 
  809b72:	ff d0                	callq  *%rax
      dhcp_discover(netif);
  809b74:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809b78:	48 89 c7             	mov    %rax,%rdi
  809b7b:	48 b8 e6 a5 80 00 00 	movabs $0x80a5e6,%rax
  809b82:	00 00 00 
  809b85:	ff d0                	callq  *%rax
    }
  }
}
  809b87:	c9                   	leaveq 
  809b88:	c3                   	retq   

0000000000809b89 <dhcp_t1_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_t1_timeout(struct netif *netif)
{
  809b89:	55                   	push   %rbp
  809b8a:	48 89 e5             	mov    %rsp,%rbp
  809b8d:	48 83 ec 20          	sub    $0x20,%rsp
  809b91:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  809b95:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809b99:	48 8b 40 38          	mov    0x38(%rax),%rax
  809b9d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  809ba1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809ba5:	0f b6 00             	movzbl (%rax),%eax
  809ba8:	3c 01                	cmp    $0x1,%al
  809baa:	74 16                	je     809bc2 <dhcp_t1_timeout+0x39>
  809bac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809bb0:	0f b6 00             	movzbl (%rax),%eax
  809bb3:	3c 0a                	cmp    $0xa,%al
  809bb5:	74 0b                	je     809bc2 <dhcp_t1_timeout+0x39>
  809bb7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809bbb:	0f b6 00             	movzbl (%rax),%eax
  809bbe:	3c 05                	cmp    $0x5,%al
  809bc0:	75 13                	jne    809bd5 <dhcp_t1_timeout+0x4c>
    /* just retry to renew - note that the rebind timer (t2) will
     * eventually time-out if renew tries fail. */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t1_timeout(): must renew\n"));
    dhcp_renew(netif);
  809bc2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809bc6:	48 89 c7             	mov    %rax,%rdi
  809bc9:	48 b8 d0 aa 80 00 00 	movabs $0x80aad0,%rax
  809bd0:	00 00 00 
  809bd3:	ff d0                	callq  *%rax
  }
}
  809bd5:	c9                   	leaveq 
  809bd6:	c3                   	retq   

0000000000809bd7 <dhcp_t2_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_t2_timeout(struct netif *netif)
{
  809bd7:	55                   	push   %rbp
  809bd8:	48 89 e5             	mov    %rsp,%rbp
  809bdb:	48 83 ec 20          	sub    $0x20,%rsp
  809bdf:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  809be3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809be7:	48 8b 40 38          	mov    0x38(%rax),%rax
  809beb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  809bef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809bf3:	0f b6 00             	movzbl (%rax),%eax
  809bf6:	3c 01                	cmp    $0x1,%al
  809bf8:	74 16                	je     809c10 <dhcp_t2_timeout+0x39>
  809bfa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809bfe:	0f b6 00             	movzbl (%rax),%eax
  809c01:	3c 0a                	cmp    $0xa,%al
  809c03:	74 0b                	je     809c10 <dhcp_t2_timeout+0x39>
  809c05:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809c09:	0f b6 00             	movzbl (%rax),%eax
  809c0c:	3c 05                	cmp    $0x5,%al
  809c0e:	75 13                	jne    809c23 <dhcp_t2_timeout+0x4c>
    /* just retry to rebind */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout(): must rebind\n"));
    dhcp_rebind(netif);
  809c10:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809c14:	48 89 c7             	mov    %rax,%rdi
  809c17:	48 b8 9a ac 80 00 00 	movabs $0x80ac9a,%rax
  809c1e:	00 00 00 
  809c21:	ff d0                	callq  *%rax
  }
}
  809c23:	c9                   	leaveq 
  809c24:	c3                   	retq   

0000000000809c25 <dhcp_handle_ack>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_ack(struct netif *netif)
{
  809c25:	55                   	push   %rbp
  809c26:	48 89 e5             	mov    %rsp,%rbp
  809c29:	53                   	push   %rbx
  809c2a:	48 83 ec 38          	sub    $0x38,%rsp
  809c2e:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  809c32:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  809c36:	48 8b 40 38          	mov    0x38(%rax),%rax
  809c3a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  u8_t *option_ptr;
  /* clear options we might not get from the ACK */
  dhcp->offered_sn_mask.addr = 0;
  809c3e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809c42:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%rax)
  dhcp->offered_gw_addr.addr = 0;
  809c49:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809c4d:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%rax)
  dhcp->offered_bc_addr.addr = 0;
  809c54:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809c58:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%rax)

  /* lease time given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_LEASE_TIME);
  809c5f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809c63:	be 33 00 00 00       	mov    $0x33,%esi
  809c68:	48 89 c7             	mov    %rax,%rdi
  809c6b:	48 b8 96 bf 80 00 00 	movabs $0x80bf96,%rax
  809c72:	00 00 00 
  809c75:	ff d0                	callq  *%rax
  809c77:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  809c7b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809c80:	74 1e                	je     809ca0 <dhcp_handle_ack+0x7b>
    /* remember offered lease time */
    dhcp->offered_t0_lease = dhcp_get_option_long(option_ptr + 2);
  809c82:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809c86:	48 83 c0 02          	add    $0x2,%rax
  809c8a:	48 89 c7             	mov    %rax,%rdi
  809c8d:	48 b8 6d c1 80 00 00 	movabs $0x80c16d,%rax
  809c94:	00 00 00 
  809c97:	ff d0                	callq  *%rax
  809c99:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  809c9d:	89 42 68             	mov    %eax,0x68(%rdx)
  }
  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T1);
  809ca0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809ca4:	be 3a 00 00 00       	mov    $0x3a,%esi
  809ca9:	48 89 c7             	mov    %rax,%rdi
  809cac:	48 b8 96 bf 80 00 00 	movabs $0x80bf96,%rax
  809cb3:	00 00 00 
  809cb6:	ff d0                	callq  *%rax
  809cb8:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  809cbc:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809cc1:	74 20                	je     809ce3 <dhcp_handle_ack+0xbe>
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_long(option_ptr + 2);
  809cc3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809cc7:	48 83 c0 02          	add    $0x2,%rax
  809ccb:	48 89 c7             	mov    %rax,%rdi
  809cce:	48 b8 6d c1 80 00 00 	movabs $0x80c16d,%rax
  809cd5:	00 00 00 
  809cd8:	ff d0                	callq  *%rax
  809cda:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  809cde:	89 42 6c             	mov    %eax,0x6c(%rdx)
  809ce1:	eb 12                	jmp    809cf5 <dhcp_handle_ack+0xd0>
  } else {
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  809ce3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809ce7:	8b 40 68             	mov    0x68(%rax),%eax
  809cea:	d1 e8                	shr    %eax
  809cec:	89 c2                	mov    %eax,%edx
  809cee:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809cf2:	89 50 6c             	mov    %edx,0x6c(%rax)
  }

  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T2);
  809cf5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809cf9:	be 3b 00 00 00       	mov    $0x3b,%esi
  809cfe:	48 89 c7             	mov    %rax,%rdi
  809d01:	48 b8 96 bf 80 00 00 	movabs $0x80bf96,%rax
  809d08:	00 00 00 
  809d0b:	ff d0                	callq  *%rax
  809d0d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  809d11:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809d16:	74 20                	je     809d38 <dhcp_handle_ack+0x113>
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_long(option_ptr + 2);
  809d18:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809d1c:	48 83 c0 02          	add    $0x2,%rax
  809d20:	48 89 c7             	mov    %rax,%rdi
  809d23:	48 b8 6d c1 80 00 00 	movabs $0x80c16d,%rax
  809d2a:	00 00 00 
  809d2d:	ff d0                	callq  *%rax
  809d2f:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  809d33:	89 42 70             	mov    %eax,0x70(%rdx)
  809d36:	eb 0e                	jmp    809d46 <dhcp_handle_ack+0x121>
  } else {
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  809d38:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809d3c:	8b 50 68             	mov    0x68(%rax),%edx
  809d3f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809d43:	89 50 70             	mov    %edx,0x70(%rax)
  }

  /* (y)our internet address */
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  809d46:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809d4a:	48 8b 40 18          	mov    0x18(%rax),%rax
  809d4e:	48 83 c0 10          	add    $0x10,%rax
  809d52:	48 85 c0             	test   %rax,%rax
  809d55:	74 0d                	je     809d64 <dhcp_handle_ack+0x13f>
  809d57:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809d5b:	48 8b 40 18          	mov    0x18(%rax),%rax
  809d5f:	8b 40 10             	mov    0x10(%rax),%eax
  809d62:	eb 05                	jmp    809d69 <dhcp_handle_ack+0x144>
  809d64:	b8 00 00 00 00       	mov    $0x0,%eax
  809d69:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  809d6d:	89 42 4c             	mov    %eax,0x4c(%rdx)
    strcpy(dhcp->boot_file_name, dhcp->msg_in->file);
  }
#endif

  /* subnet mask */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SUBNET_MASK);
  809d70:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809d74:	be 01 00 00 00       	mov    $0x1,%esi
  809d79:	48 89 c7             	mov    %rax,%rdi
  809d7c:	48 b8 96 bf 80 00 00 	movabs $0x80bf96,%rax
  809d83:	00 00 00 
  809d86:	ff d0                	callq  *%rax
  809d88:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  /* subnet mask given? */
  if (option_ptr != NULL) {
  809d8c:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809d91:	74 2c                	je     809dbf <dhcp_handle_ack+0x19a>
    dhcp->offered_sn_mask.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  809d93:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809d97:	48 83 c0 02          	add    $0x2,%rax
  809d9b:	48 89 c7             	mov    %rax,%rdi
  809d9e:	48 b8 6d c1 80 00 00 	movabs $0x80c16d,%rax
  809da5:	00 00 00 
  809da8:	ff d0                	callq  *%rax
  809daa:	89 c7                	mov    %eax,%edi
  809dac:	48 b8 54 30 81 00 00 	movabs $0x813054,%rax
  809db3:	00 00 00 
  809db6:	ff d0                	callq  *%rax
  809db8:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  809dbc:	89 42 50             	mov    %eax,0x50(%rdx)
  }

  /* gateway router */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_ROUTER);
  809dbf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809dc3:	be 03 00 00 00       	mov    $0x3,%esi
  809dc8:	48 89 c7             	mov    %rax,%rdi
  809dcb:	48 b8 96 bf 80 00 00 	movabs $0x80bf96,%rax
  809dd2:	00 00 00 
  809dd5:	ff d0                	callq  *%rax
  809dd7:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  809ddb:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809de0:	74 2c                	je     809e0e <dhcp_handle_ack+0x1e9>
    dhcp->offered_gw_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  809de2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809de6:	48 83 c0 02          	add    $0x2,%rax
  809dea:	48 89 c7             	mov    %rax,%rdi
  809ded:	48 b8 6d c1 80 00 00 	movabs $0x80c16d,%rax
  809df4:	00 00 00 
  809df7:	ff d0                	callq  *%rax
  809df9:	89 c7                	mov    %eax,%edi
  809dfb:	48 b8 54 30 81 00 00 	movabs $0x813054,%rax
  809e02:	00 00 00 
  809e05:	ff d0                	callq  *%rax
  809e07:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  809e0b:	89 42 54             	mov    %eax,0x54(%rdx)
  }

  /* broadcast address */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_BROADCAST);
  809e0e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809e12:	be 1c 00 00 00       	mov    $0x1c,%esi
  809e17:	48 89 c7             	mov    %rax,%rdi
  809e1a:	48 b8 96 bf 80 00 00 	movabs $0x80bf96,%rax
  809e21:	00 00 00 
  809e24:	ff d0                	callq  *%rax
  809e26:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  809e2a:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809e2f:	74 2c                	je     809e5d <dhcp_handle_ack+0x238>
    dhcp->offered_bc_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  809e31:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809e35:	48 83 c0 02          	add    $0x2,%rax
  809e39:	48 89 c7             	mov    %rax,%rdi
  809e3c:	48 b8 6d c1 80 00 00 	movabs $0x80c16d,%rax
  809e43:	00 00 00 
  809e46:	ff d0                	callq  *%rax
  809e48:	89 c7                	mov    %eax,%edi
  809e4a:	48 b8 54 30 81 00 00 	movabs $0x813054,%rax
  809e51:	00 00 00 
  809e54:	ff d0                	callq  *%rax
  809e56:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  809e5a:	89 42 58             	mov    %eax,0x58(%rdx)
  }
  
  /* DNS servers */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
  809e5d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809e61:	be 06 00 00 00       	mov    $0x6,%esi
  809e66:	48 89 c7             	mov    %rax,%rdi
  809e69:	48 b8 96 bf 80 00 00 	movabs $0x80bf96,%rax
  809e70:	00 00 00 
  809e73:	ff d0                	callq  *%rax
  809e75:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  809e79:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809e7e:	0f 84 9d 00 00 00    	je     809f21 <dhcp_handle_ack+0x2fc>
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
  809e84:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809e88:	48 83 c0 01          	add    $0x1,%rax
  809e8c:	48 89 c7             	mov    %rax,%rdi
  809e8f:	48 b8 58 c1 80 00 00 	movabs $0x80c158,%rax
  809e96:	00 00 00 
  809e99:	ff d0                	callq  *%rax
  809e9b:	c0 e8 02             	shr    $0x2,%al
  809e9e:	0f b6 d0             	movzbl %al,%edx
  809ea1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809ea5:	89 50 5c             	mov    %edx,0x5c(%rax)
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
  809ea8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809eac:	8b 40 5c             	mov    0x5c(%rax),%eax
  809eaf:	83 f8 02             	cmp    $0x2,%eax
  809eb2:	76 0b                	jbe    809ebf <dhcp_handle_ack+0x29a>
      dhcp->dns_count = DHCP_MAX_DNS;
  809eb4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809eb8:	c7 40 5c 02 00 00 00 	movl   $0x2,0x5c(%rax)
    for (n = 0; n < dhcp->dns_count; n++) {
  809ebf:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  809ec3:	eb 4d                	jmp    809f12 <dhcp_handle_ack+0x2ed>
      dhcp->offered_dns_addr[n].addr = htonl(dhcp_get_option_long(&option_ptr[2 + n * 4]));
  809ec5:	0f b6 5d ef          	movzbl -0x11(%rbp),%ebx
  809ec9:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  809ecd:	c1 e0 02             	shl    $0x2,%eax
  809ed0:	83 c0 02             	add    $0x2,%eax
  809ed3:	48 63 d0             	movslq %eax,%rdx
  809ed6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809eda:	48 01 d0             	add    %rdx,%rax
  809edd:	48 89 c7             	mov    %rax,%rdi
  809ee0:	48 b8 6d c1 80 00 00 	movabs $0x80c16d,%rax
  809ee7:	00 00 00 
  809eea:	ff d0                	callq  *%rax
  809eec:	89 c7                	mov    %eax,%edi
  809eee:	48 b8 54 30 81 00 00 	movabs $0x813054,%rax
  809ef5:	00 00 00 
  809ef8:	ff d0                	callq  *%rax
  809efa:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  809efe:	48 63 cb             	movslq %ebx,%rcx
  809f01:	48 83 c1 18          	add    $0x18,%rcx
  809f05:	89 04 8a             	mov    %eax,(%rdx,%rcx,4)
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
    for (n = 0; n < dhcp->dns_count; n++) {
  809f08:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  809f0c:	83 c0 01             	add    $0x1,%eax
  809f0f:	88 45 ef             	mov    %al,-0x11(%rbp)
  809f12:	0f b6 55 ef          	movzbl -0x11(%rbp),%edx
  809f16:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809f1a:	8b 40 5c             	mov    0x5c(%rax),%eax
  809f1d:	39 c2                	cmp    %eax,%edx
  809f1f:	72 a4                	jb     809ec5 <dhcp_handle_ack+0x2a0>
    }
#if LWIP_DNS
    dns_setserver( n, (struct ip_addr *)(&ip_addr_any));
#endif /* LWIP_DNS */
  }
}
  809f21:	48 83 c4 38          	add    $0x38,%rsp
  809f25:	5b                   	pop    %rbx
  809f26:	5d                   	pop    %rbp
  809f27:	c3                   	retq   

0000000000809f28 <dhcp_start>:
 * - ERR_OK - No error
 * - ERR_MEM - Out of memory
 */
err_t
dhcp_start(struct netif *netif)
{
  809f28:	55                   	push   %rbp
  809f29:	48 89 e5             	mov    %rsp,%rbp
  809f2c:	48 83 ec 20          	sub    $0x20,%rsp
  809f30:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp;
  err_t result = ERR_OK;
  809f34:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  809f38:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  809f3d:	75 2a                	jne    809f69 <dhcp_start+0x41>
  809f3f:	48 ba 68 18 82 00 00 	movabs $0x821868,%rdx
  809f46:	00 00 00 
  809f49:	be 39 02 00 00       	mov    $0x239,%esi
  809f4e:	48 bf 76 18 82 00 00 	movabs $0x821876,%rdi
  809f55:	00 00 00 
  809f58:	b8 00 00 00 00       	mov    $0x0,%eax
  809f5d:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  809f64:	00 00 00 
  809f67:	ff d1                	callq  *%rcx
  dhcp = netif->dhcp;
  809f69:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809f6d:	48 8b 40 38          	mov    0x38(%rax),%rax
  809f71:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  809f75:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809f79:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  809f7d:	83 e0 f7             	and    $0xfffffff7,%eax
  809f80:	89 c2                	mov    %eax,%edx
  809f82:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809f86:	88 50 4a             	mov    %dl,0x4a(%rax)

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
  809f89:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  809f8e:	75 32                	jne    809fc2 <dhcp_start+0x9a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = mem_malloc(sizeof(struct dhcp));
  809f90:	bf 78 00 00 00       	mov    $0x78,%edi
  809f95:	48 b8 96 c9 80 00 00 	movabs $0x80c996,%rax
  809f9c:	00 00 00 
  809f9f:	ff d0                	callq  *%rax
  809fa1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (dhcp == NULL) {
  809fa5:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  809faa:	75 0a                	jne    809fb6 <dhcp_start+0x8e>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
  809fac:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809fb1:	e9 3a 01 00 00       	jmpq   80a0f0 <dhcp_start+0x1c8>
    }
    /* store this dhcp client in the netif */
    netif->dhcp = dhcp;
  809fb6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809fba:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  809fbe:	48 89 50 38          	mov    %rdx,0x38(%rax)
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 3, ("dhcp_start(): restarting DHCP configuration\n"));
  }
    
  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
  809fc2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809fc6:	ba 78 00 00 00       	mov    $0x78,%edx
  809fcb:	be 00 00 00 00       	mov    $0x0,%esi
  809fd0:	48 89 c7             	mov    %rax,%rdi
  809fd3:	48 b8 70 21 80 00 00 	movabs $0x802170,%rax
  809fda:	00 00 00 
  809fdd:	ff d0                	callq  *%rax
  /* allocate UDP PCB */
  dhcp->pcb = udp_new();
  809fdf:	48 b8 46 59 81 00 00 	movabs $0x815946,%rax
  809fe6:	00 00 00 
  809fe9:	ff d0                	callq  *%rax
  809feb:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  809fef:	48 89 42 08          	mov    %rax,0x8(%rdx)
  if (dhcp->pcb == NULL) {
  809ff3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809ff7:	48 8b 40 08          	mov    0x8(%rax),%rax
  809ffb:	48 85 c0             	test   %rax,%rax
  809ffe:	75 31                	jne    80a031 <dhcp_start+0x109>
    LWIP_DEBUGF(DHCP_DEBUG  | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    mem_free((void *)dhcp);
  80a000:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a004:	48 89 c7             	mov    %rax,%rdi
  80a007:	48 b8 fa c4 80 00 00 	movabs $0x80c4fa,%rax
  80a00e:	00 00 00 
  80a011:	ff d0                	callq  *%rax
    netif->dhcp = dhcp = NULL;
  80a013:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80a01a:	00 
  80a01b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a01f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80a023:	48 89 50 38          	mov    %rdx,0x38(%rax)
    return ERR_MEM;
  80a027:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a02c:	e9 bf 00 00 00       	jmpq   80a0f0 <dhcp_start+0x1c8>
  }
  /* set up local and remote port for the pcb */
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  80a031:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a035:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a039:	ba 44 00 00 00       	mov    $0x44,%edx
  80a03e:	48 be 68 26 82 00 00 	movabs $0x822668,%rsi
  80a045:	00 00 00 
  80a048:	48 89 c7             	mov    %rax,%rdi
  80a04b:	48 b8 ea 55 81 00 00 	movabs $0x8155ea,%rax
  80a052:	00 00 00 
  80a055:	ff d0                	callq  *%rax
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80a057:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a05b:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a05f:	ba 43 00 00 00       	mov    $0x43,%edx
  80a064:	48 be 68 26 82 00 00 	movabs $0x822668,%rsi
  80a06b:	00 00 00 
  80a06e:	48 89 c7             	mov    %rax,%rdi
  80a071:	48 b8 36 57 81 00 00 	movabs $0x815736,%rax
  80a078:	00 00 00 
  80a07b:	ff d0                	callq  *%rax
  /* set up the recv callback and argument */
  udp_recv(dhcp->pcb, dhcp_recv, netif);
  80a07d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a081:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a085:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80a089:	48 be 73 b7 80 00 00 	movabs $0x80b773,%rsi
  80a090:	00 00 00 
  80a093:	48 89 c7             	mov    %rax,%rdi
  80a096:	48 b8 6e 58 81 00 00 	movabs $0x81586e,%rax
  80a09d:	00 00 00 
  80a0a0:	ff d0                	callq  *%rax
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
  80a0a2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a0a6:	48 89 c7             	mov    %rax,%rdi
  80a0a9:	48 b8 e6 a5 80 00 00 	movabs $0x80a5e6,%rax
  80a0b0:	00 00 00 
  80a0b3:	ff d0                	callq  *%rax
  80a0b5:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result != ERR_OK) {
  80a0b8:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80a0bc:	74 1a                	je     80a0d8 <dhcp_start+0x1b0>
    /* free resources allocated above */
    dhcp_stop(netif);
  80a0be:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a0c2:	48 89 c7             	mov    %rax,%rdi
  80a0c5:	48 b8 d3 b0 80 00 00 	movabs $0x80b0d3,%rax
  80a0cc:	00 00 00 
  80a0cf:	ff d0                	callq  *%rax
    return ERR_MEM;
  80a0d1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a0d6:	eb 18                	jmp    80a0f0 <dhcp_start+0x1c8>
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
  80a0d8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a0dc:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80a0e0:	83 c8 08             	or     $0x8,%eax
  80a0e3:	89 c2                	mov    %eax,%edx
  80a0e5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a0e9:	88 50 4a             	mov    %dl,0x4a(%rax)
  return result;
  80a0ec:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  80a0f0:	c9                   	leaveq 
  80a0f1:	c3                   	retq   

000000000080a0f2 <dhcp_inform>:
 *
 * @param netif The lwIP network interface
 */
void
dhcp_inform(struct netif *netif)
{
  80a0f2:	55                   	push   %rbp
  80a0f3:	48 89 e5             	mov    %rsp,%rbp
  80a0f6:	48 83 ec 30          	sub    $0x30,%rsp
  80a0fa:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  80a0fe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80a102:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a106:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result = ERR_OK;
  80a10a:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
  dhcp = mem_malloc(sizeof(struct dhcp));
  80a10e:	bf 78 00 00 00       	mov    $0x78,%edi
  80a113:	48 b8 96 c9 80 00 00 	movabs $0x80c996,%rax
  80a11a:	00 00 00 
  80a11d:	ff d0                	callq  *%rax
  80a11f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if (dhcp == NULL) {
  80a123:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80a128:	75 05                	jne    80a12f <dhcp_inform+0x3d>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not allocate dhcp\n"));
    return;
  80a12a:	e9 37 02 00 00       	jmpq   80a366 <dhcp_inform+0x274>
  }
  netif->dhcp = dhcp;
  80a12f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80a133:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80a137:	48 89 50 38          	mov    %rdx,0x38(%rax)
  memset(dhcp, 0, sizeof(struct dhcp));
  80a13b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a13f:	ba 78 00 00 00       	mov    $0x78,%edx
  80a144:	be 00 00 00 00       	mov    $0x0,%esi
  80a149:	48 89 c7             	mov    %rax,%rdi
  80a14c:	48 b8 70 21 80 00 00 	movabs $0x802170,%rax
  80a153:	00 00 00 
  80a156:	ff d0                	callq  *%rax

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): allocated dhcp\n"));
  dhcp->pcb = udp_new();
  80a158:	48 b8 46 59 81 00 00 	movabs $0x815946,%rax
  80a15f:	00 00 00 
  80a162:	ff d0                	callq  *%rax
  80a164:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80a168:	48 89 42 08          	mov    %rax,0x8(%rdx)
  if (dhcp->pcb == NULL) {
  80a16c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a170:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a174:	48 85 c0             	test   %rax,%rax
  80a177:	75 18                	jne    80a191 <dhcp_inform+0x9f>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not obtain pcb"));
    mem_free((void *)dhcp);
  80a179:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a17d:	48 89 c7             	mov    %rax,%rdi
  80a180:	48 b8 fa c4 80 00 00 	movabs $0x80c4fa,%rax
  80a187:	00 00 00 
  80a18a:	ff d0                	callq  *%rax
    return;
  80a18c:	e9 d5 01 00 00       	jmpq   80a366 <dhcp_inform+0x274>
  }
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): created new udp pcb\n"));
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80a191:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80a195:	48 89 c7             	mov    %rax,%rdi
  80a198:	48 b8 c3 b9 80 00 00 	movabs $0x80b9c3,%rax
  80a19f:	00 00 00 
  80a1a2:	ff d0                	callq  *%rax
  80a1a4:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80a1a7:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80a1ab:	0f 85 5f 01 00 00    	jne    80a310 <dhcp_inform+0x21e>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80a1b1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a1b5:	ba 01 00 00 00       	mov    $0x1,%edx
  80a1ba:	be 35 00 00 00       	mov    $0x35,%esi
  80a1bf:	48 89 c7             	mov    %rax,%rdi
  80a1c2:	48 b8 00 b2 80 00 00 	movabs $0x80b200,%rax
  80a1c9:	00 00 00 
  80a1cc:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_INFORM);
  80a1ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a1d2:	be 08 00 00 00       	mov    $0x8,%esi
  80a1d7:	48 89 c7             	mov    %rax,%rdi
  80a1da:	48 b8 b1 b2 80 00 00 	movabs $0x80b2b1,%rax
  80a1e1:	00 00 00 
  80a1e4:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80a1e6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a1ea:	ba 02 00 00 00       	mov    $0x2,%edx
  80a1ef:	be 39 00 00 00       	mov    $0x39,%esi
  80a1f4:	48 89 c7             	mov    %rax,%rdi
  80a1f7:	48 b8 00 b2 80 00 00 	movabs $0x80b200,%rax
  80a1fe:	00 00 00 
  80a201:	ff d0                	callq  *%rax
    /* TODO: use netif->mtu ?! */
    dhcp_option_short(dhcp, 576);
  80a203:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a207:	be 40 02 00 00       	mov    $0x240,%esi
  80a20c:	48 89 c7             	mov    %rax,%rdi
  80a20f:	48 b8 27 b3 80 00 00 	movabs $0x80b327,%rax
  80a216:	00 00 00 
  80a219:	ff d0                	callq  *%rax

    dhcp_option_trailer(dhcp);
  80a21b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a21f:	48 89 c7             	mov    %rax,%rdi
  80a222:	48 b8 3e be 80 00 00 	movabs $0x80be3e,%rax
  80a229:	00 00 00 
  80a22c:	ff d0                	callq  *%rax

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80a22e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a232:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80a236:	66 05 f0 00          	add    $0xf0,%ax
  80a23a:	0f b7 d0             	movzwl %ax,%edx
  80a23d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a241:	48 8b 40 30          	mov    0x30(%rax),%rax
  80a245:	89 d6                	mov    %edx,%esi
  80a247:	48 89 c7             	mov    %rax,%rdi
  80a24a:	48 b8 36 d9 80 00 00 	movabs $0x80d936,%rax
  80a251:	00 00 00 
  80a254:	ff d0                	callq  *%rax

    udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  80a256:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a25a:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a25e:	ba 44 00 00 00       	mov    $0x44,%edx
  80a263:	48 be 68 26 82 00 00 	movabs $0x822668,%rsi
  80a26a:	00 00 00 
  80a26d:	48 89 c7             	mov    %rax,%rdi
  80a270:	48 b8 ea 55 81 00 00 	movabs $0x8155ea,%rax
  80a277:	00 00 00 
  80a27a:	ff d0                	callq  *%rax
    udp_connect(dhcp->pcb, IP_ADDR_BROADCAST, DHCP_SERVER_PORT);
  80a27c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a280:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a284:	ba 43 00 00 00       	mov    $0x43,%edx
  80a289:	48 be 6c 26 82 00 00 	movabs $0x82266c,%rsi
  80a290:	00 00 00 
  80a293:	48 89 c7             	mov    %rax,%rdi
  80a296:	48 b8 36 57 81 00 00 	movabs $0x815736,%rax
  80a29d:	00 00 00 
  80a2a0:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_inform: INFORMING\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80a2a2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a2a6:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80a2aa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a2ae:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a2b2:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80a2b6:	49 89 d0             	mov    %rdx,%r8
  80a2b9:	b9 43 00 00 00       	mov    $0x43,%ecx
  80a2be:	48 ba 6c 26 82 00 00 	movabs $0x82266c,%rdx
  80a2c5:	00 00 00 
  80a2c8:	48 89 c7             	mov    %rax,%rdi
  80a2cb:	48 b8 39 53 81 00 00 	movabs $0x815339,%rax
  80a2d2:	00 00 00 
  80a2d5:	ff d0                	callq  *%rax
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80a2d7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a2db:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a2df:	ba 43 00 00 00       	mov    $0x43,%edx
  80a2e4:	48 be 68 26 82 00 00 	movabs $0x822668,%rsi
  80a2eb:	00 00 00 
  80a2ee:	48 89 c7             	mov    %rax,%rdi
  80a2f1:	48 b8 36 57 81 00 00 	movabs $0x815736,%rax
  80a2f8:	00 00 00 
  80a2fb:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  80a2fd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80a301:	48 89 c7             	mov    %rax,%rdi
  80a304:	48 b8 18 bd 80 00 00 	movabs $0x80bd18,%rax
  80a30b:	00 00 00 
  80a30e:	ff d0                	callq  *%rax
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp != NULL) {
  80a310:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80a315:	74 4f                	je     80a366 <dhcp_inform+0x274>
    if (dhcp->pcb != NULL) {
  80a317:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a31b:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a31f:	48 85 c0             	test   %rax,%rax
  80a322:	74 17                	je     80a33b <dhcp_inform+0x249>
      udp_remove(dhcp->pcb);
  80a324:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a328:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a32c:	48 89 c7             	mov    %rax,%rdi
  80a32f:	48 b8 9c 58 81 00 00 	movabs $0x81589c,%rax
  80a336:	00 00 00 
  80a339:	ff d0                	callq  *%rax
    }
    dhcp->pcb = NULL;
  80a33b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a33f:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  80a346:	00 
    mem_free((void *)dhcp);
  80a347:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a34b:	48 89 c7             	mov    %rax,%rdi
  80a34e:	48 b8 fa c4 80 00 00 	movabs $0x80c4fa,%rax
  80a355:	00 00 00 
  80a358:	ff d0                	callq  *%rax
    netif->dhcp = old_dhcp;
  80a35a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80a35e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80a362:	48 89 50 38          	mov    %rdx,0x38(%rax)
  }
}
  80a366:	c9                   	leaveq 
  80a367:	c3                   	retq   

000000000080a368 <dhcp_arp_reply>:
 *
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void dhcp_arp_reply(struct netif *netif, struct ip_addr *addr)
{
  80a368:	55                   	push   %rbp
  80a369:	48 89 e5             	mov    %rsp,%rbp
  80a36c:	48 83 ec 10          	sub    $0x10,%rsp
  80a370:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80a374:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  80a378:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80a37d:	75 2a                	jne    80a3a9 <dhcp_arp_reply+0x41>
  80a37f:	48 ba 68 18 82 00 00 	movabs $0x821868,%rdx
  80a386:	00 00 00 
  80a389:	be b6 02 00 00       	mov    $0x2b6,%esi
  80a38e:	48 bf 76 18 82 00 00 	movabs $0x821876,%rdi
  80a395:	00 00 00 
  80a398:	b8 00 00 00 00       	mov    $0x0,%eax
  80a39d:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80a3a4:	00 00 00 
  80a3a7:	ff d1                	callq  *%rcx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
  80a3a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a3ad:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a3b1:	48 85 c0             	test   %rax,%rax
  80a3b4:	74 37                	je     80a3ed <dhcp_arp_reply+0x85>
  80a3b6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a3ba:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a3be:	0f b6 00             	movzbl (%rax),%eax
  80a3c1:	3c 08                	cmp    $0x8,%al
  80a3c3:	75 28                	jne    80a3ed <dhcp_arp_reply+0x85>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n", addr->addr));
    /* did a host respond with the address we
       were offered by the DHCP server? */
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
  80a3c5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80a3c9:	8b 10                	mov    (%rax),%edx
  80a3cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a3cf:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a3d3:	8b 40 4c             	mov    0x4c(%rax),%eax
  80a3d6:	39 c2                	cmp    %eax,%edx
  80a3d8:	75 13                	jne    80a3ed <dhcp_arp_reply+0x85>
      /* we will not accept the offered address */
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 1, ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
  80a3da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a3de:	48 89 c7             	mov    %rax,%rdi
  80a3e1:	48 b8 ef a3 80 00 00 	movabs $0x80a3ef,%rax
  80a3e8:	00 00 00 
  80a3eb:	ff d0                	callq  *%rax
    }
  }
}
  80a3ed:	c9                   	leaveq 
  80a3ee:	c3                   	retq   

000000000080a3ef <dhcp_decline>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_decline(struct netif *netif)
{
  80a3ef:	55                   	push   %rbp
  80a3f0:	48 89 e5             	mov    %rsp,%rbp
  80a3f3:	48 83 ec 20          	sub    $0x20,%rsp
  80a3f7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80a3fb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a3ff:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a403:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result = ERR_OK;
  80a407:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  80a40b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a40f:	be 0c 00 00 00       	mov    $0xc,%esi
  80a414:	48 89 c7             	mov    %rax,%rdi
  80a417:	48 b8 cf b1 80 00 00 	movabs $0x80b1cf,%rax
  80a41e:	00 00 00 
  80a421:	ff d0                	callq  *%rax
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80a423:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a427:	48 89 c7             	mov    %rax,%rdi
  80a42a:	48 b8 c3 b9 80 00 00 	movabs $0x80b9c3,%rax
  80a431:	00 00 00 
  80a434:	ff d0                	callq  *%rax
  80a436:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80a439:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80a43d:	0f 85 5c 01 00 00    	jne    80a59f <dhcp_decline+0x1b0>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80a443:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a447:	ba 01 00 00 00       	mov    $0x1,%edx
  80a44c:	be 35 00 00 00       	mov    $0x35,%esi
  80a451:	48 89 c7             	mov    %rax,%rdi
  80a454:	48 b8 00 b2 80 00 00 	movabs $0x80b200,%rax
  80a45b:	00 00 00 
  80a45e:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_DECLINE);
  80a460:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a464:	be 04 00 00 00       	mov    $0x4,%esi
  80a469:	48 89 c7             	mov    %rax,%rdi
  80a46c:	48 b8 b1 b2 80 00 00 	movabs $0x80b2b1,%rax
  80a473:	00 00 00 
  80a476:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80a478:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a47c:	ba 02 00 00 00       	mov    $0x2,%edx
  80a481:	be 39 00 00 00       	mov    $0x39,%esi
  80a486:	48 89 c7             	mov    %rax,%rdi
  80a489:	48 b8 00 b2 80 00 00 	movabs $0x80b200,%rax
  80a490:	00 00 00 
  80a493:	ff d0                	callq  *%rax
    dhcp_option_short(dhcp, 576);
  80a495:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a499:	be 40 02 00 00       	mov    $0x240,%esi
  80a49e:	48 89 c7             	mov    %rax,%rdi
  80a4a1:	48 b8 27 b3 80 00 00 	movabs $0x80b327,%rax
  80a4a8:	00 00 00 
  80a4ab:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  80a4ad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a4b1:	ba 04 00 00 00       	mov    $0x4,%edx
  80a4b6:	be 32 00 00 00       	mov    $0x32,%esi
  80a4bb:	48 89 c7             	mov    %rax,%rdi
  80a4be:	48 b8 00 b2 80 00 00 	movabs $0x80b200,%rax
  80a4c5:	00 00 00 
  80a4c8:	ff d0                	callq  *%rax
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  80a4ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a4ce:	8b 40 4c             	mov    0x4c(%rax),%eax
  80a4d1:	89 c7                	mov    %eax,%edi
  80a4d3:	48 b8 8c 30 81 00 00 	movabs $0x81308c,%rax
  80a4da:	00 00 00 
  80a4dd:	ff d0                	callq  *%rax
  80a4df:	89 c2                	mov    %eax,%edx
  80a4e1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a4e5:	89 d6                	mov    %edx,%esi
  80a4e7:	48 89 c7             	mov    %rax,%rdi
  80a4ea:	48 b8 d2 b3 80 00 00 	movabs $0x80b3d2,%rax
  80a4f1:	00 00 00 
  80a4f4:	ff d0                	callq  *%rax

    dhcp_option_trailer(dhcp);
  80a4f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a4fa:	48 89 c7             	mov    %rax,%rdi
  80a4fd:	48 b8 3e be 80 00 00 	movabs $0x80be3e,%rax
  80a504:	00 00 00 
  80a507:	ff d0                	callq  *%rax
    /* resize pbuf to reflect true size of options */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80a509:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a50d:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80a511:	66 05 f0 00          	add    $0xf0,%ax
  80a515:	0f b7 d0             	movzwl %ax,%edx
  80a518:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a51c:	48 8b 40 30          	mov    0x30(%rax),%rax
  80a520:	89 d6                	mov    %edx,%esi
  80a522:	48 89 c7             	mov    %rax,%rdi
  80a525:	48 b8 36 d9 80 00 00 	movabs $0x80d936,%rax
  80a52c:	00 00 00 
  80a52f:	ff d0                	callq  *%rax

    /* @todo: should we really connect here? we are performing sendto() */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80a531:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a535:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a539:	ba 43 00 00 00       	mov    $0x43,%edx
  80a53e:	48 be 68 26 82 00 00 	movabs $0x822668,%rsi
  80a545:	00 00 00 
  80a548:	48 89 c7             	mov    %rax,%rdi
  80a54b:	48 b8 36 57 81 00 00 	movabs $0x815736,%rax
  80a552:	00 00 00 
  80a555:	ff d0                	callq  *%rax
    /* per section 4.4.4, broadcast DECLINE messages */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80a557:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a55b:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80a55f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a563:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a567:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80a56b:	49 89 d0             	mov    %rdx,%r8
  80a56e:	b9 43 00 00 00       	mov    $0x43,%ecx
  80a573:	48 ba 6c 26 82 00 00 	movabs $0x82266c,%rdx
  80a57a:	00 00 00 
  80a57d:	48 89 c7             	mov    %rax,%rdi
  80a580:	48 b8 39 53 81 00 00 	movabs $0x815339,%rax
  80a587:	00 00 00 
  80a58a:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  80a58c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a590:	48 89 c7             	mov    %rax,%rdi
  80a593:	48 b8 18 bd 80 00 00 	movabs $0x80bd18,%rax
  80a59a:	00 00 00 
  80a59d:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_decline: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80a59f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a5a3:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a5a7:	8d 50 01             	lea    0x1(%rax),%edx
  80a5aa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a5ae:	88 50 01             	mov    %dl,0x1(%rax)
  msecs = 10*1000;
  80a5b1:	66 c7 45 f4 10 27    	movw   $0x2710,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80a5b7:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80a5bb:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  80a5c1:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80a5c6:	89 c8                	mov    %ecx,%eax
  80a5c8:	f7 ea                	imul   %edx
  80a5ca:	c1 fa 05             	sar    $0x5,%edx
  80a5cd:	89 c8                	mov    %ecx,%eax
  80a5cf:	c1 f8 1f             	sar    $0x1f,%eax
  80a5d2:	29 c2                	sub    %eax,%edx
  80a5d4:	89 d0                	mov    %edx,%eax
  80a5d6:	89 c2                	mov    %eax,%edx
  80a5d8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a5dc:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  80a5e0:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  80a5e4:	c9                   	leaveq 
  80a5e5:	c3                   	retq   

000000000080a5e6 <dhcp_discover>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
  80a5e6:	55                   	push   %rbp
  80a5e7:	48 89 e5             	mov    %rsp,%rbp
  80a5ea:	48 83 ec 20          	sub    $0x20,%rsp
  80a5ee:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80a5f2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a5f6:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a5fa:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result = ERR_OK;
  80a5fe:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_discover()\n"));
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
  80a602:	48 b8 68 26 82 00 00 	movabs $0x822668,%rax
  80a609:	00 00 00 
  80a60c:	8b 10                	mov    (%rax),%edx
  80a60e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a612:	89 50 4c             	mov    %edx,0x4c(%rax)
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80a615:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a619:	48 89 c7             	mov    %rax,%rdi
  80a61c:	48 b8 c3 b9 80 00 00 	movabs $0x80b9c3,%rax
  80a623:	00 00 00 
  80a626:	ff d0                	callq  *%rax
  80a628:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80a62b:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80a62f:	0f 85 a8 01 00 00    	jne    80a7dd <dhcp_discover+0x1f7>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80a635:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a639:	ba 01 00 00 00       	mov    $0x1,%edx
  80a63e:	be 35 00 00 00       	mov    $0x35,%esi
  80a643:	48 89 c7             	mov    %rax,%rdi
  80a646:	48 b8 00 b2 80 00 00 	movabs $0x80b200,%rax
  80a64d:	00 00 00 
  80a650:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_DISCOVER);
  80a652:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a656:	be 01 00 00 00       	mov    $0x1,%esi
  80a65b:	48 89 c7             	mov    %rax,%rdi
  80a65e:	48 b8 b1 b2 80 00 00 	movabs $0x80b2b1,%rax
  80a665:	00 00 00 
  80a668:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80a66a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a66e:	ba 02 00 00 00       	mov    $0x2,%edx
  80a673:	be 39 00 00 00       	mov    $0x39,%esi
  80a678:	48 89 c7             	mov    %rax,%rdi
  80a67b:	48 b8 00 b2 80 00 00 	movabs $0x80b200,%rax
  80a682:	00 00 00 
  80a685:	ff d0                	callq  *%rax
    dhcp_option_short(dhcp, 576);
  80a687:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a68b:	be 40 02 00 00       	mov    $0x240,%esi
  80a690:	48 89 c7             	mov    %rax,%rdi
  80a693:	48 b8 27 b3 80 00 00 	movabs $0x80b327,%rax
  80a69a:	00 00 00 
  80a69d:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  80a69f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a6a3:	ba 04 00 00 00       	mov    $0x4,%edx
  80a6a8:	be 37 00 00 00       	mov    $0x37,%esi
  80a6ad:	48 89 c7             	mov    %rax,%rdi
  80a6b0:	48 b8 00 b2 80 00 00 	movabs $0x80b200,%rax
  80a6b7:	00 00 00 
  80a6ba:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  80a6bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a6c0:	be 01 00 00 00       	mov    $0x1,%esi
  80a6c5:	48 89 c7             	mov    %rax,%rdi
  80a6c8:	48 b8 b1 b2 80 00 00 	movabs $0x80b2b1,%rax
  80a6cf:	00 00 00 
  80a6d2:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  80a6d4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a6d8:	be 03 00 00 00       	mov    $0x3,%esi
  80a6dd:	48 89 c7             	mov    %rax,%rdi
  80a6e0:	48 b8 b1 b2 80 00 00 	movabs $0x80b2b1,%rax
  80a6e7:	00 00 00 
  80a6ea:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  80a6ec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a6f0:	be 1c 00 00 00       	mov    $0x1c,%esi
  80a6f5:	48 89 c7             	mov    %rax,%rdi
  80a6f8:	48 b8 b1 b2 80 00 00 	movabs $0x80b2b1,%rax
  80a6ff:	00 00 00 
  80a702:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  80a704:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a708:	be 06 00 00 00       	mov    $0x6,%esi
  80a70d:	48 89 c7             	mov    %rax,%rdi
  80a710:	48 b8 b1 b2 80 00 00 	movabs $0x80b2b1,%rax
  80a717:	00 00 00 
  80a71a:	ff d0                	callq  *%rax

    dhcp_option_trailer(dhcp);
  80a71c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a720:	48 89 c7             	mov    %rax,%rdi
  80a723:	48 b8 3e be 80 00 00 	movabs $0x80be3e,%rax
  80a72a:	00 00 00 
  80a72d:	ff d0                	callq  *%rax

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80a72f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a733:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80a737:	66 05 f0 00          	add    $0xf0,%ax
  80a73b:	0f b7 d0             	movzwl %ax,%edx
  80a73e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a742:	48 8b 40 30          	mov    0x30(%rax),%rax
  80a746:	89 d6                	mov    %edx,%esi
  80a748:	48 89 c7             	mov    %rax,%rdi
  80a74b:	48 b8 36 d9 80 00 00 	movabs $0x80d936,%rax
  80a752:	00 00 00 
  80a755:	ff d0                	callq  *%rax

    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80a757:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a75b:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a75f:	ba 43 00 00 00       	mov    $0x43,%edx
  80a764:	48 be 68 26 82 00 00 	movabs $0x822668,%rsi
  80a76b:	00 00 00 
  80a76e:	48 89 c7             	mov    %rax,%rdi
  80a771:	48 b8 36 57 81 00 00 	movabs $0x815736,%rax
  80a778:	00 00 00 
  80a77b:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, DHCP_SERVER_PORT)\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80a77d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a781:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80a785:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a789:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a78d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80a791:	49 89 d0             	mov    %rdx,%r8
  80a794:	b9 43 00 00 00       	mov    $0x43,%ecx
  80a799:	48 ba 6c 26 82 00 00 	movabs $0x82266c,%rdx
  80a7a0:	00 00 00 
  80a7a3:	48 89 c7             	mov    %rax,%rdi
  80a7a6:	48 b8 39 53 81 00 00 	movabs $0x815339,%rax
  80a7ad:	00 00 00 
  80a7b0:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
    dhcp_delete_request(netif);
  80a7b2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a7b6:	48 89 c7             	mov    %rax,%rdi
  80a7b9:	48 b8 18 bd 80 00 00 	movabs $0x80bd18,%rax
  80a7c0:	00 00 00 
  80a7c3:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
    dhcp_set_state(dhcp, DHCP_SELECTING);
  80a7c5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a7c9:	be 06 00 00 00       	mov    $0x6,%esi
  80a7ce:	48 89 c7             	mov    %rax,%rdi
  80a7d1:	48 b8 cf b1 80 00 00 	movabs $0x80b1cf,%rax
  80a7d8:	00 00 00 
  80a7db:	ff d0                	callq  *%rax
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80a7dd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a7e1:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a7e5:	8d 50 01             	lea    0x1(%rax),%edx
  80a7e8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a7ec:	88 50 01             	mov    %dl,0x1(%rax)
  if(dhcp->tries >= 9 && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = dhcp->tries < 4 ? (dhcp->tries + 1) * 1000 : 10 * 1000;
  80a7ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a7f3:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a7f7:	3c 03                	cmp    $0x3,%al
  80a7f9:	77 15                	ja     80a810 <dhcp_discover+0x22a>
  80a7fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a7ff:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a803:	0f b6 c0             	movzbl %al,%eax
  80a806:	83 c0 01             	add    $0x1,%eax
  80a809:	66 69 c0 e8 03       	imul   $0x3e8,%ax,%ax
  80a80e:	eb 05                	jmp    80a815 <dhcp_discover+0x22f>
  80a810:	b8 10 27 00 00       	mov    $0x2710,%eax
  80a815:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80a819:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80a81d:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  80a823:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80a828:	89 c8                	mov    %ecx,%eax
  80a82a:	f7 ea                	imul   %edx
  80a82c:	c1 fa 05             	sar    $0x5,%edx
  80a82f:	89 c8                	mov    %ecx,%eax
  80a831:	c1 f8 1f             	sar    $0x1f,%eax
  80a834:	29 c2                	sub    %eax,%edx
  80a836:	89 d0                	mov    %edx,%eax
  80a838:	89 c2                	mov    %eax,%edx
  80a83a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a83e:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  80a842:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  80a846:	c9                   	leaveq 
  80a847:	c3                   	retq   

000000000080a848 <dhcp_bind>:
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
  80a848:	55                   	push   %rbp
  80a849:	48 89 e5             	mov    %rsp,%rbp
  80a84c:	53                   	push   %rbx
  80a84d:	48 83 ec 48          	sub    $0x48,%rsp
  80a851:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  u32_t timeout;
  struct dhcp *dhcp;
  struct ip_addr sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  80a855:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  80a85a:	75 2a                	jne    80a886 <dhcp_bind+0x3e>
  80a85c:	48 ba 8b 18 82 00 00 	movabs $0x82188b,%rdx
  80a863:	00 00 00 
  80a866:	be 3e 03 00 00       	mov    $0x33e,%esi
  80a86b:	48 bf 76 18 82 00 00 	movabs $0x821876,%rdi
  80a872:	00 00 00 
  80a875:	b8 00 00 00 00       	mov    $0x0,%eax
  80a87a:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80a881:	00 00 00 
  80a884:	ff d1                	callq  *%rcx
  dhcp = netif->dhcp;
  80a886:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80a88a:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a88e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  80a892:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80a897:	75 2a                	jne    80a8c3 <dhcp_bind+0x7b>
  80a899:	48 ba a4 18 82 00 00 	movabs $0x8218a4,%rdx
  80a8a0:	00 00 00 
  80a8a3:	be 40 03 00 00       	mov    $0x340,%esi
  80a8a8:	48 bf 76 18 82 00 00 	movabs $0x821876,%rdi
  80a8af:	00 00 00 
  80a8b2:	b8 00 00 00 00       	mov    $0x0,%eax
  80a8b7:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80a8be:	00 00 00 
  80a8c1:	ff d1                	callq  *%rcx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* temporary DHCP lease? */
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
  80a8c3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a8c7:	8b 40 6c             	mov    0x6c(%rax),%eax
  80a8ca:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a8cd:	74 4d                	je     80a91c <dhcp_bind+0xd4>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  80a8cf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a8d3:	8b 40 6c             	mov    0x6c(%rax),%eax
  80a8d6:	83 c0 1e             	add    $0x1e,%eax
  80a8d9:	ba 89 88 88 88       	mov    $0x88888889,%edx
  80a8de:	f7 e2                	mul    %edx
  80a8e0:	89 d0                	mov    %edx,%eax
  80a8e2:	c1 e8 05             	shr    $0x5,%eax
  80a8e5:	89 45 ec             	mov    %eax,-0x14(%rbp)
    if(timeout > 0xffff) {
  80a8e8:	81 7d ec ff ff 00 00 	cmpl   $0xffff,-0x14(%rbp)
  80a8ef:	76 07                	jbe    80a8f8 <dhcp_bind+0xb0>
      timeout = 0xffff;
  80a8f1:	c7 45 ec ff ff 00 00 	movl   $0xffff,-0x14(%rbp)
    }
    dhcp->t1_timeout = (u16_t)timeout;
  80a8f8:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80a8fb:	89 c2                	mov    %eax,%edx
  80a8fd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a901:	66 89 50 44          	mov    %dx,0x44(%rax)
    if (dhcp->t1_timeout == 0) {
  80a905:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a909:	0f b7 40 44          	movzwl 0x44(%rax),%eax
  80a90d:	66 85 c0             	test   %ax,%ax
  80a910:	75 0a                	jne    80a91c <dhcp_bind+0xd4>
      dhcp->t1_timeout = 1;
  80a912:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a916:	66 c7 40 44 01 00    	movw   $0x1,0x44(%rax)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
  80a91c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a920:	8b 40 70             	mov    0x70(%rax),%eax
  80a923:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a926:	74 4d                	je     80a975 <dhcp_bind+0x12d>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  80a928:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a92c:	8b 40 70             	mov    0x70(%rax),%eax
  80a92f:	83 c0 1e             	add    $0x1e,%eax
  80a932:	ba 89 88 88 88       	mov    $0x88888889,%edx
  80a937:	f7 e2                	mul    %edx
  80a939:	89 d0                	mov    %edx,%eax
  80a93b:	c1 e8 05             	shr    $0x5,%eax
  80a93e:	89 45 ec             	mov    %eax,-0x14(%rbp)
    if(timeout > 0xffff) {
  80a941:	81 7d ec ff ff 00 00 	cmpl   $0xffff,-0x14(%rbp)
  80a948:	76 07                	jbe    80a951 <dhcp_bind+0x109>
      timeout = 0xffff;
  80a94a:	c7 45 ec ff ff 00 00 	movl   $0xffff,-0x14(%rbp)
    }
    dhcp->t2_timeout = (u16_t)timeout;
  80a951:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80a954:	89 c2                	mov    %eax,%edx
  80a956:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a95a:	66 89 50 46          	mov    %dx,0x46(%rax)
    if (dhcp->t2_timeout == 0) {
  80a95e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a962:	0f b7 40 46          	movzwl 0x46(%rax),%eax
  80a966:	66 85 c0             	test   %ax,%ax
  80a969:	75 0a                	jne    80a975 <dhcp_bind+0x12d>
      dhcp->t2_timeout = 1;
  80a96b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a96f:	66 c7 40 46 01 00    	movw   $0x1,0x46(%rax)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  80a975:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a979:	48 83 c0 50          	add    $0x50,%rax
  80a97d:	48 85 c0             	test   %rax,%rax
  80a980:	74 09                	je     80a98b <dhcp_bind+0x143>
  80a982:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a986:	8b 40 50             	mov    0x50(%rax),%eax
  80a989:	eb 05                	jmp    80a990 <dhcp_bind+0x148>
  80a98b:	b8 00 00 00 00       	mov    $0x0,%eax
  80a990:	89 45 d0             	mov    %eax,-0x30(%rbp)

  /* subnet mask not given? */
  /* TODO: this is not a valid check. what if the network mask is 0? */
  if (sn_mask.addr == 0) {
  80a993:	8b 45 d0             	mov    -0x30(%rbp),%eax
  80a996:	85 c0                	test   %eax,%eax
  80a998:	75 65                	jne    80a9ff <dhcp_bind+0x1b7>
    /* choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&sn_mask);
  80a99a:	8b 45 d0             	mov    -0x30(%rbp),%eax
  80a99d:	89 c7                	mov    %eax,%edi
  80a99f:	48 b8 8c 30 81 00 00 	movabs $0x81308c,%rax
  80a9a6:	00 00 00 
  80a9a9:	ff d0                	callq  *%rax
  80a9ab:	c1 e8 18             	shr    $0x18,%eax
  80a9ae:	88 45 df             	mov    %al,-0x21(%rbp)
    if (first_octet <= 127) {
  80a9b1:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  80a9b5:	84 c0                	test   %al,%al
  80a9b7:	78 16                	js     80a9cf <dhcp_bind+0x187>
      sn_mask.addr = htonl(0xff000000);
  80a9b9:	bf 00 00 00 ff       	mov    $0xff000000,%edi
  80a9be:	48 b8 54 30 81 00 00 	movabs $0x813054,%rax
  80a9c5:	00 00 00 
  80a9c8:	ff d0                	callq  *%rax
  80a9ca:	89 45 d0             	mov    %eax,-0x30(%rbp)
  80a9cd:	eb 30                	jmp    80a9ff <dhcp_bind+0x1b7>
    } else if (first_octet >= 192) {
  80a9cf:	80 7d df bf          	cmpb   $0xbf,-0x21(%rbp)
  80a9d3:	76 16                	jbe    80a9eb <dhcp_bind+0x1a3>
      sn_mask.addr = htonl(0xffffff00);
  80a9d5:	bf 00 ff ff ff       	mov    $0xffffff00,%edi
  80a9da:	48 b8 54 30 81 00 00 	movabs $0x813054,%rax
  80a9e1:	00 00 00 
  80a9e4:	ff d0                	callq  *%rax
  80a9e6:	89 45 d0             	mov    %eax,-0x30(%rbp)
  80a9e9:	eb 14                	jmp    80a9ff <dhcp_bind+0x1b7>
    } else {
      sn_mask.addr = htonl(0xffff0000);
  80a9eb:	bf 00 00 ff ff       	mov    $0xffff0000,%edi
  80a9f0:	48 b8 54 30 81 00 00 	movabs $0x813054,%rax
  80a9f7:	00 00 00 
  80a9fa:	ff d0                	callq  *%rax
  80a9fc:	89 45 d0             	mov    %eax,-0x30(%rbp)
    }
  }

  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  80a9ff:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80aa03:	48 83 c0 54          	add    $0x54,%rax
  80aa07:	48 85 c0             	test   %rax,%rax
  80aa0a:	74 09                	je     80aa15 <dhcp_bind+0x1cd>
  80aa0c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80aa10:	8b 40 54             	mov    0x54(%rax),%eax
  80aa13:	eb 05                	jmp    80aa1a <dhcp_bind+0x1d2>
  80aa15:	b8 00 00 00 00       	mov    $0x0,%eax
  80aa1a:	89 45 c0             	mov    %eax,-0x40(%rbp)
  /* gateway address not given? */
  if (gw_addr.addr == 0) {
  80aa1d:	8b 45 c0             	mov    -0x40(%rbp),%eax
  80aa20:	85 c0                	test   %eax,%eax
  80aa22:	75 28                	jne    80aa4c <dhcp_bind+0x204>
    /* copy network address */
    gw_addr.addr = (dhcp->offered_ip_addr.addr & sn_mask.addr);
  80aa24:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80aa28:	8b 50 4c             	mov    0x4c(%rax),%edx
  80aa2b:	8b 45 d0             	mov    -0x30(%rbp),%eax
  80aa2e:	21 d0                	and    %edx,%eax
  80aa30:	89 45 c0             	mov    %eax,-0x40(%rbp)
    /* use first host address on network as gateway */
    gw_addr.addr |= htonl(0x00000001);
  80aa33:	8b 5d c0             	mov    -0x40(%rbp),%ebx
  80aa36:	bf 01 00 00 00       	mov    $0x1,%edi
  80aa3b:	48 b8 54 30 81 00 00 	movabs $0x813054,%rax
  80aa42:	00 00 00 
  80aa45:	ff d0                	callq  *%rax
  80aa47:	09 d8                	or     %ebx,%eax
  80aa49:	89 45 c0             	mov    %eax,-0x40(%rbp)
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
  80aa4c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80aa50:	48 8d 50 4c          	lea    0x4c(%rax),%rdx
  80aa54:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80aa58:	48 89 d6             	mov    %rdx,%rsi
  80aa5b:	48 89 c7             	mov    %rax,%rdi
  80aa5e:	48 b8 24 d2 80 00 00 	movabs $0x80d224,%rax
  80aa65:	00 00 00 
  80aa68:	ff d0                	callq  *%rax
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): SN: 0x%08"X32_F"\n", sn_mask.addr));
  netif_set_netmask(netif, &sn_mask);
  80aa6a:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  80aa6e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80aa72:	48 89 d6             	mov    %rdx,%rsi
  80aa75:	48 89 c7             	mov    %rax,%rdi
  80aa78:	48 b8 57 d3 80 00 00 	movabs $0x80d357,%rax
  80aa7f:	00 00 00 
  80aa82:	ff d0                	callq  *%rax
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): GW: 0x%08"X32_F"\n", gw_addr.addr));
  netif_set_gw(netif, &gw_addr);
  80aa84:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
  80aa88:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80aa8c:	48 89 d6             	mov    %rdx,%rsi
  80aa8f:	48 89 c7             	mov    %rax,%rdi
  80aa92:	48 b8 2a d3 80 00 00 	movabs $0x80d32a,%rax
  80aa99:	00 00 00 
  80aa9c:	ff d0                	callq  *%rax
  /* bring the interface up */
  netif_set_up(netif);
  80aa9e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80aaa2:	48 89 c7             	mov    %rax,%rdi
  80aaa5:	48 b8 a3 d3 80 00 00 	movabs $0x80d3a3,%rax
  80aaac:	00 00 00 
  80aaaf:	ff d0                	callq  *%rax
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
  80aab1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80aab5:	be 0a 00 00 00       	mov    $0xa,%esi
  80aaba:	48 89 c7             	mov    %rax,%rdi
  80aabd:	48 b8 cf b1 80 00 00 	movabs $0x80b1cf,%rax
  80aac4:	00 00 00 
  80aac7:	ff d0                	callq  *%rax
}
  80aac9:	48 83 c4 48          	add    $0x48,%rsp
  80aacd:	5b                   	pop    %rbx
  80aace:	5d                   	pop    %rbp
  80aacf:	c3                   	retq   

000000000080aad0 <dhcp_renew>:
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
  80aad0:	55                   	push   %rbp
  80aad1:	48 89 e5             	mov    %rsp,%rbp
  80aad4:	48 83 ec 20          	sub    $0x20,%rsp
  80aad8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80aadc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80aae0:	48 8b 40 38          	mov    0x38(%rax),%rax
  80aae4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_renew()\n"));
  dhcp_set_state(dhcp, DHCP_RENEWING);
  80aae8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aaec:	be 05 00 00 00       	mov    $0x5,%esi
  80aaf1:	48 89 c7             	mov    %rax,%rdi
  80aaf4:	48 b8 cf b1 80 00 00 	movabs $0x80b1cf,%rax
  80aafb:	00 00 00 
  80aafe:	ff d0                	callq  *%rax

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80ab00:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ab04:	48 89 c7             	mov    %rax,%rdi
  80ab07:	48 b8 c3 b9 80 00 00 	movabs $0x80b9c3,%rax
  80ab0e:	00 00 00 
  80ab11:	ff d0                	callq  *%rax
  80ab13:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80ab16:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80ab1a:	0f 85 12 01 00 00    	jne    80ac32 <dhcp_renew+0x162>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80ab20:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab24:	ba 01 00 00 00       	mov    $0x1,%edx
  80ab29:	be 35 00 00 00       	mov    $0x35,%esi
  80ab2e:	48 89 c7             	mov    %rax,%rdi
  80ab31:	48 b8 00 b2 80 00 00 	movabs $0x80b200,%rax
  80ab38:	00 00 00 
  80ab3b:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  80ab3d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab41:	be 03 00 00 00       	mov    $0x3,%esi
  80ab46:	48 89 c7             	mov    %rax,%rdi
  80ab49:	48 b8 b1 b2 80 00 00 	movabs $0x80b2b1,%rax
  80ab50:	00 00 00 
  80ab53:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80ab55:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab59:	ba 02 00 00 00       	mov    $0x2,%edx
  80ab5e:	be 39 00 00 00       	mov    $0x39,%esi
  80ab63:	48 89 c7             	mov    %rax,%rdi
  80ab66:	48 b8 00 b2 80 00 00 	movabs $0x80b200,%rax
  80ab6d:	00 00 00 
  80ab70:	ff d0                	callq  *%rax
    /* TODO: use netif->mtu in some way */
    dhcp_option_short(dhcp, 576);
  80ab72:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab76:	be 40 02 00 00       	mov    $0x240,%esi
  80ab7b:	48 89 c7             	mov    %rax,%rdi
  80ab7e:	48 b8 27 b3 80 00 00 	movabs $0x80b327,%rax
  80ab85:	00 00 00 
  80ab88:	ff d0                	callq  *%rax
#if 0
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif
    /* append DHCP message trailer */
    dhcp_option_trailer(dhcp);
  80ab8a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab8e:	48 89 c7             	mov    %rax,%rdi
  80ab91:	48 b8 3e be 80 00 00 	movabs $0x80be3e,%rax
  80ab98:	00 00 00 
  80ab9b:	ff d0                	callq  *%rax

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80ab9d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aba1:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80aba5:	66 05 f0 00          	add    $0xf0,%ax
  80aba9:	0f b7 d0             	movzwl %ax,%edx
  80abac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80abb0:	48 8b 40 30          	mov    0x30(%rax),%rax
  80abb4:	89 d6                	mov    %edx,%esi
  80abb6:	48 89 c7             	mov    %rax,%rdi
  80abb9:	48 b8 36 d9 80 00 00 	movabs $0x80d936,%rax
  80abc0:	00 00 00 
  80abc3:	ff d0                	callq  *%rax

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  80abc5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80abc9:	48 8d 48 48          	lea    0x48(%rax),%rcx
  80abcd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80abd1:	48 8b 40 08          	mov    0x8(%rax),%rax
  80abd5:	ba 43 00 00 00       	mov    $0x43,%edx
  80abda:	48 89 ce             	mov    %rcx,%rsi
  80abdd:	48 89 c7             	mov    %rax,%rdi
  80abe0:	48 b8 36 57 81 00 00 	movabs $0x815736,%rax
  80abe7:	00 00 00 
  80abea:	ff d0                	callq  *%rax
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  80abec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80abf0:	48 8d 50 48          	lea    0x48(%rax),%rdx
  80abf4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80abf8:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80abfc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac00:	48 8b 40 08          	mov    0x8(%rax),%rax
  80ac04:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80ac08:	49 89 c8             	mov    %rcx,%r8
  80ac0b:	b9 43 00 00 00       	mov    $0x43,%ecx
  80ac10:	48 89 c7             	mov    %rax,%rdi
  80ac13:	48 b8 39 53 81 00 00 	movabs $0x815339,%rax
  80ac1a:	00 00 00 
  80ac1d:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  80ac1f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ac23:	48 89 c7             	mov    %rax,%rdi
  80ac26:	48 b8 18 bd 80 00 00 	movabs $0x80bd18,%rax
  80ac2d:	00 00 00 
  80ac30:	ff d0                	callq  *%rax

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80ac32:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac36:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80ac3a:	8d 50 01             	lea    0x1(%rax),%edx
  80ac3d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac41:	88 50 01             	mov    %dl,0x1(%rax)
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  80ac44:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac48:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80ac4c:	3c 09                	cmp    $0x9,%al
  80ac4e:	77 12                	ja     80ac62 <dhcp_renew+0x192>
  80ac50:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac54:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80ac58:	0f b6 c0             	movzbl %al,%eax
  80ac5b:	66 69 c0 d0 07       	imul   $0x7d0,%ax,%ax
  80ac60:	eb 05                	jmp    80ac67 <dhcp_renew+0x197>
  80ac62:	b8 20 4e 00 00       	mov    $0x4e20,%eax
  80ac67:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80ac6b:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80ac6f:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  80ac75:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80ac7a:	89 c8                	mov    %ecx,%eax
  80ac7c:	f7 ea                	imul   %edx
  80ac7e:	c1 fa 05             	sar    $0x5,%edx
  80ac81:	89 c8                	mov    %ecx,%eax
  80ac83:	c1 f8 1f             	sar    $0x1f,%eax
  80ac86:	29 c2                	sub    %eax,%edx
  80ac88:	89 d0                	mov    %edx,%eax
  80ac8a:	89 c2                	mov    %eax,%edx
  80ac8c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac90:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  80ac94:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  80ac98:	c9                   	leaveq 
  80ac99:	c3                   	retq   

000000000080ac9a <dhcp_rebind>:
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
  80ac9a:	55                   	push   %rbp
  80ac9b:	48 89 e5             	mov    %rsp,%rbp
  80ac9e:	48 83 ec 20          	sub    $0x20,%rsp
  80aca2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80aca6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80acaa:	48 8b 40 38          	mov    0x38(%rax),%rax
  80acae:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
  dhcp_set_state(dhcp, DHCP_REBINDING);
  80acb2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80acb6:	be 04 00 00 00       	mov    $0x4,%esi
  80acbb:	48 89 c7             	mov    %rax,%rdi
  80acbe:	48 b8 cf b1 80 00 00 	movabs $0x80b1cf,%rax
  80acc5:	00 00 00 
  80acc8:	ff d0                	callq  *%rax

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80acca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80acce:	48 89 c7             	mov    %rax,%rdi
  80acd1:	48 b8 c3 b9 80 00 00 	movabs $0x80b9c3,%rax
  80acd8:	00 00 00 
  80acdb:	ff d0                	callq  *%rax
  80acdd:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80ace0:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80ace4:	0f 85 13 01 00 00    	jne    80adfd <dhcp_rebind+0x163>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80acea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80acee:	ba 01 00 00 00       	mov    $0x1,%edx
  80acf3:	be 35 00 00 00       	mov    $0x35,%esi
  80acf8:	48 89 c7             	mov    %rax,%rdi
  80acfb:	48 b8 00 b2 80 00 00 	movabs $0x80b200,%rax
  80ad02:	00 00 00 
  80ad05:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  80ad07:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ad0b:	be 03 00 00 00       	mov    $0x3,%esi
  80ad10:	48 89 c7             	mov    %rax,%rdi
  80ad13:	48 b8 b1 b2 80 00 00 	movabs $0x80b2b1,%rax
  80ad1a:	00 00 00 
  80ad1d:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80ad1f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ad23:	ba 02 00 00 00       	mov    $0x2,%edx
  80ad28:	be 39 00 00 00       	mov    $0x39,%esi
  80ad2d:	48 89 c7             	mov    %rax,%rdi
  80ad30:	48 b8 00 b2 80 00 00 	movabs $0x80b200,%rax
  80ad37:	00 00 00 
  80ad3a:	ff d0                	callq  *%rax
    dhcp_option_short(dhcp, 576);
  80ad3c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ad40:	be 40 02 00 00       	mov    $0x240,%esi
  80ad45:	48 89 c7             	mov    %rax,%rdi
  80ad48:	48 b8 27 b3 80 00 00 	movabs $0x80b327,%rax
  80ad4f:	00 00 00 
  80ad52:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif

    dhcp_option_trailer(dhcp);
  80ad54:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ad58:	48 89 c7             	mov    %rax,%rdi
  80ad5b:	48 b8 3e be 80 00 00 	movabs $0x80be3e,%rax
  80ad62:	00 00 00 
  80ad65:	ff d0                	callq  *%rax

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80ad67:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ad6b:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80ad6f:	66 05 f0 00          	add    $0xf0,%ax
  80ad73:	0f b7 d0             	movzwl %ax,%edx
  80ad76:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ad7a:	48 8b 40 30          	mov    0x30(%rax),%rax
  80ad7e:	89 d6                	mov    %edx,%esi
  80ad80:	48 89 c7             	mov    %rax,%rdi
  80ad83:	48 b8 36 d9 80 00 00 	movabs $0x80d936,%rax
  80ad8a:	00 00 00 
  80ad8d:	ff d0                	callq  *%rax

    /* broadcast to server */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80ad8f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ad93:	48 8b 40 08          	mov    0x8(%rax),%rax
  80ad97:	ba 43 00 00 00       	mov    $0x43,%edx
  80ad9c:	48 be 68 26 82 00 00 	movabs $0x822668,%rsi
  80ada3:	00 00 00 
  80ada6:	48 89 c7             	mov    %rax,%rdi
  80ada9:	48 b8 36 57 81 00 00 	movabs $0x815736,%rax
  80adb0:	00 00 00 
  80adb3:	ff d0                	callq  *%rax
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80adb5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80adb9:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80adbd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80adc1:	48 8b 40 08          	mov    0x8(%rax),%rax
  80adc5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80adc9:	49 89 d0             	mov    %rdx,%r8
  80adcc:	b9 43 00 00 00       	mov    $0x43,%ecx
  80add1:	48 ba 6c 26 82 00 00 	movabs $0x82266c,%rdx
  80add8:	00 00 00 
  80addb:	48 89 c7             	mov    %rax,%rdi
  80adde:	48 b8 39 53 81 00 00 	movabs $0x815339,%rax
  80ade5:	00 00 00 
  80ade8:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  80adea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80adee:	48 89 c7             	mov    %rax,%rdi
  80adf1:	48 b8 18 bd 80 00 00 	movabs $0x80bd18,%rax
  80adf8:	00 00 00 
  80adfb:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80adfd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae01:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80ae05:	8d 50 01             	lea    0x1(%rax),%edx
  80ae08:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae0c:	88 50 01             	mov    %dl,0x1(%rax)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  80ae0f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae13:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80ae17:	3c 09                	cmp    $0x9,%al
  80ae19:	77 12                	ja     80ae2d <dhcp_rebind+0x193>
  80ae1b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae1f:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80ae23:	0f b6 c0             	movzbl %al,%eax
  80ae26:	66 69 c0 e8 03       	imul   $0x3e8,%ax,%ax
  80ae2b:	eb 05                	jmp    80ae32 <dhcp_rebind+0x198>
  80ae2d:	b8 10 27 00 00       	mov    $0x2710,%eax
  80ae32:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80ae36:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80ae3a:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  80ae40:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80ae45:	89 c8                	mov    %ecx,%eax
  80ae47:	f7 ea                	imul   %edx
  80ae49:	c1 fa 05             	sar    $0x5,%edx
  80ae4c:	89 c8                	mov    %ecx,%eax
  80ae4e:	c1 f8 1f             	sar    $0x1f,%eax
  80ae51:	29 c2                	sub    %eax,%edx
  80ae53:	89 d0                	mov    %edx,%eax
  80ae55:	89 c2                	mov    %eax,%edx
  80ae57:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae5b:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  80ae5f:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  80ae63:	c9                   	leaveq 
  80ae64:	c3                   	retq   

000000000080ae65 <dhcp_release>:
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
  80ae65:	55                   	push   %rbp
  80ae66:	48 89 e5             	mov    %rsp,%rbp
  80ae69:	48 83 ec 20          	sub    $0x20,%rsp
  80ae6d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80ae71:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ae75:	48 8b 40 38          	mov    0x38(%rax),%rax
  80ae79:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_release()\n"));

  /* idle DHCP client */
  dhcp_set_state(dhcp, DHCP_OFF);
  80ae7d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae81:	be 0d 00 00 00       	mov    $0xd,%esi
  80ae86:	48 89 c7             	mov    %rax,%rdi
  80ae89:	48 b8 cf b1 80 00 00 	movabs $0x80b1cf,%rax
  80ae90:	00 00 00 
  80ae93:	ff d0                	callq  *%rax
  /* clean old DHCP offer */
  dhcp->server_ip_addr.addr = 0;
  80ae95:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae99:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%rax)
  dhcp->offered_ip_addr.addr = dhcp->offered_sn_mask.addr = 0;
  80aea0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aea4:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%rax)
  80aeab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aeaf:	8b 50 50             	mov    0x50(%rax),%edx
  80aeb2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aeb6:	89 50 4c             	mov    %edx,0x4c(%rax)
  dhcp->offered_gw_addr.addr = dhcp->offered_bc_addr.addr = 0;
  80aeb9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aebd:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%rax)
  80aec4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aec8:	8b 50 58             	mov    0x58(%rax),%edx
  80aecb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aecf:	89 50 54             	mov    %edx,0x54(%rax)
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
  80aed2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aed6:	c7 40 70 00 00 00 00 	movl   $0x0,0x70(%rax)
  80aedd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aee1:	8b 50 70             	mov    0x70(%rax),%edx
  80aee4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aee8:	89 50 6c             	mov    %edx,0x6c(%rax)
  80aeeb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aeef:	8b 50 6c             	mov    0x6c(%rax),%edx
  80aef2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aef6:	89 50 68             	mov    %edx,0x68(%rax)
  dhcp->dns_count = 0;
  80aef9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aefd:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%rax)
  
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80af04:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80af08:	48 89 c7             	mov    %rax,%rdi
  80af0b:	48 b8 c3 b9 80 00 00 	movabs $0x80b9c3,%rax
  80af12:	00 00 00 
  80af15:	ff d0                	callq  *%rax
  80af17:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80af1a:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80af1e:	0f 85 dd 00 00 00    	jne    80b001 <dhcp_release+0x19c>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80af24:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80af28:	ba 01 00 00 00       	mov    $0x1,%edx
  80af2d:	be 35 00 00 00       	mov    $0x35,%esi
  80af32:	48 89 c7             	mov    %rax,%rdi
  80af35:	48 b8 00 b2 80 00 00 	movabs $0x80b200,%rax
  80af3c:	00 00 00 
  80af3f:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_RELEASE);
  80af41:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80af45:	be 07 00 00 00       	mov    $0x7,%esi
  80af4a:	48 89 c7             	mov    %rax,%rdi
  80af4d:	48 b8 b1 b2 80 00 00 	movabs $0x80b2b1,%rax
  80af54:	00 00 00 
  80af57:	ff d0                	callq  *%rax

    dhcp_option_trailer(dhcp);
  80af59:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80af5d:	48 89 c7             	mov    %rax,%rdi
  80af60:	48 b8 3e be 80 00 00 	movabs $0x80be3e,%rax
  80af67:	00 00 00 
  80af6a:	ff d0                	callq  *%rax

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80af6c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80af70:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80af74:	66 05 f0 00          	add    $0xf0,%ax
  80af78:	0f b7 d0             	movzwl %ax,%edx
  80af7b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80af7f:	48 8b 40 30          	mov    0x30(%rax),%rax
  80af83:	89 d6                	mov    %edx,%esi
  80af85:	48 89 c7             	mov    %rax,%rdi
  80af88:	48 b8 36 d9 80 00 00 	movabs $0x80d936,%rax
  80af8f:	00 00 00 
  80af92:	ff d0                	callq  *%rax

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  80af94:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80af98:	48 8d 48 48          	lea    0x48(%rax),%rcx
  80af9c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80afa0:	48 8b 40 08          	mov    0x8(%rax),%rax
  80afa4:	ba 43 00 00 00       	mov    $0x43,%edx
  80afa9:	48 89 ce             	mov    %rcx,%rsi
  80afac:	48 89 c7             	mov    %rax,%rdi
  80afaf:	48 b8 36 57 81 00 00 	movabs $0x815736,%rax
  80afb6:	00 00 00 
  80afb9:	ff d0                	callq  *%rax
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  80afbb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80afbf:	48 8d 50 48          	lea    0x48(%rax),%rdx
  80afc3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80afc7:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80afcb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80afcf:	48 8b 40 08          	mov    0x8(%rax),%rax
  80afd3:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80afd7:	49 89 c8             	mov    %rcx,%r8
  80afda:	b9 43 00 00 00       	mov    $0x43,%ecx
  80afdf:	48 89 c7             	mov    %rax,%rdi
  80afe2:	48 b8 39 53 81 00 00 	movabs $0x815339,%rax
  80afe9:	00 00 00 
  80afec:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  80afee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80aff2:	48 89 c7             	mov    %rax,%rdi
  80aff5:	48 b8 18 bd 80 00 00 	movabs $0x80bd18,%rax
  80affc:	00 00 00 
  80afff:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_release: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80b001:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b005:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80b009:	8d 50 01             	lea    0x1(%rax),%edx
  80b00c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b010:	88 50 01             	mov    %dl,0x1(%rax)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  80b013:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b017:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80b01b:	3c 09                	cmp    $0x9,%al
  80b01d:	77 12                	ja     80b031 <dhcp_release+0x1cc>
  80b01f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b023:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80b027:	0f b6 c0             	movzbl %al,%eax
  80b02a:	66 69 c0 e8 03       	imul   $0x3e8,%ax,%ax
  80b02f:	eb 05                	jmp    80b036 <dhcp_release+0x1d1>
  80b031:	b8 10 27 00 00       	mov    $0x2710,%eax
  80b036:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80b03a:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80b03e:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  80b044:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80b049:	89 c8                	mov    %ecx,%eax
  80b04b:	f7 ea                	imul   %edx
  80b04d:	c1 fa 05             	sar    $0x5,%edx
  80b050:	89 c8                	mov    %ecx,%eax
  80b052:	c1 f8 1f             	sar    $0x1f,%eax
  80b055:	29 c2                	sub    %eax,%edx
  80b057:	89 d0                	mov    %edx,%eax
  80b059:	89 c2                	mov    %eax,%edx
  80b05b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b05f:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release(): set request timeout %"U16_F" msecs\n", msecs));
  /* bring the interface down */
  netif_set_down(netif);
  80b063:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b067:	48 89 c7             	mov    %rax,%rdi
  80b06a:	48 b8 0c d4 80 00 00 	movabs $0x80d40c,%rax
  80b071:	00 00 00 
  80b074:	ff d0                	callq  *%rax
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  80b076:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b07a:	48 be 68 26 82 00 00 	movabs $0x822668,%rsi
  80b081:	00 00 00 
  80b084:	48 89 c7             	mov    %rax,%rdi
  80b087:	48 b8 24 d2 80 00 00 	movabs $0x80d224,%rax
  80b08e:	00 00 00 
  80b091:	ff d0                	callq  *%rax
  netif_set_gw(netif, IP_ADDR_ANY);
  80b093:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b097:	48 be 68 26 82 00 00 	movabs $0x822668,%rsi
  80b09e:	00 00 00 
  80b0a1:	48 89 c7             	mov    %rax,%rdi
  80b0a4:	48 b8 2a d3 80 00 00 	movabs $0x80d32a,%rax
  80b0ab:	00 00 00 
  80b0ae:	ff d0                	callq  *%rax
  netif_set_netmask(netif, IP_ADDR_ANY);
  80b0b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b0b4:	48 be 68 26 82 00 00 	movabs $0x822668,%rsi
  80b0bb:	00 00 00 
  80b0be:	48 89 c7             	mov    %rax,%rdi
  80b0c1:	48 b8 57 d3 80 00 00 	movabs $0x80d357,%rax
  80b0c8:	00 00 00 
  80b0cb:	ff d0                	callq  *%rax
  
  /* TODO: netif_down(netif); */
  return result;
  80b0cd:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  80b0d1:	c9                   	leaveq 
  80b0d2:	c3                   	retq   

000000000080b0d3 <dhcp_stop>:
 *
 * @param netif The network interface to stop DHCP on
 */
void
dhcp_stop(struct netif *netif)
{
  80b0d3:	55                   	push   %rbp
  80b0d4:	48 89 e5             	mov    %rsp,%rbp
  80b0d7:	48 83 ec 20          	sub    $0x20,%rsp
  80b0db:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80b0df:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b0e3:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b0e7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
  80b0eb:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80b0f0:	75 2a                	jne    80b11c <dhcp_stop+0x49>
  80b0f2:	48 ba bc 18 82 00 00 	movabs $0x8218bc,%rdx
  80b0f9:	00 00 00 
  80b0fc:	be 2d 04 00 00       	mov    $0x42d,%esi
  80b101:	48 bf 76 18 82 00 00 	movabs $0x821876,%rdi
  80b108:	00 00 00 
  80b10b:	b8 00 00 00 00       	mov    $0x0,%eax
  80b110:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80b117:	00 00 00 
  80b11a:	ff d1                	callq  *%rcx
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  80b11c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b120:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80b124:	83 e0 f7             	and    $0xfffffff7,%eax
  80b127:	89 c2                	mov    %eax,%edx
  80b129:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b12d:	88 50 4a             	mov    %dl,0x4a(%rax)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_stop()\n"));
  /* netif is DHCP configured? */
  if (dhcp != NULL) {
  80b130:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80b135:	0f 84 92 00 00 00    	je     80b1cd <dhcp_stop+0xfa>
    if (dhcp->pcb != NULL) {
  80b13b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b13f:	48 8b 40 08          	mov    0x8(%rax),%rax
  80b143:	48 85 c0             	test   %rax,%rax
  80b146:	74 23                	je     80b16b <dhcp_stop+0x98>
      udp_remove(dhcp->pcb);
  80b148:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b14c:	48 8b 40 08          	mov    0x8(%rax),%rax
  80b150:	48 89 c7             	mov    %rax,%rdi
  80b153:	48 b8 9c 58 81 00 00 	movabs $0x81589c,%rax
  80b15a:	00 00 00 
  80b15d:	ff d0                	callq  *%rax
      dhcp->pcb = NULL;
  80b15f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b163:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  80b16a:	00 
    }
    if (dhcp->p != NULL) {
  80b16b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b16f:	48 8b 40 10          	mov    0x10(%rax),%rax
  80b173:	48 85 c0             	test   %rax,%rax
  80b176:	74 23                	je     80b19b <dhcp_stop+0xc8>
      pbuf_free(dhcp->p);
  80b178:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b17c:	48 8b 40 10          	mov    0x10(%rax),%rax
  80b180:	48 89 c7             	mov    %rax,%rdi
  80b183:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  80b18a:	00 00 00 
  80b18d:	ff d0                	callq  *%rax
      dhcp->p = NULL;
  80b18f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b193:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80b19a:	00 
    }
    /* free unfolded reply */
    dhcp_free_reply(dhcp);
  80b19b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b19f:	48 89 c7             	mov    %rax,%rdi
  80b1a2:	48 b8 fb b6 80 00 00 	movabs $0x80b6fb,%rax
  80b1a9:	00 00 00 
  80b1ac:	ff d0                	callq  *%rax
    mem_free((void *)dhcp);
  80b1ae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b1b2:	48 89 c7             	mov    %rax,%rdi
  80b1b5:	48 b8 fa c4 80 00 00 	movabs $0x80c4fa,%rax
  80b1bc:	00 00 00 
  80b1bf:	ff d0                	callq  *%rax
    netif->dhcp = NULL;
  80b1c1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b1c5:	48 c7 40 38 00 00 00 	movq   $0x0,0x38(%rax)
  80b1cc:	00 
  }
}
  80b1cd:	c9                   	leaveq 
  80b1ce:	c3                   	retq   

000000000080b1cf <dhcp_set_state>:
 *
 * TODO: we might also want to reset the timeout here?
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  80b1cf:	55                   	push   %rbp
  80b1d0:	48 89 e5             	mov    %rsp,%rbp
  80b1d3:	48 83 ec 0c          	sub    $0xc,%rsp
  80b1d7:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80b1db:	89 f0                	mov    %esi,%eax
  80b1dd:	88 45 f4             	mov    %al,-0xc(%rbp)
  if (new_state != dhcp->state) {
  80b1e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b1e4:	0f b6 00             	movzbl (%rax),%eax
  80b1e7:	3a 45 f4             	cmp    -0xc(%rbp),%al
  80b1ea:	74 12                	je     80b1fe <dhcp_set_state+0x2f>
    dhcp->state = new_state;
  80b1ec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b1f0:	0f b6 55 f4          	movzbl -0xc(%rbp),%edx
  80b1f4:	88 10                	mov    %dl,(%rax)
    dhcp->tries = 0;
  80b1f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b1fa:	c6 40 01 00          	movb   $0x0,0x1(%rax)
  }
}
  80b1fe:	c9                   	leaveq 
  80b1ff:	c3                   	retq   

000000000080b200 <dhcp_option>:
 * DHCP message.
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  80b200:	55                   	push   %rbp
  80b201:	48 89 e5             	mov    %rsp,%rbp
  80b204:	48 83 ec 10          	sub    $0x10,%rsp
  80b208:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80b20c:	89 f1                	mov    %esi,%ecx
  80b20e:	89 d0                	mov    %edx,%eax
  80b210:	88 4d f4             	mov    %cl,-0xc(%rbp)
  80b213:	88 45 f0             	mov    %al,-0x10(%rbp)
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  80b216:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b21a:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b21e:	0f b7 d0             	movzwl %ax,%edx
  80b221:	0f b6 45 f0          	movzbl -0x10(%rbp),%eax
  80b225:	01 d0                	add    %edx,%eax
  80b227:	83 c0 02             	add    $0x2,%eax
  80b22a:	83 f8 44             	cmp    $0x44,%eax
  80b22d:	76 2a                	jbe    80b259 <dhcp_option+0x59>
  80b22f:	48 ba d8 18 82 00 00 	movabs $0x8218d8,%rdx
  80b236:	00 00 00 
  80b239:	be 5b 04 00 00       	mov    $0x45b,%esi
  80b23e:	48 bf 76 18 82 00 00 	movabs $0x821876,%rdi
  80b245:	00 00 00 
  80b248:	b8 00 00 00 00       	mov    $0x0,%eax
  80b24d:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80b254:	00 00 00 
  80b257:	ff d1                	callq  *%rcx
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
  80b259:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b25d:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b261:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b265:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b269:	8d 70 01             	lea    0x1(%rax),%esi
  80b26c:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b270:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b274:	0f b7 c0             	movzwl %ax,%eax
  80b277:	48 98                	cltq   
  80b279:	0f b6 4d f4          	movzbl -0xc(%rbp),%ecx
  80b27d:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
  80b284:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b288:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b28c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b290:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b294:	8d 70 01             	lea    0x1(%rax),%esi
  80b297:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b29b:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b29f:	0f b7 c0             	movzwl %ax,%eax
  80b2a2:	48 98                	cltq   
  80b2a4:	0f b6 4d f0          	movzbl -0x10(%rbp),%ecx
  80b2a8:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
}
  80b2af:	c9                   	leaveq 
  80b2b0:	c3                   	retq   

000000000080b2b1 <dhcp_option_byte>:
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
  80b2b1:	55                   	push   %rbp
  80b2b2:	48 89 e5             	mov    %rsp,%rbp
  80b2b5:	48 83 ec 10          	sub    $0x10,%rsp
  80b2b9:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80b2bd:	89 f0                	mov    %esi,%eax
  80b2bf:	88 45 f4             	mov    %al,-0xc(%rbp)
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  80b2c2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b2c6:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b2ca:	66 83 f8 43          	cmp    $0x43,%ax
  80b2ce:	76 2a                	jbe    80b2fa <dhcp_option_byte+0x49>
  80b2d0:	48 ba 20 19 82 00 00 	movabs $0x821920,%rdx
  80b2d7:	00 00 00 
  80b2da:	be 66 04 00 00       	mov    $0x466,%esi
  80b2df:	48 bf 76 18 82 00 00 	movabs $0x821876,%rdi
  80b2e6:	00 00 00 
  80b2e9:	b8 00 00 00 00       	mov    $0x0,%eax
  80b2ee:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80b2f5:	00 00 00 
  80b2f8:	ff d1                	callq  *%rcx
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
  80b2fa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b2fe:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b302:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b306:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b30a:	8d 70 01             	lea    0x1(%rax),%esi
  80b30d:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b311:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b315:	0f b7 c0             	movzwl %ax,%eax
  80b318:	48 98                	cltq   
  80b31a:	0f b6 4d f4          	movzbl -0xc(%rbp),%ecx
  80b31e:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
}
  80b325:	c9                   	leaveq 
  80b326:	c3                   	retq   

000000000080b327 <dhcp_option_short>:

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  80b327:	55                   	push   %rbp
  80b328:	48 89 e5             	mov    %rsp,%rbp
  80b32b:	48 83 ec 10          	sub    $0x10,%rsp
  80b32f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80b333:	89 f0                	mov    %esi,%eax
  80b335:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  80b339:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b33d:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b341:	0f b7 c0             	movzwl %ax,%eax
  80b344:	83 c0 02             	add    $0x2,%eax
  80b347:	83 f8 44             	cmp    $0x44,%eax
  80b34a:	76 2a                	jbe    80b376 <dhcp_option_short+0x4f>
  80b34c:	48 ba 60 19 82 00 00 	movabs $0x821960,%rdx
  80b353:	00 00 00 
  80b356:	be 6d 04 00 00       	mov    $0x46d,%esi
  80b35b:	48 bf 76 18 82 00 00 	movabs $0x821876,%rdi
  80b362:	00 00 00 
  80b365:	b8 00 00 00 00       	mov    $0x0,%eax
  80b36a:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80b371:	00 00 00 
  80b374:	ff d1                	callq  *%rcx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
  80b376:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b37a:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b37e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b382:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b386:	8d 70 01             	lea    0x1(%rax),%esi
  80b389:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b38d:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b391:	0f b7 c0             	movzwl %ax,%eax
  80b394:	0f b7 4d f4          	movzwl -0xc(%rbp),%ecx
  80b398:	66 c1 e9 08          	shr    $0x8,%cx
  80b39c:	48 98                	cltq   
  80b39e:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
  80b3a5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b3a9:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b3ad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b3b1:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b3b5:	8d 70 01             	lea    0x1(%rax),%esi
  80b3b8:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b3bc:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b3c0:	0f b7 c0             	movzwl %ax,%eax
  80b3c3:	0f b7 4d f4          	movzwl -0xc(%rbp),%ecx
  80b3c7:	48 98                	cltq   
  80b3c9:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
}
  80b3d0:	c9                   	leaveq 
  80b3d1:	c3                   	retq   

000000000080b3d2 <dhcp_option_long>:

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
  80b3d2:	55                   	push   %rbp
  80b3d3:	48 89 e5             	mov    %rsp,%rbp
  80b3d6:	48 83 ec 10          	sub    $0x10,%rsp
  80b3da:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80b3de:	89 75 f4             	mov    %esi,-0xc(%rbp)
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  80b3e1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b3e5:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b3e9:	0f b7 c0             	movzwl %ax,%eax
  80b3ec:	83 c0 04             	add    $0x4,%eax
  80b3ef:	83 f8 44             	cmp    $0x44,%eax
  80b3f2:	76 2a                	jbe    80b41e <dhcp_option_long+0x4c>
  80b3f4:	48 ba a8 19 82 00 00 	movabs $0x8219a8,%rdx
  80b3fb:	00 00 00 
  80b3fe:	be 75 04 00 00       	mov    $0x475,%esi
  80b403:	48 bf 76 18 82 00 00 	movabs $0x821876,%rdi
  80b40a:	00 00 00 
  80b40d:	b8 00 00 00 00       	mov    $0x0,%eax
  80b412:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80b419:	00 00 00 
  80b41c:	ff d1                	callq  *%rcx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  80b41e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b422:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b426:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b42a:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b42e:	8d 70 01             	lea    0x1(%rax),%esi
  80b431:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b435:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b439:	0f b7 c0             	movzwl %ax,%eax
  80b43c:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  80b43f:	c1 e9 18             	shr    $0x18,%ecx
  80b442:	48 98                	cltq   
  80b444:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  80b44b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b44f:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b453:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b457:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b45b:	8d 70 01             	lea    0x1(%rax),%esi
  80b45e:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b462:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b466:	0f b7 c0             	movzwl %ax,%eax
  80b469:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  80b46c:	81 e1 00 00 ff 00    	and    $0xff0000,%ecx
  80b472:	48 c1 e9 10          	shr    $0x10,%rcx
  80b476:	48 98                	cltq   
  80b478:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  80b47f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b483:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b487:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b48b:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b48f:	8d 70 01             	lea    0x1(%rax),%esi
  80b492:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b496:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b49a:	0f b7 c0             	movzwl %ax,%eax
  80b49d:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  80b4a0:	81 e1 00 ff 00 00    	and    $0xff00,%ecx
  80b4a6:	48 c1 e9 08          	shr    $0x8,%rcx
  80b4aa:	48 98                	cltq   
  80b4ac:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
  80b4b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b4b7:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b4bb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b4bf:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b4c3:	8d 70 01             	lea    0x1(%rax),%esi
  80b4c6:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b4ca:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b4ce:	0f b7 c0             	movzwl %ax,%eax
  80b4d1:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  80b4d4:	48 98                	cltq   
  80b4d6:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
}
  80b4dd:	c9                   	leaveq 
  80b4de:	c3                   	retq   

000000000080b4df <dhcp_unfold_reply>:
 * use that further on.
 *
 */
static err_t
dhcp_unfold_reply(struct dhcp *dhcp)
{
  80b4df:	55                   	push   %rbp
  80b4e0:	48 89 e5             	mov    %rsp,%rbp
  80b4e3:	48 83 ec 20          	sub    $0x20,%rsp
  80b4e7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  u16_t ret;
  LWIP_ERROR("dhcp != NULL", (dhcp != NULL), return ERR_ARG;);
  80b4eb:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80b4f0:	75 2a                	jne    80b51c <dhcp_unfold_reply+0x3d>
  80b4f2:	48 ba e8 19 82 00 00 	movabs $0x8219e8,%rdx
  80b4f9:	00 00 00 
  80b4fc:	be 8a 04 00 00       	mov    $0x48a,%esi
  80b501:	48 bf 76 18 82 00 00 	movabs $0x821876,%rdi
  80b508:	00 00 00 
  80b50b:	b8 00 00 00 00       	mov    $0x0,%eax
  80b510:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80b517:	00 00 00 
  80b51a:	ff d1                	callq  *%rcx
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  80b51c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b520:	48 8b 40 10          	mov    0x10(%rax),%rax
  80b524:	48 85 c0             	test   %rax,%rax
  80b527:	75 2a                	jne    80b553 <dhcp_unfold_reply+0x74>
  80b529:	48 ba f5 19 82 00 00 	movabs $0x8219f5,%rdx
  80b530:	00 00 00 
  80b533:	be 8b 04 00 00       	mov    $0x48b,%esi
  80b538:	48 bf 76 18 82 00 00 	movabs $0x821876,%rdi
  80b53f:	00 00 00 
  80b542:	b8 00 00 00 00       	mov    $0x0,%eax
  80b547:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80b54e:	00 00 00 
  80b551:	ff d1                	callq  *%rcx
  /* free any left-overs from previous unfolds */
  dhcp_free_reply(dhcp);
  80b553:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b557:	48 89 c7             	mov    %rax,%rdi
  80b55a:	48 b8 fb b6 80 00 00 	movabs $0x80b6fb,%rax
  80b561:	00 00 00 
  80b564:	ff d0                	callq  *%rax
  /* options present? */
  if (dhcp->p->tot_len > (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN)) {
  80b566:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b56a:	48 8b 40 10          	mov    0x10(%rax),%rax
  80b56e:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80b572:	66 3d f0 00          	cmp    $0xf0,%ax
  80b576:	76 52                	jbe    80b5ca <dhcp_unfold_reply+0xeb>
    dhcp->options_in_len = dhcp->p->tot_len - (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80b578:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b57c:	48 8b 40 10          	mov    0x10(%rax),%rax
  80b580:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80b584:	8d 90 10 ff ff ff    	lea    -0xf0(%rax),%edx
  80b58a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b58e:	66 89 50 28          	mov    %dx,0x28(%rax)
    dhcp->options_in = mem_malloc(dhcp->options_in_len);
  80b592:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b596:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80b59a:	0f b7 c0             	movzwl %ax,%eax
  80b59d:	89 c7                	mov    %eax,%edi
  80b59f:	48 b8 96 c9 80 00 00 	movabs $0x80c996,%rax
  80b5a6:	00 00 00 
  80b5a9:	ff d0                	callq  *%rax
  80b5ab:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80b5af:	48 89 42 20          	mov    %rax,0x20(%rdx)
    if (dhcp->options_in == NULL) {
  80b5b3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b5b7:	48 8b 40 20          	mov    0x20(%rax),%rax
  80b5bb:	48 85 c0             	test   %rax,%rax
  80b5be:	75 0a                	jne    80b5ca <dhcp_unfold_reply+0xeb>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->options\n"));
      return ERR_MEM;
  80b5c0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80b5c5:	e9 2f 01 00 00       	jmpq   80b6f9 <dhcp_unfold_reply+0x21a>
    }
  }
  dhcp->msg_in = mem_malloc(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80b5ca:	bf f0 00 00 00       	mov    $0xf0,%edi
  80b5cf:	48 b8 96 c9 80 00 00 	movabs $0x80c996,%rax
  80b5d6:	00 00 00 
  80b5d9:	ff d0                	callq  *%rax
  80b5db:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80b5df:	48 89 42 18          	mov    %rax,0x18(%rdx)
  if (dhcp->msg_in == NULL) {
  80b5e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b5e7:	48 8b 40 18          	mov    0x18(%rax),%rax
  80b5eb:	48 85 c0             	test   %rax,%rax
  80b5ee:	75 2d                	jne    80b61d <dhcp_unfold_reply+0x13e>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->msg_in\n"));
    mem_free((void *)dhcp->options_in);
  80b5f0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b5f4:	48 8b 40 20          	mov    0x20(%rax),%rax
  80b5f8:	48 89 c7             	mov    %rax,%rdi
  80b5fb:	48 b8 fa c4 80 00 00 	movabs $0x80c4fa,%rax
  80b602:	00 00 00 
  80b605:	ff d0                	callq  *%rax
    dhcp->options_in = NULL;
  80b607:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b60b:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  80b612:	00 
    return ERR_MEM;
  80b613:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80b618:	e9 dc 00 00 00       	jmpq   80b6f9 <dhcp_unfold_reply+0x21a>
  }

  /** copy the DHCP message without options */
  ret = pbuf_copy_partial(dhcp->p, dhcp->msg_in, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN, 0);
  80b61d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b621:	48 8b 70 18          	mov    0x18(%rax),%rsi
  80b625:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b629:	48 8b 40 10          	mov    0x10(%rax),%rax
  80b62d:	b9 00 00 00 00       	mov    $0x0,%ecx
  80b632:	ba f0 00 00 00       	mov    $0xf0,%edx
  80b637:	48 89 c7             	mov    %rax,%rdi
  80b63a:	48 b8 4e e4 80 00 00 	movabs $0x80e44e,%rax
  80b641:	00 00 00 
  80b644:	ff d0                	callq  *%rax
  80b646:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80b64a:	66 81 7d fe f0 00    	cmpw   $0xf0,-0x2(%rbp)
  80b650:	74 2a                	je     80b67c <dhcp_unfold_reply+0x19d>
  80b652:	48 ba 08 1a 82 00 00 	movabs $0x821a08,%rdx
  80b659:	00 00 00 
  80b65c:	be a1 04 00 00       	mov    $0x4a1,%esi
  80b661:	48 bf 76 18 82 00 00 	movabs $0x821876,%rdi
  80b668:	00 00 00 
  80b66b:	b8 00 00 00 00       	mov    $0x0,%eax
  80b670:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80b677:	00 00 00 
  80b67a:	ff d1                	callq  *%rcx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_unfold_reply(): copied %"U16_F" bytes into dhcp->msg_in[]\n",
     sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN));

  if (dhcp->options_in != NULL) {
  80b67c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b680:	48 8b 40 20          	mov    0x20(%rax),%rax
  80b684:	48 85 c0             	test   %rax,%rax
  80b687:	74 6b                	je     80b6f4 <dhcp_unfold_reply+0x215>
    /** copy the DHCP options */
    ret = pbuf_copy_partial(dhcp->p, dhcp->options_in, dhcp->options_in_len, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80b689:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b68d:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80b691:	0f b7 d0             	movzwl %ax,%edx
  80b694:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b698:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80b69c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b6a0:	48 8b 40 10          	mov    0x10(%rax),%rax
  80b6a4:	b9 f0 00 00 00       	mov    $0xf0,%ecx
  80b6a9:	48 89 c7             	mov    %rax,%rdi
  80b6ac:	48 b8 4e e4 80 00 00 	movabs $0x80e44e,%rax
  80b6b3:	00 00 00 
  80b6b6:	ff d0                	callq  *%rax
  80b6b8:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  80b6bc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b6c0:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80b6c4:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  80b6c8:	74 2a                	je     80b6f4 <dhcp_unfold_reply+0x215>
  80b6ca:	48 ba 3a 1a 82 00 00 	movabs $0x821a3a,%rdx
  80b6d1:	00 00 00 
  80b6d4:	be a8 04 00 00       	mov    $0x4a8,%esi
  80b6d9:	48 bf 76 18 82 00 00 	movabs $0x821876,%rdi
  80b6e0:	00 00 00 
  80b6e3:	b8 00 00 00 00       	mov    $0x0,%eax
  80b6e8:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80b6ef:	00 00 00 
  80b6f2:	ff d1                	callq  *%rcx
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_unfold_reply(): copied %"U16_F" bytes to dhcp->options_in[]\n",
      dhcp->options_in_len));
  }
  LWIP_UNUSED_ARG(ret);
  return ERR_OK;
  80b6f4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80b6f9:	c9                   	leaveq 
  80b6fa:	c3                   	retq   

000000000080b6fb <dhcp_free_reply>:
 * Free the incoming DHCP message including contiguous copy of
 * its DHCP options.
 *
 */
static void dhcp_free_reply(struct dhcp *dhcp)
{
  80b6fb:	55                   	push   %rbp
  80b6fc:	48 89 e5             	mov    %rsp,%rbp
  80b6ff:	48 83 ec 10          	sub    $0x10,%rsp
  80b703:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (dhcp->msg_in != NULL) {
  80b707:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b70b:	48 8b 40 18          	mov    0x18(%rax),%rax
  80b70f:	48 85 c0             	test   %rax,%rax
  80b712:	74 23                	je     80b737 <dhcp_free_reply+0x3c>
    mem_free((void *)dhcp->msg_in);
  80b714:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b718:	48 8b 40 18          	mov    0x18(%rax),%rax
  80b71c:	48 89 c7             	mov    %rax,%rdi
  80b71f:	48 b8 fa c4 80 00 00 	movabs $0x80c4fa,%rax
  80b726:	00 00 00 
  80b729:	ff d0                	callq  *%rax
    dhcp->msg_in = NULL;
  80b72b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b72f:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  80b736:	00 
  }
  if (dhcp->options_in) {
  80b737:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b73b:	48 8b 40 20          	mov    0x20(%rax),%rax
  80b73f:	48 85 c0             	test   %rax,%rax
  80b742:	74 2d                	je     80b771 <dhcp_free_reply+0x76>
    mem_free((void *)dhcp->options_in);
  80b744:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b748:	48 8b 40 20          	mov    0x20(%rax),%rax
  80b74c:	48 89 c7             	mov    %rax,%rdi
  80b74f:	48 b8 fa c4 80 00 00 	movabs $0x80c4fa,%rax
  80b756:	00 00 00 
  80b759:	ff d0                	callq  *%rax
    dhcp->options_in = NULL;
  80b75b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b75f:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  80b766:	00 
    dhcp->options_in_len = 0;
  80b767:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b76b:	66 c7 40 28 00 00    	movw   $0x0,0x28(%rax)
  }
  LWIP_DEBUGF(DHCP_DEBUG, ("dhcp_free_reply(): free'd\n"));
}
  80b771:	c9                   	leaveq 
  80b772:	c3                   	retq   

000000000080b773 <dhcp_recv>:

/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
{
  80b773:	55                   	push   %rbp
  80b774:	48 89 e5             	mov    %rsp,%rbp
  80b777:	48 83 ec 60          	sub    $0x60,%rsp
  80b77b:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80b77f:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  80b783:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  80b787:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  80b78b:	44 89 c0             	mov    %r8d,%eax
  80b78e:	66 89 45 ac          	mov    %ax,-0x54(%rbp)
  struct netif *netif = (struct netif *)arg;
  80b792:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80b796:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80b79a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b79e:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b7a2:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
  80b7a6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80b7aa:	48 8b 40 08          	mov    0x8(%rax),%rax
  80b7ae:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("pbuf->tot_len = %"U16_F"\n", p->tot_len));
  /* prevent warnings about unused arguments */
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);
  dhcp->p = p;
  80b7b2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b7b6:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  80b7ba:	48 89 50 10          	mov    %rdx,0x10(%rax)
  /* TODO: check packet length before reading them */
  if (reply_msg->op != DHCP_BOOTREPLY) {
  80b7be:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b7c2:	0f b6 00             	movzbl (%rax),%eax
  80b7c5:	3c 02                	cmp    $0x2,%al
  80b7c7:	74 05                	je     80b7ce <dhcp_recv+0x5b>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  80b7c9:	e9 d4 01 00 00       	jmpq   80b9a2 <dhcp_recv+0x22f>
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  80b7ce:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  80b7d2:	eb 31                	jmp    80b805 <dhcp_recv+0x92>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
  80b7d4:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  80b7d8:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80b7dc:	48 98                	cltq   
  80b7de:	0f b6 4c 02 41       	movzbl 0x41(%rdx,%rax,1),%ecx
  80b7e3:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  80b7e7:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80b7eb:	48 98                	cltq   
  80b7ed:	0f b6 44 02 1c       	movzbl 0x1c(%rdx,%rax,1),%eax
  80b7f2:	38 c1                	cmp    %al,%cl
  80b7f4:	74 05                	je     80b7fb <dhcp_recv+0x88>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("netif->hwaddr[%"U16_F"]==%02"X16_F" != reply_msg->chaddr[%"U16_F"]==%02"X16_F"\n",
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
  80b7f6:	e9 a7 01 00 00       	jmpq   80b9a2 <dhcp_recv+0x22f>
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  80b7fb:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  80b7ff:	83 c0 01             	add    $0x1,%eax
  80b802:	88 45 ff             	mov    %al,-0x1(%rbp)
  80b805:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b809:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  80b80d:	3a 45 ff             	cmp    -0x1(%rbp),%al
  80b810:	77 c2                	ja     80b7d4 <dhcp_recv+0x61>
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    }
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
  80b812:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b816:	8b 40 04             	mov    0x4(%rax),%eax
  80b819:	89 c7                	mov    %eax,%edi
  80b81b:	48 b8 8c 30 81 00 00 	movabs $0x81308c,%rax
  80b822:	00 00 00 
  80b825:	ff d0                	callq  *%rax
  80b827:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80b82b:	8b 52 04             	mov    0x4(%rdx),%edx
  80b82e:	39 d0                	cmp    %edx,%eax
  80b830:	74 05                	je     80b837 <dhcp_recv+0xc4>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("transaction id mismatch reply_msg->xid(%"X32_F")!=dhcp->xid(%"X32_F")\n",ntohl(reply_msg->xid),dhcp->xid));
    goto free_pbuf_and_return;
  80b832:	e9 6b 01 00 00       	jmpq   80b9a2 <dhcp_recv+0x22f>
  }
  /* option fields could be unfold? */
  if (dhcp_unfold_reply(dhcp) != ERR_OK) {
  80b837:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b83b:	48 89 c7             	mov    %rax,%rdi
  80b83e:	48 b8 df b4 80 00 00 	movabs $0x80b4df,%rax
  80b845:	00 00 00 
  80b848:	ff d0                	callq  *%rax
  80b84a:	84 c0                	test   %al,%al
  80b84c:	74 05                	je     80b853 <dhcp_recv+0xe0>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("problem unfolding DHCP message - too short on memory?\n"));
    goto free_pbuf_and_return;
  80b84e:	e9 4f 01 00 00       	jmpq   80b9a2 <dhcp_recv+0x22f>
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  80b853:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b857:	be 35 00 00 00       	mov    $0x35,%esi
  80b85c:	48 89 c7             	mov    %rax,%rdi
  80b85f:	48 b8 96 bf 80 00 00 	movabs $0x80bf96,%rax
  80b866:	00 00 00 
  80b869:	ff d0                	callq  *%rax
  80b86b:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (options_ptr == NULL) {
  80b86f:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80b874:	75 05                	jne    80b87b <dhcp_recv+0x108>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
  80b876:	e9 27 01 00 00       	jmpq   80b9a2 <dhcp_recv+0x22f>
  }

  /* read DHCP message type */
  msg_type = dhcp_get_option_byte(options_ptr + 2);
  80b87b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80b87f:	48 83 c0 02          	add    $0x2,%rax
  80b883:	48 89 c7             	mov    %rax,%rdi
  80b886:	48 b8 58 c1 80 00 00 	movabs $0x80c158,%rax
  80b88d:	00 00 00 
  80b890:	ff d0                	callq  *%rax
  80b892:	88 45 d7             	mov    %al,-0x29(%rbp)
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
  80b895:	80 7d d7 05          	cmpb   $0x5,-0x29(%rbp)
  80b899:	0f 85 84 00 00 00    	jne    80b923 <dhcp_recv+0x1b0>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
  80b89f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b8a3:	0f b6 00             	movzbl (%rax),%eax
  80b8a6:	3c 01                	cmp    $0x1,%al
  80b8a8:	75 35                	jne    80b8df <dhcp_recv+0x16c>
      dhcp_handle_ack(netif);
  80b8aa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b8ae:	48 89 c7             	mov    %rax,%rdi
  80b8b1:	48 b8 25 9c 80 00 00 	movabs $0x809c25,%rax
  80b8b8:	00 00 00 
  80b8bb:	ff d0                	callq  *%rax
      dhcp->request_timeout = 0;
  80b8bd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b8c1:	66 c7 40 42 00 00    	movw   $0x0,0x42(%rax)
#if DHCP_DOES_ARP_CHECK
      /* check if the acknowledged lease address is already in use */
      dhcp_check(netif);
  80b8c7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b8cb:	48 89 c7             	mov    %rax,%rdi
  80b8ce:	48 b8 e7 94 80 00 00 	movabs $0x8094e7,%rax
  80b8d5:	00 00 00 
  80b8d8:	ff d0                	callq  *%rax
  80b8da:	e9 c3 00 00 00       	jmpq   80b9a2 <dhcp_recv+0x22f>
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address? */
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
  80b8df:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b8e3:	0f b6 00             	movzbl (%rax),%eax
  80b8e6:	3c 03                	cmp    $0x3,%al
  80b8e8:	74 1a                	je     80b904 <dhcp_recv+0x191>
  80b8ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b8ee:	0f b6 00             	movzbl (%rax),%eax
  80b8f1:	3c 04                	cmp    $0x4,%al
  80b8f3:	74 0f                	je     80b904 <dhcp_recv+0x191>
  80b8f5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b8f9:	0f b6 00             	movzbl (%rax),%eax
  80b8fc:	3c 05                	cmp    $0x5,%al
  80b8fe:	0f 85 9e 00 00 00    	jne    80b9a2 <dhcp_recv+0x22f>
      dhcp->request_timeout = 0;
  80b904:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b908:	66 c7 40 42 00 00    	movw   $0x0,0x42(%rax)
      dhcp_bind(netif);
  80b90e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b912:	48 89 c7             	mov    %rax,%rdi
  80b915:	48 b8 48 a8 80 00 00 	movabs $0x80a848,%rax
  80b91c:	00 00 00 
  80b91f:	ff d0                	callq  *%rax
  80b921:	eb 7f                	jmp    80b9a2 <dhcp_recv+0x22f>
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  80b923:	80 7d d7 06          	cmpb   $0x6,-0x29(%rbp)
  80b927:	75 4b                	jne    80b974 <dhcp_recv+0x201>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  80b929:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b92d:	0f b6 00             	movzbl (%rax),%eax
      dhcp->request_timeout = 0;
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  80b930:	3c 03                	cmp    $0x3,%al
  80b932:	74 21                	je     80b955 <dhcp_recv+0x1e2>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  80b934:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b938:	0f b6 00             	movzbl (%rax),%eax
  80b93b:	3c 01                	cmp    $0x1,%al
  80b93d:	74 16                	je     80b955 <dhcp_recv+0x1e2>
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
  80b93f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b943:	0f b6 00             	movzbl (%rax),%eax
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  80b946:	3c 04                	cmp    $0x4,%al
  80b948:	74 0b                	je     80b955 <dhcp_recv+0x1e2>
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
  80b94a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b94e:	0f b6 00             	movzbl (%rax),%eax
  80b951:	3c 05                	cmp    $0x5,%al
  80b953:	75 1f                	jne    80b974 <dhcp_recv+0x201>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
  80b955:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b959:	66 c7 40 42 00 00    	movw   $0x0,0x42(%rax)
    dhcp_handle_nak(netif);
  80b95f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b963:	48 89 c7             	mov    %rax,%rdi
  80b966:	48 b8 38 94 80 00 00 	movabs $0x809438,%rax
  80b96d:	00 00 00 
  80b970:	ff d0                	callq  *%rax
  80b972:	eb 2e                	jmp    80b9a2 <dhcp_recv+0x22f>
  }
  /* received a DHCP_OFFER in DHCP_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
  80b974:	80 7d d7 02          	cmpb   $0x2,-0x29(%rbp)
  80b978:	75 28                	jne    80b9a2 <dhcp_recv+0x22f>
  80b97a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b97e:	0f b6 00             	movzbl (%rax),%eax
  80b981:	3c 06                	cmp    $0x6,%al
  80b983:	75 1d                	jne    80b9a2 <dhcp_recv+0x22f>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OFFER received in DHCP_SELECTING state\n"));
    dhcp->request_timeout = 0;
  80b985:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b989:	66 c7 40 42 00 00    	movw   $0x0,0x42(%rax)
    /* remember offered lease */
    dhcp_handle_offer(netif);
  80b98f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b993:	48 89 c7             	mov    %rax,%rdi
  80b996:	48 b8 80 95 80 00 00 	movabs $0x809580,%rax
  80b99d:	00 00 00 
  80b9a0:	ff d0                	callq  *%rax
  }
free_pbuf_and_return:
  pbuf_free(p);
  80b9a2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80b9a6:	48 89 c7             	mov    %rax,%rdi
  80b9a9:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  80b9b0:	00 00 00 
  80b9b3:	ff d0                	callq  *%rax
  dhcp->p = NULL;
  80b9b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b9b9:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80b9c0:	00 
}
  80b9c1:	c9                   	leaveq 
  80b9c2:	c3                   	retq   

000000000080b9c3 <dhcp_create_request>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_create_request(struct netif *netif)
{
  80b9c3:	55                   	push   %rbp
  80b9c4:	48 89 e5             	mov    %rsp,%rbp
  80b9c7:	53                   	push   %rbx
  80b9c8:	48 83 ec 28          	sub    $0x28,%rsp
  80b9cc:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  struct dhcp *dhcp;
  u16_t i;
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  80b9d0:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80b9d5:	75 2a                	jne    80ba01 <dhcp_create_request+0x3e>
  80b9d7:	48 ba 58 1a 82 00 00 	movabs $0x821a58,%rdx
  80b9de:	00 00 00 
  80b9e1:	be 2e 05 00 00       	mov    $0x52e,%esi
  80b9e6:	48 bf 76 18 82 00 00 	movabs $0x821876,%rdi
  80b9ed:	00 00 00 
  80b9f0:	b8 00 00 00 00       	mov    $0x0,%eax
  80b9f5:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80b9fc:	00 00 00 
  80b9ff:	ff d1                	callq  *%rcx
  dhcp = netif->dhcp;
  80ba01:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80ba05:	48 8b 40 38          	mov    0x38(%rax),%rax
  80ba09:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  80ba0d:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80ba12:	75 2a                	jne    80ba3e <dhcp_create_request+0x7b>
  80ba14:	48 ba 80 1a 82 00 00 	movabs $0x821a80,%rdx
  80ba1b:	00 00 00 
  80ba1e:	be 30 05 00 00       	mov    $0x530,%esi
  80ba23:	48 bf 76 18 82 00 00 	movabs $0x821876,%rdi
  80ba2a:	00 00 00 
  80ba2d:	b8 00 00 00 00       	mov    $0x0,%eax
  80ba32:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80ba39:	00 00 00 
  80ba3c:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  80ba3e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80ba42:	48 8b 40 30          	mov    0x30(%rax),%rax
  80ba46:	48 85 c0             	test   %rax,%rax
  80ba49:	74 2a                	je     80ba75 <dhcp_create_request+0xb2>
  80ba4b:	48 ba a8 1a 82 00 00 	movabs $0x821aa8,%rdx
  80ba52:	00 00 00 
  80ba55:	be 31 05 00 00       	mov    $0x531,%esi
  80ba5a:	48 bf 76 18 82 00 00 	movabs $0x821876,%rdi
  80ba61:	00 00 00 
  80ba64:	b8 00 00 00 00       	mov    $0x0,%eax
  80ba69:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80ba70:	00 00 00 
  80ba73:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  80ba75:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80ba79:	48 8b 40 38          	mov    0x38(%rax),%rax
  80ba7d:	48 85 c0             	test   %rax,%rax
  80ba80:	74 2a                	je     80baac <dhcp_create_request+0xe9>
  80ba82:	48 ba d8 1a 82 00 00 	movabs $0x821ad8,%rdx
  80ba89:	00 00 00 
  80ba8c:	be 32 05 00 00       	mov    $0x532,%esi
  80ba91:	48 bf 76 18 82 00 00 	movabs $0x821876,%rdi
  80ba98:	00 00 00 
  80ba9b:	b8 00 00 00 00       	mov    $0x0,%eax
  80baa0:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80baa7:	00 00 00 
  80baaa:	ff d1                	callq  *%rcx
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  80baac:	ba 00 00 00 00       	mov    $0x0,%edx
  80bab1:	be 34 01 00 00       	mov    $0x134,%esi
  80bab6:	bf 00 00 00 00       	mov    $0x0,%edi
  80babb:	48 b8 61 d4 80 00 00 	movabs $0x80d461,%rax
  80bac2:	00 00 00 
  80bac5:	ff d0                	callq  *%rax
  80bac7:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80bacb:	48 89 42 30          	mov    %rax,0x30(%rdx)
  if (dhcp->p_out == NULL) {
  80bacf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bad3:	48 8b 40 30          	mov    0x30(%rax),%rax
  80bad7:	48 85 c0             	test   %rax,%rax
  80bada:	75 0a                	jne    80bae6 <dhcp_create_request+0x123>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_create_request(): could not allocate pbuf\n"));
    return ERR_MEM;
  80badc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80bae1:	e9 2b 02 00 00       	jmpq   80bd11 <dhcp_create_request+0x34e>
  }
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  80bae6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80baea:	48 8b 40 30          	mov    0x30(%rax),%rax
  80baee:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80baf2:	66 3d 33 01          	cmp    $0x133,%ax
  80baf6:	77 2a                	ja     80bb22 <dhcp_create_request+0x15f>
  80baf8:	48 ba 08 1b 82 00 00 	movabs $0x821b08,%rdx
  80baff:	00 00 00 
  80bb02:	be 39 05 00 00       	mov    $0x539,%esi
  80bb07:	48 bf 76 18 82 00 00 	movabs $0x821876,%rdi
  80bb0e:	00 00 00 
  80bb11:	b8 00 00 00 00       	mov    $0x0,%eax
  80bb16:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80bb1d:	00 00 00 
  80bb20:	ff d1                	callq  *%rcx
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* give unique transaction identifier to this request */
  dhcp->xid = xid++;
  80bb22:	48 b8 7c 81 82 00 00 	movabs $0x82817c,%rax
  80bb29:	00 00 00 
  80bb2c:	8b 00                	mov    (%rax),%eax
  80bb2e:	8d 48 01             	lea    0x1(%rax),%ecx
  80bb31:	48 ba 7c 81 82 00 00 	movabs $0x82817c,%rdx
  80bb38:	00 00 00 
  80bb3b:	89 0a                	mov    %ecx,(%rdx)
  80bb3d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80bb41:	89 42 04             	mov    %eax,0x4(%rdx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("transaction id xid++(%"X32_F") dhcp->xid(%"U32_F")\n",xid,dhcp->xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
  80bb44:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bb48:	48 8b 40 30          	mov    0x30(%rax),%rax
  80bb4c:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80bb50:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bb54:	48 89 50 38          	mov    %rdx,0x38(%rax)

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  80bb58:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bb5c:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bb60:	c6 00 01             	movb   $0x1,(%rax)
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  80bb63:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bb67:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bb6b:	c6 40 01 01          	movb   $0x1,0x1(%rax)
  /* TODO: make link layer independent */
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
  80bb6f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bb73:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bb77:	c6 40 02 06          	movb   $0x6,0x2(%rax)
  dhcp->msg_out->hops = 0;
  80bb7b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bb7f:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bb83:	c6 40 03 00          	movb   $0x0,0x3(%rax)
  dhcp->msg_out->xid = htonl(dhcp->xid);
  80bb87:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bb8b:	48 8b 58 38          	mov    0x38(%rax),%rbx
  80bb8f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bb93:	8b 40 04             	mov    0x4(%rax),%eax
  80bb96:	89 c7                	mov    %eax,%edi
  80bb98:	48 b8 54 30 81 00 00 	movabs $0x813054,%rax
  80bb9f:	00 00 00 
  80bba2:	ff d0                	callq  *%rax
  80bba4:	89 43 04             	mov    %eax,0x4(%rbx)
  dhcp->msg_out->secs = 0;
  80bba7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bbab:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bbaf:	66 c7 40 08 00 00    	movw   $0x0,0x8(%rax)
  dhcp->msg_out->flags = 0;
  80bbb5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bbb9:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bbbd:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  80bbc3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bbc7:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bbcb:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80bbcf:	8b 52 08             	mov    0x8(%rdx),%edx
  80bbd2:	89 50 0c             	mov    %edx,0xc(%rax)
  dhcp->msg_out->yiaddr.addr = 0;
  80bbd5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bbd9:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bbdd:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%rax)
  dhcp->msg_out->siaddr.addr = 0;
  80bbe4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bbe8:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bbec:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%rax)
  dhcp->msg_out->giaddr.addr = 0;
  80bbf3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bbf7:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bbfb:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  80bc02:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  80bc08:	eb 45                	jmp    80bc4f <dhcp_create_request+0x28c>
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  80bc0a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bc0e:	48 8b 48 38          	mov    0x38(%rax),%rcx
  80bc12:	0f b7 75 ee          	movzwl -0x12(%rbp),%esi
  80bc16:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bc1a:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  80bc1e:	0f b6 c0             	movzbl %al,%eax
  80bc21:	66 3b 45 ee          	cmp    -0x12(%rbp),%ax
  80bc25:	76 11                	jbe    80bc38 <dhcp_create_request+0x275>
  80bc27:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bc2b:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80bc2f:	48 98                	cltq   
  80bc31:	0f b6 44 02 41       	movzbl 0x41(%rdx,%rax,1),%eax
  80bc36:	eb 05                	jmp    80bc3d <dhcp_create_request+0x27a>
  80bc38:	b8 00 00 00 00       	mov    $0x0,%eax
  80bc3d:	48 63 d6             	movslq %esi,%rdx
  80bc40:	88 44 11 1c          	mov    %al,0x1c(%rcx,%rdx,1)
  dhcp->msg_out->flags = 0;
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  dhcp->msg_out->yiaddr.addr = 0;
  dhcp->msg_out->siaddr.addr = 0;
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  80bc44:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bc48:	83 c0 01             	add    $0x1,%eax
  80bc4b:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
  80bc4f:	66 83 7d ee 0f       	cmpw   $0xf,-0x12(%rbp)
  80bc54:	76 b4                	jbe    80bc0a <dhcp_create_request+0x247>
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  80bc56:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  80bc5c:	eb 1e                	jmp    80bc7c <dhcp_create_request+0x2b9>
    dhcp->msg_out->sname[i] = 0;
  80bc5e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bc62:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80bc66:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bc6a:	48 98                	cltq   
  80bc6c:	c6 44 02 2c 00       	movb   $0x0,0x2c(%rdx,%rax,1)
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  80bc71:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bc75:	83 c0 01             	add    $0x1,%eax
  80bc78:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
  80bc7c:	66 83 7d ee 3f       	cmpw   $0x3f,-0x12(%rbp)
  80bc81:	76 db                	jbe    80bc5e <dhcp_create_request+0x29b>
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  80bc83:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  80bc89:	eb 1e                	jmp    80bca9 <dhcp_create_request+0x2e6>
    dhcp->msg_out->file[i] = 0;
  80bc8b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bc8f:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80bc93:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bc97:	48 98                	cltq   
  80bc99:	c6 44 02 6c 00       	movb   $0x0,0x6c(%rdx,%rax,1)
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  80bc9e:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bca2:	83 c0 01             	add    $0x1,%eax
  80bca5:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
  80bca9:	66 83 7d ee 7f       	cmpw   $0x7f,-0x12(%rbp)
  80bcae:	76 db                	jbe    80bc8b <dhcp_create_request+0x2c8>
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  80bcb0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bcb4:	48 8b 58 38          	mov    0x38(%rax),%rbx
  80bcb8:	bf 63 53 82 63       	mov    $0x63825363,%edi
  80bcbd:	48 b8 54 30 81 00 00 	movabs $0x813054,%rax
  80bcc4:	00 00 00 
  80bcc7:	ff d0                	callq  *%rax
  80bcc9:	89 83 ec 00 00 00    	mov    %eax,0xec(%rbx)
  dhcp->options_out_len = 0;
  80bccf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bcd3:	66 c7 40 40 00 00    	movw   $0x0,0x40(%rax)
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  80bcd9:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  80bcdf:	eb 24                	jmp    80bd05 <dhcp_create_request+0x342>
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  80bce1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bce5:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80bce9:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bced:	0f b7 4d ee          	movzwl -0x12(%rbp),%ecx
  80bcf1:	48 98                	cltq   
  80bcf3:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  80bcfa:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bcfe:	83 c0 01             	add    $0x1,%eax
  80bd01:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
  80bd05:	66 83 7d ee 43       	cmpw   $0x43,-0x12(%rbp)
  80bd0a:	76 d5                	jbe    80bce1 <dhcp_create_request+0x31e>
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  return ERR_OK;
  80bd0c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80bd11:	48 83 c4 28          	add    $0x28,%rsp
  80bd15:	5b                   	pop    %rbx
  80bd16:	5d                   	pop    %rbp
  80bd17:	c3                   	retq   

000000000080bd18 <dhcp_delete_request>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_delete_request(struct netif *netif)
{
  80bd18:	55                   	push   %rbp
  80bd19:	48 89 e5             	mov    %rsp,%rbp
  80bd1c:	48 83 ec 20          	sub    $0x20,%rsp
  80bd20:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  80bd24:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80bd29:	75 2a                	jne    80bd55 <dhcp_delete_request+0x3d>
  80bd2b:	48 ba 50 1b 82 00 00 	movabs $0x821b50,%rdx
  80bd32:	00 00 00 
  80bd35:	be 6a 05 00 00       	mov    $0x56a,%esi
  80bd3a:	48 bf 76 18 82 00 00 	movabs $0x821876,%rdi
  80bd41:	00 00 00 
  80bd44:	b8 00 00 00 00       	mov    $0x0,%eax
  80bd49:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80bd50:	00 00 00 
  80bd53:	ff d1                	callq  *%rcx
  dhcp = netif->dhcp;
  80bd55:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80bd59:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bd5d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  80bd61:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80bd66:	75 2a                	jne    80bd92 <dhcp_delete_request+0x7a>
  80bd68:	48 ba 78 1b 82 00 00 	movabs $0x821b78,%rdx
  80bd6f:	00 00 00 
  80bd72:	be 6c 05 00 00       	mov    $0x56c,%esi
  80bd77:	48 bf 76 18 82 00 00 	movabs $0x821876,%rdi
  80bd7e:	00 00 00 
  80bd81:	b8 00 00 00 00       	mov    $0x0,%eax
  80bd86:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80bd8d:	00 00 00 
  80bd90:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  80bd92:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bd96:	48 8b 40 30          	mov    0x30(%rax),%rax
  80bd9a:	48 85 c0             	test   %rax,%rax
  80bd9d:	75 2a                	jne    80bdc9 <dhcp_delete_request+0xb1>
  80bd9f:	48 ba a0 1b 82 00 00 	movabs $0x821ba0,%rdx
  80bda6:	00 00 00 
  80bda9:	be 6d 05 00 00       	mov    $0x56d,%esi
  80bdae:	48 bf 76 18 82 00 00 	movabs $0x821876,%rdi
  80bdb5:	00 00 00 
  80bdb8:	b8 00 00 00 00       	mov    $0x0,%eax
  80bdbd:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80bdc4:	00 00 00 
  80bdc7:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  80bdc9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bdcd:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bdd1:	48 85 c0             	test   %rax,%rax
  80bdd4:	75 2a                	jne    80be00 <dhcp_delete_request+0xe8>
  80bdd6:	48 ba d0 1b 82 00 00 	movabs $0x821bd0,%rdx
  80bddd:	00 00 00 
  80bde0:	be 6e 05 00 00       	mov    $0x56e,%esi
  80bde5:	48 bf 76 18 82 00 00 	movabs $0x821876,%rdi
  80bdec:	00 00 00 
  80bdef:	b8 00 00 00 00       	mov    $0x0,%eax
  80bdf4:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80bdfb:	00 00 00 
  80bdfe:	ff d1                	callq  *%rcx
  if (dhcp->p_out != NULL) {
  80be00:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80be04:	48 8b 40 30          	mov    0x30(%rax),%rax
  80be08:	48 85 c0             	test   %rax,%rax
  80be0b:	74 17                	je     80be24 <dhcp_delete_request+0x10c>
    pbuf_free(dhcp->p_out);
  80be0d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80be11:	48 8b 40 30          	mov    0x30(%rax),%rax
  80be15:	48 89 c7             	mov    %rax,%rdi
  80be18:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  80be1f:	00 00 00 
  80be22:	ff d0                	callq  *%rax
  }
  dhcp->p_out = NULL;
  80be24:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80be28:	48 c7 40 30 00 00 00 	movq   $0x0,0x30(%rax)
  80be2f:	00 
  dhcp->msg_out = NULL;
  80be30:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80be34:	48 c7 40 38 00 00 00 	movq   $0x0,0x38(%rax)
  80be3b:	00 
}
  80be3c:	c9                   	leaveq 
  80be3d:	c3                   	retq   

000000000080be3e <dhcp_option_trailer>:
 *
 * @param dhcp DHCP state structure
 */
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
  80be3e:	55                   	push   %rbp
  80be3f:	48 89 e5             	mov    %rsp,%rbp
  80be42:	48 83 ec 10          	sub    $0x10,%rsp
  80be46:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  80be4a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80be4f:	75 2a                	jne    80be7b <dhcp_option_trailer+0x3d>
  80be51:	48 ba 00 1c 82 00 00 	movabs $0x821c00,%rdx
  80be58:	00 00 00 
  80be5b:	be 81 05 00 00       	mov    $0x581,%esi
  80be60:	48 bf 76 18 82 00 00 	movabs $0x821876,%rdi
  80be67:	00 00 00 
  80be6a:	b8 00 00 00 00       	mov    $0x0,%eax
  80be6f:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80be76:	00 00 00 
  80be79:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  80be7b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80be7f:	48 8b 40 38          	mov    0x38(%rax),%rax
  80be83:	48 85 c0             	test   %rax,%rax
  80be86:	75 2a                	jne    80beb2 <dhcp_option_trailer+0x74>
  80be88:	48 ba 28 1c 82 00 00 	movabs $0x821c28,%rdx
  80be8f:	00 00 00 
  80be92:	be 82 05 00 00       	mov    $0x582,%esi
  80be97:	48 bf 76 18 82 00 00 	movabs $0x821876,%rdi
  80be9e:	00 00 00 
  80bea1:	b8 00 00 00 00       	mov    $0x0,%eax
  80bea6:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80bead:	00 00 00 
  80beb0:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  80beb2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80beb6:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80beba:	66 83 f8 43          	cmp    $0x43,%ax
  80bebe:	76 2a                	jbe    80beea <dhcp_option_trailer+0xac>
  80bec0:	48 ba 58 1c 82 00 00 	movabs $0x821c58,%rdx
  80bec7:	00 00 00 
  80beca:	be 83 05 00 00       	mov    $0x583,%esi
  80becf:	48 bf 76 18 82 00 00 	movabs $0x821876,%rdi
  80bed6:	00 00 00 
  80bed9:	b8 00 00 00 00       	mov    $0x0,%eax
  80bede:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80bee5:	00 00 00 
  80bee8:	ff d1                	callq  *%rcx
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  80beea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80beee:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80bef2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bef6:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80befa:	8d 70 01             	lea    0x1(%rax),%esi
  80befd:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80bf01:	66 89 71 40          	mov    %si,0x40(%rcx)
  80bf05:	0f b7 c0             	movzwl %ax,%eax
  80bf08:	48 98                	cltq   
  80bf0a:	c6 84 02 f0 00 00 00 	movb   $0xff,0xf0(%rdx,%rax,1)
  80bf11:	ff 
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  80bf12:	eb 60                	jmp    80bf74 <dhcp_option_trailer+0x136>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  80bf14:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bf18:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80bf1c:	66 83 f8 43          	cmp    $0x43,%ax
  80bf20:	76 2a                	jbe    80bf4c <dhcp_option_trailer+0x10e>
  80bf22:	48 ba 58 1c 82 00 00 	movabs $0x821c58,%rdx
  80bf29:	00 00 00 
  80bf2c:	be 88 05 00 00       	mov    $0x588,%esi
  80bf31:	48 bf 76 18 82 00 00 	movabs $0x821876,%rdi
  80bf38:	00 00 00 
  80bf3b:	b8 00 00 00 00       	mov    $0x0,%eax
  80bf40:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80bf47:	00 00 00 
  80bf4a:	ff d1                	callq  *%rcx
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  80bf4c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bf50:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80bf54:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bf58:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80bf5c:	8d 70 01             	lea    0x1(%rax),%esi
  80bf5f:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80bf63:	66 89 71 40          	mov    %si,0x40(%rcx)
  80bf67:	0f b7 c0             	movzwl %ax,%eax
  80bf6a:	48 98                	cltq   
  80bf6c:	c6 84 02 f0 00 00 00 	movb   $0x0,0xf0(%rdx,%rax,1)
  80bf73:	00 
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  80bf74:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bf78:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80bf7c:	66 83 f8 43          	cmp    $0x43,%ax
  80bf80:	76 92                	jbe    80bf14 <dhcp_option_trailer+0xd6>
  80bf82:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bf86:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80bf8a:	0f b7 c0             	movzwl %ax,%eax
  80bf8d:	83 e0 03             	and    $0x3,%eax
  80bf90:	85 c0                	test   %eax,%eax
  80bf92:	75 80                	jne    80bf14 <dhcp_option_trailer+0xd6>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  }
}
  80bf94:	c9                   	leaveq 
  80bf95:	c3                   	retq   

000000000080bf96 <dhcp_get_option_ptr>:
 *
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  80bf96:	55                   	push   %rbp
  80bf97:	48 89 e5             	mov    %rsp,%rbp
  80bf9a:	48 83 ec 2c          	sub    $0x2c,%rsp
  80bf9e:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80bfa2:	89 f0                	mov    %esi,%eax
  80bfa4:	88 45 d4             	mov    %al,-0x2c(%rbp)
  u8_t overload = DHCP_OVERLOAD_NONE;
  80bfa7:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  80bfab:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bfaf:	48 8b 40 20          	mov    0x20(%rax),%rax
  80bfb3:	48 85 c0             	test   %rax,%rax
  80bfb6:	0f 84 95 01 00 00    	je     80c151 <dhcp_get_option_ptr+0x1bb>
  80bfbc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bfc0:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80bfc4:	66 85 c0             	test   %ax,%ax
  80bfc7:	0f 84 84 01 00 00    	je     80c151 <dhcp_get_option_ptr+0x1bb>
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
  80bfcd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bfd1:	48 8b 40 20          	mov    0x20(%rax),%rax
  80bfd5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    u16_t offset = 0;
  80bfd9:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  80bfdf:	e9 80 00 00 00       	jmpq   80c064 <dhcp_get_option_ptr+0xce>
      /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
      /* are the sname and/or file field overloaded with options? */
      if (options[offset] == DHCP_OPTION_OVERLOAD) {
  80bfe4:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80bfe8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80bfec:	48 01 d0             	add    %rdx,%rax
  80bfef:	0f b6 00             	movzbl (%rax),%eax
  80bff2:	3c 34                	cmp    $0x34,%al
  80bff4:	75 22                	jne    80c018 <dhcp_get_option_ptr+0x82>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("overloaded message detected\n"));
        /* skip option type and length */
        offset += 2;
  80bff6:	66 83 45 ee 02       	addw   $0x2,-0x12(%rbp)
        overload = options[offset++];
  80bffb:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bfff:	8d 50 01             	lea    0x1(%rax),%edx
  80c002:	66 89 55 ee          	mov    %dx,-0x12(%rbp)
  80c006:	0f b7 d0             	movzwl %ax,%edx
  80c009:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c00d:	48 01 d0             	add    %rdx,%rax
  80c010:	0f b6 00             	movzbl (%rax),%eax
  80c013:	88 45 ff             	mov    %al,-0x1(%rbp)
  80c016:	eb 4c                	jmp    80c064 <dhcp_get_option_ptr+0xce>
      }
      /* requested option found */
      else if (options[offset] == option_type) {
  80c018:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80c01c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c020:	48 01 d0             	add    %rdx,%rax
  80c023:	0f b6 00             	movzbl (%rax),%eax
  80c026:	3a 45 d4             	cmp    -0x2c(%rbp),%al
  80c029:	75 10                	jne    80c03b <dhcp_get_option_ptr+0xa5>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("option found at offset %"U16_F" in options\n", offset));
        return &options[offset];
  80c02b:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80c02f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c033:	48 01 d0             	add    %rdx,%rax
  80c036:	e9 1b 01 00 00       	jmpq   80c156 <dhcp_get_option_ptr+0x1c0>
      /* skip option */
      } else {
         LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", options[offset]));
        /* skip option type */
        offset++;
  80c03b:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80c03f:	83 c0 01             	add    $0x1,%eax
  80c042:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
  80c046:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80c04a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c04e:	48 01 d0             	add    %rdx,%rax
  80c051:	0f b6 00             	movzbl (%rax),%eax
  80c054:	0f b6 d0             	movzbl %al,%edx
  80c057:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80c05b:	01 d0                	add    %edx,%eax
  80c05d:	83 c0 01             	add    $0x1,%eax
  80c060:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  80c064:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80c068:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80c06c:	66 3b 45 ee          	cmp    -0x12(%rbp),%ax
  80c070:	76 16                	jbe    80c088 <dhcp_get_option_ptr+0xf2>
  80c072:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80c076:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c07a:	48 01 d0             	add    %rdx,%rax
  80c07d:	0f b6 00             	movzbl (%rax),%eax
  80c080:	3c ff                	cmp    $0xff,%al
  80c082:	0f 85 5c ff ff ff    	jne    80bfe4 <dhcp_get_option_ptr+0x4e>
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
      }
    }
    /* is this an overloaded message? */
    if (overload != DHCP_OVERLOAD_NONE) {
  80c088:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80c08c:	0f 84 bf 00 00 00    	je     80c151 <dhcp_get_option_ptr+0x1bb>
      u16_t field_len;
      if (overload == DHCP_OVERLOAD_FILE) {
  80c092:	80 7d ff 01          	cmpb   $0x1,-0x1(%rbp)
  80c096:	75 18                	jne    80c0b0 <dhcp_get_option_ptr+0x11a>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded file field\n"));
        options = (u8_t *)&dhcp->msg_in->file;
  80c098:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80c09c:	48 8b 40 18          	mov    0x18(%rax),%rax
  80c0a0:	48 83 c0 6c          	add    $0x6c,%rax
  80c0a4:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        field_len = DHCP_FILE_LEN;
  80c0a8:	66 c7 45 ec 80 00    	movw   $0x80,-0x14(%rbp)
  80c0ae:	eb 34                	jmp    80c0e4 <dhcp_get_option_ptr+0x14e>
      } else if (overload == DHCP_OVERLOAD_SNAME) {
  80c0b0:	80 7d ff 02          	cmpb   $0x2,-0x1(%rbp)
  80c0b4:	75 18                	jne    80c0ce <dhcp_get_option_ptr+0x138>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  80c0b6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80c0ba:	48 8b 40 18          	mov    0x18(%rax),%rax
  80c0be:	48 83 c0 2c          	add    $0x2c,%rax
  80c0c2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        field_len = DHCP_SNAME_LEN;
  80c0c6:	66 c7 45 ec 40 00    	movw   $0x40,-0x14(%rbp)
  80c0cc:	eb 16                	jmp    80c0e4 <dhcp_get_option_ptr+0x14e>
      /* TODO: check if else if () is necessary */
      } else {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname and file field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  80c0ce:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80c0d2:	48 8b 40 18          	mov    0x18(%rax),%rax
  80c0d6:	48 83 c0 2c          	add    $0x2c,%rax
  80c0da:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
  80c0de:	66 c7 45 ec c0 00    	movw   $0xc0,-0x14(%rbp)
      }
      offset = 0;
  80c0e4:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  80c0ea:	eb 49                	jmp    80c135 <dhcp_get_option_ptr+0x19f>
        if (options[offset] == option_type) {
  80c0ec:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80c0f0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c0f4:	48 01 d0             	add    %rdx,%rax
  80c0f7:	0f b6 00             	movzbl (%rax),%eax
  80c0fa:	3a 45 d4             	cmp    -0x2c(%rbp),%al
  80c0fd:	75 0d                	jne    80c10c <dhcp_get_option_ptr+0x176>
           LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("option found at offset=%"U16_F"\n", offset));
          return &options[offset];
  80c0ff:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80c103:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c107:	48 01 d0             	add    %rdx,%rax
  80c10a:	eb 4a                	jmp    80c156 <dhcp_get_option_ptr+0x1c0>
        /* skip option */
        } else {
          LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("skipping option %"U16_F"\n", options[offset]));
          /* skip option type */
          offset++;
  80c10c:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80c110:	83 c0 01             	add    $0x1,%eax
  80c113:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
          offset += 1 + options[offset];
  80c117:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80c11b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c11f:	48 01 d0             	add    %rdx,%rax
  80c122:	0f b6 00             	movzbl (%rax),%eax
  80c125:	0f b6 d0             	movzbl %al,%edx
  80c128:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80c12c:	01 d0                	add    %edx,%eax
  80c12e:	83 c0 01             	add    $0x1,%eax
  80c131:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
      }
      offset = 0;

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  80c135:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80c139:	66 3b 45 ec          	cmp    -0x14(%rbp),%ax
  80c13d:	73 12                	jae    80c151 <dhcp_get_option_ptr+0x1bb>
  80c13f:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80c143:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c147:	48 01 d0             	add    %rdx,%rax
  80c14a:	0f b6 00             	movzbl (%rax),%eax
  80c14d:	3c ff                	cmp    $0xff,%al
  80c14f:	75 9b                	jne    80c0ec <dhcp_get_option_ptr+0x156>
          offset += 1 + options[offset];
        }
      }
    }
  }
  return NULL;
  80c151:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80c156:	c9                   	leaveq 
  80c157:	c3                   	retq   

000000000080c158 <dhcp_get_option_byte>:
 *
 * @return byte value at the given address.
 */
static u8_t
dhcp_get_option_byte(u8_t *ptr)
{
  80c158:	55                   	push   %rbp
  80c159:	48 89 e5             	mov    %rsp,%rbp
  80c15c:	48 83 ec 08          	sub    $0x8,%rsp
  80c160:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG, ("option byte value=%"U16_F"\n", (u16_t)(*ptr)));
  return *ptr;
  80c164:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c168:	0f b6 00             	movzbl (%rax),%eax
}
  80c16b:	c9                   	leaveq 
  80c16c:	c3                   	retq   

000000000080c16d <dhcp_get_option_long>:
 * @param ptr pointer obtained by dhcp_get_option_ptr().
 *
 * @return byte value at the given address.
 */
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  80c16d:	55                   	push   %rbp
  80c16e:	48 89 e5             	mov    %rsp,%rbp
  80c171:	48 83 ec 18          	sub    $0x18,%rsp
  80c175:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  80c179:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c17d:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80c181:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80c185:	0f b6 00             	movzbl (%rax),%eax
  80c188:	0f b6 c0             	movzbl %al,%eax
  80c18b:	c1 e0 18             	shl    $0x18,%eax
  80c18e:	89 45 fc             	mov    %eax,-0x4(%rbp)
  value |= (u32_t)(*ptr++) << 16;
  80c191:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c195:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80c199:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80c19d:	0f b6 00             	movzbl (%rax),%eax
  80c1a0:	0f b6 c0             	movzbl %al,%eax
  80c1a3:	c1 e0 10             	shl    $0x10,%eax
  80c1a6:	09 45 fc             	or     %eax,-0x4(%rbp)
  value |= (u32_t)(*ptr++) << 8;
  80c1a9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c1ad:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80c1b1:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80c1b5:	0f b6 00             	movzbl (%rax),%eax
  80c1b8:	0f b6 c0             	movzbl %al,%eax
  80c1bb:	c1 e0 08             	shl    $0x8,%eax
  80c1be:	09 45 fc             	or     %eax,-0x4(%rbp)
  value |= (u32_t)(*ptr++);
  80c1c1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c1c5:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80c1c9:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80c1cd:	0f b6 00             	movzbl (%rax),%eax
  80c1d0:	0f b6 c0             	movzbl %al,%eax
  80c1d3:	09 45 fc             	or     %eax,-0x4(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG, ("option long value=%"U32_F"\n", value));
  return value;
  80c1d6:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80c1d9:	c9                   	leaveq 
  80c1da:	c3                   	retq   

000000000080c1db <plug_holes>:
 * This assumes access to the heap is protected by the calling function
 * already.
 */
static void
plug_holes(struct mem *mem)
{
  80c1db:	55                   	push   %rbp
  80c1dc:	48 89 e5             	mov    %rsp,%rbp
  80c1df:	48 83 ec 20          	sub    $0x20,%rsp
  80c1e3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  80c1e7:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c1ee:	00 00 00 
  80c1f1:	48 8b 00             	mov    (%rax),%rax
  80c1f4:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80c1f8:	73 2a                	jae    80c224 <plug_holes+0x49>
  80c1fa:	48 ba 98 1c 82 00 00 	movabs $0x821c98,%rdx
  80c201:	00 00 00 
  80c204:	be e4 00 00 00       	mov    $0xe4,%esi
  80c209:	48 bf af 1c 82 00 00 	movabs $0x821caf,%rdi
  80c210:	00 00 00 
  80c213:	b8 00 00 00 00       	mov    $0x0,%eax
  80c218:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80c21f:	00 00 00 
  80c222:	ff d1                	callq  *%rcx
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  80c224:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c22b:	00 00 00 
  80c22e:	48 8b 00             	mov    (%rax),%rax
  80c231:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80c235:	72 2a                	jb     80c261 <plug_holes+0x86>
  80c237:	48 ba c3 1c 82 00 00 	movabs $0x821cc3,%rdx
  80c23e:	00 00 00 
  80c241:	be e5 00 00 00       	mov    $0xe5,%esi
  80c246:	48 bf af 1c 82 00 00 	movabs $0x821caf,%rdi
  80c24d:	00 00 00 
  80c250:	b8 00 00 00 00       	mov    $0x0,%eax
  80c255:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80c25c:	00 00 00 
  80c25f:	ff d1                	callq  *%rcx
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
  80c261:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c265:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80c269:	84 c0                	test   %al,%al
  80c26b:	74 2a                	je     80c297 <plug_holes+0xbc>
  80c26d:	48 ba dd 1c 82 00 00 	movabs $0x821cdd,%rdx
  80c274:	00 00 00 
  80c277:	be e6 00 00 00       	mov    $0xe6,%esi
  80c27c:	48 bf af 1c 82 00 00 	movabs $0x821caf,%rdi
  80c283:	00 00 00 
  80c286:	b8 00 00 00 00       	mov    $0x0,%eax
  80c28b:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80c292:	00 00 00 
  80c295:	ff d1                	callq  *%rcx

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  80c297:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c29b:	8b 00                	mov    (%rax),%eax
  80c29d:	3d 00 00 22 00       	cmp    $0x220000,%eax
  80c2a2:	76 2a                	jbe    80c2ce <plug_holes+0xf3>
  80c2a4:	48 ba f8 1c 82 00 00 	movabs $0x821cf8,%rdx
  80c2ab:	00 00 00 
  80c2ae:	be e9 00 00 00       	mov    $0xe9,%esi
  80c2b3:	48 bf af 1c 82 00 00 	movabs $0x821caf,%rdi
  80c2ba:	00 00 00 
  80c2bd:	b8 00 00 00 00       	mov    $0x0,%eax
  80c2c2:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80c2c9:	00 00 00 
  80c2cc:	ff d1                	callq  *%rcx

  nmem = (struct mem *)&ram[mem->next];
  80c2ce:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c2d5:	00 00 00 
  80c2d8:	48 8b 10             	mov    (%rax),%rdx
  80c2db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c2df:	8b 00                	mov    (%rax),%eax
  80c2e1:	89 c0                	mov    %eax,%eax
  80c2e3:	48 01 d0             	add    %rdx,%rax
  80c2e6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  80c2ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c2ee:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80c2f2:	0f 84 81 00 00 00    	je     80c379 <plug_holes+0x19e>
  80c2f8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c2fc:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80c300:	84 c0                	test   %al,%al
  80c302:	75 75                	jne    80c379 <plug_holes+0x19e>
  80c304:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c30b:	00 00 00 
  80c30e:	48 8b 00             	mov    (%rax),%rax
  80c311:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80c315:	74 62                	je     80c379 <plug_holes+0x19e>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
  80c317:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c31e:	00 00 00 
  80c321:	48 8b 00             	mov    (%rax),%rax
  80c324:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80c328:	75 11                	jne    80c33b <plug_holes+0x160>
      lfree = mem;
  80c32a:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c331:	00 00 00 
  80c334:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80c338:	48 89 10             	mov    %rdx,(%rax)
    }
    mem->next = nmem->next;
  80c33b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c33f:	8b 10                	mov    (%rax),%edx
  80c341:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c345:	89 10                	mov    %edx,(%rax)
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
  80c347:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c34e:	00 00 00 
  80c351:	48 8b 10             	mov    (%rax),%rdx
  80c354:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c358:	8b 00                	mov    (%rax),%eax
  80c35a:	89 c0                	mov    %eax,%eax
  80c35c:	48 01 c2             	add    %rax,%rdx
  80c35f:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80c363:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c36a:	00 00 00 
  80c36d:	48 8b 00             	mov    (%rax),%rax
  80c370:	48 29 c1             	sub    %rax,%rcx
  80c373:	48 89 c8             	mov    %rcx,%rax
  80c376:	89 42 04             	mov    %eax,0x4(%rdx)
  }

  /* plug hole backward */
  pmem = (struct mem *)&ram[mem->prev];
  80c379:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c380:	00 00 00 
  80c383:	48 8b 10             	mov    (%rax),%rdx
  80c386:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c38a:	8b 40 04             	mov    0x4(%rax),%eax
  80c38d:	89 c0                	mov    %eax,%eax
  80c38f:	48 01 d0             	add    %rdx,%rax
  80c392:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (pmem != mem && pmem->used == 0) {
  80c396:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c39a:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80c39e:	74 6e                	je     80c40e <plug_holes+0x233>
  80c3a0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c3a4:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80c3a8:	84 c0                	test   %al,%al
  80c3aa:	75 62                	jne    80c40e <plug_holes+0x233>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
  80c3ac:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c3b3:	00 00 00 
  80c3b6:	48 8b 00             	mov    (%rax),%rax
  80c3b9:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80c3bd:	75 11                	jne    80c3d0 <plug_holes+0x1f5>
      lfree = pmem;
  80c3bf:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c3c6:	00 00 00 
  80c3c9:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80c3cd:	48 89 10             	mov    %rdx,(%rax)
    }
    pmem->next = mem->next;
  80c3d0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c3d4:	8b 10                	mov    (%rax),%edx
  80c3d6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c3da:	89 10                	mov    %edx,(%rax)
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
  80c3dc:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c3e3:	00 00 00 
  80c3e6:	48 8b 10             	mov    (%rax),%rdx
  80c3e9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c3ed:	8b 00                	mov    (%rax),%eax
  80c3ef:	89 c0                	mov    %eax,%eax
  80c3f1:	48 01 c2             	add    %rax,%rdx
  80c3f4:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  80c3f8:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c3ff:	00 00 00 
  80c402:	48 8b 00             	mov    (%rax),%rax
  80c405:	48 29 c1             	sub    %rax,%rcx
  80c408:	48 89 c8             	mov    %rcx,%rax
  80c40b:	89 42 04             	mov    %eax,0x4(%rdx)
  }
}
  80c40e:	c9                   	leaveq 
  80c40f:	c3                   	retq   

000000000080c410 <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
  80c410:	55                   	push   %rbp
  80c411:	48 89 e5             	mov    %rsp,%rbp
  80c414:	48 83 ec 10          	sub    $0x10,%rsp

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
  80c418:	48 b8 e0 94 82 00 00 	movabs $0x8294e0,%rax
  80c41f:	00 00 00 
  80c422:	48 83 c0 03          	add    $0x3,%rax
  80c426:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  80c42a:	48 89 c2             	mov    %rax,%rdx
  80c42d:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c434:	00 00 00 
  80c437:	48 89 10             	mov    %rdx,(%rax)
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
  80c43a:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c441:	00 00 00 
  80c444:	48 8b 00             	mov    (%rax),%rax
  80c447:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  mem->next = MEM_SIZE_ALIGNED;
  80c44b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c44f:	c7 00 00 00 22 00    	movl   $0x220000,(%rax)
  mem->prev = 0;
  80c455:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c459:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
  mem->used = 0;
  80c460:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c464:	c6 40 08 00          	movb   $0x0,0x8(%rax)
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  80c468:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c46f:	00 00 00 
  80c472:	48 8b 00             	mov    (%rax),%rax
  80c475:	48 8d 90 00 00 22 00 	lea    0x220000(%rax),%rdx
  80c47c:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c483:	00 00 00 
  80c486:	48 89 10             	mov    %rdx,(%rax)
  ram_end->used = 1;
  80c489:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c490:	00 00 00 
  80c493:	48 8b 00             	mov    (%rax),%rax
  80c496:	c6 40 08 01          	movb   $0x1,0x8(%rax)
  ram_end->next = MEM_SIZE_ALIGNED;
  80c49a:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c4a1:	00 00 00 
  80c4a4:	48 8b 00             	mov    (%rax),%rax
  80c4a7:	c7 00 00 00 22 00    	movl   $0x220000,(%rax)
  ram_end->prev = MEM_SIZE_ALIGNED;
  80c4ad:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c4b4:	00 00 00 
  80c4b7:	48 8b 00             	mov    (%rax),%rax
  80c4ba:	c7 40 04 00 00 22 00 	movl   $0x220000,0x4(%rax)

  mem_sem = sys_sem_new(1);
  80c4c1:	bf 01 00 00 00       	mov    $0x1,%edi
  80c4c6:	48 b8 cc 7d 81 00 00 	movabs $0x817dcc,%rax
  80c4cd:	00 00 00 
  80c4d0:	ff d0                	callq  *%rax
  80c4d2:	48 ba 18 95 a4 00 00 	movabs $0xa49518,%rdx
  80c4d9:	00 00 00 
  80c4dc:	89 02                	mov    %eax,(%rdx)

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
  80c4de:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c4e5:	00 00 00 
  80c4e8:	48 8b 10             	mov    (%rax),%rdx
  80c4eb:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c4f2:	00 00 00 
  80c4f5:	48 89 10             	mov    %rdx,(%rax)

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
}
  80c4f8:	c9                   	leaveq 
  80c4f9:	c3                   	retq   

000000000080c4fa <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
  80c4fa:	55                   	push   %rbp
  80c4fb:	48 89 e5             	mov    %rsp,%rbp
  80c4fe:	48 83 ec 20          	sub    $0x20,%rsp
  80c502:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
  80c506:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80c50b:	75 05                	jne    80c512 <mem_free+0x18>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  80c50d:	e9 6b 01 00 00       	jmpq   80c67d <mem_free+0x183>
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  80c512:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c516:	83 e0 03             	and    $0x3,%eax
  80c519:	48 85 c0             	test   %rax,%rax
  80c51c:	74 2a                	je     80c548 <mem_free+0x4e>
  80c51e:	48 ba 28 1d 82 00 00 	movabs $0x821d28,%rdx
  80c525:	00 00 00 
  80c528:	be 31 01 00 00       	mov    $0x131,%esi
  80c52d:	48 bf af 1c 82 00 00 	movabs $0x821caf,%rdi
  80c534:	00 00 00 
  80c537:	b8 00 00 00 00       	mov    $0x0,%eax
  80c53c:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80c543:	00 00 00 
  80c546:	ff d1                	callq  *%rcx

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  80c548:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c54f:	00 00 00 
  80c552:	48 8b 00             	mov    (%rax),%rax
  80c555:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80c559:	72 13                	jb     80c56e <mem_free+0x74>
  80c55b:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c562:	00 00 00 
  80c565:	48 8b 00             	mov    (%rax),%rax
  80c568:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80c56c:	72 2a                	jb     80c598 <mem_free+0x9e>
  80c56e:	48 ba 49 1d 82 00 00 	movabs $0x821d49,%rdx
  80c575:	00 00 00 
  80c578:	be 34 01 00 00       	mov    $0x134,%esi
  80c57d:	48 bf af 1c 82 00 00 	movabs $0x821caf,%rdi
  80c584:	00 00 00 
  80c587:	b8 00 00 00 00       	mov    $0x0,%eax
  80c58c:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80c593:	00 00 00 
  80c596:	ff d1                	callq  *%rcx
    (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
  80c598:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c59f:	00 00 00 
  80c5a2:	48 8b 00             	mov    (%rax),%rax
  80c5a5:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80c5a9:	72 13                	jb     80c5be <mem_free+0xc4>
  80c5ab:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c5b2:	00 00 00 
  80c5b5:	48 8b 00             	mov    (%rax),%rax
  80c5b8:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80c5bc:	72 05                	jb     80c5c3 <mem_free+0xc9>
    LWIP_DEBUGF(MEM_DEBUG | 3, ("mem_free: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  80c5be:	e9 ba 00 00 00       	jmpq   80c67d <mem_free+0x183>
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  80c5c3:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80c5ca:	00 00 00 
  80c5cd:	8b 00                	mov    (%rax),%eax
  80c5cf:	be 00 00 00 00       	mov    $0x0,%esi
  80c5d4:	89 c7                	mov    %eax,%edi
  80c5d6:	48 b8 4d 81 81 00 00 	movabs $0x81814d,%rax
  80c5dd:	00 00 00 
  80c5e0:	ff d0                	callq  *%rax
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  80c5e2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c5e6:	48 83 e8 0c          	sub    $0xc,%rax
  80c5ea:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  80c5ee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c5f2:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80c5f6:	84 c0                	test   %al,%al
  80c5f8:	75 2a                	jne    80c624 <mem_free+0x12a>
  80c5fa:	48 ba 60 1d 82 00 00 	movabs $0x821d60,%rdx
  80c601:	00 00 00 
  80c604:	be 44 01 00 00       	mov    $0x144,%esi
  80c609:	48 bf af 1c 82 00 00 	movabs $0x821caf,%rdi
  80c610:	00 00 00 
  80c613:	b8 00 00 00 00       	mov    $0x0,%eax
  80c618:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80c61f:	00 00 00 
  80c622:	ff d1                	callq  *%rcx
  /* ... and is now unused. */
  mem->used = 0;
  80c624:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c628:	c6 40 08 00          	movb   $0x0,0x8(%rax)

  if (mem < lfree) {
  80c62c:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c633:	00 00 00 
  80c636:	48 8b 00             	mov    (%rax),%rax
  80c639:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80c63d:	73 11                	jae    80c650 <mem_free+0x156>
    /* the newly freed struct is now the lowest */
    lfree = mem;
  80c63f:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c646:	00 00 00 
  80c649:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80c64d:	48 89 10             	mov    %rdx,(%rax)
  }

  MEM_STATS_DEC_USED(used, mem->next - ((u8_t *)mem - ram));

  /* finally, see if prev or next are free also */
  plug_holes(mem);
  80c650:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c654:	48 89 c7             	mov    %rax,%rdi
  80c657:	48 b8 db c1 80 00 00 	movabs $0x80c1db,%rax
  80c65e:	00 00 00 
  80c661:	ff d0                	callq  *%rax
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  80c663:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80c66a:	00 00 00 
  80c66d:	8b 00                	mov    (%rax),%eax
  80c66f:	89 c7                	mov    %eax,%edi
  80c671:	48 b8 4c 80 81 00 00 	movabs $0x81804c,%rax
  80c678:	00 00 00 
  80c67b:	ff d0                	callq  *%rax
}
  80c67d:	c9                   	leaveq 
  80c67e:	c3                   	retq   

000000000080c67f <mem_realloc>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
  80c67f:	55                   	push   %rbp
  80c680:	48 89 e5             	mov    %rsp,%rbp
  80c683:	48 83 ec 30          	sub    $0x30,%rsp
  80c687:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80c68b:	89 75 d4             	mov    %esi,-0x2c(%rbp)
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
  80c68e:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c691:	83 c0 03             	add    $0x3,%eax
  80c694:	83 e0 fc             	and    $0xfffffffc,%eax
  80c697:	89 45 d4             	mov    %eax,-0x2c(%rbp)

  if(newsize < MIN_SIZE_ALIGNED) {
  80c69a:	83 7d d4 0b          	cmpl   $0xb,-0x2c(%rbp)
  80c69e:	77 07                	ja     80c6a7 <mem_realloc+0x28>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  80c6a0:	c7 45 d4 0c 00 00 00 	movl   $0xc,-0x2c(%rbp)
  }

  if (newsize > MEM_SIZE_ALIGNED) {
  80c6a7:	81 7d d4 00 00 22 00 	cmpl   $0x220000,-0x2c(%rbp)
  80c6ae:	76 0a                	jbe    80c6ba <mem_realloc+0x3b>
    return NULL;
  80c6b0:	b8 00 00 00 00       	mov    $0x0,%eax
  80c6b5:	e9 da 02 00 00       	jmpq   80c994 <mem_realloc+0x315>
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  80c6ba:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c6c1:	00 00 00 
  80c6c4:	48 8b 00             	mov    (%rax),%rax
  80c6c7:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80c6cb:	72 13                	jb     80c6e0 <mem_realloc+0x61>
  80c6cd:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c6d4:	00 00 00 
  80c6d7:	48 8b 00             	mov    (%rax),%rax
  80c6da:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80c6de:	72 2a                	jb     80c70a <mem_realloc+0x8b>
  80c6e0:	48 ba 74 1d 82 00 00 	movabs $0x821d74,%rdx
  80c6e7:	00 00 00 
  80c6ea:	be 7a 01 00 00       	mov    $0x17a,%esi
  80c6ef:	48 bf af 1c 82 00 00 	movabs $0x821caf,%rdi
  80c6f6:	00 00 00 
  80c6f9:	b8 00 00 00 00       	mov    $0x0,%eax
  80c6fe:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80c705:	00 00 00 
  80c708:	ff d1                	callq  *%rcx
   (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
  80c70a:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c711:	00 00 00 
  80c714:	48 8b 00             	mov    (%rax),%rax
  80c717:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80c71b:	72 13                	jb     80c730 <mem_realloc+0xb1>
  80c71d:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c724:	00 00 00 
  80c727:	48 8b 00             	mov    (%rax),%rax
  80c72a:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80c72e:	72 09                	jb     80c739 <mem_realloc+0xba>
    LWIP_DEBUGF(MEM_DEBUG | 3, ("mem_realloc: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
  80c730:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80c734:	e9 5b 02 00 00       	jmpq   80c994 <mem_realloc+0x315>
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  80c739:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80c73d:	48 83 e8 0c          	sub    $0xc,%rax
  80c741:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
  80c745:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80c749:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c750:	00 00 00 
  80c753:	48 8b 00             	mov    (%rax),%rax
  80c756:	48 29 c2             	sub    %rax,%rdx
  80c759:	48 89 d0             	mov    %rdx,%rax
  80c75c:	89 45 f4             	mov    %eax,-0xc(%rbp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  80c75f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c763:	8b 00                	mov    (%rax),%eax
  80c765:	2b 45 f4             	sub    -0xc(%rbp),%eax
  80c768:	83 e8 0c             	sub    $0xc,%eax
  80c76b:	89 45 f0             	mov    %eax,-0x10(%rbp)
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  80c76e:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c771:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  80c774:	76 2a                	jbe    80c7a0 <mem_realloc+0x121>
  80c776:	48 ba 90 1d 82 00 00 	movabs $0x821d90,%rdx
  80c77d:	00 00 00 
  80c780:	be 8b 01 00 00       	mov    $0x18b,%esi
  80c785:	48 bf af 1c 82 00 00 	movabs $0x821caf,%rdi
  80c78c:	00 00 00 
  80c78f:	b8 00 00 00 00       	mov    $0x0,%eax
  80c794:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80c79b:	00 00 00 
  80c79e:	ff d1                	callq  *%rcx
  if (newsize > size) {
  80c7a0:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c7a3:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  80c7a6:	76 0a                	jbe    80c7b2 <mem_realloc+0x133>
    /* not supported */
    return NULL;
  80c7a8:	b8 00 00 00 00       	mov    $0x0,%eax
  80c7ad:	e9 e2 01 00 00       	jmpq   80c994 <mem_realloc+0x315>
  }
  if (newsize == size) {
  80c7b2:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c7b5:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  80c7b8:	75 09                	jne    80c7c3 <mem_realloc+0x144>
    /* No change in size, simply return */
    return rmem;
  80c7ba:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80c7be:	e9 d1 01 00 00       	jmpq   80c994 <mem_realloc+0x315>
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  80c7c3:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80c7ca:	00 00 00 
  80c7cd:	8b 00                	mov    (%rax),%eax
  80c7cf:	be 00 00 00 00       	mov    $0x0,%esi
  80c7d4:	89 c7                	mov    %eax,%edi
  80c7d6:	48 b8 4d 81 81 00 00 	movabs $0x81814d,%rax
  80c7dd:	00 00 00 
  80c7e0:	ff d0                	callq  *%rax

  MEM_STATS_DEC_USED(used, (size - newsize));

  mem2 = (struct mem *)&ram[mem->next];
  80c7e2:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c7e9:	00 00 00 
  80c7ec:	48 8b 10             	mov    (%rax),%rdx
  80c7ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c7f3:	8b 00                	mov    (%rax),%eax
  80c7f5:	89 c0                	mov    %eax,%eax
  80c7f7:	48 01 d0             	add    %rdx,%rax
  80c7fa:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if(mem2->used == 0) {
  80c7fe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c802:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80c806:	84 c0                	test   %al,%al
  80c808:	0f 85 ba 00 00 00    	jne    80c8c8 <mem_realloc+0x249>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
  80c80e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c812:	8b 00                	mov    (%rax),%eax
  80c814:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  80c817:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c81a:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80c81d:	01 d0                	add    %edx,%eax
  80c81f:	83 c0 0c             	add    $0xc,%eax
  80c822:	89 45 e0             	mov    %eax,-0x20(%rbp)
    if (lfree == mem2) {
  80c825:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c82c:	00 00 00 
  80c82f:	48 8b 00             	mov    (%rax),%rax
  80c832:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80c836:	75 20                	jne    80c858 <mem_realloc+0x1d9>
      lfree = (struct mem *)&ram[ptr2];
  80c838:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c83f:	00 00 00 
  80c842:	48 8b 10             	mov    (%rax),%rdx
  80c845:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80c848:	48 01 c2             	add    %rax,%rdx
  80c84b:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c852:	00 00 00 
  80c855:	48 89 10             	mov    %rdx,(%rax)
    }
    mem2 = (struct mem *)&ram[ptr2];
  80c858:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c85f:	00 00 00 
  80c862:	48 8b 10             	mov    (%rax),%rdx
  80c865:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80c868:	48 01 d0             	add    %rdx,%rax
  80c86b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    mem2->used = 0;
  80c86f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c873:	c6 40 08 00          	movb   $0x0,0x8(%rax)
    /* restore the next pointer */
    mem2->next = next;
  80c877:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c87b:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80c87e:	89 10                	mov    %edx,(%rax)
    /* link it back to mem */
    mem2->prev = ptr;
  80c880:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c884:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80c887:	89 50 04             	mov    %edx,0x4(%rax)
    /* link mem to it */
    mem->next = ptr2;
  80c88a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c88e:	8b 55 e0             	mov    -0x20(%rbp),%edx
  80c891:	89 10                	mov    %edx,(%rax)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
  80c893:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c897:	8b 00                	mov    (%rax),%eax
  80c899:	3d 00 00 22 00       	cmp    $0x220000,%eax
  80c89e:	74 23                	je     80c8c3 <mem_realloc+0x244>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80c8a0:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c8a7:	00 00 00 
  80c8aa:	48 8b 10             	mov    (%rax),%rdx
  80c8ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c8b1:	8b 00                	mov    (%rax),%eax
  80c8b3:	89 c0                	mov    %eax,%eax
  80c8b5:	48 01 c2             	add    %rax,%rdx
  80c8b8:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80c8bb:	89 42 04             	mov    %eax,0x4(%rdx)
  80c8be:	e9 b3 00 00 00       	jmpq   80c976 <mem_realloc+0x2f7>
  80c8c3:	e9 ae 00 00 00       	jmpq   80c976 <mem_realloc+0x2f7>
    }
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
  80c8c8:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c8cb:	48 8d 50 18          	lea    0x18(%rax),%rdx
  80c8cf:	8b 45 f0             	mov    -0x10(%rbp),%eax
  80c8d2:	48 39 c2             	cmp    %rax,%rdx
  80c8d5:	0f 87 9b 00 00 00    	ja     80c976 <mem_realloc+0x2f7>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  80c8db:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c8de:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80c8e1:	01 d0                	add    %edx,%eax
  80c8e3:	83 c0 0c             	add    $0xc,%eax
  80c8e6:	89 45 e0             	mov    %eax,-0x20(%rbp)
    mem2 = (struct mem *)&ram[ptr2];
  80c8e9:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c8f0:	00 00 00 
  80c8f3:	48 8b 10             	mov    (%rax),%rdx
  80c8f6:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80c8f9:	48 01 d0             	add    %rdx,%rax
  80c8fc:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if (mem2 < lfree) {
  80c900:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c907:	00 00 00 
  80c90a:	48 8b 00             	mov    (%rax),%rax
  80c90d:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80c911:	73 11                	jae    80c924 <mem_realloc+0x2a5>
      lfree = mem2;
  80c913:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c91a:	00 00 00 
  80c91d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80c921:	48 89 10             	mov    %rdx,(%rax)
    }
    mem2->used = 0;
  80c924:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c928:	c6 40 08 00          	movb   $0x0,0x8(%rax)
    mem2->next = mem->next;
  80c92c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c930:	8b 10                	mov    (%rax),%edx
  80c932:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c936:	89 10                	mov    %edx,(%rax)
    mem2->prev = ptr;
  80c938:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c93c:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80c93f:	89 50 04             	mov    %edx,0x4(%rax)
    mem->next = ptr2;
  80c942:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c946:	8b 55 e0             	mov    -0x20(%rbp),%edx
  80c949:	89 10                	mov    %edx,(%rax)
    if (mem2->next != MEM_SIZE_ALIGNED) {
  80c94b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c94f:	8b 00                	mov    (%rax),%eax
  80c951:	3d 00 00 22 00       	cmp    $0x220000,%eax
  80c956:	74 1e                	je     80c976 <mem_realloc+0x2f7>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80c958:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c95f:	00 00 00 
  80c962:	48 8b 10             	mov    (%rax),%rdx
  80c965:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c969:	8b 00                	mov    (%rax),%eax
  80c96b:	89 c0                	mov    %eax,%eax
  80c96d:	48 01 c2             	add    %rax,%rdx
  80c970:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80c973:	89 42 04             	mov    %eax,0x4(%rdx)
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  80c976:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80c97d:	00 00 00 
  80c980:	8b 00                	mov    (%rax),%eax
  80c982:	89 c7                	mov    %eax,%edi
  80c984:	48 b8 4c 80 81 00 00 	movabs $0x81804c,%rax
  80c98b:	00 00 00 
  80c98e:	ff d0                	callq  *%rax
  return rmem;
  80c990:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
}
  80c994:	c9                   	leaveq 
  80c995:	c3                   	retq   

000000000080c996 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
  80c996:	55                   	push   %rbp
  80c997:	48 89 e5             	mov    %rsp,%rbp
  80c99a:	48 83 ec 30          	sub    $0x30,%rsp
  80c99e:	89 7d dc             	mov    %edi,-0x24(%rbp)
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
  80c9a1:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80c9a5:	75 0a                	jne    80c9b1 <mem_malloc+0x1b>
    return NULL;
  80c9a7:	b8 00 00 00 00       	mov    $0x0,%eax
  80c9ac:	e9 6b 03 00 00       	jmpq   80cd1c <mem_malloc+0x386>
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
  80c9b1:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80c9b4:	83 c0 03             	add    $0x3,%eax
  80c9b7:	83 e0 fc             	and    $0xfffffffc,%eax
  80c9ba:	89 45 dc             	mov    %eax,-0x24(%rbp)

  if(size < MIN_SIZE_ALIGNED) {
  80c9bd:	83 7d dc 0b          	cmpl   $0xb,-0x24(%rbp)
  80c9c1:	77 07                	ja     80c9ca <mem_malloc+0x34>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  80c9c3:	c7 45 dc 0c 00 00 00 	movl   $0xc,-0x24(%rbp)
  }

  if (size > MEM_SIZE_ALIGNED) {
  80c9ca:	81 7d dc 00 00 22 00 	cmpl   $0x220000,-0x24(%rbp)
  80c9d1:	76 0a                	jbe    80c9dd <mem_malloc+0x47>
    return NULL;
  80c9d3:	b8 00 00 00 00       	mov    $0x0,%eax
  80c9d8:	e9 3f 03 00 00       	jmpq   80cd1c <mem_malloc+0x386>
  }

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
  80c9dd:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80c9e4:	00 00 00 
  80c9e7:	8b 00                	mov    (%rax),%eax
  80c9e9:	be 00 00 00 00       	mov    $0x0,%esi
  80c9ee:	89 c7                	mov    %eax,%edi
  80c9f0:	48 b8 4d 81 81 00 00 	movabs $0x81814d,%rax
  80c9f7:	00 00 00 
  80c9fa:	ff d0                	callq  *%rax
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  80c9fc:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80ca03:	00 00 00 
  80ca06:	48 8b 00             	mov    (%rax),%rax
  80ca09:	48 89 c2             	mov    %rax,%rdx
  80ca0c:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80ca13:	00 00 00 
  80ca16:	48 8b 00             	mov    (%rax),%rax
  80ca19:	48 29 c2             	sub    %rax,%rdx
  80ca1c:	48 89 d0             	mov    %rdx,%rax
  80ca1f:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80ca22:	e9 c5 02 00 00       	jmpq   80ccec <mem_malloc+0x356>
         ptr = ((struct mem *)&ram[ptr])->next) {
      mem = (struct mem *)&ram[ptr];
  80ca27:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80ca2e:	00 00 00 
  80ca31:	48 8b 10             	mov    (%rax),%rdx
  80ca34:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80ca37:	48 01 d0             	add    %rdx,%rax
  80ca3a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  80ca3e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80ca42:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80ca46:	84 c0                	test   %al,%al
  80ca48:	0f 85 86 02 00 00    	jne    80ccd4 <mem_malloc+0x33e>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
  80ca4e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80ca52:	8b 00                	mov    (%rax),%eax
  80ca54:	89 c2                	mov    %eax,%edx
  80ca56:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80ca59:	48 29 c2             	sub    %rax,%rdx
  80ca5c:	48 89 d0             	mov    %rdx,%rax
  80ca5f:	48 8d 50 f4          	lea    -0xc(%rax),%rdx
  80ca63:	8b 45 dc             	mov    -0x24(%rbp),%eax
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  80ca66:	48 39 c2             	cmp    %rax,%rdx
  80ca69:	0f 82 65 02 00 00    	jb     80ccd4 <mem_malloc+0x33e>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
  80ca6f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80ca73:	8b 00                	mov    (%rax),%eax
  80ca75:	89 c2                	mov    %eax,%edx
  80ca77:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80ca7a:	48 29 c2             	sub    %rax,%rdx
  80ca7d:	48 89 d0             	mov    %rdx,%rax
  80ca80:	48 8d 50 f4          	lea    -0xc(%rax),%rdx
  80ca84:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80ca87:	48 83 c0 18          	add    $0x18,%rax
  80ca8b:	48 39 c2             	cmp    %rax,%rdx
  80ca8e:	0f 82 81 00 00 00    	jb     80cb15 <mem_malloc+0x17f>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
  80ca94:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80ca97:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80ca9a:	01 d0                	add    %edx,%eax
  80ca9c:	83 c0 0c             	add    $0xc,%eax
  80ca9f:	89 45 ec             	mov    %eax,-0x14(%rbp)
          /* create mem2 struct */
          mem2 = (struct mem *)&ram[ptr2];
  80caa2:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80caa9:	00 00 00 
  80caac:	48 8b 10             	mov    (%rax),%rdx
  80caaf:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80cab2:	48 01 d0             	add    %rdx,%rax
  80cab5:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
          mem2->used = 0;
  80cab9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80cabd:	c6 40 08 00          	movb   $0x0,0x8(%rax)
          mem2->next = mem->next;
  80cac1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80cac5:	8b 10                	mov    (%rax),%edx
  80cac7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80cacb:	89 10                	mov    %edx,(%rax)
          mem2->prev = ptr;
  80cacd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80cad1:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80cad4:	89 50 04             	mov    %edx,0x4(%rax)
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
  80cad7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80cadb:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80cade:	89 10                	mov    %edx,(%rax)
          mem->used = 1;
  80cae0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80cae4:	c6 40 08 01          	movb   $0x1,0x8(%rax)

          if (mem2->next != MEM_SIZE_ALIGNED) {
  80cae8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80caec:	8b 00                	mov    (%rax),%eax
  80caee:	3d 00 00 22 00       	cmp    $0x220000,%eax
  80caf3:	74 28                	je     80cb1d <mem_malloc+0x187>
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80caf5:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80cafc:	00 00 00 
  80caff:	48 8b 10             	mov    (%rax),%rdx
  80cb02:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80cb06:	8b 00                	mov    (%rax),%eax
  80cb08:	89 c0                	mov    %eax,%eax
  80cb0a:	48 01 c2             	add    %rax,%rdx
  80cb0d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80cb10:	89 42 04             	mov    %eax,0x4(%rdx)
  80cb13:	eb 08                	jmp    80cb1d <mem_malloc+0x187>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
  80cb15:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80cb19:	c6 40 08 01          	movb   $0x1,0x8(%rax)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
  80cb1d:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80cb24:	00 00 00 
  80cb27:	48 8b 00             	mov    (%rax),%rax
  80cb2a:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  80cb2e:	0f 85 c2 00 00 00    	jne    80cbf6 <mem_malloc+0x260>
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  80cb34:	eb 2e                	jmp    80cb64 <mem_malloc+0x1ce>
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
  80cb36:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80cb3d:	00 00 00 
  80cb40:	48 8b 10             	mov    (%rax),%rdx
  80cb43:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80cb4a:	00 00 00 
  80cb4d:	48 8b 00             	mov    (%rax),%rax
  80cb50:	8b 00                	mov    (%rax),%eax
  80cb52:	89 c0                	mov    %eax,%eax
  80cb54:	48 01 c2             	add    %rax,%rdx
  80cb57:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80cb5e:	00 00 00 
  80cb61:	48 89 10             	mov    %rdx,(%rax)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  80cb64:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80cb6b:	00 00 00 
  80cb6e:	48 8b 00             	mov    (%rax),%rax
  80cb71:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80cb75:	84 c0                	test   %al,%al
  80cb77:	74 1f                	je     80cb98 <mem_malloc+0x202>
  80cb79:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80cb80:	00 00 00 
  80cb83:	48 8b 10             	mov    (%rax),%rdx
  80cb86:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80cb8d:	00 00 00 
  80cb90:	48 8b 00             	mov    (%rax),%rax
  80cb93:	48 39 c2             	cmp    %rax,%rdx
  80cb96:	75 9e                	jne    80cb36 <mem_malloc+0x1a0>
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
  80cb98:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80cb9f:	00 00 00 
  80cba2:	48 8b 10             	mov    (%rax),%rdx
  80cba5:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80cbac:	00 00 00 
  80cbaf:	48 8b 00             	mov    (%rax),%rax
  80cbb2:	48 39 c2             	cmp    %rax,%rdx
  80cbb5:	74 3f                	je     80cbf6 <mem_malloc+0x260>
  80cbb7:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80cbbe:	00 00 00 
  80cbc1:	48 8b 00             	mov    (%rax),%rax
  80cbc4:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80cbc8:	84 c0                	test   %al,%al
  80cbca:	74 2a                	je     80cbf6 <mem_malloc+0x260>
  80cbcc:	48 ba b3 1d 82 00 00 	movabs $0x821db3,%rdx
  80cbd3:	00 00 00 
  80cbd6:	be 47 02 00 00       	mov    $0x247,%esi
  80cbdb:	48 bf af 1c 82 00 00 	movabs $0x821caf,%rdi
  80cbe2:	00 00 00 
  80cbe5:	b8 00 00 00 00       	mov    $0x0,%eax
  80cbea:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80cbf1:	00 00 00 
  80cbf4:	ff d1                	callq  *%rcx
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_sem_signal(mem_sem);
  80cbf6:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80cbfd:	00 00 00 
  80cc00:	8b 00                	mov    (%rax),%eax
  80cc02:	89 c7                	mov    %eax,%edi
  80cc04:	48 b8 4c 80 81 00 00 	movabs $0x81804c,%rax
  80cc0b:	00 00 00 
  80cc0e:	ff d0                	callq  *%rax
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  80cc10:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80cc13:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80cc17:	48 01 d0             	add    %rdx,%rax
  80cc1a:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  80cc1e:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80cc25:	00 00 00 
  80cc28:	48 8b 00             	mov    (%rax),%rax
  80cc2b:	48 39 c2             	cmp    %rax,%rdx
  80cc2e:	76 2a                	jbe    80cc5a <mem_malloc+0x2c4>
  80cc30:	48 ba d0 1d 82 00 00 	movabs $0x821dd0,%rdx
  80cc37:	00 00 00 
  80cc3a:	be 4c 02 00 00       	mov    $0x24c,%esi
  80cc3f:	48 bf af 1c 82 00 00 	movabs $0x821caf,%rdi
  80cc46:	00 00 00 
  80cc49:	b8 00 00 00 00       	mov    $0x0,%eax
  80cc4e:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80cc55:	00 00 00 
  80cc58:	ff d1                	callq  *%rcx
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  80cc5a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80cc5e:	48 83 c0 0c          	add    $0xc,%rax
  80cc62:	83 e0 03             	and    $0x3,%eax
  80cc65:	48 85 c0             	test   %rax,%rax
  80cc68:	74 2a                	je     80cc94 <mem_malloc+0x2fe>
  80cc6a:	48 ba 00 1e 82 00 00 	movabs $0x821e00,%rdx
  80cc71:	00 00 00 
  80cc74:	be 4e 02 00 00       	mov    $0x24e,%esi
  80cc79:	48 bf af 1c 82 00 00 	movabs $0x821caf,%rdi
  80cc80:	00 00 00 
  80cc83:	b8 00 00 00 00       	mov    $0x0,%eax
  80cc88:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80cc8f:	00 00 00 
  80cc92:	ff d1                	callq  *%rcx
         (unsigned long)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
  80cc94:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80cc98:	83 e0 03             	and    $0x3,%eax
  80cc9b:	48 85 c0             	test   %rax,%rax
  80cc9e:	74 2a                	je     80ccca <mem_malloc+0x334>
  80cca0:	48 ba 30 1e 82 00 00 	movabs $0x821e30,%rdx
  80cca7:	00 00 00 
  80ccaa:	be 50 02 00 00       	mov    $0x250,%esi
  80ccaf:	48 bf af 1c 82 00 00 	movabs $0x821caf,%rdi
  80ccb6:	00 00 00 
  80ccb9:	b8 00 00 00 00       	mov    $0x0,%eax
  80ccbe:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80ccc5:	00 00 00 
  80ccc8:	ff d1                	callq  *%rcx
          (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);

        return (u8_t *)mem + SIZEOF_STRUCT_MEM;
  80ccca:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80ccce:	48 83 c0 0c          	add    $0xc,%rax
  80ccd2:	eb 48                	jmp    80cd1c <mem_malloc+0x386>

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
         ptr = ((struct mem *)&ram[ptr])->next) {
  80ccd4:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80ccdb:	00 00 00 
  80ccde:	48 8b 10             	mov    (%rax),%rdx
  80cce1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80cce4:	48 01 d0             	add    %rdx,%rax
  80cce7:	8b 00                	mov    (%rax),%eax
  80cce9:	89 45 fc             	mov    %eax,-0x4(%rbp)
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  80ccec:	b8 00 00 22 00       	mov    $0x220000,%eax
  80ccf1:	2b 45 dc             	sub    -0x24(%rbp),%eax
  80ccf4:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80ccf7:	0f 87 2a fd ff ff    	ja     80ca27 <mem_malloc+0x91>
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  80ccfd:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80cd04:	00 00 00 
  80cd07:	8b 00                	mov    (%rax),%eax
  80cd09:	89 c7                	mov    %eax,%edi
  80cd0b:	48 b8 4c 80 81 00 00 	movabs $0x81804c,%rax
  80cd12:	00 00 00 
  80cd15:	ff d0                	callq  *%rax
  return NULL;
  80cd17:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80cd1c:	c9                   	leaveq 
  80cd1d:	c3                   	retq   

000000000080cd1e <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
  80cd1e:	55                   	push   %rbp
  80cd1f:	48 89 e5             	mov    %rsp,%rbp
  80cd22:	48 83 ec 20          	sub    $0x20,%rsp
  80cd26:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80cd29:	89 75 e8             	mov    %esi,-0x18(%rbp)
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
  80cd2c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80cd2f:	0f af 45 e8          	imul   -0x18(%rbp),%eax
  80cd33:	89 c7                	mov    %eax,%edi
  80cd35:	48 b8 96 c9 80 00 00 	movabs $0x80c996,%rax
  80cd3c:	00 00 00 
  80cd3f:	ff d0                	callq  *%rax
  80cd41:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (p) {
  80cd45:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80cd4a:	74 21                	je     80cd6d <mem_calloc+0x4f>
    /* zero the memory */
    memset(p, 0, count * size);
  80cd4c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80cd4f:	0f af 45 e8          	imul   -0x18(%rbp),%eax
  80cd53:	89 c2                	mov    %eax,%edx
  80cd55:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cd59:	be 00 00 00 00       	mov    $0x0,%esi
  80cd5e:	48 89 c7             	mov    %rax,%rdi
  80cd61:	48 b8 70 21 80 00 00 	movabs $0x802170,%rax
  80cd68:	00 00 00 
  80cd6b:	ff d0                	callq  *%rax
  }
  return p;
  80cd6d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80cd71:	c9                   	leaveq 
  80cd72:	c3                   	retq   

000000000080cd73 <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
  80cd73:	55                   	push   %rbp
  80cd74:	48 89 e5             	mov    %rsp,%rbp
  80cd77:	48 83 ec 10          	sub    $0x10,%rsp
  struct memp *memp;
  u16_t i, j;

  for (i = 0; i < MEMP_MAX; ++i) {
  80cd7b:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%rbp)
  80cd81:	eb 05                	jmp    80cd88 <memp_init+0x15>
  80cd83:	66 83 45 f6 01       	addw   $0x1,-0xa(%rbp)
  80cd88:	66 83 7d f6 0d       	cmpw   $0xd,-0xa(%rbp)
  80cd8d:	76 f4                	jbe    80cd83 <memp_init+0x10>
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  80cd8f:	48 b8 a0 95 a4 00 00 	movabs $0xa495a0,%rax
  80cd96:	00 00 00 
  80cd99:	48 83 c0 03          	add    $0x3,%rax
  80cd9d:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  80cda1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  80cda5:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%rbp)
  80cdab:	e9 97 00 00 00       	jmpq   80ce47 <memp_init+0xd4>
    memp_tab[i] = NULL;
  80cdb0:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80cdb4:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80cdbb:	00 00 00 
  80cdbe:	48 63 d2             	movslq %edx,%rdx
  80cdc1:	48 c7 04 d0 00 00 00 	movq   $0x0,(%rax,%rdx,8)
  80cdc8:	00 
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  80cdc9:	66 c7 45 f4 00 00    	movw   $0x0,-0xc(%rbp)
  80cdcf:	eb 56                	jmp    80ce27 <memp_init+0xb4>
      memp->next = memp_tab[i];
  80cdd1:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80cdd5:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80cddc:	00 00 00 
  80cddf:	48 63 d2             	movslq %edx,%rdx
  80cde2:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  80cde6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cdea:	48 89 10             	mov    %rdx,(%rax)
      memp_tab[i] = memp;
  80cded:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80cdf1:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80cdf8:	00 00 00 
  80cdfb:	48 63 d2             	movslq %edx,%rdx
  80cdfe:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80ce02:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
  80ce06:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80ce0a:	48 b8 60 1e 82 00 00 	movabs $0x821e60,%rax
  80ce11:	00 00 00 
  80ce14:	48 63 d2             	movslq %edx,%rdx
  80ce17:	0f b7 04 50          	movzwl (%rax,%rdx,2),%eax
  80ce1b:	0f b7 c0             	movzwl %ax,%eax
  80ce1e:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  80ce22:	66 83 45 f4 01       	addw   $0x1,-0xc(%rbp)
  80ce27:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80ce2b:	48 b8 80 1e 82 00 00 	movabs $0x821e80,%rax
  80ce32:	00 00 00 
  80ce35:	48 63 d2             	movslq %edx,%rdx
  80ce38:	0f b7 04 50          	movzwl (%rax,%rdx,2),%eax
  80ce3c:	66 3b 45 f4          	cmp    -0xc(%rbp),%ax
  80ce40:	77 8f                	ja     80cdd1 <memp_init+0x5e>
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  80ce42:	66 83 45 f6 01       	addw   $0x1,-0xa(%rbp)
  80ce47:	66 83 7d f6 0d       	cmpw   $0xd,-0xa(%rbp)
  80ce4c:	0f 86 5e ff ff ff    	jbe    80cdb0 <memp_init+0x3d>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
  80ce52:	c9                   	leaveq 
  80ce53:	c3                   	retq   

000000000080ce54 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
  80ce54:	55                   	push   %rbp
  80ce55:	48 89 e5             	mov    %rsp,%rbp
  80ce58:	48 83 ec 20          	sub    $0x20,%rsp
  80ce5c:	89 7d ec             	mov    %edi,-0x14(%rbp)
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  80ce5f:	83 7d ec 0d          	cmpl   $0xd,-0x14(%rbp)
  80ce63:	76 2a                	jbe    80ce8f <memp_malloc+0x3b>
  80ce65:	48 ba 2f 1f 82 00 00 	movabs $0x821f2f,%rdx
  80ce6c:	00 00 00 
  80ce6f:	be 2e 01 00 00       	mov    $0x12e,%esi
  80ce74:	48 bf 4c 1f 82 00 00 	movabs $0x821f4c,%rdi
  80ce7b:	00 00 00 
  80ce7e:	b8 00 00 00 00       	mov    $0x0,%eax
  80ce83:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80ce8a:	00 00 00 
  80ce8d:	ff d1                	callq  *%rcx
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  80ce8f:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80ce96:	00 00 00 
  80ce99:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80ce9c:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80cea0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  
  if (memp != NULL) {    
  80cea4:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80cea9:	74 4e                	je     80cef9 <memp_malloc+0xa5>
    memp_tab[type] = memp->next;    
  80ceab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ceaf:	48 8b 08             	mov    (%rax),%rcx
  80ceb2:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80ceb9:	00 00 00 
  80cebc:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80cebf:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  80cec3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cec7:	83 e0 03             	and    $0x3,%eax
  80ceca:	48 85 c0             	test   %rax,%rax
  80cecd:	74 2a                	je     80cef9 <memp_malloc+0xa5>
  80cecf:	48 ba 68 1f 82 00 00 	movabs $0x821f68,%rdx
  80ced6:	00 00 00 
  80ced9:	be 40 01 00 00       	mov    $0x140,%esi
  80cede:	48 bf 4c 1f 82 00 00 	movabs $0x821f4c,%rdi
  80cee5:	00 00 00 
  80cee8:	b8 00 00 00 00       	mov    $0x0,%eax
  80ceed:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80cef4:	00 00 00 
  80cef7:	ff d1                	callq  *%rcx
    MEMP_STATS_INC(err, type);
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
  80cef9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80cefd:	c9                   	leaveq 
  80cefe:	c3                   	retq   

000000000080ceff <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
  80ceff:	55                   	push   %rbp
  80cf00:	48 89 e5             	mov    %rsp,%rbp
  80cf03:	48 83 ec 20          	sub    $0x20,%rsp
  80cf07:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80cf0a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
  80cf0e:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80cf13:	75 02                	jne    80cf17 <memp_free+0x18>
    return;
  80cf15:	eb 6b                	jmp    80cf82 <memp_free+0x83>
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
  80cf17:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80cf1b:	83 e0 03             	and    $0x3,%eax
  80cf1e:	48 85 c0             	test   %rax,%rax
  80cf21:	74 2a                	je     80cf4d <memp_free+0x4e>
  80cf23:	48 ba 90 1f 82 00 00 	movabs $0x821f90,%rdx
  80cf2a:	00 00 00 
  80cf2d:	be 5c 01 00 00       	mov    $0x15c,%esi
  80cf32:	48 bf 4c 1f 82 00 00 	movabs $0x821f4c,%rdi
  80cf39:	00 00 00 
  80cf3c:	b8 00 00 00 00       	mov    $0x0,%eax
  80cf41:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80cf48:	00 00 00 
  80cf4b:	ff d1                	callq  *%rcx
                ((mem_ptr_t)mem % MEM_ALIGNMENT) == 0);

  memp = (struct memp *)((u8_t*)mem - MEMP_SIZE);
  80cf4d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80cf51:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
  80cf55:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80cf5c:	00 00 00 
  80cf5f:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80cf62:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  80cf66:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cf6a:	48 89 10             	mov    %rdx,(%rax)
  memp_tab[type] = memp;
  80cf6d:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80cf74:	00 00 00 
  80cf77:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80cf7a:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80cf7e:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
  80cf82:	c9                   	leaveq 
  80cf83:	c3                   	retq   

000000000080cf84 <netif_add>:
netif_add(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
  struct ip_addr *gw,
  void *state,
  err_t (* init)(struct netif *netif),
  err_t (* input)(struct pbuf *p, struct netif *netif))
{
  80cf84:	55                   	push   %rbp
  80cf85:	48 89 e5             	mov    %rsp,%rbp
  80cf88:	48 83 ec 30          	sub    $0x30,%rsp
  80cf8c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80cf90:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80cf94:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80cf98:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  80cf9c:	4c 89 45 d8          	mov    %r8,-0x28(%rbp)
  80cfa0:	4c 89 4d d0          	mov    %r9,-0x30(%rbp)
  static u8_t netifnum = 0;

  /* reset new interface configuration state */
  netif->ip_addr.addr = 0;
  80cfa4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cfa8:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
  netif->netmask.addr = 0;
  80cfaf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cfb3:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%rax)
  netif->gw.addr = 0;
  80cfba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cfbe:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%rax)
  netif->flags = 0;
  80cfc5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cfc9:	c6 40 4a 00          	movb   $0x0,0x4a(%rax)
#if LWIP_DHCP
  /* netif not under DHCP control by default */
  netif->dhcp = NULL;
  80cfcd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cfd1:	48 c7 40 38 00 00 00 	movq   $0x0,0x38(%rax)
  80cfd8:	00 
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  80cfd9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cfdd:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80cfe1:	48 89 50 30          	mov    %rdx,0x30(%rax)
  netif->num = netifnum++;
  80cfe5:	48 b8 4b b0 b4 00 00 	movabs $0xb4b04b,%rax
  80cfec:	00 00 00 
  80cfef:	0f b6 00             	movzbl (%rax),%eax
  80cff2:	8d 48 01             	lea    0x1(%rax),%ecx
  80cff5:	48 ba 4b b0 b4 00 00 	movabs $0xb4b04b,%rdx
  80cffc:	00 00 00 
  80cfff:	88 0a                	mov    %cl,(%rdx)
  80d001:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80d005:	88 42 4d             	mov    %al,0x4d(%rdx)
  netif->input = input;
  80d008:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d00c:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80d010:	48 89 50 18          	mov    %rdx,0x18(%rax)
#endif /* LWIP_NETIF_HWADDRHINT*/
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);
  80d014:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  80d018:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80d01c:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  80d020:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d024:	48 89 c7             	mov    %rax,%rdi
  80d027:	48 b8 76 d0 80 00 00 	movabs $0x80d076,%rax
  80d02e:	00 00 00 
  80d031:	ff d0                	callq  *%rax

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
  80d033:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80d037:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80d03b:	48 89 d7             	mov    %rdx,%rdi
  80d03e:	ff d0                	callq  *%rax
  80d040:	84 c0                	test   %al,%al
  80d042:	74 07                	je     80d04b <netif_add+0xc7>
    return NULL;
  80d044:	b8 00 00 00 00       	mov    $0x0,%eax
  80d049:	eb 29                	jmp    80d074 <netif_add+0xf0>
  }

  /* add this netif to the list */
  netif->next = netif_list;
  80d04b:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80d052:	00 00 00 
  80d055:	48 8b 10             	mov    (%rax),%rdx
  80d058:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d05c:	48 89 10             	mov    %rdx,(%rax)
  netif_list = netif;
  80d05f:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80d066:	00 00 00 
  80d069:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80d06d:	48 89 10             	mov    %rdx,(%rax)
  LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
  80d070:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80d074:	c9                   	leaveq 
  80d075:	c3                   	retq   

000000000080d076 <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
    struct ip_addr *gw)
{
  80d076:	55                   	push   %rbp
  80d077:	48 89 e5             	mov    %rsp,%rbp
  80d07a:	48 83 ec 20          	sub    $0x20,%rsp
  80d07e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80d082:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80d086:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80d08a:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  netif_set_ipaddr(netif, ipaddr);
  80d08e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80d092:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d096:	48 89 d6             	mov    %rdx,%rsi
  80d099:	48 89 c7             	mov    %rax,%rdi
  80d09c:	48 b8 24 d2 80 00 00 	movabs $0x80d224,%rax
  80d0a3:	00 00 00 
  80d0a6:	ff d0                	callq  *%rax
  netif_set_netmask(netif, netmask);
  80d0a8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80d0ac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d0b0:	48 89 d6             	mov    %rdx,%rsi
  80d0b3:	48 89 c7             	mov    %rax,%rdi
  80d0b6:	48 b8 57 d3 80 00 00 	movabs $0x80d357,%rax
  80d0bd:	00 00 00 
  80d0c0:	ff d0                	callq  *%rax
  netif_set_gw(netif, gw);
  80d0c2:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80d0c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d0ca:	48 89 d6             	mov    %rdx,%rsi
  80d0cd:	48 89 c7             	mov    %rax,%rdi
  80d0d0:	48 b8 2a d3 80 00 00 	movabs $0x80d32a,%rax
  80d0d7:	00 00 00 
  80d0da:	ff d0                	callq  *%rax
}
  80d0dc:	c9                   	leaveq 
  80d0dd:	c3                   	retq   

000000000080d0de <netif_remove>:
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  80d0de:	55                   	push   %rbp
  80d0df:	48 89 e5             	mov    %rsp,%rbp
  80d0e2:	48 83 ec 20          	sub    $0x20,%rsp
  80d0e6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  if ( netif == NULL ) return;
  80d0ea:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80d0ef:	75 05                	jne    80d0f6 <netif_remove+0x18>
  80d0f1:	e9 98 00 00 00       	jmpq   80d18e <netif_remove+0xb0>
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
  80d0f6:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80d0fd:	00 00 00 
  80d100:	48 8b 00             	mov    (%rax),%rax
  80d103:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80d107:	75 16                	jne    80d11f <netif_remove+0x41>
    netif_list = netif->next;
  80d109:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d10d:	48 8b 10             	mov    (%rax),%rdx
  80d110:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80d117:	00 00 00 
  80d11a:	48 89 10             	mov    %rdx,(%rax)
  80d11d:	eb 4b                	jmp    80d16a <netif_remove+0x8c>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  80d11f:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80d126:	00 00 00 
  80d129:	48 8b 00             	mov    (%rax),%rax
  80d12c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80d130:	eb 28                	jmp    80d15a <netif_remove+0x7c>
      if (tmpNetif->next == netif) {
  80d132:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d136:	48 8b 00             	mov    (%rax),%rax
  80d139:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80d13d:	75 10                	jne    80d14f <netif_remove+0x71>
        tmpNetif->next = netif->next;
  80d13f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d143:	48 8b 10             	mov    (%rax),%rdx
  80d146:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d14a:	48 89 10             	mov    %rdx,(%rax)
        snmp_dec_iflist();
        break;
  80d14d:	eb 12                	jmp    80d161 <netif_remove+0x83>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  80d14f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d153:	48 8b 00             	mov    (%rax),%rax
  80d156:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80d15a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d15f:	75 d1                	jne    80d132 <netif_remove+0x54>
        tmpNetif->next = netif->next;
        snmp_dec_iflist();
        break;
      }
    }
    if (tmpNetif == NULL)
  80d161:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d166:	75 02                	jne    80d16a <netif_remove+0x8c>
      return; /*  we didn't find any netif today */
  80d168:	eb 24                	jmp    80d18e <netif_remove+0xb0>
  }
  /* this netif is default? */
  if (netif_default == netif)
  80d16a:	48 b8 10 b0 b5 00 00 	movabs $0xb5b010,%rax
  80d171:	00 00 00 
  80d174:	48 8b 00             	mov    (%rax),%rax
  80d177:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80d17b:	75 11                	jne    80d18e <netif_remove+0xb0>
    /* reset default netif */
    netif_set_default(NULL);
  80d17d:	bf 00 00 00 00       	mov    $0x0,%edi
  80d182:	48 b8 84 d3 80 00 00 	movabs $0x80d384,%rax
  80d189:	00 00 00 
  80d18c:	ff d0                	callq  *%rax
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
  80d18e:	c9                   	leaveq 
  80d18f:	c3                   	retq   

000000000080d190 <netif_find>:
 * @param name the name of the netif (like netif->name) plus concatenated number
 * in ascii representation (e.g. 'en0')
 */
struct netif *
netif_find(char *name)
{
  80d190:	55                   	push   %rbp
  80d191:	48 89 e5             	mov    %rsp,%rbp
  80d194:	48 83 ec 18          	sub    $0x18,%rsp
  80d198:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
  80d19c:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80d1a1:	75 07                	jne    80d1aa <netif_find+0x1a>
    return NULL;
  80d1a3:	b8 00 00 00 00       	mov    $0x0,%eax
  80d1a8:	eb 78                	jmp    80d222 <netif_find+0x92>
  }

  num = name[2] - '0';
  80d1aa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d1ae:	48 83 c0 02          	add    $0x2,%rax
  80d1b2:	0f b6 00             	movzbl (%rax),%eax
  80d1b5:	83 e8 30             	sub    $0x30,%eax
  80d1b8:	88 45 f7             	mov    %al,-0x9(%rbp)

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  80d1bb:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80d1c2:	00 00 00 
  80d1c5:	48 8b 00             	mov    (%rax),%rax
  80d1c8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80d1cc:	eb 48                	jmp    80d216 <netif_find+0x86>
    if (num == netif->num &&
  80d1ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d1d2:	0f b6 40 4d          	movzbl 0x4d(%rax),%eax
  80d1d6:	3a 45 f7             	cmp    -0x9(%rbp),%al
  80d1d9:	75 30                	jne    80d20b <netif_find+0x7b>
       name[0] == netif->name[0] &&
  80d1db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d1df:	0f b6 10             	movzbl (%rax),%edx
  80d1e2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d1e6:	0f b6 40 4b          	movzbl 0x4b(%rax),%eax
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    if (num == netif->num &&
  80d1ea:	38 c2                	cmp    %al,%dl
  80d1ec:	75 1d                	jne    80d20b <netif_find+0x7b>
       name[0] == netif->name[0] &&
       name[1] == netif->name[1]) {
  80d1ee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d1f2:	48 83 c0 01          	add    $0x1,%rax
  80d1f6:	0f b6 10             	movzbl (%rax),%edx
  80d1f9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d1fd:	0f b6 40 4c          	movzbl 0x4c(%rax),%eax

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    if (num == netif->num &&
       name[0] == netif->name[0] &&
  80d201:	38 c2                	cmp    %al,%dl
  80d203:	75 06                	jne    80d20b <netif_find+0x7b>
       name[1] == netif->name[1]) {
      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
      return netif;
  80d205:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d209:	eb 17                	jmp    80d222 <netif_find+0x92>
    return NULL;
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  80d20b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d20f:	48 8b 00             	mov    (%rax),%rax
  80d212:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80d216:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d21b:	75 b1                	jne    80d1ce <netif_find+0x3e>
      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
      return netif;
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
  80d21d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80d222:	c9                   	leaveq 
  80d223:	c3                   	retq   

000000000080d224 <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, struct ip_addr *ipaddr)
{
  80d224:	55                   	push   %rbp
  80d225:	48 89 e5             	mov    %rsp,%rbp
  80d228:	48 83 ec 30          	sub    $0x30,%rsp
  80d22c:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80d230:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  80d234:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80d238:	8b 10                	mov    (%rax),%edx
  80d23a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d23e:	8b 40 08             	mov    0x8(%rax),%eax
  80d241:	39 c2                	cmp    %eax,%edx
  80d243:	0f 84 c4 00 00 00    	je     80d30d <netif_set_ipaddr+0xe9>
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
  80d249:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80d250:	00 00 00 
  80d253:	48 8b 00             	mov    (%rax),%rax
  80d256:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    while (pcb != NULL) {
  80d25a:	eb 46                	jmp    80d2a2 <netif_set_ipaddr+0x7e>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  80d25c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d260:	8b 10                	mov    (%rax),%edx
  80d262:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d266:	8b 40 08             	mov    0x8(%rax),%eax
  80d269:	39 c2                	cmp    %eax,%edx
  80d26b:	75 29                	jne    80d296 <netif_set_ipaddr+0x72>
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
  80d26d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d271:	48 8b 40 10          	mov    0x10(%rax),%rax
  80d275:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
  80d279:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d27d:	48 89 c7             	mov    %rax,%rdi
  80d280:	48 b8 ff ee 80 00 00 	movabs $0x80eeff,%rax
  80d287:	00 00 00 
  80d28a:	ff d0                	callq  *%rax
        pcb = next;
  80d28c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d290:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80d294:	eb 0c                	jmp    80d2a2 <netif_set_ipaddr+0x7e>
      } else {
        pcb = pcb->next;
  80d296:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d29a:	48 8b 40 10          	mov    0x10(%rax),%rax
  80d29e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
  80d2a2:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d2a7:	75 b3                	jne    80d25c <netif_set_ipaddr+0x38>
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d2a9:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  80d2b0:	00 00 00 
  80d2b3:	48 8b 00             	mov    (%rax),%rax
  80d2b6:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80d2ba:	eb 4a                	jmp    80d306 <netif_set_ipaddr+0xe2>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  80d2bc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80d2c0:	48 85 c0             	test   %rax,%rax
  80d2c3:	74 35                	je     80d2fa <netif_set_ipaddr+0xd6>
  80d2c5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80d2c9:	8b 00                	mov    (%rax),%eax
  80d2cb:	85 c0                	test   %eax,%eax
  80d2cd:	74 2b                	je     80d2fa <netif_set_ipaddr+0xd6>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
  80d2cf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80d2d3:	8b 10                	mov    (%rax),%edx
  80d2d5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d2d9:	8b 40 08             	mov    0x8(%rax),%eax
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  80d2dc:	39 c2                	cmp    %eax,%edx
  80d2de:	75 1a                	jne    80d2fa <netif_set_ipaddr+0xd6>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  80d2e0:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80d2e5:	74 08                	je     80d2ef <netif_set_ipaddr+0xcb>
  80d2e7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80d2eb:	8b 00                	mov    (%rax),%eax
  80d2ed:	eb 05                	jmp    80d2f4 <netif_set_ipaddr+0xd0>
  80d2ef:	b8 00 00 00 00       	mov    $0x0,%eax
  80d2f4:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80d2f8:	89 02                	mov    %eax,(%rdx)
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d2fa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80d2fe:	48 8b 40 10          	mov    0x10(%rax),%rax
  80d302:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80d306:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80d30b:	75 af                	jne    80d2bc <netif_set_ipaddr+0x98>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
  80d30d:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80d312:	74 08                	je     80d31c <netif_set_ipaddr+0xf8>
  80d314:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80d318:	8b 00                	mov    (%rax),%eax
  80d31a:	eb 05                	jmp    80d321 <netif_set_ipaddr+0xfd>
  80d31c:	b8 00 00 00 00       	mov    $0x0,%eax
  80d321:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80d325:	89 42 08             	mov    %eax,0x8(%rdx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->ip_addr),
    ip4_addr2(&netif->ip_addr),
    ip4_addr3(&netif->ip_addr),
    ip4_addr4(&netif->ip_addr)));
}
  80d328:	c9                   	leaveq 
  80d329:	c3                   	retq   

000000000080d32a <netif_set_gw>:
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
  80d32a:	55                   	push   %rbp
  80d32b:	48 89 e5             	mov    %rsp,%rbp
  80d32e:	48 83 ec 10          	sub    $0x10,%rsp
  80d332:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80d336:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  ip_addr_set(&(netif->gw), gw);
  80d33a:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80d33f:	74 08                	je     80d349 <netif_set_gw+0x1f>
  80d341:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80d345:	8b 00                	mov    (%rax),%eax
  80d347:	eb 05                	jmp    80d34e <netif_set_gw+0x24>
  80d349:	b8 00 00 00 00       	mov    $0x0,%eax
  80d34e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80d352:	89 42 10             	mov    %eax,0x10(%rdx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->gw),
    ip4_addr2(&netif->gw),
    ip4_addr3(&netif->gw),
    ip4_addr4(&netif->gw)));
}
  80d355:	c9                   	leaveq 
  80d356:	c3                   	retq   

000000000080d357 <netif_set_netmask>:
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
  80d357:	55                   	push   %rbp
  80d358:	48 89 e5             	mov    %rsp,%rbp
  80d35b:	48 83 ec 10          	sub    $0x10,%rsp
  80d35f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80d363:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
  80d367:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80d36c:	74 08                	je     80d376 <netif_set_netmask+0x1f>
  80d36e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80d372:	8b 00                	mov    (%rax),%eax
  80d374:	eb 05                	jmp    80d37b <netif_set_netmask+0x24>
  80d376:	b8 00 00 00 00       	mov    $0x0,%eax
  80d37b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80d37f:	89 42 0c             	mov    %eax,0xc(%rdx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->netmask),
    ip4_addr2(&netif->netmask),
    ip4_addr3(&netif->netmask),
    ip4_addr4(&netif->netmask)));
}
  80d382:	c9                   	leaveq 
  80d383:	c3                   	retq   

000000000080d384 <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
  80d384:	55                   	push   %rbp
  80d385:	48 89 e5             	mov    %rsp,%rbp
  80d388:	48 83 ec 08          	sub    $0x8,%rsp
  80d38c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  80d390:	48 b8 10 b0 b5 00 00 	movabs $0xb5b010,%rax
  80d397:	00 00 00 
  80d39a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80d39e:	48 89 10             	mov    %rdx,(%rax)
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
  80d3a1:	c9                   	leaveq 
  80d3a2:	c3                   	retq   

000000000080d3a3 <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  80d3a3:	55                   	push   %rbp
  80d3a4:	48 89 e5             	mov    %rsp,%rbp
  80d3a7:	48 83 ec 10          	sub    $0x10,%rsp
  80d3ab:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if ( !(netif->flags & NETIF_FLAG_UP )) {
  80d3af:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d3b3:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80d3b7:	0f b6 c0             	movzbl %al,%eax
  80d3ba:	83 e0 01             	and    $0x1,%eax
  80d3bd:	85 c0                	test   %eax,%eax
  80d3bf:	75 49                	jne    80d40a <netif_set_up+0x67>
    netif->flags |= NETIF_FLAG_UP;
  80d3c1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d3c5:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80d3c9:	83 c8 01             	or     $0x1,%eax
  80d3cc:	89 c2                	mov    %eax,%edx
  80d3ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d3d2:	88 50 4a             	mov    %dl,0x4a(%rax)
    /** For Ethernet network interfaces, we would like to send a
     *  "gratuitous ARP"; this is an ARP packet sent by a node in order
     *  to spontaneously cause other nodes to update an entry in their
     *  ARP cache. From RFC 3220 "IP Mobility Support for IPv4" section 4.6.
     */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
  80d3d5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d3d9:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80d3dd:	0f b6 c0             	movzbl %al,%eax
  80d3e0:	83 e0 20             	and    $0x20,%eax
  80d3e3:	85 c0                	test   %eax,%eax
  80d3e5:	74 23                	je     80d40a <netif_set_up+0x67>
      etharp_query(netif, &(netif->ip_addr), NULL);
  80d3e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d3eb:	48 8d 48 08          	lea    0x8(%rax),%rcx
  80d3ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d3f3:	ba 00 00 00 00       	mov    $0x0,%edx
  80d3f8:	48 89 ce             	mov    %rcx,%rsi
  80d3fb:	48 89 c7             	mov    %rax,%rdi
  80d3fe:	48 b8 e7 6b 81 00 00 	movabs $0x816be7,%rax
  80d405:	00 00 00 
  80d408:	ff d0                	callq  *%rax
    }
#endif /* LWIP_ARP */
    
  }
}
  80d40a:	c9                   	leaveq 
  80d40b:	c3                   	retq   

000000000080d40c <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  80d40c:	55                   	push   %rbp
  80d40d:	48 89 e5             	mov    %rsp,%rbp
  80d410:	48 83 ec 08          	sub    $0x8,%rsp
  80d414:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if ( netif->flags & NETIF_FLAG_UP )
  80d418:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d41c:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80d420:	0f b6 c0             	movzbl %al,%eax
  80d423:	83 e0 01             	and    $0x1,%eax
  80d426:	85 c0                	test   %eax,%eax
  80d428:	74 14                	je     80d43e <netif_set_down+0x32>
    {
      netif->flags &= ~NETIF_FLAG_UP;
  80d42a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d42e:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80d432:	83 e0 fe             	and    $0xfffffffe,%eax
  80d435:	89 c2                	mov    %eax,%edx
  80d437:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d43b:	88 50 4a             	mov    %dl,0x4a(%rax)
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
  80d43e:	c9                   	leaveq 
  80d43f:	c3                   	retq   

000000000080d440 <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
  80d440:	55                   	push   %rbp
  80d441:	48 89 e5             	mov    %rsp,%rbp
  80d444:	48 83 ec 08          	sub    $0x8,%rsp
  80d448:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  return (netif->flags & NETIF_FLAG_UP)?1:0;
  80d44c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d450:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80d454:	0f b6 c0             	movzbl %al,%eax
  80d457:	83 e0 01             	and    $0x1,%eax
  80d45a:	85 c0                	test   %eax,%eax
  80d45c:	0f 95 c0             	setne  %al
}
  80d45f:	c9                   	leaveq 
  80d460:	c3                   	retq   

000000000080d461 <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
  80d461:	55                   	push   %rbp
  80d462:	48 89 e5             	mov    %rsp,%rbp
  80d465:	48 83 ec 30          	sub    $0x30,%rsp
  80d469:	89 7d dc             	mov    %edi,-0x24(%rbp)
  80d46c:	89 f0                	mov    %esi,%eax
  80d46e:	89 55 d4             	mov    %edx,-0x2c(%rbp)
  80d471:	66 89 45 d8          	mov    %ax,-0x28(%rbp)
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  80d475:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  switch (layer) {
  80d47b:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80d47e:	83 f8 01             	cmp    $0x1,%eax
  80d481:	74 16                	je     80d499 <pbuf_alloc+0x38>
  80d483:	83 f8 01             	cmp    $0x1,%eax
  80d486:	72 0c                	jb     80d494 <pbuf_alloc+0x33>
  80d488:	83 f8 02             	cmp    $0x2,%eax
  80d48b:	74 11                	je     80d49e <pbuf_alloc+0x3d>
  80d48d:	83 f8 03             	cmp    $0x3,%eax
  80d490:	74 3d                	je     80d4cf <pbuf_alloc+0x6e>
  80d492:	eb 11                	jmp    80d4a5 <pbuf_alloc+0x44>
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
  80d494:	66 83 45 ee 14       	addw   $0x14,-0x12(%rbp)
    /* FALLTHROUGH */
  case PBUF_IP:
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
  80d499:	66 83 45 ee 14       	addw   $0x14,-0x12(%rbp)
    /* FALLTHROUGH */
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
  80d49e:	66 83 45 ee 0e       	addw   $0xe,-0x12(%rbp)
    break;
  80d4a3:	eb 2b                	jmp    80d4d0 <pbuf_alloc+0x6f>
  case PBUF_RAW:
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
  80d4a5:	48 ba b0 1f 82 00 00 	movabs $0x821fb0,%rdx
  80d4ac:	00 00 00 
  80d4af:	be 8b 00 00 00       	mov    $0x8b,%esi
  80d4b4:	48 bf cb 1f 82 00 00 	movabs $0x821fcb,%rdi
  80d4bb:	00 00 00 
  80d4be:	b8 00 00 00 00       	mov    $0x0,%eax
  80d4c3:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80d4ca:	00 00 00 
  80d4cd:	ff d1                	callq  *%rcx
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
    break;
  case PBUF_RAW:
    break;
  80d4cf:	90                   	nop
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    return NULL;
  }

  switch (type) {
  80d4d0:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80d4d3:	83 f8 02             	cmp    $0x2,%eax
  80d4d6:	77 0e                	ja     80d4e6 <pbuf_alloc+0x85>
  80d4d8:	83 f8 01             	cmp    $0x1,%eax
  80d4db:	0f 83 ac 03 00 00    	jae    80d88d <pbuf_alloc+0x42c>
  80d4e1:	e9 d8 02 00 00       	jmpq   80d7be <pbuf_alloc+0x35d>
  80d4e6:	83 f8 03             	cmp    $0x3,%eax
  80d4e9:	0f 85 05 04 00 00    	jne    80d8f4 <pbuf_alloc+0x493>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
      p = memp_malloc(MEMP_PBUF_POOL);
  80d4ef:	bf 0d 00 00 00       	mov    $0xd,%edi
  80d4f4:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  80d4fb:	00 00 00 
  80d4fe:	ff d0                	callq  *%rax
  80d500:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
  80d504:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d509:	75 0a                	jne    80d515 <pbuf_alloc+0xb4>
      return NULL;
  80d50b:	b8 00 00 00 00       	mov    $0x0,%eax
  80d510:	e9 1f 04 00 00       	jmpq   80d934 <pbuf_alloc+0x4d3>
    }
    p->type = type;
  80d515:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80d518:	89 c2                	mov    %eax,%edx
  80d51a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d51e:	88 50 14             	mov    %dl,0x14(%rax)
    p->next = NULL;
  80d521:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d525:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
  80d52c:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80d530:	48 8d 50 18          	lea    0x18(%rax),%rdx
  80d534:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d538:	48 01 d0             	add    %rdx,%rax
  80d53b:	48 83 c0 03          	add    $0x3,%rax
  80d53f:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  80d543:	48 89 c2             	mov    %rax,%rdx
  80d546:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d54a:	48 89 50 08          	mov    %rdx,0x8(%rax)
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
  80d54e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d552:	48 8b 40 08          	mov    0x8(%rax),%rax
  80d556:	83 e0 03             	and    $0x3,%eax
  80d559:	48 85 c0             	test   %rax,%rax
  80d55c:	74 2a                	je     80d588 <pbuf_alloc+0x127>
  80d55e:	48 ba e0 1f 82 00 00 	movabs $0x821fe0,%rdx
  80d565:	00 00 00 
  80d568:	be 9d 00 00 00       	mov    $0x9d,%esi
  80d56d:	48 bf cb 1f 82 00 00 	movabs $0x821fcb,%rdi
  80d574:	00 00 00 
  80d577:	b8 00 00 00 00       	mov    $0x0,%eax
  80d57c:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80d583:	00 00 00 
  80d586:	ff d1                	callq  *%rcx
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
  80d588:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d58c:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  80d590:	66 89 50 10          	mov    %dx,0x10(%rax)
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
  80d594:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80d598:	83 c0 03             	add    $0x3,%eax
  80d59b:	83 e0 fc             	and    $0xfffffffc,%eax
  80d59e:	89 c2                	mov    %eax,%edx
  80d5a0:	b8 d0 07 00 00       	mov    $0x7d0,%eax
  80d5a5:	29 d0                	sub    %edx,%eax
  80d5a7:	89 c2                	mov    %eax,%edx
  80d5a9:	0f b7 45 d8          	movzwl -0x28(%rbp),%eax
  80d5ad:	39 c2                	cmp    %eax,%edx
  80d5af:	0f 4e c2             	cmovle %edx,%eax
  80d5b2:	89 c2                	mov    %eax,%edx
  80d5b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d5b8:	66 89 50 12          	mov    %dx,0x12(%rax)
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  80d5bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d5c0:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80d5c4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d5c8:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d5cc:	0f b7 c0             	movzwl %ax,%eax
  80d5cf:	48 01 c2             	add    %rax,%rdx
  80d5d2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d5d6:	48 05 e8 07 00 00    	add    $0x7e8,%rax
  80d5dc:	48 39 c2             	cmp    %rax,%rdx
  80d5df:	76 2a                	jbe    80d60b <pbuf_alloc+0x1aa>
  80d5e1:	48 ba 10 20 82 00 00 	movabs $0x822010,%rdx
  80d5e8:	00 00 00 
  80d5eb:	be a4 00 00 00       	mov    $0xa4,%esi
  80d5f0:	48 bf cb 1f 82 00 00 	movabs $0x821fcb,%rdi
  80d5f7:	00 00 00 
  80d5fa:	b8 00 00 00 00       	mov    $0x0,%eax
  80d5ff:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80d606:	00 00 00 
  80d609:	ff d1                	callq  *%rcx
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
  80d60b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d60f:	66 c7 40 16 01 00    	movw   $0x1,0x16(%rax)

    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
  80d615:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d619:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    /* remaining length to be allocated */
    rem_len = length - p->len;
  80d61d:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  80d621:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d625:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d629:	0f b7 c0             	movzwl %ax,%eax
  80d62c:	29 c2                	sub    %eax,%edx
  80d62e:	89 d0                	mov    %edx,%eax
  80d630:	89 45 e8             	mov    %eax,-0x18(%rbp)
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  80d633:	e9 77 01 00 00       	jmpq   80d7af <pbuf_alloc+0x34e>
      q = memp_malloc(MEMP_PBUF_POOL);
  80d638:	bf 0d 00 00 00       	mov    $0xd,%edi
  80d63d:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  80d644:	00 00 00 
  80d647:	ff d0                	callq  *%rax
  80d649:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      if (q == NULL) {
  80d64d:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80d652:	75 1d                	jne    80d671 <pbuf_alloc+0x210>
        /* free chain so far allocated */
        pbuf_free(p);
  80d654:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d658:	48 89 c7             	mov    %rax,%rdi
  80d65b:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  80d662:	00 00 00 
  80d665:	ff d0                	callq  *%rax
        /* bail out unsuccesfully */
        return NULL;
  80d667:	b8 00 00 00 00       	mov    $0x0,%eax
  80d66c:	e9 c3 02 00 00       	jmpq   80d934 <pbuf_alloc+0x4d3>
      }
      q->type = type;
  80d671:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80d674:	89 c2                	mov    %eax,%edx
  80d676:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d67a:	88 50 14             	mov    %dl,0x14(%rax)
      q->flags = 0;
  80d67d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d681:	c6 40 15 00          	movb   $0x0,0x15(%rax)
      q->next = NULL;
  80d685:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d689:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
      /* make previous pbuf point to this pbuf */
      r->next = q;
  80d690:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80d694:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80d698:	48 89 10             	mov    %rdx,(%rax)
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  80d69b:	81 7d e8 fe ff 00 00 	cmpl   $0xfffe,-0x18(%rbp)
  80d6a2:	7e 2a                	jle    80d6ce <pbuf_alloc+0x26d>
  80d6a4:	48 ba 41 20 82 00 00 	movabs $0x822041,%rdx
  80d6ab:	00 00 00 
  80d6ae:	be bd 00 00 00       	mov    $0xbd,%esi
  80d6b3:	48 bf cb 1f 82 00 00 	movabs $0x821fcb,%rdi
  80d6ba:	00 00 00 
  80d6bd:	b8 00 00 00 00       	mov    $0x0,%eax
  80d6c2:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80d6c9:	00 00 00 
  80d6cc:	ff d1                	callq  *%rcx
      q->tot_len = (u16_t)rem_len;
  80d6ce:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80d6d1:	89 c2                	mov    %eax,%edx
  80d6d3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d6d7:	66 89 50 10          	mov    %dx,0x10(%rax)
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
  80d6db:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80d6de:	66 3d cf 07          	cmp    $0x7cf,%ax
  80d6e2:	77 05                	ja     80d6e9 <pbuf_alloc+0x288>
  80d6e4:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80d6e7:	eb 05                	jmp    80d6ee <pbuf_alloc+0x28d>
  80d6e9:	b8 d0 07 00 00       	mov    $0x7d0,%eax
  80d6ee:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80d6f2:	66 89 42 12          	mov    %ax,0x12(%rdx)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
  80d6f6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d6fa:	48 8d 50 18          	lea    0x18(%rax),%rdx
  80d6fe:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d702:	48 89 50 08          	mov    %rdx,0x8(%rax)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  80d706:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d70a:	48 8b 40 08          	mov    0x8(%rax),%rax
  80d70e:	83 e0 03             	and    $0x3,%eax
  80d711:	48 85 c0             	test   %rax,%rax
  80d714:	74 2a                	je     80d740 <pbuf_alloc+0x2df>
  80d716:	48 ba 58 20 82 00 00 	movabs $0x822058,%rdx
  80d71d:	00 00 00 
  80d720:	be c3 00 00 00       	mov    $0xc3,%esi
  80d725:	48 bf cb 1f 82 00 00 	movabs $0x821fcb,%rdi
  80d72c:	00 00 00 
  80d72f:	b8 00 00 00 00       	mov    $0x0,%eax
  80d734:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80d73b:	00 00 00 
  80d73e:	ff d1                	callq  *%rcx
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  80d740:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d744:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80d748:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d74c:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d750:	0f b7 c0             	movzwl %ax,%eax
  80d753:	48 01 c2             	add    %rax,%rdx
  80d756:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d75a:	48 05 e8 07 00 00    	add    $0x7e8,%rax
  80d760:	48 39 c2             	cmp    %rax,%rdx
  80d763:	76 2a                	jbe    80d78f <pbuf_alloc+0x32e>
  80d765:	48 ba 10 20 82 00 00 	movabs $0x822010,%rdx
  80d76c:	00 00 00 
  80d76f:	be c6 00 00 00       	mov    $0xc6,%esi
  80d774:	48 bf cb 1f 82 00 00 	movabs $0x821fcb,%rdi
  80d77b:	00 00 00 
  80d77e:	b8 00 00 00 00       	mov    $0x0,%eax
  80d783:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80d78a:	00 00 00 
  80d78d:	ff d1                	callq  *%rcx
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
  80d78f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d793:	66 c7 40 16 01 00    	movw   $0x1,0x16(%rax)
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
  80d799:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d79d:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d7a1:	0f b7 c0             	movzwl %ax,%eax
  80d7a4:	29 45 e8             	sub    %eax,-0x18(%rbp)
      /* remember this pbuf for linkage in next iteration */
      r = q;
  80d7a7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d7ab:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  80d7af:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  80d7b3:	0f 8f 7f fe ff ff    	jg     80d638 <pbuf_alloc+0x1d7>
      r = q;
    }
    /* end of chain */
    /*r->next = NULL;*/

    break;
  80d7b9:	e9 60 01 00 00       	jmpq   80d91e <pbuf_alloc+0x4bd>
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
  80d7be:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80d7c2:	83 c0 1b             	add    $0x1b,%eax
  80d7c5:	83 e0 fc             	and    $0xfffffffc,%eax
  80d7c8:	89 c2                	mov    %eax,%edx
  80d7ca:	0f b7 45 d8          	movzwl -0x28(%rbp),%eax
  80d7ce:	83 c0 03             	add    $0x3,%eax
  80d7d1:	83 e0 fc             	and    $0xfffffffc,%eax
  80d7d4:	01 d0                	add    %edx,%eax
  80d7d6:	89 c7                	mov    %eax,%edi
  80d7d8:	48 b8 96 c9 80 00 00 	movabs $0x80c996,%rax
  80d7df:	00 00 00 
  80d7e2:	ff d0                	callq  *%rax
  80d7e4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (p == NULL) {
  80d7e8:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d7ed:	75 0a                	jne    80d7f9 <pbuf_alloc+0x398>
      return NULL;
  80d7ef:	b8 00 00 00 00       	mov    $0x0,%eax
  80d7f4:	e9 3b 01 00 00       	jmpq   80d934 <pbuf_alloc+0x4d3>
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
  80d7f9:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80d7fd:	48 8d 50 18          	lea    0x18(%rax),%rdx
  80d801:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d805:	48 01 d0             	add    %rdx,%rax
  80d808:	48 83 c0 03          	add    $0x3,%rax
  80d80c:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  80d810:	48 89 c2             	mov    %rax,%rdx
  80d813:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d817:	48 89 50 08          	mov    %rdx,0x8(%rax)
    p->len = p->tot_len = length;
  80d81b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d81f:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  80d823:	66 89 50 10          	mov    %dx,0x10(%rax)
  80d827:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d82b:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80d82f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d833:	66 89 50 12          	mov    %dx,0x12(%rax)
    p->next = NULL;
  80d837:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d83b:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    p->type = type;
  80d842:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80d845:	89 c2                	mov    %eax,%edx
  80d847:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d84b:	88 50 14             	mov    %dl,0x14(%rax)

    LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
  80d84e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d852:	48 8b 40 08          	mov    0x8(%rax),%rax
  80d856:	83 e0 03             	and    $0x3,%eax
  80d859:	48 85 c0             	test   %rax,%rax
  80d85c:	74 2a                	je     80d888 <pbuf_alloc+0x427>
  80d85e:	48 ba 88 20 82 00 00 	movabs $0x822088,%rdx
  80d865:	00 00 00 
  80d868:	be de 00 00 00       	mov    $0xde,%esi
  80d86d:	48 bf cb 1f 82 00 00 	movabs $0x821fcb,%rdi
  80d874:	00 00 00 
  80d877:	b8 00 00 00 00       	mov    $0x0,%eax
  80d87c:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80d883:	00 00 00 
  80d886:	ff d1                	callq  *%rcx
           ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    break;
  80d888:	e9 91 00 00 00       	jmpq   80d91e <pbuf_alloc+0x4bd>
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
  80d88d:	bf 0c 00 00 00       	mov    $0xc,%edi
  80d892:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  80d899:	00 00 00 
  80d89c:	ff d0                	callq  *%rax
  80d89e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (p == NULL) {
  80d8a2:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d8a7:	75 0a                	jne    80d8b3 <pbuf_alloc+0x452>
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
  80d8a9:	b8 00 00 00 00       	mov    $0x0,%eax
  80d8ae:	e9 81 00 00 00       	jmpq   80d934 <pbuf_alloc+0x4d3>
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
  80d8b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d8b7:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  80d8be:	00 
    p->len = p->tot_len = length;
  80d8bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d8c3:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  80d8c7:	66 89 50 10          	mov    %dx,0x10(%rax)
  80d8cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d8cf:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80d8d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d8d7:	66 89 50 12          	mov    %dx,0x12(%rax)
    p->next = NULL;
  80d8db:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d8df:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    p->type = type;
  80d8e6:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80d8e9:	89 c2                	mov    %eax,%edx
  80d8eb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d8ef:	88 50 14             	mov    %dl,0x14(%rax)
    break;
  80d8f2:	eb 2a                	jmp    80d91e <pbuf_alloc+0x4bd>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
  80d8f4:	48 ba b3 20 82 00 00 	movabs $0x8220b3,%rdx
  80d8fb:	00 00 00 
  80d8fe:	be f2 00 00 00       	mov    $0xf2,%esi
  80d903:	48 bf cb 1f 82 00 00 	movabs $0x821fcb,%rdi
  80d90a:	00 00 00 
  80d90d:	b8 00 00 00 00       	mov    $0x0,%eax
  80d912:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80d919:	00 00 00 
  80d91c:	ff d1                	callq  *%rcx
    return NULL;
  }
  /* set reference count */
  p->ref = 1;
  80d91e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d922:	66 c7 40 16 01 00    	movw   $0x1,0x16(%rax)
  /* set flags */
  p->flags = 0;
  80d928:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d92c:	c6 40 15 00          	movb   $0x0,0x15(%rax)
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
  80d930:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80d934:	c9                   	leaveq 
  80d935:	c3                   	retq   

000000000080d936 <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
  80d936:	55                   	push   %rbp
  80d937:	48 89 e5             	mov    %rsp,%rbp
  80d93a:	48 83 ec 20          	sub    $0x20,%rsp
  80d93e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80d942:	89 f0                	mov    %esi,%eax
  80d944:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s32_t grow;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  80d948:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80d94d:	75 2a                	jne    80d979 <pbuf_realloc+0x43>
  80d94f:	48 ba ce 20 82 00 00 	movabs $0x8220ce,%rdx
  80d956:	00 00 00 
  80d959:	be 14 01 00 00       	mov    $0x114,%esi
  80d95e:	48 bf cb 1f 82 00 00 	movabs $0x821fcb,%rdi
  80d965:	00 00 00 
  80d968:	b8 00 00 00 00       	mov    $0x0,%eax
  80d96d:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80d974:	00 00 00 
  80d977:	ff d1                	callq  *%rcx
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  80d979:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d97d:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d981:	3c 03                	cmp    $0x3,%al
  80d983:	74 4e                	je     80d9d3 <pbuf_realloc+0x9d>
  80d985:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d989:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d98d:	3c 01                	cmp    $0x1,%al
  80d98f:	74 42                	je     80d9d3 <pbuf_realloc+0x9d>
  80d991:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d995:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d999:	84 c0                	test   %al,%al
  80d99b:	74 36                	je     80d9d3 <pbuf_realloc+0x9d>
  80d99d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d9a1:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d9a5:	3c 02                	cmp    $0x2,%al
  80d9a7:	74 2a                	je     80d9d3 <pbuf_realloc+0x9d>
  80d9a9:	48 ba e6 20 82 00 00 	movabs $0x8220e6,%rdx
  80d9b0:	00 00 00 
  80d9b3:	be 18 01 00 00       	mov    $0x118,%esi
  80d9b8:	48 bf cb 1f 82 00 00 	movabs $0x821fcb,%rdi
  80d9bf:	00 00 00 
  80d9c2:	b8 00 00 00 00       	mov    $0x0,%eax
  80d9c7:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80d9ce:	00 00 00 
  80d9d1:	ff d1                	callq  *%rcx
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
  80d9d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d9d7:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80d9db:	66 3b 45 e4          	cmp    -0x1c(%rbp),%ax
  80d9df:	77 05                	ja     80d9e6 <pbuf_realloc+0xb0>
    /* enlarging not yet supported */
    return;
  80d9e1:	e9 97 01 00 00       	jmpq   80db7d <pbuf_realloc+0x247>
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
  80d9e6:	0f b7 55 e4          	movzwl -0x1c(%rbp),%edx
  80d9ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d9ee:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80d9f2:	0f b7 c0             	movzwl %ax,%eax
  80d9f5:	29 c2                	sub    %eax,%edx
  80d9f7:	89 d0                	mov    %edx,%eax
  80d9f9:	89 45 f0             	mov    %eax,-0x10(%rbp)

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  80d9fc:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80da00:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
  q = p;
  80da04:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80da08:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  80da0c:	e9 90 00 00 00       	jmpq   80daa1 <pbuf_realloc+0x16b>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
  80da11:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80da15:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80da19:	66 29 45 f6          	sub    %ax,-0xa(%rbp)
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  80da1d:	81 7d f0 fe ff 00 00 	cmpl   $0xfffe,-0x10(%rbp)
  80da24:	7e 2a                	jle    80da50 <pbuf_realloc+0x11a>
  80da26:	48 ba 01 21 82 00 00 	movabs $0x822101,%rdx
  80da2d:	00 00 00 
  80da30:	be 2c 01 00 00       	mov    $0x12c,%esi
  80da35:	48 bf cb 1f 82 00 00 	movabs $0x821fcb,%rdi
  80da3c:	00 00 00 
  80da3f:	b8 00 00 00 00       	mov    $0x0,%eax
  80da44:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80da4b:	00 00 00 
  80da4e:	ff d1                	callq  *%rcx
    q->tot_len += (u16_t)grow;
  80da50:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80da54:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80da58:	8b 45 f0             	mov    -0x10(%rbp),%eax
  80da5b:	01 c2                	add    %eax,%edx
  80da5d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80da61:	66 89 50 10          	mov    %dx,0x10(%rax)
    /* proceed to next pbuf in chain */
    q = q->next;
  80da65:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80da69:	48 8b 00             	mov    (%rax),%rax
  80da6c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
  80da70:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80da75:	75 2a                	jne    80daa1 <pbuf_realloc+0x16b>
  80da77:	48 ba 12 21 82 00 00 	movabs $0x822112,%rdx
  80da7e:	00 00 00 
  80da81:	be 30 01 00 00       	mov    $0x130,%esi
  80da86:	48 bf cb 1f 82 00 00 	movabs $0x821fcb,%rdi
  80da8d:	00 00 00 
  80da90:	b8 00 00 00 00       	mov    $0x0,%eax
  80da95:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80da9c:	00 00 00 
  80da9f:	ff d1                	callq  *%rcx

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  80daa1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80daa5:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80daa9:	66 3b 45 f6          	cmp    -0xa(%rbp),%ax
  80daad:	0f 82 5e ff ff ff    	jb     80da11 <pbuf_realloc+0xdb>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
  80dab3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dab7:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80dabb:	84 c0                	test   %al,%al
  80dabd:	75 75                	jne    80db34 <pbuf_realloc+0x1fe>
  80dabf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dac3:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80dac7:	66 3b 45 f6          	cmp    -0xa(%rbp),%ax
  80dacb:	74 67                	je     80db34 <pbuf_realloc+0x1fe>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
  80dacd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dad1:	48 8b 40 08          	mov    0x8(%rax),%rax
  80dad5:	48 89 c2             	mov    %rax,%rdx
  80dad8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dadc:	48 29 c2             	sub    %rax,%rdx
  80dadf:	48 89 d0             	mov    %rdx,%rax
  80dae2:	89 c2                	mov    %eax,%edx
  80dae4:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  80dae8:	01 c2                	add    %eax,%edx
  80daea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80daee:	89 d6                	mov    %edx,%esi
  80daf0:	48 89 c7             	mov    %rax,%rdi
  80daf3:	48 b8 7f c6 80 00 00 	movabs $0x80c67f,%rax
  80dafa:	00 00 00 
  80dafd:	ff d0                	callq  *%rax
  80daff:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  80db03:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80db08:	75 2a                	jne    80db34 <pbuf_realloc+0x1fe>
  80db0a:	48 ba 2a 21 82 00 00 	movabs $0x82212a,%rdx
  80db11:	00 00 00 
  80db14:	be 3a 01 00 00       	mov    $0x13a,%esi
  80db19:	48 bf cb 1f 82 00 00 	movabs $0x821fcb,%rdi
  80db20:	00 00 00 
  80db23:	b8 00 00 00 00       	mov    $0x0,%eax
  80db28:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80db2f:	00 00 00 
  80db32:	ff d1                	callq  *%rcx
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
  80db34:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80db38:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80db3c:	66 89 50 12          	mov    %dx,0x12(%rax)
  q->tot_len = q->len;
  80db40:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80db44:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80db48:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80db4c:	66 89 50 10          	mov    %dx,0x10(%rax)

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
  80db50:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80db54:	48 8b 00             	mov    (%rax),%rax
  80db57:	48 85 c0             	test   %rax,%rax
  80db5a:	74 16                	je     80db72 <pbuf_realloc+0x23c>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
  80db5c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80db60:	48 8b 00             	mov    (%rax),%rax
  80db63:	48 89 c7             	mov    %rax,%rdi
  80db66:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  80db6d:	00 00 00 
  80db70:	ff d0                	callq  *%rax
  }
  /* q is last packet in chain */
  q->next = NULL;
  80db72:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80db76:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

}
  80db7d:	c9                   	leaveq 
  80db7e:	c3                   	retq   

000000000080db7f <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
  80db7f:	55                   	push   %rbp
  80db80:	48 89 e5             	mov    %rsp,%rbp
  80db83:	48 83 ec 20          	sub    $0x20,%rsp
  80db87:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80db8b:	89 f0                	mov    %esi,%eax
  80db8d:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  80db91:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80db96:	75 2a                	jne    80dbc2 <pbuf_header+0x43>
  80db98:	48 ba 45 21 82 00 00 	movabs $0x822145,%rdx
  80db9f:	00 00 00 
  80dba2:	be 65 01 00 00       	mov    $0x165,%esi
  80dba7:	48 bf cb 1f 82 00 00 	movabs $0x821fcb,%rdi
  80dbae:	00 00 00 
  80dbb1:	b8 00 00 00 00       	mov    $0x0,%eax
  80dbb6:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80dbbd:	00 00 00 
  80dbc0:	ff d1                	callq  *%rcx
  if ((header_size_increment == 0) || (p == NULL))
  80dbc2:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%rbp)
  80dbc7:	74 07                	je     80dbd0 <pbuf_header+0x51>
  80dbc9:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80dbce:	75 0a                	jne    80dbda <pbuf_header+0x5b>
    return 0;
  80dbd0:	b8 00 00 00 00       	mov    $0x0,%eax
  80dbd5:	e9 64 01 00 00       	jmpq   80dd3e <pbuf_header+0x1bf>
 
  if (header_size_increment < 0){
  80dbda:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%rbp)
  80dbdf:	79 42                	jns    80dc23 <pbuf_header+0xa4>
    increment_magnitude = -header_size_increment;
  80dbe1:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80dbe5:	f7 d8                	neg    %eax
  80dbe7:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  80dbeb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dbef:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80dbf3:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  80dbf7:	73 32                	jae    80dc2b <pbuf_header+0xac>
  80dbf9:	48 ba 4f 21 82 00 00 	movabs $0x82214f,%rdx
  80dc00:	00 00 00 
  80dc03:	be 6c 01 00 00       	mov    $0x16c,%esi
  80dc08:	48 bf cb 1f 82 00 00 	movabs $0x821fcb,%rdi
  80dc0f:	00 00 00 
  80dc12:	b8 00 00 00 00       	mov    $0x0,%eax
  80dc17:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80dc1e:	00 00 00 
  80dc21:	ff d1                	callq  *%rcx
  } else {
    increment_magnitude = header_size_increment;
  80dc23:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80dc27:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
  80dc2b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dc2f:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80dc33:	0f b6 c0             	movzbl %al,%eax
  80dc36:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
  /* remember current payload pointer */
  payload = p->payload;
  80dc3a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dc3e:	48 8b 40 08          	mov    0x8(%rax),%rax
  80dc42:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
  80dc46:	66 83 7d fc 00       	cmpw   $0x0,-0x4(%rbp)
  80dc4b:	74 07                	je     80dc54 <pbuf_header+0xd5>
  80dc4d:	66 83 7d fc 03       	cmpw   $0x3,-0x4(%rbp)
  80dc52:	75 48                	jne    80dc9c <pbuf_header+0x11d>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
  80dc54:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dc58:	48 8b 40 08          	mov    0x8(%rax),%rax
  80dc5c:	48 0f bf 55 e4       	movswq -0x1c(%rbp),%rdx
  80dc61:	48 f7 da             	neg    %rdx
  80dc64:	48 01 c2             	add    %rax,%rdx
  80dc67:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dc6b:	48 89 50 08          	mov    %rdx,0x8(%rax)
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  80dc6f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dc73:	48 8b 40 08          	mov    0x8(%rax),%rax
  80dc77:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80dc7b:	48 83 c2 18          	add    $0x18,%rdx
  80dc7f:	48 39 d0             	cmp    %rdx,%rax
  80dc82:	73 16                	jae    80dc9a <pbuf_header+0x11b>
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
        (void *)p->payload,
        (void *)(p + 1)));\
      /* restore old payload pointer */
      p->payload = payload;
  80dc84:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dc88:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80dc8c:	48 89 50 08          	mov    %rdx,0x8(%rax)
      /* bail out unsuccesfully */
      return 1;
  80dc90:	b8 01 00 00 00       	mov    $0x1,%eax
  80dc95:	e9 a4 00 00 00       	jmpq   80dd3e <pbuf_header+0x1bf>
  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  80dc9a:	eb 71                	jmp    80dd0d <pbuf_header+0x18e>
      p->payload = payload;
      /* bail out unsuccesfully */
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
  80dc9c:	66 83 7d fc 02       	cmpw   $0x2,-0x4(%rbp)
  80dca1:	74 07                	je     80dcaa <pbuf_header+0x12b>
  80dca3:	66 83 7d fc 01       	cmpw   $0x1,-0x4(%rbp)
  80dca8:	75 39                	jne    80dce3 <pbuf_header+0x164>
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  80dcaa:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%rbp)
  80dcaf:	79 2b                	jns    80dcdc <pbuf_header+0x15d>
  80dcb1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dcb5:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80dcb9:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  80dcbd:	72 1d                	jb     80dcdc <pbuf_header+0x15d>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
  80dcbf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dcc3:	48 8b 40 08          	mov    0x8(%rax),%rax
  80dcc7:	48 0f bf 55 e4       	movswq -0x1c(%rbp),%rdx
  80dccc:	48 f7 da             	neg    %rdx
  80dccf:	48 01 c2             	add    %rax,%rdx
  80dcd2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dcd6:	48 89 50 08          	mov    %rdx,0x8(%rax)
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  80dcda:	eb 31                	jmp    80dd0d <pbuf_header+0x18e>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
  80dcdc:	b8 01 00 00 00       	mov    $0x1,%eax
  80dce1:	eb 5b                	jmp    80dd3e <pbuf_header+0x1bf>
    }
  }
  else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
  80dce3:	48 ba 6d 21 82 00 00 	movabs $0x82216d,%rdx
  80dcea:	00 00 00 
  80dced:	be 9b 01 00 00       	mov    $0x19b,%esi
  80dcf2:	48 bf cb 1f 82 00 00 	movabs $0x821fcb,%rdi
  80dcf9:	00 00 00 
  80dcfc:	b8 00 00 00 00       	mov    $0x0,%eax
  80dd01:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80dd08:	00 00 00 
  80dd0b:	ff d1                	callq  *%rcx
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  80dd0d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dd11:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80dd15:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80dd19:	01 c2                	add    %eax,%edx
  80dd1b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dd1f:	66 89 50 12          	mov    %dx,0x12(%rax)
  p->tot_len += header_size_increment;
  80dd23:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dd27:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80dd2b:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80dd2f:	01 c2                	add    %eax,%edx
  80dd31:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dd35:	66 89 50 10          	mov    %dx,0x10(%rax)

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
  80dd39:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80dd3e:	c9                   	leaveq 
  80dd3f:	c3                   	retq   

000000000080dd40 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
  80dd40:	55                   	push   %rbp
  80dd41:	48 89 e5             	mov    %rsp,%rbp
  80dd44:	48 83 ec 30          	sub    $0x30,%rsp
  80dd48:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
  80dd4c:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80dd51:	75 3b                	jne    80dd8e <pbuf_free+0x4e>
    LWIP_ASSERT("p != NULL", p != NULL);
  80dd53:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80dd58:	75 2a                	jne    80dd84 <pbuf_free+0x44>
  80dd5a:	48 ba 45 21 82 00 00 	movabs $0x822145,%rdx
  80dd61:	00 00 00 
  80dd64:	be d1 01 00 00       	mov    $0x1d1,%esi
  80dd69:	48 bf cb 1f 82 00 00 	movabs $0x821fcb,%rdi
  80dd70:	00 00 00 
  80dd73:	b8 00 00 00 00       	mov    $0x0,%eax
  80dd78:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80dd7f:	00 00 00 
  80dd82:	ff d1                	callq  *%rcx
    /* if assertions are disabled, proceed with debug output */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_free(p == NULL) was called.\n"));
    return 0;
  80dd84:	b8 00 00 00 00       	mov    $0x0,%eax
  80dd89:	e9 65 01 00 00       	jmpq   80def3 <pbuf_free+0x1b3>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  80dd8e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dd92:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80dd96:	84 c0                	test   %al,%al
  80dd98:	74 4e                	je     80dde8 <pbuf_free+0xa8>
  80dd9a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dd9e:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80dda2:	3c 01                	cmp    $0x1,%al
  80dda4:	74 42                	je     80dde8 <pbuf_free+0xa8>
  80dda6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80ddaa:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80ddae:	3c 02                	cmp    $0x2,%al
  80ddb0:	74 36                	je     80dde8 <pbuf_free+0xa8>
  80ddb2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80ddb6:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80ddba:	3c 03                	cmp    $0x3,%al
  80ddbc:	74 2a                	je     80dde8 <pbuf_free+0xa8>
  80ddbe:	48 ba 7b 21 82 00 00 	movabs $0x82217b,%rdx
  80ddc5:	00 00 00 
  80ddc8:	be dc 01 00 00       	mov    $0x1dc,%esi
  80ddcd:	48 bf cb 1f 82 00 00 	movabs $0x821fcb,%rdi
  80ddd4:	00 00 00 
  80ddd7:	b8 00 00 00 00       	mov    $0x0,%eax
  80dddc:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80dde3:	00 00 00 
  80dde6:	ff d1                	callq  *%rcx
    p->type == PBUF_RAM || p->type == PBUF_ROM ||
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  80dde8:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
  80ddec:	e9 f3 00 00 00       	jmpq   80dee4 <pbuf_free+0x1a4>
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  80ddf1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80ddf5:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  80ddf9:	66 85 c0             	test   %ax,%ax
  80ddfc:	75 2a                	jne    80de28 <pbuf_free+0xe8>
  80ddfe:	48 ba 90 21 82 00 00 	movabs $0x822190,%rdx
  80de05:	00 00 00 
  80de08:	be e9 01 00 00       	mov    $0x1e9,%esi
  80de0d:	48 bf cb 1f 82 00 00 	movabs $0x821fcb,%rdi
  80de14:	00 00 00 
  80de17:	b8 00 00 00 00       	mov    $0x0,%eax
  80de1c:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80de23:	00 00 00 
  80de26:	ff d1                	callq  *%rcx
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
  80de28:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80de2c:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  80de30:	8d 50 ff             	lea    -0x1(%rax),%edx
  80de33:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80de37:	66 89 50 16          	mov    %dx,0x16(%rax)
  80de3b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80de3f:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  80de43:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
  80de47:	66 83 7d fc 00       	cmpw   $0x0,-0x4(%rbp)
  80de4c:	0f 85 8a 00 00 00    	jne    80dedc <pbuf_free+0x19c>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
  80de52:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80de56:	48 8b 00             	mov    (%rax),%rax
  80de59:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
  80de5d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80de61:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80de65:	0f b6 c0             	movzbl %al,%eax
  80de68:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
  80de6c:	66 83 7d ee 03       	cmpw   $0x3,-0x12(%rbp)
  80de71:	75 1a                	jne    80de8d <pbuf_free+0x14d>
        memp_free(MEMP_PBUF_POOL, p);
  80de73:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80de77:	48 89 c6             	mov    %rax,%rsi
  80de7a:	bf 0d 00 00 00       	mov    $0xd,%edi
  80de7f:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  80de86:	00 00 00 
  80de89:	ff d0                	callq  *%rax
  80de8b:	eb 3b                	jmp    80dec8 <pbuf_free+0x188>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
  80de8d:	66 83 7d ee 01       	cmpw   $0x1,-0x12(%rbp)
  80de92:	74 07                	je     80de9b <pbuf_free+0x15b>
  80de94:	66 83 7d ee 02       	cmpw   $0x2,-0x12(%rbp)
  80de99:	75 1a                	jne    80deb5 <pbuf_free+0x175>
        memp_free(MEMP_PBUF, p);
  80de9b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80de9f:	48 89 c6             	mov    %rax,%rsi
  80dea2:	bf 0c 00 00 00       	mov    $0xc,%edi
  80dea7:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  80deae:	00 00 00 
  80deb1:	ff d0                	callq  *%rax
  80deb3:	eb 13                	jmp    80dec8 <pbuf_free+0x188>
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
  80deb5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80deb9:	48 89 c7             	mov    %rax,%rdi
  80debc:	48 b8 fa c4 80 00 00 	movabs $0x80c4fa,%rax
  80dec3:	00 00 00 
  80dec6:	ff d0                	callq  *%rax
      }
      count++;
  80dec8:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  80decc:	83 c0 01             	add    $0x1,%eax
  80decf:	88 45 ff             	mov    %al,-0x1(%rbp)
      /* proceed to next pbuf */
      p = q;
  80ded2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80ded6:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80deda:	eb 08                	jmp    80dee4 <pbuf_free+0x1a4>
    /* p->ref > 0, this pbuf is still referenced to */
    /* (and so the remaining pbufs in chain as well) */
    } else {
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, ref));
      /* stop walking through the chain */
      p = NULL;
  80dedc:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  80dee3:	00 
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
  80dee4:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80dee9:	0f 85 02 ff ff ff    	jne    80ddf1 <pbuf_free+0xb1>
      p = NULL;
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
  80deef:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  80def3:	c9                   	leaveq 
  80def4:	c3                   	retq   

000000000080def5 <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
  80def5:	55                   	push   %rbp
  80def6:	48 89 e5             	mov    %rsp,%rbp
  80def9:	48 83 ec 18          	sub    $0x18,%rsp
  80defd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  u8_t len;

  len = 0;
  80df01:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  while (p != NULL) {
  80df05:	eb 0f                	jmp    80df16 <pbuf_clen+0x21>
    ++len;
  80df07:	80 45 ff 01          	addb   $0x1,-0x1(%rbp)
    p = p->next;
  80df0b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80df0f:	48 8b 00             	mov    (%rax),%rax
  80df12:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
  80df16:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80df1b:	75 ea                	jne    80df07 <pbuf_clen+0x12>
    ++len;
    p = p->next;
  }
  return len;
  80df1d:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  80df21:	c9                   	leaveq 
  80df22:	c3                   	retq   

000000000080df23 <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
  80df23:	55                   	push   %rbp
  80df24:	48 89 e5             	mov    %rsp,%rbp
  80df27:	48 83 ec 08          	sub    $0x8,%rsp
  80df2b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
  80df2f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80df34:	74 13                	je     80df49 <pbuf_ref+0x26>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
  80df36:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80df3a:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  80df3e:	8d 50 01             	lea    0x1(%rax),%edx
  80df41:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80df45:	66 89 50 16          	mov    %dx,0x16(%rax)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
  80df49:	c9                   	leaveq 
  80df4a:	c3                   	retq   

000000000080df4b <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  80df4b:	55                   	push   %rbp
  80df4c:	48 89 e5             	mov    %rsp,%rbp
  80df4f:	48 83 ec 20          	sub    $0x20,%rsp
  80df53:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80df57:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  80df5b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80df60:	74 07                	je     80df69 <pbuf_cat+0x1e>
  80df62:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80df67:	75 2a                	jne    80df93 <pbuf_cat+0x48>
  80df69:	48 ba a8 21 82 00 00 	movabs $0x8221a8,%rdx
  80df70:	00 00 00 
  80df73:	be 43 02 00 00       	mov    $0x243,%esi
  80df78:	48 bf cb 1f 82 00 00 	movabs $0x821fcb,%rdi
  80df7f:	00 00 00 
  80df82:	b8 00 00 00 00       	mov    $0x0,%eax
  80df87:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80df8e:	00 00 00 
  80df91:	ff d1                	callq  *%rcx
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  80df93:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80df97:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80df9b:	eb 25                	jmp    80dfc2 <pbuf_cat+0x77>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  80df9d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dfa1:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80dfa5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80dfa9:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80dfad:	01 c2                	add    %eax,%edx
  80dfaf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dfb3:	66 89 50 10          	mov    %dx,0x10(%rax)

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  80dfb7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dfbb:	48 8b 00             	mov    (%rax),%rax
  80dfbe:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80dfc2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dfc6:	48 8b 00             	mov    (%rax),%rax
  80dfc9:	48 85 c0             	test   %rax,%rax
  80dfcc:	75 cf                	jne    80df9d <pbuf_cat+0x52>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  80dfce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dfd2:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80dfd6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dfda:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80dfde:	66 39 c2             	cmp    %ax,%dx
  80dfe1:	74 2a                	je     80e00d <pbuf_cat+0xc2>
  80dfe3:	48 ba e0 21 82 00 00 	movabs $0x8221e0,%rdx
  80dfea:	00 00 00 
  80dfed:	be 4b 02 00 00       	mov    $0x24b,%esi
  80dff2:	48 bf cb 1f 82 00 00 	movabs $0x821fcb,%rdi
  80dff9:	00 00 00 
  80dffc:	b8 00 00 00 00       	mov    $0x0,%eax
  80e001:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80e008:	00 00 00 
  80e00b:	ff d1                	callq  *%rcx
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  80e00d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e011:	48 8b 00             	mov    (%rax),%rax
  80e014:	48 85 c0             	test   %rax,%rax
  80e017:	74 2a                	je     80e043 <pbuf_cat+0xf8>
  80e019:	48 ba 0d 22 82 00 00 	movabs $0x82220d,%rdx
  80e020:	00 00 00 
  80e023:	be 4c 02 00 00       	mov    $0x24c,%esi
  80e028:	48 bf cb 1f 82 00 00 	movabs $0x821fcb,%rdi
  80e02f:	00 00 00 
  80e032:	b8 00 00 00 00       	mov    $0x0,%eax
  80e037:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80e03e:	00 00 00 
  80e041:	ff d1                	callq  *%rcx
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  80e043:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e047:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80e04b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e04f:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80e053:	01 c2                	add    %eax,%edx
  80e055:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e059:	66 89 50 10          	mov    %dx,0x10(%rax)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  80e05d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e061:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80e065:	48 89 10             	mov    %rdx,(%rax)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
  80e068:	c9                   	leaveq 
  80e069:	c3                   	retq   

000000000080e06a <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
  80e06a:	55                   	push   %rbp
  80e06b:	48 89 e5             	mov    %rsp,%rbp
  80e06e:	48 83 ec 10          	sub    $0x10,%rsp
  80e072:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80e076:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  pbuf_cat(h, t);
  80e07a:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e07e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e082:	48 89 d6             	mov    %rdx,%rsi
  80e085:	48 89 c7             	mov    %rax,%rdi
  80e088:	48 b8 4b df 80 00 00 	movabs $0x80df4b,%rax
  80e08f:	00 00 00 
  80e092:	ff d0                	callq  *%rax
  /* t is now referenced by h */
  pbuf_ref(t);
  80e094:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e098:	48 89 c7             	mov    %rax,%rdi
  80e09b:	48 b8 23 df 80 00 00 	movabs $0x80df23,%rax
  80e0a2:	00 00 00 
  80e0a5:	ff d0                	callq  *%rax
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
  80e0a7:	c9                   	leaveq 
  80e0a8:	c3                   	retq   

000000000080e0a9 <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  80e0a9:	55                   	push   %rbp
  80e0aa:	48 89 e5             	mov    %rsp,%rbp
  80e0ad:	48 83 ec 20          	sub    $0x20,%rsp
  80e0b1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct pbuf *q;
  u8_t tail_gone = 1;
  80e0b5:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
  /* tail */
  q = p->next;
  80e0b9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e0bd:	48 8b 00             	mov    (%rax),%rax
  80e0c0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  /* pbuf has successor in chain? */
  if (q != NULL) {
  80e0c4:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80e0c9:	0f 84 9e 00 00 00    	je     80e16d <pbuf_dechain+0xc4>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  80e0cf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e0d3:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80e0d7:	0f b7 d0             	movzwl %ax,%edx
  80e0da:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e0de:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80e0e2:	0f b7 c8             	movzwl %ax,%ecx
  80e0e5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e0e9:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e0ed:	0f b7 c0             	movzwl %ax,%eax
  80e0f0:	29 c1                	sub    %eax,%ecx
  80e0f2:	89 c8                	mov    %ecx,%eax
  80e0f4:	39 c2                	cmp    %eax,%edx
  80e0f6:	74 2a                	je     80e122 <pbuf_dechain+0x79>
  80e0f8:	48 ba 20 22 82 00 00 	movabs $0x822220,%rdx
  80e0ff:	00 00 00 
  80e102:	be 81 02 00 00       	mov    $0x281,%esi
  80e107:	48 bf cb 1f 82 00 00 	movabs $0x821fcb,%rdi
  80e10e:	00 00 00 
  80e111:	b8 00 00 00 00       	mov    $0x0,%eax
  80e116:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80e11d:	00 00 00 
  80e120:	ff d1                	callq  *%rcx
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
  80e122:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e126:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80e12a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e12e:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e132:	29 c2                	sub    %eax,%edx
  80e134:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e138:	66 89 50 10          	mov    %dx,0x10(%rax)
    /* decouple pbuf from remainder */
    p->next = NULL;
  80e13c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e140:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
  80e147:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e14b:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80e14f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e153:	66 89 50 10          	mov    %dx,0x10(%rax)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
  80e157:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e15b:	48 89 c7             	mov    %rax,%rdi
  80e15e:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  80e165:	00 00 00 
  80e168:	ff d0                	callq  *%rax
  80e16a:	88 45 ff             	mov    %al,-0x1(%rbp)
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  80e16d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e171:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80e175:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e179:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e17d:	66 39 c2             	cmp    %ax,%dx
  80e180:	74 2a                	je     80e1ac <pbuf_dechain+0x103>
  80e182:	48 ba 42 22 82 00 00 	movabs $0x822242,%rdx
  80e189:	00 00 00 
  80e18c:	be 92 02 00 00       	mov    $0x292,%esi
  80e191:	48 bf cb 1f 82 00 00 	movabs $0x821fcb,%rdi
  80e198:	00 00 00 
  80e19b:	b8 00 00 00 00       	mov    $0x0,%eax
  80e1a0:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80e1a7:	00 00 00 
  80e1aa:	ff d1                	callq  *%rcx
  return ((tail_gone > 0) ? NULL : q);
  80e1ac:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80e1b0:	75 06                	jne    80e1b8 <pbuf_dechain+0x10f>
  80e1b2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e1b6:	eb 05                	jmp    80e1bd <pbuf_dechain+0x114>
  80e1b8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80e1bd:	c9                   	leaveq 
  80e1be:	c3                   	retq   

000000000080e1bf <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
  80e1bf:	55                   	push   %rbp
  80e1c0:	48 89 e5             	mov    %rsp,%rbp
  80e1c3:	48 83 ec 20          	sub    $0x20,%rsp
  80e1c7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80e1cb:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  u16_t offset_to=0, offset_from=0, len;
  80e1cf:	66 c7 45 fe 00 00    	movw   $0x0,-0x2(%rbp)
  80e1d5:	66 c7 45 fc 00 00    	movw   $0x0,-0x4(%rbp)

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  80e1db:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e1e0:	74 1c                	je     80e1fe <pbuf_copy+0x3f>
  80e1e2:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80e1e7:	74 15                	je     80e1fe <pbuf_copy+0x3f>
  80e1e9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e1ed:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80e1f1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e1f5:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80e1f9:	66 39 c2             	cmp    %ax,%dx
  80e1fc:	73 2a                	jae    80e228 <pbuf_copy+0x69>
  80e1fe:	48 ba 58 22 82 00 00 	movabs $0x822258,%rdx
  80e205:	00 00 00 
  80e208:	be b2 02 00 00       	mov    $0x2b2,%esi
  80e20d:	48 bf cb 1f 82 00 00 	movabs $0x821fcb,%rdi
  80e214:	00 00 00 
  80e217:	b8 00 00 00 00       	mov    $0x0,%eax
  80e21c:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80e223:	00 00 00 
  80e226:	ff d1                	callq  *%rcx
             (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);

  /* iterate through pbuf chain */
  do
  {
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
  80e228:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e22d:	75 2a                	jne    80e259 <pbuf_copy+0x9a>
  80e22f:	48 ba 88 22 82 00 00 	movabs $0x822288,%rdx
  80e236:	00 00 00 
  80e239:	be b7 02 00 00       	mov    $0x2b7,%esi
  80e23e:	48 bf cb 1f 82 00 00 	movabs $0x821fcb,%rdi
  80e245:	00 00 00 
  80e248:	b8 00 00 00 00       	mov    $0x0,%eax
  80e24d:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80e254:	00 00 00 
  80e257:	ff d1                	callq  *%rcx
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
  80e259:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e25d:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e261:	0f b7 d0             	movzwl %ax,%edx
  80e264:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  80e268:	89 d1                	mov    %edx,%ecx
  80e26a:	29 c1                	sub    %eax,%ecx
  80e26c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e270:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e274:	0f b7 d0             	movzwl %ax,%edx
  80e277:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
  80e27b:	29 c2                	sub    %eax,%edx
  80e27d:	89 d0                	mov    %edx,%eax
  80e27f:	39 c1                	cmp    %eax,%ecx
  80e281:	7c 12                	jl     80e295 <pbuf_copy+0xd6>
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
  80e283:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e287:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e28b:	66 2b 45 fc          	sub    -0x4(%rbp),%ax
  80e28f:	66 89 45 fa          	mov    %ax,-0x6(%rbp)
  80e293:	eb 10                	jmp    80e2a5 <pbuf_copy+0xe6>
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
  80e295:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e299:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e29d:	66 2b 45 fe          	sub    -0x2(%rbp),%ax
  80e2a1:	66 89 45 fa          	mov    %ax,-0x6(%rbp)
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
  80e2a5:	0f b7 45 fa          	movzwl -0x6(%rbp),%eax
  80e2a9:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80e2ad:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80e2b1:	0f b7 55 fc          	movzwl -0x4(%rbp),%edx
  80e2b5:	48 8d 34 11          	lea    (%rcx,%rdx,1),%rsi
  80e2b9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80e2bd:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80e2c1:	0f b7 55 fe          	movzwl -0x2(%rbp),%edx
  80e2c5:	48 01 d1             	add    %rdx,%rcx
  80e2c8:	48 89 c2             	mov    %rax,%rdx
  80e2cb:	48 89 cf             	mov    %rcx,%rdi
  80e2ce:	48 b8 12 23 80 00 00 	movabs $0x802312,%rax
  80e2d5:	00 00 00 
  80e2d8:	ff d0                	callq  *%rax
    offset_to += len;
  80e2da:	0f b7 45 fa          	movzwl -0x6(%rbp),%eax
  80e2de:	66 01 45 fe          	add    %ax,-0x2(%rbp)
    offset_from += len;
  80e2e2:	0f b7 45 fa          	movzwl -0x6(%rbp),%eax
  80e2e6:	66 01 45 fc          	add    %ax,-0x4(%rbp)
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  80e2ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e2ee:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e2f2:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  80e2f6:	73 2a                	jae    80e322 <pbuf_copy+0x163>
  80e2f8:	48 ba 95 22 82 00 00 	movabs $0x822295,%rdx
  80e2ff:	00 00 00 
  80e302:	be c3 02 00 00       	mov    $0x2c3,%esi
  80e307:	48 bf cb 1f 82 00 00 	movabs $0x821fcb,%rdi
  80e30e:	00 00 00 
  80e311:	b8 00 00 00 00       	mov    $0x0,%eax
  80e316:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80e31d:	00 00 00 
  80e320:	ff d1                	callq  *%rcx
    if (offset_to == p_to->len) {
  80e322:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e326:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e32a:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  80e32e:	75 11                	jne    80e341 <pbuf_copy+0x182>
      /* on to next p_to (if any) */
      offset_to = 0;
  80e330:	66 c7 45 fe 00 00    	movw   $0x0,-0x2(%rbp)
      p_to = p_to->next;
  80e336:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e33a:	48 8b 00             	mov    (%rax),%rax
  80e33d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  80e341:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e345:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e349:	66 3b 45 fc          	cmp    -0x4(%rbp),%ax
  80e34d:	73 2a                	jae    80e379 <pbuf_copy+0x1ba>
  80e34f:	48 ba ac 22 82 00 00 	movabs $0x8222ac,%rdx
  80e356:	00 00 00 
  80e359:	be c9 02 00 00       	mov    $0x2c9,%esi
  80e35e:	48 bf cb 1f 82 00 00 	movabs $0x821fcb,%rdi
  80e365:	00 00 00 
  80e368:	b8 00 00 00 00       	mov    $0x0,%eax
  80e36d:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80e374:	00 00 00 
  80e377:	ff d1                	callq  *%rcx
    if (offset_from >= p_from->len) {
  80e379:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e37d:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e381:	66 3b 45 fc          	cmp    -0x4(%rbp),%ax
  80e385:	77 11                	ja     80e398 <pbuf_copy+0x1d9>
      /* on to next p_from (if any) */
      offset_from = 0;
  80e387:	66 c7 45 fc 00 00    	movw   $0x0,-0x4(%rbp)
      p_from = p_from->next;
  80e38d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e391:	48 8b 00             	mov    (%rax),%rax
  80e394:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  80e398:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80e39d:	74 4b                	je     80e3ea <pbuf_copy+0x22b>
  80e39f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e3a3:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80e3a7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e3ab:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80e3af:	66 39 c2             	cmp    %ax,%dx
  80e3b2:	75 36                	jne    80e3ea <pbuf_copy+0x22b>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  80e3b4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e3b8:	48 8b 00             	mov    (%rax),%rax
  80e3bb:	48 85 c0             	test   %rax,%rax
  80e3be:	74 2a                	je     80e3ea <pbuf_copy+0x22b>
  80e3c0:	48 ba c8 22 82 00 00 	movabs $0x8222c8,%rdx
  80e3c7:	00 00 00 
  80e3ca:	be d3 02 00 00       	mov    $0x2d3,%esi
  80e3cf:	48 bf cb 1f 82 00 00 	movabs $0x821fcb,%rdi
  80e3d6:	00 00 00 
  80e3d9:	b8 00 00 00 00       	mov    $0x0,%eax
  80e3de:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80e3e5:	00 00 00 
  80e3e8:	ff d1                	callq  *%rcx
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  80e3ea:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e3ef:	74 4b                	je     80e43c <pbuf_copy+0x27d>
  80e3f1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e3f5:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80e3f9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e3fd:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80e401:	66 39 c2             	cmp    %ax,%dx
  80e404:	75 36                	jne    80e43c <pbuf_copy+0x27d>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  80e406:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e40a:	48 8b 00             	mov    (%rax),%rax
  80e40d:	48 85 c0             	test   %rax,%rax
  80e410:	74 2a                	je     80e43c <pbuf_copy+0x27d>
  80e412:	48 ba c8 22 82 00 00 	movabs $0x8222c8,%rdx
  80e419:	00 00 00 
  80e41c:	be d8 02 00 00       	mov    $0x2d8,%esi
  80e421:	48 bf cb 1f 82 00 00 	movabs $0x821fcb,%rdi
  80e428:	00 00 00 
  80e42b:	b8 00 00 00 00       	mov    $0x0,%eax
  80e430:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80e437:	00 00 00 
  80e43a:	ff d1                	callq  *%rcx
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  80e43c:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80e441:	0f 85 e1 fd ff ff    	jne    80e228 <pbuf_copy+0x69>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 1, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
  80e447:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80e44c:	c9                   	leaveq 
  80e44d:	c3                   	retq   

000000000080e44e <pbuf_copy_partial>:
 * @param len length of data to copy (dataptr must be big enough)
 * @param offset offset into the packet buffer from where to begin copying len bytes
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
  80e44e:	55                   	push   %rbp
  80e44f:	48 89 e5             	mov    %rsp,%rbp
  80e452:	48 83 ec 30          	sub    $0x30,%rsp
  80e456:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80e45a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80e45e:	89 c8                	mov    %ecx,%eax
  80e460:	66 89 55 dc          	mov    %dx,-0x24(%rbp)
  80e464:	66 89 45 d8          	mov    %ax,-0x28(%rbp)
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;
  80e468:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%rbp)

  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  80e46e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e473:	75 2a                	jne    80e49f <pbuf_copy_partial+0x51>
  80e475:	48 ba f8 22 82 00 00 	movabs $0x8222f8,%rdx
  80e47c:	00 00 00 
  80e47f:	be f0 02 00 00       	mov    $0x2f0,%esi
  80e484:	48 bf cb 1f 82 00 00 	movabs $0x821fcb,%rdi
  80e48b:	00 00 00 
  80e48e:	b8 00 00 00 00       	mov    $0x0,%eax
  80e493:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80e49a:	00 00 00 
  80e49d:	ff d1                	callq  *%rcx
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  80e49f:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80e4a4:	75 2a                	jne    80e4d0 <pbuf_copy_partial+0x82>
  80e4a6:	48 ba 20 23 82 00 00 	movabs $0x822320,%rdx
  80e4ad:	00 00 00 
  80e4b0:	be f1 02 00 00       	mov    $0x2f1,%esi
  80e4b5:	48 bf cb 1f 82 00 00 	movabs $0x821fcb,%rdi
  80e4bc:	00 00 00 
  80e4bf:	b8 00 00 00 00       	mov    $0x0,%eax
  80e4c4:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80e4cb:	00 00 00 
  80e4ce:	ff d1                	callq  *%rcx

  left = 0;
  80e4d0:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%rbp)

  if((buf == NULL) || (dataptr == NULL)) {
  80e4d6:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e4db:	74 07                	je     80e4e4 <pbuf_copy_partial+0x96>
  80e4dd:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80e4e2:	75 0a                	jne    80e4ee <pbuf_copy_partial+0xa0>
    return 0;
  80e4e4:	b8 00 00 00 00       	mov    $0x0,%eax
  80e4e9:	e9 c2 00 00 00       	jmpq   80e5b0 <pbuf_copy_partial+0x162>
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  80e4ee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e4f2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80e4f6:	e9 9f 00 00 00       	jmpq   80e59a <pbuf_copy_partial+0x14c>
    if ((offset != 0) && (offset >= p->len)) {
  80e4fb:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%rbp)
  80e500:	74 1c                	je     80e51e <pbuf_copy_partial+0xd0>
  80e502:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e506:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e50a:	66 3b 45 d8          	cmp    -0x28(%rbp),%ax
  80e50e:	77 0e                	ja     80e51e <pbuf_copy_partial+0xd0>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
  80e510:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e514:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e518:	66 29 45 d8          	sub    %ax,-0x28(%rbp)
  80e51c:	eb 71                	jmp    80e58f <pbuf_copy_partial+0x141>
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
  80e51e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e522:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e526:	66 2b 45 d8          	sub    -0x28(%rbp),%ax
  80e52a:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
      if (buf_copy_len > len)
  80e52e:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80e532:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  80e536:	76 08                	jbe    80e540 <pbuf_copy_partial+0xf2>
          buf_copy_len = len;
  80e538:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  80e53c:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
  80e540:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80e544:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80e548:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80e54c:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  80e550:	48 8d 34 11          	lea    (%rcx,%rdx,1),%rsi
  80e554:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  80e558:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80e55c:	48 01 d1             	add    %rdx,%rcx
  80e55f:	48 89 c2             	mov    %rax,%rdx
  80e562:	48 89 cf             	mov    %rcx,%rdi
  80e565:	48 b8 12 23 80 00 00 	movabs $0x802312,%rax
  80e56c:	00 00 00 
  80e56f:	ff d0                	callq  *%rax
      copied_total += buf_copy_len;
  80e571:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80e575:	66 01 45 f2          	add    %ax,-0xe(%rbp)
      left += buf_copy_len;
  80e579:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80e57d:	66 01 45 f6          	add    %ax,-0xa(%rbp)
      len -= buf_copy_len;
  80e581:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80e585:	66 29 45 dc          	sub    %ax,-0x24(%rbp)
      offset = 0;
  80e589:	66 c7 45 d8 00 00    	movw   $0x0,-0x28(%rbp)
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  80e58f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e593:	48 8b 00             	mov    (%rax),%rax
  80e596:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80e59a:	66 83 7d dc 00       	cmpw   $0x0,-0x24(%rbp)
  80e59f:	74 0b                	je     80e5ac <pbuf_copy_partial+0x15e>
  80e5a1:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80e5a6:	0f 85 4f ff ff ff    	jne    80e4fb <pbuf_copy_partial+0xad>
      left += buf_copy_len;
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
  80e5ac:	0f b7 45 f2          	movzwl -0xe(%rbp),%eax
}
  80e5b0:	c9                   	leaveq 
  80e5b1:	c3                   	retq   

000000000080e5b2 <sys_mbox_fetch>:
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
void
sys_mbox_fetch(sys_mbox_t mbox, void **msg)
{
  80e5b2:	55                   	push   %rbp
  80e5b3:	48 89 e5             	mov    %rsp,%rbp
  80e5b6:	48 83 ec 40          	sub    $0x40,%rsp
  80e5ba:	89 7d cc             	mov    %edi,-0x34(%rbp)
  80e5bd:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  struct sys_timeo *tmptimeout;
  sys_timeout_handler h;
  void *arg;

 again:
  timeouts = sys_arch_timeouts();
  80e5c1:	48 b8 58 88 81 00 00 	movabs $0x818858,%rax
  80e5c8:	00 00 00 
  80e5cb:	ff d0                	callq  *%rax
  80e5cd:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

  if (!timeouts || !timeouts->next) {
  80e5d1:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80e5d6:	74 0c                	je     80e5e4 <sys_mbox_fetch+0x32>
  80e5d8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e5dc:	48 8b 00             	mov    (%rax),%rax
  80e5df:	48 85 c0             	test   %rax,%rax
  80e5e2:	75 25                	jne    80e609 <sys_mbox_fetch+0x57>
    UNLOCK_TCPIP_CORE();
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
  80e5e4:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  80e5e8:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80e5eb:	ba 00 00 00 00       	mov    $0x0,%edx
  80e5f0:	48 89 ce             	mov    %rcx,%rsi
  80e5f3:	89 c7                	mov    %eax,%edi
  80e5f5:	48 b8 73 83 81 00 00 	movabs $0x818373,%rax
  80e5fc:	00 00 00 
  80e5ff:	ff d0                	callq  *%rax
  80e601:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80e604:	e9 e1 00 00 00       	jmpq   80e6ea <sys_mbox_fetch+0x138>
    LOCK_TCPIP_CORE();
  } else {
    if (timeouts->next->time > 0) {
  80e609:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e60d:	48 8b 00             	mov    (%rax),%rax
  80e610:	8b 40 08             	mov    0x8(%rax),%eax
  80e613:	85 c0                	test   %eax,%eax
  80e615:	74 27                	je     80e63e <sys_mbox_fetch+0x8c>
      UNLOCK_TCPIP_CORE();
      time_needed = sys_arch_mbox_fetch(mbox, msg, timeouts->next->time);
  80e617:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e61b:	48 8b 00             	mov    (%rax),%rax
  80e61e:	8b 50 08             	mov    0x8(%rax),%edx
  80e621:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  80e625:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80e628:	48 89 ce             	mov    %rcx,%rsi
  80e62b:	89 c7                	mov    %eax,%edi
  80e62d:	48 b8 73 83 81 00 00 	movabs $0x818373,%rax
  80e634:	00 00 00 
  80e637:	ff d0                	callq  *%rax
  80e639:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80e63c:	eb 07                	jmp    80e645 <sys_mbox_fetch+0x93>
      LOCK_TCPIP_CORE();
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
  80e63e:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  80e645:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  80e649:	75 69                	jne    80e6b4 <sys_mbox_fetch+0x102>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
         could be fetched. We should now call the timeout handler and
         deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  80e64b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e64f:	48 8b 00             	mov    (%rax),%rax
  80e652:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      timeouts->next = tmptimeout->next;
  80e656:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e65a:	48 8b 10             	mov    (%rax),%rdx
  80e65d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e661:	48 89 10             	mov    %rdx,(%rax)
      h   = tmptimeout->h;
  80e664:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e668:	48 8b 40 10          	mov    0x10(%rax),%rax
  80e66c:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
      arg = tmptimeout->arg;
  80e670:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e674:	48 8b 40 18          	mov    0x18(%rax),%rax
  80e678:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  80e67c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e680:	48 89 c6             	mov    %rax,%rsi
  80e683:	bf 0b 00 00 00       	mov    $0xb,%edi
  80e688:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  80e68f:	00 00 00 
  80e692:	ff d0                	callq  *%rax
      if (h != NULL) {
  80e694:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80e698:	48 85 c0             	test   %rax,%rax
  80e69b:	74 12                	je     80e6af <sys_mbox_fetch+0xfd>
        LWIP_DEBUGF(SYS_DEBUG, ("smf calling h=%p(%p)\n", (void*)&h, arg));
        h(arg);
  80e69d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80e6a1:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80e6a5:	48 89 d7             	mov    %rdx,%rdi
  80e6a8:	ff d0                	callq  *%rax
      }

      /* We try again to fetch a message from the mbox. */
      goto again;
  80e6aa:	e9 12 ff ff ff       	jmpq   80e5c1 <sys_mbox_fetch+0xf>
  80e6af:	e9 0d ff ff ff       	jmpq   80e5c1 <sys_mbox_fetch+0xf>
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  80e6b4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e6b8:	48 8b 00             	mov    (%rax),%rax
  80e6bb:	8b 40 08             	mov    0x8(%rax),%eax
  80e6be:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80e6c1:	76 19                	jbe    80e6dc <sys_mbox_fetch+0x12a>
        timeouts->next->time -= time_needed;
  80e6c3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e6c7:	48 8b 00             	mov    (%rax),%rax
  80e6ca:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e6ce:	48 8b 12             	mov    (%rdx),%rdx
  80e6d1:	8b 52 08             	mov    0x8(%rdx),%edx
  80e6d4:	2b 55 fc             	sub    -0x4(%rbp),%edx
  80e6d7:	89 50 08             	mov    %edx,0x8(%rax)
  80e6da:	eb 0e                	jmp    80e6ea <sys_mbox_fetch+0x138>
      } else {
        timeouts->next->time = 0;
  80e6dc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e6e0:	48 8b 00             	mov    (%rax),%rax
  80e6e3:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
      }
    }
  }
}
  80e6ea:	c9                   	leaveq 
  80e6eb:	c3                   	retq   

000000000080e6ec <sys_sem_wait>:
 *
 * @param sem semaphore to wait for
 */
void
sys_sem_wait(sys_sem_t sem)
{
  80e6ec:	55                   	push   %rbp
  80e6ed:	48 89 e5             	mov    %rsp,%rbp
  80e6f0:	48 83 ec 40          	sub    $0x40,%rsp
  80e6f4:	89 7d cc             	mov    %edi,-0x34(%rbp)
  sys_timeout_handler h;
  void *arg;

 again:

  timeouts = sys_arch_timeouts();
  80e6f7:	48 b8 58 88 81 00 00 	movabs $0x818858,%rax
  80e6fe:	00 00 00 
  80e701:	ff d0                	callq  *%rax
  80e703:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

  if (!timeouts || !timeouts->next) {
  80e707:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80e70c:	74 0c                	je     80e71a <sys_sem_wait+0x2e>
  80e70e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e712:	48 8b 00             	mov    (%rax),%rax
  80e715:	48 85 c0             	test   %rax,%rax
  80e718:	75 1b                	jne    80e735 <sys_sem_wait+0x49>
    sys_arch_sem_wait(sem, 0);
  80e71a:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80e71d:	be 00 00 00 00       	mov    $0x0,%esi
  80e722:	89 c7                	mov    %eax,%edi
  80e724:	48 b8 4d 81 81 00 00 	movabs $0x81814d,%rax
  80e72b:	00 00 00 
  80e72e:	ff d0                	callq  *%rax
  80e730:	e9 dc 00 00 00       	jmpq   80e811 <sys_sem_wait+0x125>
  } else {
    if (timeouts->next->time > 0) {
  80e735:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e739:	48 8b 00             	mov    (%rax),%rax
  80e73c:	8b 40 08             	mov    0x8(%rax),%eax
  80e73f:	85 c0                	test   %eax,%eax
  80e741:	74 22                	je     80e765 <sys_sem_wait+0x79>
      time_needed = sys_arch_sem_wait(sem, timeouts->next->time);
  80e743:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e747:	48 8b 00             	mov    (%rax),%rax
  80e74a:	8b 50 08             	mov    0x8(%rax),%edx
  80e74d:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80e750:	89 d6                	mov    %edx,%esi
  80e752:	89 c7                	mov    %eax,%edi
  80e754:	48 b8 4d 81 81 00 00 	movabs $0x81814d,%rax
  80e75b:	00 00 00 
  80e75e:	ff d0                	callq  *%rax
  80e760:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80e763:	eb 07                	jmp    80e76c <sys_sem_wait+0x80>
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
  80e765:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  80e76c:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  80e770:	75 69                	jne    80e7db <sys_sem_wait+0xef>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
        could be fetched. We should now call the timeout handler and
        deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  80e772:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e776:	48 8b 00             	mov    (%rax),%rax
  80e779:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      timeouts->next = tmptimeout->next;
  80e77d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e781:	48 8b 10             	mov    (%rax),%rdx
  80e784:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e788:	48 89 10             	mov    %rdx,(%rax)
      h = tmptimeout->h;
  80e78b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e78f:	48 8b 40 10          	mov    0x10(%rax),%rax
  80e793:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
      arg = tmptimeout->arg;
  80e797:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e79b:	48 8b 40 18          	mov    0x18(%rax),%rax
  80e79f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  80e7a3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e7a7:	48 89 c6             	mov    %rax,%rsi
  80e7aa:	bf 0b 00 00 00       	mov    $0xb,%edi
  80e7af:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  80e7b6:	00 00 00 
  80e7b9:	ff d0                	callq  *%rax
      if (h != NULL) {
  80e7bb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80e7bf:	48 85 c0             	test   %rax,%rax
  80e7c2:	74 12                	je     80e7d6 <sys_sem_wait+0xea>
        LWIP_DEBUGF(SYS_DEBUG, ("ssw h=%p(%p)\n", (void*)&h, (void *)arg));
        h(arg);
  80e7c4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80e7c8:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80e7cc:	48 89 d7             	mov    %rdx,%rdi
  80e7cf:	ff d0                	callq  *%rax
      }

      /* We try again to fetch a message from the mbox. */
      goto again;
  80e7d1:	e9 21 ff ff ff       	jmpq   80e6f7 <sys_sem_wait+0xb>
  80e7d6:	e9 1c ff ff ff       	jmpq   80e6f7 <sys_sem_wait+0xb>
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  80e7db:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e7df:	48 8b 00             	mov    (%rax),%rax
  80e7e2:	8b 40 08             	mov    0x8(%rax),%eax
  80e7e5:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80e7e8:	76 19                	jbe    80e803 <sys_sem_wait+0x117>
        timeouts->next->time -= time_needed;
  80e7ea:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e7ee:	48 8b 00             	mov    (%rax),%rax
  80e7f1:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e7f5:	48 8b 12             	mov    (%rdx),%rdx
  80e7f8:	8b 52 08             	mov    0x8(%rdx),%edx
  80e7fb:	2b 55 fc             	sub    -0x4(%rbp),%edx
  80e7fe:	89 50 08             	mov    %edx,0x8(%rax)
  80e801:	eb 0e                	jmp    80e811 <sys_sem_wait+0x125>
      } else {
        timeouts->next->time = 0;
  80e803:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e807:	48 8b 00             	mov    (%rax),%rax
  80e80a:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
      }
    }
  }
}
  80e811:	c9                   	leaveq 
  80e812:	c3                   	retq   

000000000080e813 <sys_timeout>:
 * @param h callback function to call when msecs have elapsed
 * @param arg argument to pass to the callback function
 */
void
sys_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  80e813:	55                   	push   %rbp
  80e814:	48 89 e5             	mov    %rsp,%rbp
  80e817:	48 83 ec 40          	sub    $0x40,%rsp
  80e81b:	89 7d dc             	mov    %edi,-0x24(%rbp)
  80e81e:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80e822:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  struct sys_timeouts *timeouts;
  struct sys_timeo *timeout, *t;

  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  80e826:	bf 0b 00 00 00       	mov    $0xb,%edi
  80e82b:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  80e832:	00 00 00 
  80e835:	ff d0                	callq  *%rax
  80e837:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (timeout == NULL) {
  80e83b:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80e840:	75 36                	jne    80e878 <sys_timeout+0x65>
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
  80e842:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80e847:	75 2a                	jne    80e873 <sys_timeout+0x60>
  80e849:	48 ba 48 23 82 00 00 	movabs $0x822348,%rdx
  80e850:	00 00 00 
  80e853:	be c4 00 00 00       	mov    $0xc4,%esi
  80e858:	48 bf 65 23 82 00 00 	movabs $0x822365,%rdi
  80e85f:	00 00 00 
  80e862:	b8 00 00 00 00       	mov    $0x0,%eax
  80e867:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80e86e:	00 00 00 
  80e871:	ff d1                	callq  *%rcx
    return;
  80e873:	e9 7e 01 00 00       	jmpq   80e9f6 <sys_timeout+0x1e3>
  }
  timeout->next = NULL;
  80e878:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e87c:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  timeout->h = h;
  80e883:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80e887:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e88b:	48 89 50 10          	mov    %rdx,0x10(%rax)
  timeout->arg = arg;
  80e88f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e893:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80e897:	48 89 50 18          	mov    %rdx,0x18(%rax)
  timeout->time = msecs;
  80e89b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e89f:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80e8a2:	89 50 08             	mov    %edx,0x8(%rax)

  timeouts = sys_arch_timeouts();
  80e8a5:	48 b8 58 88 81 00 00 	movabs $0x818858,%rax
  80e8ac:	00 00 00 
  80e8af:	ff d0                	callq  *%rax
  80e8b1:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

  LWIP_DEBUGF(SYS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" h=%p arg=%p\n",
    (void *)timeout, msecs, (void*)&h, (void *)arg));

  if (timeouts == NULL) {
  80e8b5:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e8ba:	75 36                	jne    80e8f2 <sys_timeout+0xdf>
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
  80e8bc:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e8c1:	75 2a                	jne    80e8ed <sys_timeout+0xda>
  80e8c3:	48 ba 79 23 82 00 00 	movabs $0x822379,%rdx
  80e8ca:	00 00 00 
  80e8cd:	be d2 00 00 00       	mov    $0xd2,%esi
  80e8d2:	48 bf 65 23 82 00 00 	movabs $0x822365,%rdi
  80e8d9:	00 00 00 
  80e8dc:	b8 00 00 00 00       	mov    $0x0,%eax
  80e8e1:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80e8e8:	00 00 00 
  80e8eb:	ff d1                	callq  *%rcx
    return;
  80e8ed:	e9 04 01 00 00       	jmpq   80e9f6 <sys_timeout+0x1e3>
  }

  if (timeouts->next == NULL) {
  80e8f2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e8f6:	48 8b 00             	mov    (%rax),%rax
  80e8f9:	48 85 c0             	test   %rax,%rax
  80e8fc:	75 10                	jne    80e90e <sys_timeout+0xfb>
    timeouts->next = timeout;
  80e8fe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e902:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e906:	48 89 10             	mov    %rdx,(%rax)
    return;
  80e909:	e9 e8 00 00 00       	jmpq   80e9f6 <sys_timeout+0x1e3>
  }

  if (timeouts->next->time > msecs) {
  80e90e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e912:	48 8b 00             	mov    (%rax),%rax
  80e915:	8b 40 08             	mov    0x8(%rax),%eax
  80e918:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  80e91b:	76 35                	jbe    80e952 <sys_timeout+0x13f>
    timeouts->next->time -= msecs;
  80e91d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e921:	48 8b 00             	mov    (%rax),%rax
  80e924:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80e928:	48 8b 12             	mov    (%rdx),%rdx
  80e92b:	8b 52 08             	mov    0x8(%rdx),%edx
  80e92e:	2b 55 dc             	sub    -0x24(%rbp),%edx
  80e931:	89 50 08             	mov    %edx,0x8(%rax)
    timeout->next = timeouts->next;
  80e934:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e938:	48 8b 10             	mov    (%rax),%rdx
  80e93b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e93f:	48 89 10             	mov    %rdx,(%rax)
    timeouts->next = timeout;
  80e942:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e946:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e94a:	48 89 10             	mov    %rdx,(%rax)
  80e94d:	e9 a4 00 00 00       	jmpq   80e9f6 <sys_timeout+0x1e3>
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
  80e952:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e956:	48 8b 00             	mov    (%rax),%rax
  80e959:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80e95d:	e9 89 00 00 00       	jmpq   80e9eb <sys_timeout+0x1d8>
      timeout->time -= t->time;
  80e962:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e966:	8b 50 08             	mov    0x8(%rax),%edx
  80e969:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e96d:	8b 40 08             	mov    0x8(%rax),%eax
  80e970:	29 c2                	sub    %eax,%edx
  80e972:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e976:	89 50 08             	mov    %edx,0x8(%rax)
      if (t->next == NULL || t->next->time > timeout->time) {
  80e979:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e97d:	48 8b 00             	mov    (%rax),%rax
  80e980:	48 85 c0             	test   %rax,%rax
  80e983:	74 15                	je     80e99a <sys_timeout+0x187>
  80e985:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e989:	48 8b 00             	mov    (%rax),%rax
  80e98c:	8b 50 08             	mov    0x8(%rax),%edx
  80e98f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e993:	8b 40 08             	mov    0x8(%rax),%eax
  80e996:	39 c2                	cmp    %eax,%edx
  80e998:	76 46                	jbe    80e9e0 <sys_timeout+0x1cd>
        if (t->next != NULL) {
  80e99a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e99e:	48 8b 00             	mov    (%rax),%rax
  80e9a1:	48 85 c0             	test   %rax,%rax
  80e9a4:	74 1f                	je     80e9c5 <sys_timeout+0x1b2>
          t->next->time -= timeout->time;
  80e9a6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e9aa:	48 8b 00             	mov    (%rax),%rax
  80e9ad:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80e9b1:	48 8b 12             	mov    (%rdx),%rdx
  80e9b4:	8b 4a 08             	mov    0x8(%rdx),%ecx
  80e9b7:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e9bb:	8b 52 08             	mov    0x8(%rdx),%edx
  80e9be:	29 d1                	sub    %edx,%ecx
  80e9c0:	89 ca                	mov    %ecx,%edx
  80e9c2:	89 50 08             	mov    %edx,0x8(%rax)
        }
        timeout->next = t->next;
  80e9c5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e9c9:	48 8b 10             	mov    (%rax),%rdx
  80e9cc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e9d0:	48 89 10             	mov    %rdx,(%rax)
        t->next = timeout;
  80e9d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e9d7:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e9db:	48 89 10             	mov    %rdx,(%rax)
        break;
  80e9de:	eb 16                	jmp    80e9f6 <sys_timeout+0x1e3>
  if (timeouts->next->time > msecs) {
    timeouts->next->time -= msecs;
    timeout->next = timeouts->next;
    timeouts->next = timeout;
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
  80e9e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e9e4:	48 8b 00             	mov    (%rax),%rax
  80e9e7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80e9eb:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80e9f0:	0f 85 6c ff ff ff    	jne    80e962 <sys_timeout+0x14f>
        t->next = timeout;
        break;
      }
    }
  }
}
  80e9f6:	c9                   	leaveq 
  80e9f7:	c3                   	retq   

000000000080e9f8 <sys_untimeout>:
 * @param h callback function that would be called by the timeout
 * @param arg callback argument that would be passed to h
*/
void
sys_untimeout(sys_timeout_handler h, void *arg)
{
  80e9f8:	55                   	push   %rbp
  80e9f9:	48 89 e5             	mov    %rsp,%rbp
  80e9fc:	48 83 ec 30          	sub    $0x30,%rsp
  80ea00:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80ea04:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  struct sys_timeouts *timeouts;
  struct sys_timeo *prev_t, *t;

  timeouts = sys_arch_timeouts();
  80ea08:	48 b8 58 88 81 00 00 	movabs $0x818858,%rax
  80ea0f:	00 00 00 
  80ea12:	ff d0                	callq  *%rax
  80ea14:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

  if (timeouts == NULL) {
  80ea18:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80ea1d:	75 36                	jne    80ea55 <sys_untimeout+0x5d>
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
  80ea1f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80ea24:	75 2a                	jne    80ea50 <sys_untimeout+0x58>
  80ea26:	48 ba 98 23 82 00 00 	movabs $0x822398,%rdx
  80ea2d:	00 00 00 
  80ea30:	be 01 01 00 00       	mov    $0x101,%esi
  80ea35:	48 bf 65 23 82 00 00 	movabs $0x822365,%rdi
  80ea3c:	00 00 00 
  80ea3f:	b8 00 00 00 00       	mov    $0x0,%eax
  80ea44:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80ea4b:	00 00 00 
  80ea4e:	ff d1                	callq  *%rcx
    return;
  80ea50:	e9 cc 00 00 00       	jmpq   80eb21 <sys_untimeout+0x129>
  }
  if (timeouts->next == NULL) {
  80ea55:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ea59:	48 8b 00             	mov    (%rax),%rax
  80ea5c:	48 85 c0             	test   %rax,%rax
  80ea5f:	75 05                	jne    80ea66 <sys_untimeout+0x6e>
    return;
  80ea61:	e9 bb 00 00 00       	jmpq   80eb21 <sys_untimeout+0x129>
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  80ea66:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ea6a:	48 8b 00             	mov    (%rax),%rax
  80ea6d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80ea71:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80ea78:	00 
  80ea79:	e9 97 00 00 00       	jmpq   80eb15 <sys_untimeout+0x11d>
    if ((t->h == h) && (t->arg == arg)) {
  80ea7e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80ea82:	48 8b 40 10          	mov    0x10(%rax),%rax
  80ea86:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  80ea8a:	75 76                	jne    80eb02 <sys_untimeout+0x10a>
  80ea8c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80ea90:	48 8b 40 18          	mov    0x18(%rax),%rax
  80ea94:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80ea98:	75 68                	jne    80eb02 <sys_untimeout+0x10a>
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL)
  80ea9a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80ea9f:	75 10                	jne    80eab1 <sys_untimeout+0xb9>
        timeouts->next = t->next;
  80eaa1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80eaa5:	48 8b 10             	mov    (%rax),%rdx
  80eaa8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80eaac:	48 89 10             	mov    %rdx,(%rax)
  80eaaf:	eb 0e                	jmp    80eabf <sys_untimeout+0xc7>
      else
        prev_t->next = t->next;
  80eab1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80eab5:	48 8b 10             	mov    (%rax),%rdx
  80eab8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80eabc:	48 89 10             	mov    %rdx,(%rax)
      /* If not the last one, add time of this one back to next */
      if (t->next != NULL)
  80eabf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80eac3:	48 8b 00             	mov    (%rax),%rax
  80eac6:	48 85 c0             	test   %rax,%rax
  80eac9:	74 1d                	je     80eae8 <sys_untimeout+0xf0>
        t->next->time += t->time;
  80eacb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80eacf:	48 8b 00             	mov    (%rax),%rax
  80ead2:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80ead6:	48 8b 12             	mov    (%rdx),%rdx
  80ead9:	8b 4a 08             	mov    0x8(%rdx),%ecx
  80eadc:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80eae0:	8b 52 08             	mov    0x8(%rdx),%edx
  80eae3:	01 ca                	add    %ecx,%edx
  80eae5:	89 50 08             	mov    %edx,0x8(%rax)
      memp_free(MEMP_SYS_TIMEOUT, t);
  80eae8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80eaec:	48 89 c6             	mov    %rax,%rsi
  80eaef:	bf 0b 00 00 00       	mov    $0xb,%edi
  80eaf4:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  80eafb:	00 00 00 
  80eafe:	ff d0                	callq  *%rax
      return;
  80eb00:	eb 1f                	jmp    80eb21 <sys_untimeout+0x129>
  }
  if (timeouts->next == NULL) {
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  80eb02:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80eb06:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80eb0a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80eb0e:	48 8b 00             	mov    (%rax),%rax
  80eb11:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80eb15:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80eb1a:	0f 85 5e ff ff ff    	jne    80ea7e <sys_untimeout+0x86>
        t->next->time += t->time;
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
  80eb20:	90                   	nop
}
  80eb21:	c9                   	leaveq 
  80eb22:	c3                   	retq   

000000000080eb23 <sswt_handler>:
 *
 * @param arg struct sswt_cb* used to signal a semaphore and end waiting.
 */
static void
sswt_handler(void *arg)
{
  80eb23:	55                   	push   %rbp
  80eb24:	48 89 e5             	mov    %rsp,%rbp
  80eb27:	48 83 ec 20          	sub    $0x20,%rsp
  80eb2b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct sswt_cb *sswt_cb = (struct sswt_cb *) arg;
  80eb2f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80eb33:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  /* Timeout. Set flag to TRUE and signal semaphore */
  sswt_cb->timeflag = 1;
  80eb37:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80eb3b:	66 c7 00 01 00       	movw   $0x1,(%rax)
  sys_sem_signal(*(sswt_cb->psem));
  80eb40:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80eb44:	48 8b 40 08          	mov    0x8(%rax),%rax
  80eb48:	8b 00                	mov    (%rax),%eax
  80eb4a:	89 c7                	mov    %eax,%edi
  80eb4c:	48 b8 4c 80 81 00 00 	movabs $0x81804c,%rax
  80eb53:	00 00 00 
  80eb56:	ff d0                	callq  *%rax
}
  80eb58:	c9                   	leaveq 
  80eb59:	c3                   	retq   

000000000080eb5a <sys_sem_wait_timeout>:
 * @param timeout timeout in ms (0: wait forever)
 * @return 0 on timeout, 1 otherwise
 */
int
sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout)
{
  80eb5a:	55                   	push   %rbp
  80eb5b:	48 89 e5             	mov    %rsp,%rbp
  80eb5e:	48 83 ec 20          	sub    $0x20,%rsp
  80eb62:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80eb65:	89 75 e8             	mov    %esi,-0x18(%rbp)
  struct sswt_cb sswt_cb;

  sswt_cb.psem = &sem;
  80eb68:	48 8d 45 ec          	lea    -0x14(%rbp),%rax
  80eb6c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  sswt_cb.timeflag = 0;
  80eb70:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%rbp)

  /* If timeout is zero, then just wait forever */
  if (timeout > 0) {
  80eb76:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  80eb7a:	74 1f                	je     80eb9b <sys_sem_wait_timeout+0x41>
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  80eb7c:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  80eb80:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80eb83:	48 be 23 eb 80 00 00 	movabs $0x80eb23,%rsi
  80eb8a:	00 00 00 
  80eb8d:	89 c7                	mov    %eax,%edi
  80eb8f:	48 b8 13 e8 80 00 00 	movabs $0x80e813,%rax
  80eb96:	00 00 00 
  80eb99:	ff d0                	callq  *%rax
  }
  sys_sem_wait(sem);
  80eb9b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80eb9e:	89 c7                	mov    %eax,%edi
  80eba0:	48 b8 ec e6 80 00 00 	movabs $0x80e6ec,%rax
  80eba7:	00 00 00 
  80ebaa:	ff d0                	callq  *%rax
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  80ebac:	0f b7 45 f0          	movzwl -0x10(%rbp),%eax
  80ebb0:	66 85 c0             	test   %ax,%ax
  80ebb3:	74 07                	je     80ebbc <sys_sem_wait_timeout+0x62>
    /* timeout */
    return 0;
  80ebb5:	b8 00 00 00 00       	mov    $0x0,%eax
  80ebba:	eb 22                	jmp    80ebde <sys_sem_wait_timeout+0x84>
  } else {
    /* Not a timeout. Remove timeout entry */
    sys_untimeout(sswt_handler, &sswt_cb);
  80ebbc:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  80ebc0:	48 89 c6             	mov    %rax,%rsi
  80ebc3:	48 bf 23 eb 80 00 00 	movabs $0x80eb23,%rdi
  80ebca:	00 00 00 
  80ebcd:	48 b8 f8 e9 80 00 00 	movabs $0x80e9f8,%rax
  80ebd4:	00 00 00 
  80ebd7:	ff d0                	callq  *%rax
    return 1;
  80ebd9:	b8 01 00 00 00       	mov    $0x1,%eax
  }
}
  80ebde:	c9                   	leaveq 
  80ebdf:	c3                   	retq   

000000000080ebe0 <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
  80ebe0:	55                   	push   %rbp
  80ebe1:	48 89 e5             	mov    %rsp,%rbp
  80ebe4:	48 83 ec 20          	sub    $0x20,%rsp
  80ebe8:	89 7d ec             	mov    %edi,-0x14(%rbp)
  sys_sem_t delaysem = sys_sem_new(0);
  80ebeb:	bf 00 00 00 00       	mov    $0x0,%edi
  80ebf0:	48 b8 cc 7d 81 00 00 	movabs $0x817dcc,%rax
  80ebf7:	00 00 00 
  80ebfa:	ff d0                	callq  *%rax
  80ebfc:	89 45 fc             	mov    %eax,-0x4(%rbp)

  sys_sem_wait_timeout(delaysem, ms);
  80ebff:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80ec02:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80ec05:	89 d6                	mov    %edx,%esi
  80ec07:	89 c7                	mov    %eax,%edi
  80ec09:	48 b8 5a eb 80 00 00 	movabs $0x80eb5a,%rax
  80ec10:	00 00 00 
  80ec13:	ff d0                	callq  *%rax

  sys_sem_free(delaysem);
  80ec15:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80ec18:	89 c7                	mov    %eax,%edi
  80ec1a:	48 b8 ca 7e 81 00 00 	movabs $0x817eca,%rax
  80ec21:	00 00 00 
  80ec24:	ff d0                	callq  *%rax
}
  80ec26:	c9                   	leaveq 
  80ec27:	c3                   	retq   

000000000080ec28 <tcp_tmr>:
 * Called periodically to dispatch TCP timers.
 *
 */
void
tcp_tmr(void)
{
  80ec28:	55                   	push   %rbp
  80ec29:	48 89 e5             	mov    %rsp,%rbp
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
  80ec2c:	48 b8 1b 03 81 00 00 	movabs $0x81031b,%rax
  80ec33:	00 00 00 
  80ec36:	ff d0                	callq  *%rax

  if (++tcp_timer & 1) {
  80ec38:	48 b8 4c b0 b4 00 00 	movabs $0xb4b04c,%rax
  80ec3f:	00 00 00 
  80ec42:	0f b6 00             	movzbl (%rax),%eax
  80ec45:	8d 50 01             	lea    0x1(%rax),%edx
  80ec48:	48 b8 4c b0 b4 00 00 	movabs $0xb4b04c,%rax
  80ec4f:	00 00 00 
  80ec52:	88 10                	mov    %dl,(%rax)
  80ec54:	48 b8 4c b0 b4 00 00 	movabs $0xb4b04c,%rax
  80ec5b:	00 00 00 
  80ec5e:	0f b6 00             	movzbl (%rax),%eax
  80ec61:	0f b6 c0             	movzbl %al,%eax
  80ec64:	83 e0 01             	and    $0x1,%eax
  80ec67:	85 c0                	test   %eax,%eax
  80ec69:	74 0c                	je     80ec77 <tcp_tmr+0x4f>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
  80ec6b:	48 b8 df fa 80 00 00 	movabs $0x80fadf,%rax
  80ec72:	00 00 00 
  80ec75:	ff d0                	callq  *%rax
  }
}
  80ec77:	5d                   	pop    %rbp
  80ec78:	c3                   	retq   

000000000080ec79 <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
  80ec79:	55                   	push   %rbp
  80ec7a:	48 89 e5             	mov    %rsp,%rbp
  80ec7d:	48 83 ec 20          	sub    $0x20,%rsp
  80ec81:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  switch (pcb->state) {
  80ec85:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ec89:	8b 40 18             	mov    0x18(%rax),%eax
  80ec8c:	83 f8 07             	cmp    $0x7,%eax
  80ec8f:	0f 87 37 02 00 00    	ja     80eecc <tcp_close+0x253>
  80ec95:	89 c0                	mov    %eax,%eax
  80ec97:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80ec9e:	00 
  80ec9f:	48 b8 d0 23 82 00 00 	movabs $0x8223d0,%rax
  80eca6:	00 00 00 
  80eca9:	48 01 d0             	add    %rdx,%rax
  80ecac:	48 8b 00             	mov    (%rax),%rax
  80ecaf:	ff e0                	jmpq   *%rax
     * and the user needs some way to free it should the need arise.
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
  80ecb1:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
    TCP_RMV(&tcp_bound_pcbs, pcb);
  80ecb5:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80ecbc:	00 00 00 
  80ecbf:	48 8b 00             	mov    (%rax),%rax
  80ecc2:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80ecc6:	75 23                	jne    80eceb <tcp_close+0x72>
  80ecc8:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80eccf:	00 00 00 
  80ecd2:	48 8b 00             	mov    (%rax),%rax
  80ecd5:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80ecd9:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80ece0:	00 00 00 
  80ece3:	48 89 10             	mov    %rdx,(%rax)
  80ece6:	e9 94 00 00 00       	jmpq   80ed7f <tcp_close+0x106>
  80eceb:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80ecf2:	00 00 00 
  80ecf5:	48 8b 10             	mov    (%rax),%rdx
  80ecf8:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80ecff:	00 00 00 
  80ed02:	48 89 10             	mov    %rdx,(%rax)
  80ed05:	eb 66                	jmp    80ed6d <tcp_close+0xf4>
  80ed07:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80ed0e:	00 00 00 
  80ed11:	48 8b 00             	mov    (%rax),%rax
  80ed14:	48 8b 40 10          	mov    0x10(%rax),%rax
  80ed18:	48 85 c0             	test   %rax,%rax
  80ed1b:	74 32                	je     80ed4f <tcp_close+0xd6>
  80ed1d:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80ed24:	00 00 00 
  80ed27:	48 8b 00             	mov    (%rax),%rax
  80ed2a:	48 8b 40 10          	mov    0x10(%rax),%rax
  80ed2e:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80ed32:	75 1b                	jne    80ed4f <tcp_close+0xd6>
  80ed34:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80ed3b:	00 00 00 
  80ed3e:	48 8b 00             	mov    (%rax),%rax
  80ed41:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80ed45:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80ed49:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80ed4d:	eb 30                	jmp    80ed7f <tcp_close+0x106>
  80ed4f:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80ed56:	00 00 00 
  80ed59:	48 8b 00             	mov    (%rax),%rax
  80ed5c:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80ed60:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80ed67:	00 00 00 
  80ed6a:	48 89 10             	mov    %rdx,(%rax)
  80ed6d:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80ed74:	00 00 00 
  80ed77:	48 8b 00             	mov    (%rax),%rax
  80ed7a:	48 85 c0             	test   %rax,%rax
  80ed7d:	75 88                	jne    80ed07 <tcp_close+0x8e>
  80ed7f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ed83:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80ed8a:	00 
    memp_free(MEMP_TCP_PCB, pcb);
  80ed8b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ed8f:	48 89 c6             	mov    %rax,%rsi
  80ed92:	bf 02 00 00 00       	mov    $0x2,%edi
  80ed97:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  80ed9e:	00 00 00 
  80eda1:	ff d0                	callq  *%rax
    pcb = NULL;
  80eda3:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80edaa:	00 
    break;
  80edab:	e9 29 01 00 00       	jmpq   80eed9 <tcp_close+0x260>
  case LISTEN:
    err = ERR_OK;
  80edb0:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
  80edb4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80edb8:	48 89 c6             	mov    %rax,%rsi
  80edbb:	48 bf 28 b0 b5 00 00 	movabs $0xb5b028,%rdi
  80edc2:	00 00 00 
  80edc5:	48 b8 a9 0a 81 00 00 	movabs $0x810aa9,%rax
  80edcc:	00 00 00 
  80edcf:	ff d0                	callq  *%rax
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
  80edd1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80edd5:	48 89 c6             	mov    %rax,%rsi
  80edd8:	bf 03 00 00 00       	mov    $0x3,%edi
  80eddd:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  80ede4:	00 00 00 
  80ede7:	ff d0                	callq  *%rax
    pcb = NULL;
  80ede9:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80edf0:	00 
    break;
  80edf1:	e9 e3 00 00 00       	jmpq   80eed9 <tcp_close+0x260>
  case SYN_SENT:
    err = ERR_OK;
  80edf6:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80edfa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80edfe:	48 89 c6             	mov    %rax,%rsi
  80ee01:	48 bf 18 b0 b5 00 00 	movabs $0xb5b018,%rdi
  80ee08:	00 00 00 
  80ee0b:	48 b8 a9 0a 81 00 00 	movabs $0x810aa9,%rax
  80ee12:	00 00 00 
  80ee15:	ff d0                	callq  *%rax
    memp_free(MEMP_TCP_PCB, pcb);
  80ee17:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ee1b:	48 89 c6             	mov    %rax,%rsi
  80ee1e:	bf 02 00 00 00       	mov    $0x2,%edi
  80ee23:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  80ee2a:	00 00 00 
  80ee2d:	ff d0                	callq  *%rax
    pcb = NULL;
  80ee2f:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80ee36:	00 
    snmp_inc_tcpattemptfails();
    break;
  80ee37:	e9 9d 00 00 00       	jmpq   80eed9 <tcp_close+0x260>
  case SYN_RCVD:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  80ee3c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ee40:	be 01 00 00 00       	mov    $0x1,%esi
  80ee45:	48 89 c7             	mov    %rax,%rdi
  80ee48:	48 b8 aa 30 81 00 00 	movabs $0x8130aa,%rax
  80ee4f:	00 00 00 
  80ee52:	ff d0                	callq  *%rax
  80ee54:	88 45 ff             	mov    %al,-0x1(%rbp)
    if (err == ERR_OK) {
  80ee57:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80ee5b:	75 0d                	jne    80ee6a <tcp_close+0x1f1>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
  80ee5d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ee61:	c7 40 18 05 00 00 00 	movl   $0x5,0x18(%rax)
    }
    break;
  80ee68:	eb 6f                	jmp    80eed9 <tcp_close+0x260>
  80ee6a:	eb 6d                	jmp    80eed9 <tcp_close+0x260>
  case ESTABLISHED:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  80ee6c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ee70:	be 01 00 00 00       	mov    $0x1,%esi
  80ee75:	48 89 c7             	mov    %rax,%rdi
  80ee78:	48 b8 aa 30 81 00 00 	movabs $0x8130aa,%rax
  80ee7f:	00 00 00 
  80ee82:	ff d0                	callq  *%rax
  80ee84:	88 45 ff             	mov    %al,-0x1(%rbp)
    if (err == ERR_OK) {
  80ee87:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80ee8b:	75 0d                	jne    80ee9a <tcp_close+0x221>
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
  80ee8d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ee91:	c7 40 18 05 00 00 00 	movl   $0x5,0x18(%rax)
    }
    break;
  80ee98:	eb 3f                	jmp    80eed9 <tcp_close+0x260>
  80ee9a:	eb 3d                	jmp    80eed9 <tcp_close+0x260>
  case CLOSE_WAIT:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  80ee9c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80eea0:	be 01 00 00 00       	mov    $0x1,%esi
  80eea5:	48 89 c7             	mov    %rax,%rdi
  80eea8:	48 b8 aa 30 81 00 00 	movabs $0x8130aa,%rax
  80eeaf:	00 00 00 
  80eeb2:	ff d0                	callq  *%rax
  80eeb4:	88 45 ff             	mov    %al,-0x1(%rbp)
    if (err == ERR_OK) {
  80eeb7:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80eebb:	75 0d                	jne    80eeca <tcp_close+0x251>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
  80eebd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80eec1:	c7 40 18 09 00 00 00 	movl   $0x9,0x18(%rax)
    }
    break;
  80eec8:	eb 0f                	jmp    80eed9 <tcp_close+0x260>
  80eeca:	eb 0d                	jmp    80eed9 <tcp_close+0x260>
  default:
    /* Has already been closed, do nothing. */
    err = ERR_OK;
  80eecc:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
    pcb = NULL;
  80eed0:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80eed7:	00 
    break;
  80eed8:	90                   	nop
  }

  if (pcb != NULL && err == ERR_OK) {
  80eed9:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80eede:	74 19                	je     80eef9 <tcp_close+0x280>
  80eee0:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80eee4:	75 13                	jne    80eef9 <tcp_close+0x280>
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent when tcp_close returns. */
    tcp_output(pcb);
  80eee6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80eeea:	48 89 c7             	mov    %rax,%rdi
  80eeed:	48 b8 3d 3c 81 00 00 	movabs $0x813c3d,%rax
  80eef4:	00 00 00 
  80eef7:	ff d0                	callq  *%rax
  }
  return err;
  80eef9:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  80eefd:	c9                   	leaveq 
  80eefe:	c3                   	retq   

000000000080eeff <tcp_abort>:
 *
 * @param pcb the tcp_pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
  80eeff:	55                   	push   %rbp
  80ef00:	48 89 e5             	mov    %rsp,%rbp
  80ef03:	48 83 ec 50          	sub    $0x50,%rsp
  80ef07:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)

  
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
  80ef0b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ef0f:	8b 40 18             	mov    0x18(%rax),%eax
  80ef12:	83 f8 0a             	cmp    $0xa,%eax
  80ef15:	75 3a                	jne    80ef51 <tcp_abort+0x52>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
  80ef17:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ef1b:	48 89 c6             	mov    %rax,%rsi
  80ef1e:	48 bf 40 b0 b5 00 00 	movabs $0xb5b040,%rdi
  80ef25:	00 00 00 
  80ef28:	48 b8 a9 0a 81 00 00 	movabs $0x810aa9,%rax
  80ef2f:	00 00 00 
  80ef32:	ff d0                	callq  *%rax
    memp_free(MEMP_TCP_PCB, pcb);
  80ef34:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ef38:	48 89 c6             	mov    %rax,%rsi
  80ef3b:	bf 02 00 00 00       	mov    $0x2,%edi
  80ef40:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  80ef47:	00 00 00 
  80ef4a:	ff d0                	callq  *%rax
  80ef4c:	e9 75 01 00 00       	jmpq   80f0c6 <tcp_abort+0x1c7>
  } else {
    seqno = pcb->snd_nxt;
  80ef51:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ef55:	8b 40 60             	mov    0x60(%rax),%eax
  80ef58:	89 45 fc             	mov    %eax,-0x4(%rbp)
    ackno = pcb->rcv_nxt;
  80ef5b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ef5f:	8b 40 30             	mov    0x30(%rax),%eax
  80ef62:	89 45 f8             	mov    %eax,-0x8(%rbp)
    ip_addr_set(&local_ip, &(pcb->local_ip));
  80ef65:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ef69:	48 85 c0             	test   %rax,%rax
  80ef6c:	74 08                	je     80ef76 <tcp_abort+0x77>
  80ef6e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ef72:	8b 00                	mov    (%rax),%eax
  80ef74:	eb 05                	jmp    80ef7b <tcp_abort+0x7c>
  80ef76:	b8 00 00 00 00       	mov    $0x0,%eax
  80ef7b:	89 45 c0             	mov    %eax,-0x40(%rbp)
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
  80ef7e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ef82:	48 83 c0 04          	add    $0x4,%rax
  80ef86:	48 85 c0             	test   %rax,%rax
  80ef89:	74 09                	je     80ef94 <tcp_abort+0x95>
  80ef8b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ef8f:	8b 40 04             	mov    0x4(%rax),%eax
  80ef92:	eb 05                	jmp    80ef99 <tcp_abort+0x9a>
  80ef94:	b8 00 00 00 00       	mov    $0x0,%eax
  80ef99:	89 45 d0             	mov    %eax,-0x30(%rbp)
    local_port = pcb->local_port;
  80ef9c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80efa0:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80efa4:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
    remote_port = pcb->remote_port;
  80efa8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80efac:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  80efb0:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
#if LWIP_CALLBACK_API
    errf = pcb->errf;
  80efb4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80efb8:	48 8b 80 c8 00 00 00 	mov    0xc8(%rax),%rax
  80efbf:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
  80efc3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80efc7:	48 8b 40 20          	mov    0x20(%rax),%rax
  80efcb:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80efcf:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80efd3:	48 89 c6             	mov    %rax,%rsi
  80efd6:	48 bf 18 b0 b5 00 00 	movabs $0xb5b018,%rdi
  80efdd:	00 00 00 
  80efe0:	48 b8 a9 0a 81 00 00 	movabs $0x810aa9,%rax
  80efe7:	00 00 00 
  80efea:	ff d0                	callq  *%rax
    if (pcb->unacked != NULL) {
  80efec:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80eff0:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  80eff7:	48 85 c0             	test   %rax,%rax
  80effa:	74 1a                	je     80f016 <tcp_abort+0x117>
      tcp_segs_free(pcb->unacked);
  80effc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80f000:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  80f007:	48 89 c7             	mov    %rax,%rdi
  80f00a:	48 b8 34 04 81 00 00 	movabs $0x810434,%rax
  80f011:	00 00 00 
  80f014:	ff d0                	callq  *%rax
    }
    if (pcb->unsent != NULL) {
  80f016:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80f01a:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  80f021:	48 85 c0             	test   %rax,%rax
  80f024:	74 1a                	je     80f040 <tcp_abort+0x141>
      tcp_segs_free(pcb->unsent);
  80f026:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80f02a:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  80f031:	48 89 c7             	mov    %rax,%rdi
  80f034:	48 b8 34 04 81 00 00 	movabs $0x810434,%rax
  80f03b:	00 00 00 
  80f03e:	ff d0                	callq  *%rax
    }
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
  80f040:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80f044:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  80f04b:	48 85 c0             	test   %rax,%rax
  80f04e:	74 1a                	je     80f06a <tcp_abort+0x16b>
      tcp_segs_free(pcb->ooseq);
  80f050:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80f054:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  80f05b:	48 89 c7             	mov    %rax,%rdi
  80f05e:	48 b8 34 04 81 00 00 	movabs $0x810434,%rax
  80f065:	00 00 00 
  80f068:	ff d0                	callq  *%rax
    }
#endif /* TCP_QUEUE_OOSEQ */
    memp_free(MEMP_TCP_PCB, pcb);
  80f06a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80f06e:	48 89 c6             	mov    %rax,%rsi
  80f071:	bf 02 00 00 00       	mov    $0x2,%edi
  80f076:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  80f07d:	00 00 00 
  80f080:	ff d0                	callq  *%rax
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  80f082:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80f087:	74 12                	je     80f09b <tcp_abort+0x19c>
  80f089:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80f08d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f091:	be fb ff ff ff       	mov    $0xfffffffb,%esi
  80f096:	48 89 d7             	mov    %rdx,%rdi
  80f099:	ff d0                	callq  *%rax
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abort: sending RST\n"));
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  80f09b:	44 0f b7 45 f4       	movzwl -0xc(%rbp),%r8d
  80f0a0:	0f b7 7d f6          	movzwl -0xa(%rbp),%edi
  80f0a4:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  80f0a8:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
  80f0ac:	8b 75 f8             	mov    -0x8(%rbp),%esi
  80f0af:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80f0b2:	45 89 c1             	mov    %r8d,%r9d
  80f0b5:	41 89 f8             	mov    %edi,%r8d
  80f0b8:	89 c7                	mov    %eax,%edi
  80f0ba:	48 b8 48 45 81 00 00 	movabs $0x814548,%rax
  80f0c1:	00 00 00 
  80f0c4:	ff d0                	callq  *%rax
  }
}
  80f0c6:	c9                   	leaveq 
  80f0c7:	c3                   	retq   

000000000080f0c8 <tcp_bind>:
 * @return ERR_USE if the port is already in use
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  80f0c8:	55                   	push   %rbp
  80f0c9:	48 89 e5             	mov    %rsp,%rbp
  80f0cc:	48 83 ec 30          	sub    $0x30,%rsp
  80f0d0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80f0d4:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80f0d8:	89 d0                	mov    %edx,%eax
  80f0da:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  80f0de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f0e2:	8b 40 18             	mov    0x18(%rax),%eax
  80f0e5:	85 c0                	test   %eax,%eax
  80f0e7:	74 2a                	je     80f113 <tcp_bind+0x4b>
  80f0e9:	48 ba 10 24 82 00 00 	movabs $0x822410,%rdx
  80f0f0:	00 00 00 
  80f0f3:	be 06 01 00 00       	mov    $0x106,%esi
  80f0f8:	48 bf 3b 24 82 00 00 	movabs $0x82243b,%rdi
  80f0ff:	00 00 00 
  80f102:	b8 00 00 00 00       	mov    $0x0,%eax
  80f107:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80f10e:	00 00 00 
  80f111:	ff d1                	callq  *%rcx

  if (port == 0) {
  80f113:	66 83 7d dc 00       	cmpw   $0x0,-0x24(%rbp)
  80f118:	75 10                	jne    80f12a <tcp_bind+0x62>
    port = tcp_new_port();
  80f11a:	48 b8 e1 f6 80 00 00 	movabs $0x80f6e1,%rax
  80f121:	00 00 00 
  80f124:	ff d0                	callq  *%rax
  80f126:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  80f12a:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  80f131:	00 00 00 
  80f134:	48 8b 00             	mov    (%rax),%rax
  80f137:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f13b:	eb 58                	jmp    80f195 <tcp_bind+0xcd>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  80f13d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f141:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80f145:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  80f149:	75 3e                	jne    80f189 <tcp_bind+0xc1>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  80f14b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f14f:	48 85 c0             	test   %rax,%rax
  80f152:	74 2b                	je     80f17f <tcp_bind+0xb7>
  80f154:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f158:	8b 00                	mov    (%rax),%eax
  80f15a:	85 c0                	test   %eax,%eax
  80f15c:	74 21                	je     80f17f <tcp_bind+0xb7>
  80f15e:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80f163:	74 1a                	je     80f17f <tcp_bind+0xb7>
          ip_addr_isany(ipaddr) ||
  80f165:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80f169:	8b 00                	mov    (%rax),%eax
  80f16b:	85 c0                	test   %eax,%eax
  80f16d:	74 10                	je     80f17f <tcp_bind+0xb7>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  80f16f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f173:	8b 10                	mov    (%rax),%edx
  80f175:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80f179:	8b 00                	mov    (%rax),%eax
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
  80f17b:	39 c2                	cmp    %eax,%edx
  80f17d:	75 0a                	jne    80f189 <tcp_bind+0xc1>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  80f17f:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80f184:	e9 a2 01 00 00       	jmpq   80f32b <tcp_bind+0x263>
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  80f189:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f18d:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f191:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (port == 0) {
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  80f195:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f19a:	75 a1                	jne    80f13d <tcp_bind+0x75>
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  80f19c:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80f1a3:	00 00 00 
  80f1a6:	48 8b 00             	mov    (%rax),%rax
  80f1a9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f1ad:	eb 58                	jmp    80f207 <tcp_bind+0x13f>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  80f1af:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f1b3:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80f1b7:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  80f1bb:	75 3e                	jne    80f1fb <tcp_bind+0x133>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  80f1bd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f1c1:	48 85 c0             	test   %rax,%rax
  80f1c4:	74 2b                	je     80f1f1 <tcp_bind+0x129>
  80f1c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f1ca:	8b 00                	mov    (%rax),%eax
  80f1cc:	85 c0                	test   %eax,%eax
  80f1ce:	74 21                	je     80f1f1 <tcp_bind+0x129>
  80f1d0:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80f1d5:	74 1a                	je     80f1f1 <tcp_bind+0x129>
          ip_addr_isany(ipaddr) ||
  80f1d7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80f1db:	8b 00                	mov    (%rax),%eax
  80f1dd:	85 c0                	test   %eax,%eax
  80f1df:	74 10                	je     80f1f1 <tcp_bind+0x129>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  80f1e1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f1e5:	8b 10                	mov    (%rax),%edx
  80f1e7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80f1eb:	8b 00                	mov    (%rax),%eax
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
  80f1ed:	39 c2                	cmp    %eax,%edx
  80f1ef:	75 0a                	jne    80f1fb <tcp_bind+0x133>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  80f1f1:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80f1f6:	e9 30 01 00 00       	jmpq   80f32b <tcp_bind+0x263>
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  80f1fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f1ff:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f203:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  80f207:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f20c:	75 a1                	jne    80f1af <tcp_bind+0xe7>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  80f20e:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f215:	00 00 00 
  80f218:	48 8b 00             	mov    (%rax),%rax
  80f21b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f21f:	eb 58                	jmp    80f279 <tcp_bind+0x1b1>
    if (cpcb->local_port == port) {
  80f221:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f225:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80f229:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  80f22d:	75 3e                	jne    80f26d <tcp_bind+0x1a5>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  80f22f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f233:	48 85 c0             	test   %rax,%rax
  80f236:	74 2b                	je     80f263 <tcp_bind+0x19b>
  80f238:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f23c:	8b 00                	mov    (%rax),%eax
  80f23e:	85 c0                	test   %eax,%eax
  80f240:	74 21                	je     80f263 <tcp_bind+0x19b>
  80f242:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80f247:	74 1a                	je     80f263 <tcp_bind+0x19b>
          ip_addr_isany(ipaddr) ||
  80f249:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80f24d:	8b 00                	mov    (%rax),%eax
  80f24f:	85 c0                	test   %eax,%eax
  80f251:	74 10                	je     80f263 <tcp_bind+0x19b>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  80f253:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f257:	8b 10                	mov    (%rax),%edx
  80f259:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80f25d:	8b 00                	mov    (%rax),%eax
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
  80f25f:	39 c2                	cmp    %eax,%edx
  80f261:	75 0a                	jne    80f26d <tcp_bind+0x1a5>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  80f263:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80f268:	e9 be 00 00 00       	jmpq   80f32b <tcp_bind+0x263>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  80f26d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f271:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f275:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f279:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f27e:	75 a1                	jne    80f221 <tcp_bind+0x159>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  80f280:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  80f287:	00 00 00 
  80f28a:	48 8b 00             	mov    (%rax),%rax
  80f28d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f291:	eb 31                	jmp    80f2c4 <tcp_bind+0x1fc>
    if (cpcb->local_port == port) {
  80f293:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f297:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80f29b:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  80f29f:	75 17                	jne    80f2b8 <tcp_bind+0x1f0>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  80f2a1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f2a5:	8b 10                	mov    (%rax),%edx
  80f2a7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80f2ab:	8b 00                	mov    (%rax),%eax
  80f2ad:	39 c2                	cmp    %eax,%edx
  80f2af:	75 07                	jne    80f2b8 <tcp_bind+0x1f0>
        return ERR_USE;
  80f2b1:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80f2b6:	eb 73                	jmp    80f32b <tcp_bind+0x263>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  80f2b8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f2bc:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f2c0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f2c4:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f2c9:	75 c8                	jne    80f293 <tcp_bind+0x1cb>
        return ERR_USE;
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
  80f2cb:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80f2d0:	74 16                	je     80f2e8 <tcp_bind+0x220>
  80f2d2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80f2d6:	8b 00                	mov    (%rax),%eax
  80f2d8:	85 c0                	test   %eax,%eax
  80f2da:	74 0c                	je     80f2e8 <tcp_bind+0x220>
    pcb->local_ip = *ipaddr;
  80f2dc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f2e0:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80f2e4:	8b 12                	mov    (%rdx),%edx
  80f2e6:	89 10                	mov    %edx,(%rax)
  }
  pcb->local_port = port;
  80f2e8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f2ec:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  80f2f0:	66 89 50 28          	mov    %dx,0x28(%rax)
  TCP_REG(&tcp_bound_pcbs, pcb);
  80f2f4:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f2fb:	00 00 00 
  80f2fe:	48 8b 10             	mov    (%rax),%rdx
  80f301:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f305:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80f309:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f310:	00 00 00 
  80f313:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80f317:	48 89 10             	mov    %rdx,(%rax)
  80f31a:	48 b8 f1 86 80 00 00 	movabs $0x8086f1,%rax
  80f321:	00 00 00 
  80f324:	ff d0                	callq  *%rax
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
  80f326:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f32b:	c9                   	leaveq 
  80f32c:	c3                   	retq   

000000000080f32d <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
  80f32d:	55                   	push   %rbp
  80f32e:	48 89 e5             	mov    %rsp,%rbp
  80f331:	48 83 ec 14          	sub    $0x14,%rsp
  80f335:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80f339:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80f33d:	89 d0                	mov    %edx,%eax
  80f33f:	88 45 ec             	mov    %al,-0x14(%rbp)
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
  80f342:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
  80f347:	c9                   	leaveq 
  80f348:	c3                   	retq   

000000000080f349 <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
  80f349:	55                   	push   %rbp
  80f34a:	48 89 e5             	mov    %rsp,%rbp
  80f34d:	53                   	push   %rbx
  80f34e:	48 83 ec 28          	sub    $0x28,%rsp
  80f352:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80f356:	89 f0                	mov    %esi,%eax
  80f358:	88 45 d4             	mov    %al,-0x2c(%rbp)
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  80f35b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80f35f:	8b 40 18             	mov    0x18(%rax),%eax
  80f362:	85 c0                	test   %eax,%eax
  80f364:	74 2a                	je     80f390 <tcp_listen_with_backlog+0x47>
  80f366:	48 ba 50 24 82 00 00 	movabs $0x822450,%rdx
  80f36d:	00 00 00 
  80f370:	be 61 01 00 00       	mov    $0x161,%esi
  80f375:	48 bf 3b 24 82 00 00 	movabs $0x82243b,%rdi
  80f37c:	00 00 00 
  80f37f:	b8 00 00 00 00       	mov    $0x0,%eax
  80f384:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80f38b:	00 00 00 
  80f38e:	ff d1                	callq  *%rcx

  /* already listening? */
  if (pcb->state == LISTEN) {
  80f390:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80f394:	8b 40 18             	mov    0x18(%rax),%eax
  80f397:	83 f8 01             	cmp    $0x1,%eax
  80f39a:	75 09                	jne    80f3a5 <tcp_listen_with_backlog+0x5c>
    return pcb;
  80f39c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80f3a0:	e9 e6 01 00 00       	jmpq   80f58b <tcp_listen_with_backlog+0x242>
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  80f3a5:	bf 03 00 00 00       	mov    $0x3,%edi
  80f3aa:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  80f3b1:	00 00 00 
  80f3b4:	ff d0                	callq  *%rax
  80f3b6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if (lpcb == NULL) {
  80f3ba:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80f3bf:	75 0a                	jne    80f3cb <tcp_listen_with_backlog+0x82>
    return NULL;
  80f3c1:	b8 00 00 00 00       	mov    $0x0,%eax
  80f3c6:	e9 c0 01 00 00       	jmpq   80f58b <tcp_listen_with_backlog+0x242>
  }
  lpcb->callback_arg = pcb->callback_arg;
  80f3cb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80f3cf:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80f3d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f3d7:	48 89 50 20          	mov    %rdx,0x20(%rax)
  lpcb->local_port = pcb->local_port;
  80f3db:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80f3df:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  80f3e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f3e7:	66 89 50 28          	mov    %dx,0x28(%rax)
  lpcb->state = LISTEN;
  80f3eb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f3ef:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%rax)
  lpcb->so_options = pcb->so_options;
  80f3f6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80f3fa:	0f b7 50 08          	movzwl 0x8(%rax),%edx
  80f3fe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f402:	66 89 50 08          	mov    %dx,0x8(%rax)
  lpcb->so_options |= SOF_ACCEPTCONN;
  80f406:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f40a:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80f40e:	83 c8 02             	or     $0x2,%eax
  80f411:	89 c2                	mov    %eax,%edx
  80f413:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f417:	66 89 50 08          	mov    %dx,0x8(%rax)
  lpcb->ttl = pcb->ttl;
  80f41b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80f41f:	0f b6 50 0b          	movzbl 0xb(%rax),%edx
  80f423:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f427:	88 50 0b             	mov    %dl,0xb(%rax)
  lpcb->tos = pcb->tos;
  80f42a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80f42e:	0f b6 50 0a          	movzbl 0xa(%rax),%edx
  80f432:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f436:	88 50 0a             	mov    %dl,0xa(%rax)
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  80f439:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80f43d:	48 85 c0             	test   %rax,%rax
  80f440:	74 08                	je     80f44a <tcp_listen_with_backlog+0x101>
  80f442:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80f446:	8b 00                	mov    (%rax),%eax
  80f448:	eb 05                	jmp    80f44f <tcp_listen_with_backlog+0x106>
  80f44a:	b8 00 00 00 00       	mov    $0x0,%eax
  80f44f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80f453:	89 02                	mov    %eax,(%rdx)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  80f455:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f45c:	00 00 00 
  80f45f:	48 8b 00             	mov    (%rax),%rax
  80f462:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  80f466:	75 23                	jne    80f48b <tcp_listen_with_backlog+0x142>
  80f468:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f46f:	00 00 00 
  80f472:	48 8b 00             	mov    (%rax),%rax
  80f475:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80f479:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f480:	00 00 00 
  80f483:	48 89 10             	mov    %rdx,(%rax)
  80f486:	e9 94 00 00 00       	jmpq   80f51f <tcp_listen_with_backlog+0x1d6>
  80f48b:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f492:	00 00 00 
  80f495:	48 8b 10             	mov    (%rax),%rdx
  80f498:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f49f:	00 00 00 
  80f4a2:	48 89 10             	mov    %rdx,(%rax)
  80f4a5:	eb 66                	jmp    80f50d <tcp_listen_with_backlog+0x1c4>
  80f4a7:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f4ae:	00 00 00 
  80f4b1:	48 8b 00             	mov    (%rax),%rax
  80f4b4:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f4b8:	48 85 c0             	test   %rax,%rax
  80f4bb:	74 32                	je     80f4ef <tcp_listen_with_backlog+0x1a6>
  80f4bd:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f4c4:	00 00 00 
  80f4c7:	48 8b 00             	mov    (%rax),%rax
  80f4ca:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f4ce:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  80f4d2:	75 1b                	jne    80f4ef <tcp_listen_with_backlog+0x1a6>
  80f4d4:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f4db:	00 00 00 
  80f4de:	48 8b 00             	mov    (%rax),%rax
  80f4e1:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80f4e5:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80f4e9:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80f4ed:	eb 30                	jmp    80f51f <tcp_listen_with_backlog+0x1d6>
  80f4ef:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f4f6:	00 00 00 
  80f4f9:	48 8b 00             	mov    (%rax),%rax
  80f4fc:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80f500:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f507:	00 00 00 
  80f50a:	48 89 10             	mov    %rdx,(%rax)
  80f50d:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f514:	00 00 00 
  80f517:	48 8b 00             	mov    (%rax),%rax
  80f51a:	48 85 c0             	test   %rax,%rax
  80f51d:	75 88                	jne    80f4a7 <tcp_listen_with_backlog+0x15e>
  80f51f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80f523:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80f52a:	00 
  memp_free(MEMP_TCP_PCB, pcb);
  80f52b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80f52f:	48 89 c6             	mov    %rax,%rsi
  80f532:	bf 02 00 00 00       	mov    $0x2,%edi
  80f537:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  80f53e:	00 00 00 
  80f541:	ff d0                	callq  *%rax
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
  80f543:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f547:	48 bb 2d f3 80 00 00 	movabs $0x80f32d,%rbx
  80f54e:	00 00 00 
  80f551:	48 89 58 30          	mov    %rbx,0x30(%rax)
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  80f555:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  80f55c:	00 00 00 
  80f55f:	48 8b 10             	mov    (%rax),%rdx
  80f562:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f566:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80f56a:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  80f571:	00 00 00 
  80f574:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80f578:	48 89 10             	mov    %rdx,(%rax)
  80f57b:	48 b8 f1 86 80 00 00 	movabs $0x8086f1,%rax
  80f582:	00 00 00 
  80f585:	ff d0                	callq  *%rax
  return (struct tcp_pcb *)lpcb;
  80f587:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  80f58b:	48 83 c4 28          	add    $0x28,%rsp
  80f58f:	5b                   	pop    %rbx
  80f590:	5d                   	pop    %rbp
  80f591:	c3                   	retq   

000000000080f592 <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
  80f592:	55                   	push   %rbp
  80f593:	48 89 e5             	mov    %rsp,%rbp
  80f596:	48 83 ec 10          	sub    $0x10,%rsp
  80f59a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80f59e:	89 f0                	mov    %esi,%eax
  80f5a0:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  if ((u32_t)pcb->rcv_wnd + len > TCP_WND) {
  80f5a4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f5a8:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  80f5ac:	0f b7 d0             	movzwl %ax,%edx
  80f5af:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80f5b3:	01 d0                	add    %edx,%eax
  80f5b5:	3d c0 5d 00 00       	cmp    $0x5dc0,%eax
  80f5ba:	76 16                	jbe    80f5d2 <tcp_recved+0x40>
    pcb->rcv_wnd = TCP_WND;
  80f5bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f5c0:	66 c7 40 34 c0 5d    	movw   $0x5dc0,0x34(%rax)
    pcb->rcv_ann_wnd = TCP_WND;
  80f5c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f5ca:	66 c7 40 36 c0 5d    	movw   $0x5dc0,0x36(%rax)
  80f5d0:	eb 3b                	jmp    80f60d <tcp_recved+0x7b>
  } else {
    pcb->rcv_wnd += len;
  80f5d2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f5d6:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  80f5da:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80f5de:	01 c2                	add    %eax,%edx
  80f5e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f5e4:	66 89 50 34          	mov    %dx,0x34(%rax)
    if (pcb->rcv_wnd >= pcb->mss) {
  80f5e8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f5ec:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  80f5f0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f5f4:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80f5f8:	66 39 c2             	cmp    %ax,%dx
  80f5fb:	72 10                	jb     80f60d <tcp_recved+0x7b>
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
  80f5fd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f601:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  80f605:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f609:	66 89 50 36          	mov    %dx,0x36(%rax)
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
  80f60d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f611:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f615:	0f b6 c0             	movzbl %al,%eax
  80f618:	83 e0 01             	and    $0x1,%eax
  80f61b:	85 c0                	test   %eax,%eax
  80f61d:	75 77                	jne    80f696 <tcp_recved+0x104>
     !(pcb->flags & TF_ACK_NOW)) {
  80f61f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f623:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f627:	0f b6 c0             	movzbl %al,%eax
  80f62a:	83 e0 02             	and    $0x2,%eax
    if (pcb->rcv_wnd >= pcb->mss) {
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
  80f62d:	85 c0                	test   %eax,%eax
  80f62f:	75 65                	jne    80f696 <tcp_recved+0x104>
     * two ACKs being sent for each received packet in some limited cases
     * (where the application is only receiving data, and is slow to
     * process it) but it is necessary to guarantee that the sender can
     * continue to transmit.
     */
    tcp_ack(pcb);
  80f631:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f635:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f639:	0f b6 c0             	movzbl %al,%eax
  80f63c:	83 e0 01             	and    $0x1,%eax
  80f63f:	85 c0                	test   %eax,%eax
  80f641:	74 3d                	je     80f680 <tcp_recved+0xee>
  80f643:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f647:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f64b:	83 e0 fe             	and    $0xfffffffe,%eax
  80f64e:	89 c2                	mov    %eax,%edx
  80f650:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f654:	88 50 2c             	mov    %dl,0x2c(%rax)
  80f657:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f65b:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f65f:	83 c8 02             	or     $0x2,%eax
  80f662:	89 c2                	mov    %eax,%edx
  80f664:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f668:	88 50 2c             	mov    %dl,0x2c(%rax)
  80f66b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f66f:	48 89 c7             	mov    %rax,%rdi
  80f672:	48 b8 3d 3c 81 00 00 	movabs $0x813c3d,%rax
  80f679:	00 00 00 
  80f67c:	ff d0                	callq  *%rax
  80f67e:	eb 5f                	jmp    80f6df <tcp_recved+0x14d>
  80f680:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f684:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f688:	83 c8 01             	or     $0x1,%eax
  80f68b:	89 c2                	mov    %eax,%edx
  80f68d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f691:	88 50 2c             	mov    %dl,0x2c(%rax)
  80f694:	eb 49                	jmp    80f6df <tcp_recved+0x14d>
  } 
  else if (pcb->flags & TF_ACK_DELAY && pcb->rcv_wnd >= TCP_WND/2) {
  80f696:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f69a:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f69e:	0f b6 c0             	movzbl %al,%eax
  80f6a1:	83 e0 01             	and    $0x1,%eax
  80f6a4:	85 c0                	test   %eax,%eax
  80f6a6:	74 37                	je     80f6df <tcp_recved+0x14d>
  80f6a8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f6ac:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  80f6b0:	66 3d df 2e          	cmp    $0x2edf,%ax
  80f6b4:	76 29                	jbe    80f6df <tcp_recved+0x14d>
     * nagle-like in its goals, and tries to hit a compromise between
     * sending acks each time the window is updated, and only sending
     * window updates when a timer expires.  The "threshold" used
     * above (currently TCP_WND/2) can be tuned to be more or less
     * aggressive  */
    tcp_ack_now(pcb);
  80f6b6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f6ba:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f6be:	83 c8 02             	or     $0x2,%eax
  80f6c1:	89 c2                	mov    %eax,%edx
  80f6c3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f6c7:	88 50 2c             	mov    %dl,0x2c(%rax)
  80f6ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f6ce:	48 89 c7             	mov    %rax,%rdi
  80f6d1:	48 b8 3d 3c 81 00 00 	movabs $0x813c3d,%rax
  80f6d8:	00 00 00 
  80f6db:	ff d0                	callq  *%rax
  80f6dd:	eb 00                	jmp    80f6df <tcp_recved+0x14d>
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
  80f6df:	c9                   	leaveq 
  80f6e0:	c3                   	retq   

000000000080f6e1 <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
  80f6e1:	55                   	push   %rbp
  80f6e2:	48 89 e5             	mov    %rsp,%rbp
  80f6e5:	48 83 ec 10          	sub    $0x10,%rsp
#define TCP_LOCAL_PORT_RANGE_END   0x7fff
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  80f6e9:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  80f6f0:	00 00 00 
  80f6f3:	0f b7 00             	movzwl (%rax),%eax
  80f6f6:	8d 50 01             	lea    0x1(%rax),%edx
  80f6f9:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  80f700:	00 00 00 
  80f703:	66 89 10             	mov    %dx,(%rax)
  80f706:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  80f70d:	00 00 00 
  80f710:	0f b7 00             	movzwl (%rax),%eax
  80f713:	66 85 c0             	test   %ax,%ax
  80f716:	79 0f                	jns    80f727 <tcp_new_port+0x46>
    port = TCP_LOCAL_PORT_RANGE_START;
  80f718:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  80f71f:	00 00 00 
  80f722:	66 c7 00 00 10       	movw   $0x1000,(%rax)
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80f727:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80f72e:	00 00 00 
  80f731:	48 8b 00             	mov    (%rax),%rax
  80f734:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f738:	eb 28                	jmp    80f762 <tcp_new_port+0x81>
    if (pcb->local_port == port) {
  80f73a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f73e:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  80f742:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  80f749:	00 00 00 
  80f74c:	0f b7 00             	movzwl (%rax),%eax
  80f74f:	66 39 c2             	cmp    %ax,%dx
  80f752:	75 02                	jne    80f756 <tcp_new_port+0x75>
      goto again;
  80f754:	eb 93                	jmp    80f6e9 <tcp_new_port+0x8>
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80f756:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f75a:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f75e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f762:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f767:	75 d1                	jne    80f73a <tcp_new_port+0x59>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80f769:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  80f770:	00 00 00 
  80f773:	48 8b 00             	mov    (%rax),%rax
  80f776:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f77a:	eb 2b                	jmp    80f7a7 <tcp_new_port+0xc6>
    if (pcb->local_port == port) {
  80f77c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f780:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  80f784:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  80f78b:	00 00 00 
  80f78e:	0f b7 00             	movzwl (%rax),%eax
  80f791:	66 39 c2             	cmp    %ax,%dx
  80f794:	75 05                	jne    80f79b <tcp_new_port+0xba>
      goto again;
  80f796:	e9 4e ff ff ff       	jmpq   80f6e9 <tcp_new_port+0x8>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80f79b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f79f:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f7a3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f7a7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f7ac:	75 ce                	jne    80f77c <tcp_new_port+0x9b>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  80f7ae:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  80f7b5:	00 00 00 
  80f7b8:	48 8b 00             	mov    (%rax),%rax
  80f7bb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f7bf:	eb 2b                	jmp    80f7ec <tcp_new_port+0x10b>
    if (pcb->local_port == port) {
  80f7c1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f7c5:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  80f7c9:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  80f7d0:	00 00 00 
  80f7d3:	0f b7 00             	movzwl (%rax),%eax
  80f7d6:	66 39 c2             	cmp    %ax,%dx
  80f7d9:	75 05                	jne    80f7e0 <tcp_new_port+0xff>
      goto again;
  80f7db:	e9 09 ff ff ff       	jmpq   80f6e9 <tcp_new_port+0x8>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  80f7e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f7e4:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f7e8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f7ec:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f7f1:	75 ce                	jne    80f7c1 <tcp_new_port+0xe0>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  return port;
  80f7f3:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  80f7fa:	00 00 00 
  80f7fd:	0f b7 00             	movzwl (%rax),%eax
}
  80f800:	c9                   	leaveq 
  80f801:	c3                   	retq   

000000000080f802 <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port,
      err_t (* connected)(void *arg, struct tcp_pcb *tpcb, err_t err))
{
  80f802:	55                   	push   %rbp
  80f803:	48 89 e5             	mov    %rsp,%rbp
  80f806:	48 83 ec 40          	sub    $0x40,%rsp
  80f80a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80f80e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80f812:	89 d0                	mov    %edx,%eax
  80f814:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  80f818:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
  u32_t optdata;
  err_t ret;
  u32_t iss;

  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  80f81c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f820:	8b 40 18             	mov    0x18(%rax),%eax
  80f823:	85 c0                	test   %eax,%eax
  80f825:	74 2a                	je     80f851 <tcp_connect+0x4f>
  80f827:	48 ba 78 24 82 00 00 	movabs $0x822478,%rdx
  80f82e:	00 00 00 
  80f831:	be ed 01 00 00       	mov    $0x1ed,%esi
  80f836:	48 bf 3b 24 82 00 00 	movabs $0x82243b,%rdi
  80f83d:	00 00 00 
  80f840:	b8 00 00 00 00       	mov    $0x0,%eax
  80f845:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80f84c:	00 00 00 
  80f84f:	ff d1                	callq  *%rcx

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
  80f851:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80f856:	74 28                	je     80f880 <tcp_connect+0x7e>
    pcb->remote_ip = *ipaddr;
  80f858:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f85c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80f860:	8b 12                	mov    (%rdx),%edx
  80f862:	89 50 04             	mov    %edx,0x4(%rax)
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
  80f865:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f869:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  80f86d:	66 89 50 2a          	mov    %dx,0x2a(%rax)
  if (pcb->local_port == 0) {
  80f871:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f875:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80f879:	66 85 c0             	test   %ax,%ax
  80f87c:	75 20                	jne    80f89e <tcp_connect+0x9c>
  80f87e:	eb 0a                	jmp    80f88a <tcp_connect+0x88>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
    pcb->remote_ip = *ipaddr;
  } else {
    return ERR_VAL;
  80f880:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80f885:	e9 53 02 00 00       	jmpq   80fadd <tcp_connect+0x2db>
  }
  pcb->remote_port = port;
  if (pcb->local_port == 0) {
    pcb->local_port = tcp_new_port();
  80f88a:	48 b8 e1 f6 80 00 00 	movabs $0x80f6e1,%rax
  80f891:	00 00 00 
  80f894:	ff d0                	callq  *%rax
  80f896:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80f89a:	66 89 42 28          	mov    %ax,0x28(%rdx)
  }
  iss = tcp_next_iss();
  80f89e:	48 b8 a6 0c 81 00 00 	movabs $0x810ca6,%rax
  80f8a5:	00 00 00 
  80f8a8:	ff d0                	callq  *%rax
  80f8aa:	89 45 fc             	mov    %eax,-0x4(%rbp)
  pcb->rcv_nxt = 0;
  80f8ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f8b1:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%rax)
  pcb->snd_nxt = iss;
  80f8b8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f8bc:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80f8bf:	89 50 60             	mov    %edx,0x60(%rax)
  pcb->lastack = iss - 1;
  80f8c2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80f8c5:	8d 50 ff             	lea    -0x1(%rax),%edx
  80f8c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f8cc:	89 50 54             	mov    %edx,0x54(%rax)
  pcb->snd_lbb = iss - 1;
  80f8cf:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80f8d2:	8d 50 ff             	lea    -0x1(%rax),%edx
  80f8d5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f8d9:	89 50 74             	mov    %edx,0x74(%rax)
  pcb->rcv_wnd = TCP_WND;
  80f8dc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f8e0:	66 c7 40 34 c0 5d    	movw   $0x5dc0,0x34(%rax)
  pcb->rcv_ann_wnd = TCP_WND;
  80f8e6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f8ea:	66 c7 40 36 c0 5d    	movw   $0x5dc0,0x36(%rax)
  pcb->snd_wnd = TCP_WND;
  80f8f0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f8f4:	66 c7 40 68 c0 5d    	movw   $0x5dc0,0x68(%rax)
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  80f8fa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f8fe:	66 c7 40 40 18 02    	movw   $0x218,0x40(%rax)
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
  80f904:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f908:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80f90c:	0f b7 c0             	movzwl %ax,%eax
  80f90f:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80f913:	48 89 d6             	mov    %rdx,%rsi
  80f916:	89 c7                	mov    %eax,%edi
  80f918:	48 b8 de 0c 81 00 00 	movabs $0x810cde,%rax
  80f91f:	00 00 00 
  80f922:	ff d0                	callq  *%rax
  80f924:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80f928:	66 89 42 40          	mov    %ax,0x40(%rdx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
  80f92c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f930:	66 c7 40 5a 01 00    	movw   $0x1,0x5a(%rax)
  pcb->ssthresh = pcb->mss * 10;
  80f936:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f93a:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  80f93e:	89 d0                	mov    %edx,%eax
  80f940:	c1 e0 02             	shl    $0x2,%eax
  80f943:	01 d0                	add    %edx,%eax
  80f945:	01 c0                	add    %eax,%eax
  80f947:	89 c2                	mov    %eax,%edx
  80f949:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f94d:	66 89 50 5c          	mov    %dx,0x5c(%rax)
  pcb->state = SYN_SENT;
  80f951:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f955:	c7 40 18 02 00 00 00 	movl   $0x2,0x18(%rax)
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
  80f95c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f960:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80f964:	48 89 90 b0 00 00 00 	mov    %rdx,0xb0(%rax)
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
  80f96b:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f972:	00 00 00 
  80f975:	48 8b 00             	mov    (%rax),%rax
  80f978:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80f97c:	75 23                	jne    80f9a1 <tcp_connect+0x19f>
  80f97e:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f985:	00 00 00 
  80f988:	48 8b 00             	mov    (%rax),%rax
  80f98b:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80f98f:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f996:	00 00 00 
  80f999:	48 89 10             	mov    %rdx,(%rax)
  80f99c:	e9 94 00 00 00       	jmpq   80fa35 <tcp_connect+0x233>
  80f9a1:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f9a8:	00 00 00 
  80f9ab:	48 8b 10             	mov    (%rax),%rdx
  80f9ae:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f9b5:	00 00 00 
  80f9b8:	48 89 10             	mov    %rdx,(%rax)
  80f9bb:	eb 66                	jmp    80fa23 <tcp_connect+0x221>
  80f9bd:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f9c4:	00 00 00 
  80f9c7:	48 8b 00             	mov    (%rax),%rax
  80f9ca:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f9ce:	48 85 c0             	test   %rax,%rax
  80f9d1:	74 32                	je     80fa05 <tcp_connect+0x203>
  80f9d3:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f9da:	00 00 00 
  80f9dd:	48 8b 00             	mov    (%rax),%rax
  80f9e0:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f9e4:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80f9e8:	75 1b                	jne    80fa05 <tcp_connect+0x203>
  80f9ea:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f9f1:	00 00 00 
  80f9f4:	48 8b 00             	mov    (%rax),%rax
  80f9f7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80f9fb:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80f9ff:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80fa03:	eb 30                	jmp    80fa35 <tcp_connect+0x233>
  80fa05:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80fa0c:	00 00 00 
  80fa0f:	48 8b 00             	mov    (%rax),%rax
  80fa12:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80fa16:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80fa1d:	00 00 00 
  80fa20:	48 89 10             	mov    %rdx,(%rax)
  80fa23:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80fa2a:	00 00 00 
  80fa2d:	48 8b 00             	mov    (%rax),%rax
  80fa30:	48 85 c0             	test   %rax,%rax
  80fa33:	75 88                	jne    80f9bd <tcp_connect+0x1bb>
  80fa35:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80fa39:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80fa40:	00 
  TCP_REG(&tcp_active_pcbs, pcb);
  80fa41:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80fa48:	00 00 00 
  80fa4b:	48 8b 10             	mov    (%rax),%rdx
  80fa4e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80fa52:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80fa56:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80fa5d:	00 00 00 
  80fa60:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80fa64:	48 89 10             	mov    %rdx,(%rax)
  80fa67:	48 b8 f1 86 80 00 00 	movabs $0x8086f1,%rax
  80fa6e:	00 00 00 
  80fa71:	ff d0                	callq  *%rax

  snmp_inc_tcpactiveopens();
  
  /* Build an MSS option */
  optdata = TCP_BUILD_MSS_OPTION();
  80fa73:	bf b4 05 04 02       	mov    $0x20405b4,%edi
  80fa78:	48 b8 54 30 81 00 00 	movabs $0x813054,%rax
  80fa7f:	00 00 00 
  80fa82:	ff d0                	callq  *%rax
  80fa84:	89 45 f4             	mov    %eax,-0xc(%rbp)

  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  80fa87:	48 8d 55 f4          	lea    -0xc(%rbp),%rdx
  80fa8b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80fa8f:	c7 04 24 04 00 00 00 	movl   $0x4,(%rsp)
  80fa96:	49 89 d1             	mov    %rdx,%r9
  80fa99:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80fa9f:	b9 02 00 00 00       	mov    $0x2,%ecx
  80faa4:	ba 00 00 00 00       	mov    $0x0,%edx
  80faa9:	be 00 00 00 00       	mov    $0x0,%esi
  80faae:	48 89 c7             	mov    %rax,%rdi
  80fab1:	48 b8 87 31 81 00 00 	movabs $0x813187,%rax
  80fab8:	00 00 00 
  80fabb:	ff d0                	callq  *%rax
  80fabd:	88 45 fb             	mov    %al,-0x5(%rbp)
  if (ret == ERR_OK) { 
  80fac0:	80 7d fb 00          	cmpb   $0x0,-0x5(%rbp)
  80fac4:	75 13                	jne    80fad9 <tcp_connect+0x2d7>
    tcp_output(pcb);
  80fac6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80faca:	48 89 c7             	mov    %rax,%rdi
  80facd:	48 b8 3d 3c 81 00 00 	movabs $0x813c3d,%rax
  80fad4:	00 00 00 
  80fad7:	ff d0                	callq  *%rax
  }
  return ret;
  80fad9:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
} 
  80fadd:	c9                   	leaveq 
  80fade:	c3                   	retq   

000000000080fadf <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
  80fadf:	55                   	push   %rbp
  80fae0:	48 89 e5             	mov    %rsp,%rbp
  80fae3:	48 83 ec 20          	sub    $0x20,%rsp
  struct tcp_pcb *pcb, *pcb2, *prev;
  u16_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;
  80fae7:	c6 45 ee 00          	movb   $0x0,-0x12(%rbp)

  ++tcp_ticks;
  80faeb:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80faf2:	00 00 00 
  80faf5:	8b 00                	mov    (%rax),%eax
  80faf7:	8d 50 01             	lea    0x1(%rax),%edx
  80fafa:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80fb01:	00 00 00 
  80fb04:	89 10                	mov    %edx,(%rax)

  /* Steps through all of the active PCBs. */
  prev = NULL;
  80fb06:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  80fb0d:	00 
  pcb = tcp_active_pcbs;
  80fb0e:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80fb15:	00 00 00 
  80fb18:	48 8b 00             	mov    (%rax),%rax
  80fb1b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
  80fb1f:	e9 5e 06 00 00       	jmpq   810182 <tcp_slowtmr+0x6a3>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  80fb24:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fb28:	8b 40 18             	mov    0x18(%rax),%eax
  80fb2b:	85 c0                	test   %eax,%eax
  80fb2d:	75 2a                	jne    80fb59 <tcp_slowtmr+0x7a>
  80fb2f:	48 ba b0 24 82 00 00 	movabs $0x8224b0,%rdx
  80fb36:	00 00 00 
  80fb39:	be 37 02 00 00       	mov    $0x237,%esi
  80fb3e:	48 bf 3b 24 82 00 00 	movabs $0x82243b,%rdi
  80fb45:	00 00 00 
  80fb48:	b8 00 00 00 00       	mov    $0x0,%eax
  80fb4d:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80fb54:	00 00 00 
  80fb57:	ff d1                	callq  *%rcx
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  80fb59:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fb5d:	8b 40 18             	mov    0x18(%rax),%eax
  80fb60:	83 f8 01             	cmp    $0x1,%eax
  80fb63:	75 2a                	jne    80fb8f <tcp_slowtmr+0xb0>
  80fb65:	48 ba e0 24 82 00 00 	movabs $0x8224e0,%rdx
  80fb6c:	00 00 00 
  80fb6f:	be 38 02 00 00       	mov    $0x238,%esi
  80fb74:	48 bf 3b 24 82 00 00 	movabs $0x82243b,%rdi
  80fb7b:	00 00 00 
  80fb7e:	b8 00 00 00 00       	mov    $0x0,%eax
  80fb83:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80fb8a:	00 00 00 
  80fb8d:	ff d1                	callq  *%rcx
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  80fb8f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fb93:	8b 40 18             	mov    0x18(%rax),%eax
  80fb96:	83 f8 0a             	cmp    $0xa,%eax
  80fb99:	75 2a                	jne    80fbc5 <tcp_slowtmr+0xe6>
  80fb9b:	48 ba 10 25 82 00 00 	movabs $0x822510,%rdx
  80fba2:	00 00 00 
  80fba5:	be 39 02 00 00       	mov    $0x239,%esi
  80fbaa:	48 bf 3b 24 82 00 00 	movabs $0x82243b,%rdi
  80fbb1:	00 00 00 
  80fbb4:	b8 00 00 00 00       	mov    $0x0,%eax
  80fbb9:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  80fbc0:	00 00 00 
  80fbc3:	ff d1                	callq  *%rcx

    pcb_remove = 0;
  80fbc5:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  80fbc9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fbcd:	8b 40 18             	mov    0x18(%rax),%eax
  80fbd0:	83 f8 02             	cmp    $0x2,%eax
  80fbd3:	75 15                	jne    80fbea <tcp_slowtmr+0x10b>
  80fbd5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fbd9:	0f b6 40 52          	movzbl 0x52(%rax),%eax
  80fbdd:	3c 06                	cmp    $0x6,%al
  80fbdf:	75 09                	jne    80fbea <tcp_slowtmr+0x10b>
      ++pcb_remove;
  80fbe1:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
  80fbe5:	e9 e4 01 00 00       	jmpq   80fdce <tcp_slowtmr+0x2ef>
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  80fbea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fbee:	0f b6 40 52          	movzbl 0x52(%rax),%eax
  80fbf2:	3c 0c                	cmp    $0xc,%al
  80fbf4:	75 09                	jne    80fbff <tcp_slowtmr+0x120>
      ++pcb_remove;
  80fbf6:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
  80fbfa:	e9 cf 01 00 00       	jmpq   80fdce <tcp_slowtmr+0x2ef>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
  80fbff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc03:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  80fc0a:	84 c0                	test   %al,%al
  80fc0c:	0f 84 9a 00 00 00    	je     80fcac <tcp_slowtmr+0x1cd>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
  80fc12:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc16:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  80fc1c:	8d 50 01             	lea    0x1(%rax),%edx
  80fc1f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc23:	89 90 d4 00 00 00    	mov    %edx,0xd4(%rax)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  80fc29:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc2d:	8b 88 d4 00 00 00    	mov    0xd4(%rax),%ecx
  80fc33:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc37:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  80fc3e:	0f b6 c0             	movzbl %al,%eax
  80fc41:	83 e8 01             	sub    $0x1,%eax
  80fc44:	48 ba c5 23 82 00 00 	movabs $0x8223c5,%rdx
  80fc4b:	00 00 00 
  80fc4e:	48 98                	cltq   
  80fc50:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  80fc54:	0f b6 c0             	movzbl %al,%eax
  80fc57:	39 c1                	cmp    %eax,%ecx
  80fc59:	0f 82 6f 01 00 00    	jb     80fdce <tcp_slowtmr+0x2ef>
          pcb->persist_cnt = 0;
  80fc5f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc63:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  80fc6a:	00 00 00 
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
  80fc6d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc71:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  80fc78:	3c 06                	cmp    $0x6,%al
  80fc7a:	77 18                	ja     80fc94 <tcp_slowtmr+0x1b5>
            pcb->persist_backoff++;
  80fc7c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc80:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  80fc87:	8d 50 01             	lea    0x1(%rax),%edx
  80fc8a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc8e:	88 90 d8 00 00 00    	mov    %dl,0xd8(%rax)
          }
          tcp_zero_window_probe(pcb);
  80fc94:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc98:	48 89 c7             	mov    %rax,%rdi
  80fc9b:	48 b8 1a 4b 81 00 00 	movabs $0x814b1a,%rax
  80fca2:	00 00 00 
  80fca5:	ff d0                	callq  *%rax
  80fca7:	e9 22 01 00 00       	jmpq   80fdce <tcp_slowtmr+0x2ef>
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
  80fcac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fcb0:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  80fcb4:	66 85 c0             	test   %ax,%ax
  80fcb7:	78 13                	js     80fccc <tcp_slowtmr+0x1ed>
          ++pcb->rtime;
  80fcb9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fcbd:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  80fcc1:	8d 50 01             	lea    0x1(%rax),%edx
  80fcc4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fcc8:	66 89 50 3e          	mov    %dx,0x3e(%rax)

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  80fccc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fcd0:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  80fcd7:	48 85 c0             	test   %rax,%rax
  80fcda:	0f 84 ee 00 00 00    	je     80fdce <tcp_slowtmr+0x2ef>
  80fce0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fce4:	0f b7 50 3e          	movzwl 0x3e(%rax),%edx
  80fce8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fcec:	0f b7 40 50          	movzwl 0x50(%rax),%eax
  80fcf0:	66 39 c2             	cmp    %ax,%dx
  80fcf3:	0f 8c d5 00 00 00    	jl     80fdce <tcp_slowtmr+0x2ef>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
  80fcf9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fcfd:	8b 40 18             	mov    0x18(%rax),%eax
  80fd00:	83 f8 02             	cmp    $0x2,%eax
  80fd03:	74 49                	je     80fd4e <tcp_slowtmr+0x26f>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
  80fd05:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd09:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  80fd0d:	66 c1 f8 03          	sar    $0x3,%ax
  80fd11:	0f bf d0             	movswl %ax,%edx
  80fd14:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd18:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  80fd1c:	98                   	cwtl   
  80fd1d:	8d 34 02             	lea    (%rdx,%rax,1),%esi
  80fd20:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd24:	0f b6 40 52          	movzbl 0x52(%rax),%eax
  80fd28:	0f b6 c0             	movzbl %al,%eax
  80fd2b:	48 ba b8 23 82 00 00 	movabs $0x8223b8,%rdx
  80fd32:	00 00 00 
  80fd35:	48 98                	cltq   
  80fd37:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  80fd3b:	0f b6 c0             	movzbl %al,%eax
  80fd3e:	89 c1                	mov    %eax,%ecx
  80fd40:	d3 e6                	shl    %cl,%esi
  80fd42:	89 f0                	mov    %esi,%eax
  80fd44:	89 c2                	mov    %eax,%edx
  80fd46:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd4a:	66 89 50 50          	mov    %dx,0x50(%rax)
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
  80fd4e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd52:	66 c7 40 3e 00 00    	movw   $0x0,0x3e(%rax)

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
  80fd58:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd5c:	0f b7 50 68          	movzwl 0x68(%rax),%edx
  80fd60:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd64:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  80fd68:	66 39 c2             	cmp    %ax,%dx
  80fd6b:	0f 46 c2             	cmovbe %edx,%eax
  80fd6e:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
          pcb->ssthresh = eff_wnd >> 1;
  80fd72:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  80fd76:	66 d1 e8             	shr    %ax
  80fd79:	89 c2                	mov    %eax,%edx
  80fd7b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd7f:	66 89 50 5c          	mov    %dx,0x5c(%rax)
          if (pcb->ssthresh < pcb->mss) {
  80fd83:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd87:	0f b7 50 5c          	movzwl 0x5c(%rax),%edx
  80fd8b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd8f:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80fd93:	66 39 c2             	cmp    %ax,%dx
  80fd96:	73 13                	jae    80fdab <tcp_slowtmr+0x2cc>
            pcb->ssthresh = pcb->mss * 2;
  80fd98:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd9c:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80fda0:	8d 14 00             	lea    (%rax,%rax,1),%edx
  80fda3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fda7:	66 89 50 5c          	mov    %dx,0x5c(%rax)
          }
          pcb->cwnd = pcb->mss;
  80fdab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fdaf:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  80fdb3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fdb7:	66 89 50 5a          	mov    %dx,0x5a(%rax)
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
  80fdbb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fdbf:	48 89 c7             	mov    %rax,%rdi
  80fdc2:	48 b8 52 47 81 00 00 	movabs $0x814752,%rax
  80fdc9:	00 00 00 
  80fdcc:	ff d0                	callq  *%rax
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
  80fdce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fdd2:	8b 40 18             	mov    0x18(%rax),%eax
  80fdd5:	83 f8 06             	cmp    $0x6,%eax
  80fdd8:	75 20                	jne    80fdfa <tcp_slowtmr+0x31b>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  80fdda:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80fde1:	00 00 00 
  80fde4:	8b 10                	mov    (%rax),%edx
  80fde6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fdea:	8b 40 38             	mov    0x38(%rax),%eax
  80fded:	29 c2                	sub    %eax,%edx
  80fdef:	89 d0                	mov    %edx,%eax
  80fdf1:	83 f8 28             	cmp    $0x28,%eax
  80fdf4:	76 04                	jbe    80fdfa <tcp_slowtmr+0x31b>
          TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  80fdf6:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
  80fdfa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fdfe:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80fe02:	0f b7 c0             	movzwl %ax,%eax
  80fe05:	83 e0 08             	and    $0x8,%eax
  80fe08:	85 c0                	test   %eax,%eax
  80fe0a:	0f 84 01 01 00 00    	je     80ff11 <tcp_slowtmr+0x432>
       ((pcb->state == ESTABLISHED) || 
  80fe10:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe14:	8b 40 18             	mov    0x18(%rax),%eax
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
  80fe17:	83 f8 04             	cmp    $0x4,%eax
  80fe1a:	74 10                	je     80fe2c <tcp_slowtmr+0x34d>
       ((pcb->state == ESTABLISHED) || 
        (pcb->state == CLOSE_WAIT))) {
  80fe1c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe20:	8b 40 18             	mov    0x18(%rax),%eax
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
       ((pcb->state == ESTABLISHED) || 
  80fe23:	83 f8 07             	cmp    $0x7,%eax
  80fe26:	0f 85 e5 00 00 00    	jne    80ff11 <tcp_slowtmr+0x432>
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  80fe2c:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80fe33:	00 00 00 
  80fe36:	8b 10                	mov    (%rax),%edx
  80fe38:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe3c:	8b 40 38             	mov    0x38(%rax),%eax
  80fe3f:	29 c2                	sub    %eax,%edx
  80fe41:	89 d0                	mov    %edx,%eax
  80fe43:	89 c1                	mov    %eax,%ecx
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
  80fe45:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe49:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  80fe4f:	89 c0                	mov    %eax,%eax
  80fe51:	48 05 b8 4c 0a 00    	add    $0xa4cb8,%rax
  80fe57:	48 c1 e8 02          	shr    $0x2,%rax
  80fe5b:	48 ba cf f7 53 e3 a5 	movabs $0x20c49ba5e353f7cf,%rdx
  80fe62:	9b c4 20 
  80fe65:	48 f7 e2             	mul    %rdx
  80fe68:	48 89 d0             	mov    %rdx,%rax
  80fe6b:	48 c1 e8 04          	shr    $0x4,%rax
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  80fe6f:	48 39 c1             	cmp    %rax,%rcx
  80fe72:	76 18                	jbe    80fe8c <tcp_slowtmr+0x3ad>
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                                ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));
        
        tcp_abort(pcb);
  80fe74:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe78:	48 89 c7             	mov    %rax,%rdi
  80fe7b:	48 b8 ff ee 80 00 00 	movabs $0x80eeff,%rax
  80fe82:	00 00 00 
  80fe85:	ff d0                	callq  *%rax
  80fe87:	e9 85 00 00 00       	jmpq   80ff11 <tcp_slowtmr+0x432>
#if LWIP_TCP_KEEPALIVE
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
  80fe8c:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80fe93:	00 00 00 
  80fe96:	8b 10                	mov    (%rax),%edx
  80fe98:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe9c:	8b 40 38             	mov    0x38(%rax),%eax
  80fe9f:	29 c2                	sub    %eax,%edx
  80fea1:	89 d0                	mov    %edx,%eax
  80fea3:	89 c1                	mov    %eax,%ecx
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
  80fea5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fea9:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  80feaf:	89 c2                	mov    %eax,%edx
  80feb1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80feb5:	0f b6 80 d9 00 00 00 	movzbl 0xd9(%rax),%eax
  80febc:	0f b6 c0             	movzbl %al,%eax
  80febf:	48 69 c0 f8 24 01 00 	imul   $0x124f8,%rax,%rax
  80fec6:	48 01 d0             	add    %rdx,%rax
              / TCP_SLOW_INTERVAL)
  80fec9:	48 c1 e8 02          	shr    $0x2,%rax
  80fecd:	48 ba cf f7 53 e3 a5 	movabs $0x20c49ba5e353f7cf,%rdx
  80fed4:	9b c4 20 
  80fed7:	48 f7 e2             	mul    %rdx
  80feda:	48 89 d0             	mov    %rdx,%rax
  80fedd:	48 c1 e8 04          	shr    $0x4,%rax
#if LWIP_TCP_KEEPALIVE
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
  80fee1:	48 39 c1             	cmp    %rax,%rcx
  80fee4:	76 2b                	jbe    80ff11 <tcp_slowtmr+0x432>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
              / TCP_SLOW_INTERVAL)
#endif /* LWIP_TCP_KEEPALIVE */
      {
        tcp_keepalive(pcb);
  80fee6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80feea:	48 89 c7             	mov    %rax,%rdi
  80feed:	48 b8 f5 48 81 00 00 	movabs $0x8148f5,%rax
  80fef4:	00 00 00 
  80fef7:	ff d0                	callq  *%rax
        pcb->keep_cnt_sent++;
  80fef9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fefd:	0f b6 80 d9 00 00 00 	movzbl 0xd9(%rax),%eax
  80ff04:	8d 50 01             	lea    0x1(%rax),%edx
  80ff07:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ff0b:	88 90 d9 00 00 00    	mov    %dl,0xd9(%rax)

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  80ff11:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ff15:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  80ff1c:	48 85 c0             	test   %rax,%rax
  80ff1f:	74 57                	je     80ff78 <tcp_slowtmr+0x499>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
  80ff21:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80ff28:	00 00 00 
  80ff2b:	8b 10                	mov    (%rax),%edx
  80ff2d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ff31:	8b 40 38             	mov    0x38(%rax),%eax
  80ff34:	89 d1                	mov    %edx,%ecx
  80ff36:	29 c1                	sub    %eax,%ecx
  80ff38:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ff3c:	0f b7 40 50          	movzwl 0x50(%rax),%eax
  80ff40:	0f bf d0             	movswl %ax,%edx
  80ff43:	89 d0                	mov    %edx,%eax
  80ff45:	01 c0                	add    %eax,%eax
  80ff47:	01 d0                	add    %edx,%eax
  80ff49:	01 c0                	add    %eax,%eax

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  80ff4b:	39 c1                	cmp    %eax,%ecx
  80ff4d:	72 29                	jb     80ff78 <tcp_slowtmr+0x499>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
      tcp_segs_free(pcb->ooseq);
  80ff4f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ff53:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  80ff5a:	48 89 c7             	mov    %rax,%rdi
  80ff5d:	48 b8 34 04 81 00 00 	movabs $0x810434,%rax
  80ff64:	00 00 00 
  80ff67:	ff d0                	callq  *%rax
      pcb->ooseq = NULL;
  80ff69:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ff6d:	48 c7 80 90 00 00 00 	movq   $0x0,0x90(%rax)
  80ff74:	00 00 00 00 
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
  80ff78:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ff7c:	8b 40 18             	mov    0x18(%rax),%eax
  80ff7f:	83 f8 03             	cmp    $0x3,%eax
  80ff82:	75 20                	jne    80ffa4 <tcp_slowtmr+0x4c5>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  80ff84:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80ff8b:	00 00 00 
  80ff8e:	8b 10                	mov    (%rax),%edx
  80ff90:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ff94:	8b 40 38             	mov    0x38(%rax),%eax
  80ff97:	29 c2                	sub    %eax,%edx
  80ff99:	89 d0                	mov    %edx,%eax
  80ff9b:	83 f8 28             	cmp    $0x28,%eax
  80ff9e:	76 04                	jbe    80ffa4 <tcp_slowtmr+0x4c5>
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  80ffa0:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
  80ffa4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ffa8:	8b 40 18             	mov    0x18(%rax),%eax
  80ffab:	83 f8 09             	cmp    $0x9,%eax
  80ffae:	75 22                	jne    80ffd2 <tcp_slowtmr+0x4f3>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  80ffb0:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80ffb7:	00 00 00 
  80ffba:	8b 10                	mov    (%rax),%edx
  80ffbc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ffc0:	8b 40 38             	mov    0x38(%rax),%eax
  80ffc3:	29 c2                	sub    %eax,%edx
  80ffc5:	89 d0                	mov    %edx,%eax
  80ffc7:	3d f0 00 00 00       	cmp    $0xf0,%eax
  80ffcc:	76 04                	jbe    80ffd2 <tcp_slowtmr+0x4f3>
        ++pcb_remove;
  80ffce:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  80ffd2:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  80ffd6:	0f 84 19 01 00 00    	je     8100f5 <tcp_slowtmr+0x616>
      tcp_pcb_purge(pcb);      
  80ffdc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ffe0:	48 89 c7             	mov    %rax,%rdi
  80ffe3:	48 b8 a7 09 81 00 00 	movabs $0x8109a7,%rax
  80ffea:	00 00 00 
  80ffed:	ff d0                	callq  *%rax
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
  80ffef:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80fff4:	74 4f                	je     810045 <tcp_slowtmr+0x566>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  80fff6:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80fffd:	00 00 00 
  810000:	48 8b 00             	mov    (%rax),%rax
  810003:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  810007:	75 2a                	jne    810033 <tcp_slowtmr+0x554>
  810009:	48 ba 40 25 82 00 00 	movabs $0x822540,%rdx
  810010:	00 00 00 
  810013:	be c2 02 00 00       	mov    $0x2c2,%esi
  810018:	48 bf 3b 24 82 00 00 	movabs $0x82243b,%rdi
  81001f:	00 00 00 
  810022:	b8 00 00 00 00       	mov    $0x0,%eax
  810027:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81002e:	00 00 00 
  810031:	ff d1                	callq  *%rcx
        prev->next = pcb->next;
  810033:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810037:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81003b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81003f:	48 89 50 10          	mov    %rdx,0x10(%rax)
  810043:	eb 52                	jmp    810097 <tcp_slowtmr+0x5b8>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  810045:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81004c:	00 00 00 
  81004f:	48 8b 00             	mov    (%rax),%rax
  810052:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  810056:	74 2a                	je     810082 <tcp_slowtmr+0x5a3>
  810058:	48 ba 70 25 82 00 00 	movabs $0x822570,%rdx
  81005f:	00 00 00 
  810062:	be c6 02 00 00       	mov    $0x2c6,%esi
  810067:	48 bf 3b 24 82 00 00 	movabs $0x82243b,%rdi
  81006e:	00 00 00 
  810071:	b8 00 00 00 00       	mov    $0x0,%eax
  810076:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81007d:	00 00 00 
  810080:	ff d1                	callq  *%rcx
        tcp_active_pcbs = pcb->next;
  810082:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810086:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81008a:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  810091:	00 00 00 
  810094:	48 89 10             	mov    %rdx,(%rax)
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
  810097:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81009b:	48 8b 80 c8 00 00 00 	mov    0xc8(%rax),%rax
  8100a2:	48 85 c0             	test   %rax,%rax
  8100a5:	74 1d                	je     8100c4 <tcp_slowtmr+0x5e5>
  8100a7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8100ab:	48 8b 80 c8 00 00 00 	mov    0xc8(%rax),%rax
  8100b2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8100b6:	48 8b 52 20          	mov    0x20(%rdx),%rdx
  8100ba:	be fb ff ff ff       	mov    $0xfffffffb,%esi
  8100bf:	48 89 d7             	mov    %rdx,%rdi
  8100c2:	ff d0                	callq  *%rax

      pcb2 = pcb->next;
  8100c4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8100c8:	48 8b 40 10          	mov    0x10(%rax),%rax
  8100cc:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      memp_free(MEMP_TCP_PCB, pcb);
  8100d0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8100d4:	48 89 c6             	mov    %rax,%rsi
  8100d7:	bf 02 00 00 00       	mov    $0x2,%edi
  8100dc:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  8100e3:	00 00 00 
  8100e6:	ff d0                	callq  *%rax
      pcb = pcb2;
  8100e8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8100ec:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8100f0:	e9 8d 00 00 00       	jmpq   810182 <tcp_slowtmr+0x6a3>
    } else {

      /* We check if we should poll the connection. */
      ++pcb->polltmr;
  8100f5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8100f9:	0f b6 40 3c          	movzbl 0x3c(%rax),%eax
  8100fd:	8d 50 01             	lea    0x1(%rax),%edx
  810100:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810104:	88 50 3c             	mov    %dl,0x3c(%rax)
      if (pcb->polltmr >= pcb->pollinterval) {
  810107:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81010b:	0f b6 50 3c          	movzbl 0x3c(%rax),%edx
  81010f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810113:	0f b6 40 3d          	movzbl 0x3d(%rax),%eax
  810117:	38 c2                	cmp    %al,%dl
  810119:	72 53                	jb     81016e <tcp_slowtmr+0x68f>
        pcb->polltmr = 0;
  81011b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81011f:	c6 40 3c 00          	movb   $0x0,0x3c(%rax)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        TCP_EVENT_POLL(pcb, err);
  810123:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810127:	48 8b 80 c0 00 00 00 	mov    0xc0(%rax),%rax
  81012e:	48 85 c0             	test   %rax,%rax
  810131:	74 22                	je     810155 <tcp_slowtmr+0x676>
  810133:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810137:	48 8b 80 c0 00 00 00 	mov    0xc0(%rax),%rax
  81013e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  810142:	48 8b 52 20          	mov    0x20(%rdx),%rdx
  810146:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  81014a:	48 89 ce             	mov    %rcx,%rsi
  81014d:	48 89 d7             	mov    %rdx,%rdi
  810150:	ff d0                	callq  *%rax
  810152:	88 45 ee             	mov    %al,-0x12(%rbp)
        if (err == ERR_OK) {
  810155:	80 7d ee 00          	cmpb   $0x0,-0x12(%rbp)
  810159:	75 13                	jne    81016e <tcp_slowtmr+0x68f>
          tcp_output(pcb);
  81015b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81015f:	48 89 c7             	mov    %rax,%rdi
  810162:	48 b8 3d 3c 81 00 00 	movabs $0x813c3d,%rax
  810169:	00 00 00 
  81016c:	ff d0                	callq  *%rax
        }
      }
      
      prev = pcb;
  81016e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810172:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      pcb = pcb->next;
  810176:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81017a:	48 8b 40 10          	mov    0x10(%rax),%rax
  81017e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
  810182:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  810187:	0f 85 97 f9 ff ff    	jne    80fb24 <tcp_slowtmr+0x45>
    }
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  81018d:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  810194:	00 
  pcb = tcp_tw_pcbs;
  810195:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81019c:	00 00 00 
  81019f:	48 8b 00             	mov    (%rax),%rax
  8101a2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  while (pcb != NULL) {
  8101a6:	e9 63 01 00 00       	jmpq   81030e <tcp_slowtmr+0x82f>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  8101ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8101af:	8b 40 18             	mov    0x18(%rax),%eax
  8101b2:	83 f8 0a             	cmp    $0xa,%eax
  8101b5:	74 2a                	je     8101e1 <tcp_slowtmr+0x702>
  8101b7:	48 ba a0 25 82 00 00 	movabs $0x8225a0,%rdx
  8101be:	00 00 00 
  8101c1:	be e6 02 00 00       	mov    $0x2e6,%esi
  8101c6:	48 bf 3b 24 82 00 00 	movabs $0x82243b,%rdi
  8101cd:	00 00 00 
  8101d0:	b8 00 00 00 00       	mov    $0x0,%eax
  8101d5:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  8101dc:	00 00 00 
  8101df:	ff d1                	callq  *%rcx
    pcb_remove = 0;
  8101e1:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  8101e5:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  8101ec:	00 00 00 
  8101ef:	8b 10                	mov    (%rax),%edx
  8101f1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8101f5:	8b 40 38             	mov    0x38(%rax),%eax
  8101f8:	29 c2                	sub    %eax,%edx
  8101fa:	89 d0                	mov    %edx,%eax
  8101fc:	3d f0 00 00 00       	cmp    $0xf0,%eax
  810201:	76 04                	jbe    810207 <tcp_slowtmr+0x728>
      ++pcb_remove;
  810203:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
    }
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  810207:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  81020b:	0f 84 e9 00 00 00    	je     8102fa <tcp_slowtmr+0x81b>
      tcp_pcb_purge(pcb);      
  810211:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810215:	48 89 c7             	mov    %rax,%rdi
  810218:	48 b8 a7 09 81 00 00 	movabs $0x8109a7,%rax
  81021f:	00 00 00 
  810222:	ff d0                	callq  *%rax
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
  810224:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  810229:	74 4f                	je     81027a <tcp_slowtmr+0x79b>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  81022b:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  810232:	00 00 00 
  810235:	48 8b 00             	mov    (%rax),%rax
  810238:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  81023c:	75 2a                	jne    810268 <tcp_slowtmr+0x789>
  81023e:	48 ba d0 25 82 00 00 	movabs $0x8225d0,%rdx
  810245:	00 00 00 
  810248:	be f5 02 00 00       	mov    $0x2f5,%esi
  81024d:	48 bf 3b 24 82 00 00 	movabs $0x82243b,%rdi
  810254:	00 00 00 
  810257:	b8 00 00 00 00       	mov    $0x0,%eax
  81025c:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  810263:	00 00 00 
  810266:	ff d1                	callq  *%rcx
        prev->next = pcb->next;
  810268:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81026c:	48 8b 50 10          	mov    0x10(%rax),%rdx
  810270:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810274:	48 89 50 10          	mov    %rdx,0x10(%rax)
  810278:	eb 52                	jmp    8102cc <tcp_slowtmr+0x7ed>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  81027a:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  810281:	00 00 00 
  810284:	48 8b 00             	mov    (%rax),%rax
  810287:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  81028b:	74 2a                	je     8102b7 <tcp_slowtmr+0x7d8>
  81028d:	48 ba f8 25 82 00 00 	movabs $0x8225f8,%rdx
  810294:	00 00 00 
  810297:	be f9 02 00 00       	mov    $0x2f9,%esi
  81029c:	48 bf 3b 24 82 00 00 	movabs $0x82243b,%rdi
  8102a3:	00 00 00 
  8102a6:	b8 00 00 00 00       	mov    $0x0,%eax
  8102ab:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  8102b2:	00 00 00 
  8102b5:	ff d1                	callq  *%rcx
        tcp_tw_pcbs = pcb->next;
  8102b7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8102bb:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8102bf:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  8102c6:	00 00 00 
  8102c9:	48 89 10             	mov    %rdx,(%rax)
      }
      pcb2 = pcb->next;
  8102cc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8102d0:	48 8b 40 10          	mov    0x10(%rax),%rax
  8102d4:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      memp_free(MEMP_TCP_PCB, pcb);
  8102d8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8102dc:	48 89 c6             	mov    %rax,%rsi
  8102df:	bf 02 00 00 00       	mov    $0x2,%edi
  8102e4:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  8102eb:	00 00 00 
  8102ee:	ff d0                	callq  *%rax
      pcb = pcb2;
  8102f0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8102f4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8102f8:	eb 14                	jmp    81030e <tcp_slowtmr+0x82f>
    } else {
      prev = pcb;
  8102fa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8102fe:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      pcb = pcb->next;
  810302:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810306:	48 8b 40 10          	mov    0x10(%rax),%rax
  81030a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
  81030e:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  810313:	0f 85 92 fe ff ff    	jne    8101ab <tcp_slowtmr+0x6cc>
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
  810319:	c9                   	leaveq 
  81031a:	c3                   	retq   

000000000081031b <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
  81031b:	55                   	push   %rbp
  81031c:	48 89 e5             	mov    %rsp,%rbp
  81031f:	48 83 ec 10          	sub    $0x10,%rsp
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  810323:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81032a:	00 00 00 
  81032d:	48 8b 00             	mov    (%rax),%rax
  810330:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  810334:	e9 ee 00 00 00       	jmpq   810427 <tcp_fasttmr+0x10c>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  810339:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81033d:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  810344:	48 85 c0             	test   %rax,%rax
  810347:	0f 84 81 00 00 00    	je     8103ce <tcp_fasttmr+0xb3>
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  81034d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810351:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  810358:	48 85 c0             	test   %rax,%rax
  81035b:	74 2e                	je     81038b <tcp_fasttmr+0x70>
  81035d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810361:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  810368:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81036c:	48 8b 92 98 00 00 00 	mov    0x98(%rdx),%rdx
  810373:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  810377:	48 8b 79 20          	mov    0x20(%rcx),%rdi
  81037b:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  81037f:	b9 00 00 00 00       	mov    $0x0,%ecx
  810384:	ff d0                	callq  *%rax
  810386:	88 45 f7             	mov    %al,-0x9(%rbp)
  810389:	eb 2e                	jmp    8103b9 <tcp_fasttmr+0x9e>
  81038b:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
  81038f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810393:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  81039a:	48 85 c0             	test   %rax,%rax
  81039d:	74 1a                	je     8103b9 <tcp_fasttmr+0x9e>
  81039f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8103a3:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  8103aa:	48 89 c7             	mov    %rax,%rdi
  8103ad:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  8103b4:	00 00 00 
  8103b7:	ff d0                	callq  *%rax
      if (err == ERR_OK) {
  8103b9:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  8103bd:	75 0f                	jne    8103ce <tcp_fasttmr+0xb3>
        pcb->refused_data = NULL;
  8103bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8103c3:	48 c7 80 98 00 00 00 	movq   $0x0,0x98(%rax)
  8103ca:	00 00 00 00 
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
  8103ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8103d2:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  8103d6:	0f b6 c0             	movzbl %al,%eax
  8103d9:	83 e0 01             	and    $0x1,%eax
  8103dc:	85 c0                	test   %eax,%eax
  8103de:	74 3b                	je     81041b <tcp_fasttmr+0x100>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
  8103e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8103e4:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  8103e8:	83 c8 02             	or     $0x2,%eax
  8103eb:	89 c2                	mov    %eax,%edx
  8103ed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8103f1:	88 50 2c             	mov    %dl,0x2c(%rax)
  8103f4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8103f8:	48 89 c7             	mov    %rax,%rdi
  8103fb:	48 b8 3d 3c 81 00 00 	movabs $0x813c3d,%rax
  810402:	00 00 00 
  810405:	ff d0                	callq  *%rax
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  810407:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81040b:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81040f:	83 e0 fc             	and    $0xfffffffc,%eax
  810412:	89 c2                	mov    %eax,%edx
  810414:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810418:	88 50 2c             	mov    %dl,0x2c(%rax)
void
tcp_fasttmr(void)
{
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  81041b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81041f:	48 8b 40 10          	mov    0x10(%rax),%rax
  810423:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  810427:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81042c:	0f 85 07 ff ff ff    	jne    810339 <tcp_fasttmr+0x1e>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }
  }
}
  810432:	c9                   	leaveq 
  810433:	c3                   	retq   

0000000000810434 <tcp_segs_free>:
 * @param seg tcp_seg list of TCP segments to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  810434:	55                   	push   %rbp
  810435:	48 89 e5             	mov    %rsp,%rbp
  810438:	48 83 ec 20          	sub    $0x20,%rsp
  81043c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  u8_t count = 0;
  810440:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  struct tcp_seg *next;
  while (seg != NULL) {
  810444:	eb 29                	jmp    81046f <tcp_segs_free+0x3b>
    next = seg->next;
  810446:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81044a:	48 8b 00             	mov    (%rax),%rax
  81044d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    count += tcp_seg_free(seg);
  810451:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810455:	48 89 c7             	mov    %rax,%rdi
  810458:	48 b8 7c 04 81 00 00 	movabs $0x81047c,%rax
  81045f:	00 00 00 
  810462:	ff d0                	callq  *%rax
  810464:	00 45 ff             	add    %al,-0x1(%rbp)
    seg = next;
  810467:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81046b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  struct tcp_seg *next;
  while (seg != NULL) {
  81046f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  810474:	75 d0                	jne    810446 <tcp_segs_free+0x12>
    next = seg->next;
    count += tcp_seg_free(seg);
    seg = next;
  }
  return count;
  810476:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  81047a:	c9                   	leaveq 
  81047b:	c3                   	retq   

000000000081047c <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  81047c:	55                   	push   %rbp
  81047d:	48 89 e5             	mov    %rsp,%rbp
  810480:	48 83 ec 20          	sub    $0x20,%rsp
  810484:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  u8_t count = 0;
  810488:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  
  if (seg != NULL) {
  81048c:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  810491:	74 3f                	je     8104d2 <tcp_seg_free+0x56>
    if (seg->p != NULL) {
  810493:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810497:	48 8b 40 08          	mov    0x8(%rax),%rax
  81049b:	48 85 c0             	test   %rax,%rax
  81049e:	74 1a                	je     8104ba <tcp_seg_free+0x3e>
      count = pbuf_free(seg->p);
  8104a0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8104a4:	48 8b 40 08          	mov    0x8(%rax),%rax
  8104a8:	48 89 c7             	mov    %rax,%rdi
  8104ab:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  8104b2:	00 00 00 
  8104b5:	ff d0                	callq  *%rax
  8104b7:	88 45 ff             	mov    %al,-0x1(%rbp)
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  8104ba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8104be:	48 89 c6             	mov    %rax,%rsi
  8104c1:	bf 04 00 00 00       	mov    $0x4,%edi
  8104c6:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  8104cd:	00 00 00 
  8104d0:	ff d0                	callq  *%rax
  }
  return count;
  8104d2:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  8104d6:	c9                   	leaveq 
  8104d7:	c3                   	retq   

00000000008104d8 <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  8104d8:	55                   	push   %rbp
  8104d9:	48 89 e5             	mov    %rsp,%rbp
  8104dc:	48 83 ec 0c          	sub    $0xc,%rsp
  8104e0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8104e4:	89 f0                	mov    %esi,%eax
  8104e6:	88 45 f4             	mov    %al,-0xc(%rbp)
  pcb->prio = prio;
  8104e9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8104ed:	0f b6 55 f4          	movzbl -0xc(%rbp),%edx
  8104f1:	88 50 1c             	mov    %dl,0x1c(%rax)
}
  8104f4:	c9                   	leaveq 
  8104f5:	c3                   	retq   

00000000008104f6 <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
  8104f6:	55                   	push   %rbp
  8104f7:	48 89 e5             	mov    %rsp,%rbp
  8104fa:	48 83 ec 20          	sub    $0x20,%rsp
  8104fe:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
  810502:	bf 04 00 00 00       	mov    $0x4,%edi
  810507:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  81050e:	00 00 00 
  810511:	ff d0                	callq  *%rax
  810513:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (cseg == NULL) {
  810517:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81051c:	75 07                	jne    810525 <tcp_seg_copy+0x2f>
    return NULL;
  81051e:	b8 00 00 00 00       	mov    $0x0,%eax
  810523:	eb 3a                	jmp    81055f <tcp_seg_copy+0x69>
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
  810525:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  810529:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81052d:	ba 28 00 00 00       	mov    $0x28,%edx
  810532:	48 89 ce             	mov    %rcx,%rsi
  810535:	48 89 c7             	mov    %rax,%rdi
  810538:	48 b8 12 23 80 00 00 	movabs $0x802312,%rax
  81053f:	00 00 00 
  810542:	ff d0                	callq  *%rax
  pbuf_ref(cseg->p);
  810544:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810548:	48 8b 40 08          	mov    0x8(%rax),%rax
  81054c:	48 89 c7             	mov    %rax,%rdi
  81054f:	48 b8 23 df 80 00 00 	movabs $0x80df23,%rax
  810556:	00 00 00 
  810559:	ff d0                	callq  *%rax
  return cseg;
  81055b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  81055f:	c9                   	leaveq 
  810560:	c3                   	retq   

0000000000810561 <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
static err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  810561:	55                   	push   %rbp
  810562:	48 89 e5             	mov    %rsp,%rbp
  810565:	48 83 ec 20          	sub    $0x20,%rsp
  810569:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81056d:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  810571:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  810575:	89 c8                	mov    %ecx,%eax
  810577:	88 45 e4             	mov    %al,-0x1c(%rbp)
  arg = arg;
  if (p != NULL) {
  81057a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81057f:	74 15                	je     810596 <tcp_recv_null+0x35>
    pbuf_free(p);
  810581:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810585:	48 89 c7             	mov    %rax,%rdi
  810588:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  81058f:	00 00 00 
  810592:	ff d0                	callq  *%rax
  810594:	eb 1b                	jmp    8105b1 <tcp_recv_null+0x50>
  } else if (err == ERR_OK) {
  810596:	80 7d e4 00          	cmpb   $0x0,-0x1c(%rbp)
  81059a:	75 15                	jne    8105b1 <tcp_recv_null+0x50>
    return tcp_close(pcb);
  81059c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8105a0:	48 89 c7             	mov    %rax,%rdi
  8105a3:	48 b8 79 ec 80 00 00 	movabs $0x80ec79,%rax
  8105aa:	00 00 00 
  8105ad:	ff d0                	callq  *%rax
  8105af:	eb 05                	jmp    8105b6 <tcp_recv_null+0x55>
  }
  return ERR_OK;
  8105b1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8105b6:	c9                   	leaveq 
  8105b7:	c3                   	retq   

00000000008105b8 <tcp_kill_prio>:
 *
 * @param prio minimum priority
 */
static void
tcp_kill_prio(u8_t prio)
{
  8105b8:	55                   	push   %rbp
  8105b9:	48 89 e5             	mov    %rsp,%rbp
  8105bc:	48 83 ec 30          	sub    $0x30,%rsp
  8105c0:	89 f8                	mov    %edi,%eax
  8105c2:	88 45 dc             	mov    %al,-0x24(%rbp)
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;


  mprio = TCP_PRIO_MAX;
  8105c5:	c6 45 eb 7f          	movb   $0x7f,-0x15(%rbp)
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  8105c9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  inactive = NULL;
  8105d0:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8105d7:	00 
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8105d8:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  8105df:	00 00 00 
  8105e2:	48 8b 00             	mov    (%rax),%rax
  8105e5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8105e9:	eb 6f                	jmp    81065a <tcp_kill_prio+0xa2>
    if (pcb->prio <= prio &&
  8105eb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8105ef:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8105f3:	3a 45 dc             	cmp    -0x24(%rbp),%al
  8105f6:	77 56                	ja     81064e <tcp_kill_prio+0x96>
       pcb->prio <= mprio &&
  8105f8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8105fc:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
  810600:	3a 45 eb             	cmp    -0x15(%rbp),%al
  810603:	77 49                	ja     81064e <tcp_kill_prio+0x96>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  810605:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  81060c:	00 00 00 
  81060f:	8b 10                	mov    (%rax),%edx
  810611:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810615:	8b 40 38             	mov    0x38(%rax),%eax
  810618:	29 c2                	sub    %eax,%edx
  81061a:	89 d0                	mov    %edx,%eax
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
  81061c:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  81061f:	72 2d                	jb     81064e <tcp_kill_prio+0x96>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
  810621:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  810628:	00 00 00 
  81062b:	8b 10                	mov    (%rax),%edx
  81062d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810631:	8b 40 38             	mov    0x38(%rax),%eax
  810634:	29 c2                	sub    %eax,%edx
  810636:	89 d0                	mov    %edx,%eax
  810638:	89 45 ec             	mov    %eax,-0x14(%rbp)
      inactive = pcb;
  81063b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81063f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      mprio = pcb->prio;
  810643:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810647:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  81064b:	88 45 eb             	mov    %al,-0x15(%rbp)
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  81064e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810652:	48 8b 40 10          	mov    0x10(%rax),%rax
  810656:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  81065a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81065f:	75 8a                	jne    8105eb <tcp_kill_prio+0x33>
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
  810661:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  810666:	74 13                	je     81067b <tcp_kill_prio+0xc3>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  810668:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81066c:	48 89 c7             	mov    %rax,%rdi
  81066f:	48 b8 ff ee 80 00 00 	movabs $0x80eeff,%rax
  810676:	00 00 00 
  810679:	ff d0                	callq  *%rax
  }      
}
  81067b:	c9                   	leaveq 
  81067c:	c3                   	retq   

000000000081067d <tcp_kill_timewait>:
 * Kills the oldest connection that is in TIME_WAIT state.
 * Called from tcp_alloc() if no more connections are available.
 */
static void
tcp_kill_timewait(void)
{
  81067d:	55                   	push   %rbp
  81067e:	48 89 e5             	mov    %rsp,%rbp
  810681:	48 83 ec 20          	sub    $0x20,%rsp
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
  810685:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  inactive = NULL;
  81068c:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  810693:	00 
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  810694:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81069b:	00 00 00 
  81069e:	48 8b 00             	mov    (%rax),%rax
  8106a1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8106a5:	eb 4a                	jmp    8106f1 <tcp_kill_timewait+0x74>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8106a7:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  8106ae:	00 00 00 
  8106b1:	8b 10                	mov    (%rax),%edx
  8106b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8106b7:	8b 40 38             	mov    0x38(%rax),%eax
  8106ba:	29 c2                	sub    %eax,%edx
  8106bc:	89 d0                	mov    %edx,%eax
  8106be:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8106c1:	72 22                	jb     8106e5 <tcp_kill_timewait+0x68>
      inactivity = tcp_ticks - pcb->tmr;
  8106c3:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  8106ca:	00 00 00 
  8106cd:	8b 10                	mov    (%rax),%edx
  8106cf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8106d3:	8b 40 38             	mov    0x38(%rax),%eax
  8106d6:	29 c2                	sub    %eax,%edx
  8106d8:	89 d0                	mov    %edx,%eax
  8106da:	89 45 ec             	mov    %eax,-0x14(%rbp)
      inactive = pcb;
  8106dd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8106e1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8106e5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8106e9:	48 8b 40 10          	mov    0x10(%rax),%rax
  8106ed:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8106f1:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8106f6:	75 af                	jne    8106a7 <tcp_kill_timewait+0x2a>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
    }
  }
  if (inactive != NULL) {
  8106f8:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8106fd:	74 13                	je     810712 <tcp_kill_timewait+0x95>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  8106ff:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810703:	48 89 c7             	mov    %rax,%rdi
  810706:	48 b8 ff ee 80 00 00 	movabs $0x80eeff,%rax
  81070d:	00 00 00 
  810710:	ff d0                	callq  *%rax
  }      
}
  810712:	c9                   	leaveq 
  810713:	c3                   	retq   

0000000000810714 <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
  810714:	55                   	push   %rbp
  810715:	48 89 e5             	mov    %rsp,%rbp
  810718:	48 83 ec 20          	sub    $0x20,%rsp
  81071c:	89 f8                	mov    %edi,%eax
  81071e:	88 45 ec             	mov    %al,-0x14(%rbp)
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = memp_malloc(MEMP_TCP_PCB);
  810721:	bf 02 00 00 00       	mov    $0x2,%edi
  810726:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  81072d:	00 00 00 
  810730:	ff d0                	callq  *%rax
  810732:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (pcb == NULL) {
  810736:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81073b:	75 4f                	jne    81078c <tcp_alloc+0x78>
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
  81073d:	48 b8 7d 06 81 00 00 	movabs $0x81067d,%rax
  810744:	00 00 00 
  810747:	ff d0                	callq  *%rax
    /* Try to allocate a tcp_pcb again. */
    pcb = memp_malloc(MEMP_TCP_PCB);
  810749:	bf 02 00 00 00       	mov    $0x2,%edi
  81074e:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  810755:	00 00 00 
  810758:	ff d0                	callq  *%rax
  81075a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (pcb == NULL) {
  81075e:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  810763:	75 27                	jne    81078c <tcp_alloc+0x78>
      /* Try killing active connections with lower priority than the new one. */
      tcp_kill_prio(prio);
  810765:	0f b6 45 ec          	movzbl -0x14(%rbp),%eax
  810769:	89 c7                	mov    %eax,%edi
  81076b:	48 b8 b8 05 81 00 00 	movabs $0x8105b8,%rax
  810772:	00 00 00 
  810775:	ff d0                	callq  *%rax
      /* Try to allocate a tcp_pcb again. */
      pcb = memp_malloc(MEMP_TCP_PCB);
  810777:	bf 02 00 00 00       	mov    $0x2,%edi
  81077c:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  810783:	00 00 00 
  810786:	ff d0                	callq  *%rax
  810788:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    }
  }
  if (pcb != NULL) {
  81078c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  810791:	0f 84 23 01 00 00    	je     8108ba <tcp_alloc+0x1a6>
    memset(pcb, 0, sizeof(struct tcp_pcb));
  810797:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81079b:	ba e0 00 00 00       	mov    $0xe0,%edx
  8107a0:	be 00 00 00 00       	mov    $0x0,%esi
  8107a5:	48 89 c7             	mov    %rax,%rdi
  8107a8:	48 b8 70 21 80 00 00 	movabs $0x802170,%rax
  8107af:	00 00 00 
  8107b2:	ff d0                	callq  *%rax
    pcb->prio = TCP_PRIO_NORMAL;
  8107b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8107b8:	c6 40 1c 40          	movb   $0x40,0x1c(%rax)
    pcb->snd_buf = TCP_SND_BUF;
  8107bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8107c0:	66 c7 40 7a 40 5b    	movw   $0x5b40,0x7a(%rax)
    pcb->snd_queuelen = 0;
  8107c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8107ca:	66 c7 40 7c 00 00    	movw   $0x0,0x7c(%rax)
    pcb->rcv_wnd = TCP_WND;
  8107d0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8107d4:	66 c7 40 34 c0 5d    	movw   $0x5dc0,0x34(%rax)
    pcb->rcv_ann_wnd = TCP_WND;
  8107da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8107de:	66 c7 40 36 c0 5d    	movw   $0x5dc0,0x36(%rax)
    pcb->tos = 0;
  8107e4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8107e8:	c6 40 0a 00          	movb   $0x0,0xa(%rax)
    pcb->ttl = TCP_TTL;
  8107ec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8107f0:	c6 40 0b ff          	movb   $0xff,0xb(%rax)
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  8107f4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8107f8:	66 c7 40 40 18 02    	movw   $0x218,0x40(%rax)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  8107fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810802:	66 c7 40 50 06 00    	movw   $0x6,0x50(%rax)
    pcb->sa = 0;
  810808:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81080c:	66 c7 40 4c 00 00    	movw   $0x0,0x4c(%rax)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
  810812:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810816:	66 c7 40 4e 06 00    	movw   $0x6,0x4e(%rax)
    pcb->rtime = -1;
  81081c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810820:	66 c7 40 3e ff ff    	movw   $0xffff,0x3e(%rax)
    pcb->cwnd = 1;
  810826:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81082a:	66 c7 40 5a 01 00    	movw   $0x1,0x5a(%rax)
    iss = tcp_next_iss();
  810830:	48 b8 a6 0c 81 00 00 	movabs $0x810ca6,%rax
  810837:	00 00 00 
  81083a:	ff d0                	callq  *%rax
  81083c:	89 45 f4             	mov    %eax,-0xc(%rbp)
    pcb->snd_wl2 = iss;
  81083f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810843:	8b 55 f4             	mov    -0xc(%rbp),%edx
  810846:	89 50 70             	mov    %edx,0x70(%rax)
    pcb->snd_nxt = iss;
  810849:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81084d:	8b 55 f4             	mov    -0xc(%rbp),%edx
  810850:	89 50 60             	mov    %edx,0x60(%rax)
    pcb->snd_max = iss;
  810853:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810857:	8b 55 f4             	mov    -0xc(%rbp),%edx
  81085a:	89 50 64             	mov    %edx,0x64(%rax)
    pcb->lastack = iss;
  81085d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810861:	8b 55 f4             	mov    -0xc(%rbp),%edx
  810864:	89 50 54             	mov    %edx,0x54(%rax)
    pcb->snd_lbb = iss;   
  810867:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81086b:	8b 55 f4             	mov    -0xc(%rbp),%edx
  81086e:	89 50 74             	mov    %edx,0x74(%rax)
    pcb->tmr = tcp_ticks;
  810871:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  810878:	00 00 00 
  81087b:	8b 10                	mov    (%rax),%edx
  81087d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810881:	89 50 38             	mov    %edx,0x38(%rax)

    pcb->polltmr = 0;
  810884:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810888:	c6 40 3c 00          	movb   $0x0,0x3c(%rax)

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
  81088c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810890:	48 b9 61 05 81 00 00 	movabs $0x810561,%rcx
  810897:	00 00 00 
  81089a:	48 89 88 a8 00 00 00 	mov    %rcx,0xa8(%rax)
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
  8108a1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8108a5:	c7 80 d0 00 00 00 00 	movl   $0x6ddd00,0xd0(%rax)
  8108ac:	dd 6d 00 
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
  8108af:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8108b3:	c6 80 d9 00 00 00 00 	movb   $0x0,0xd9(%rax)
  }
  return pcb;
  8108ba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8108be:	c9                   	leaveq 
  8108bf:	c3                   	retq   

00000000008108c0 <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
  8108c0:	55                   	push   %rbp
  8108c1:	48 89 e5             	mov    %rsp,%rbp
  return tcp_alloc(TCP_PRIO_NORMAL);
  8108c4:	bf 40 00 00 00       	mov    $0x40,%edi
  8108c9:	48 b8 14 07 81 00 00 	movabs $0x810714,%rax
  8108d0:	00 00 00 
  8108d3:	ff d0                	callq  *%rax
}
  8108d5:	5d                   	pop    %rbp
  8108d6:	c3                   	retq   

00000000008108d7 <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
  8108d7:	55                   	push   %rbp
  8108d8:	48 89 e5             	mov    %rsp,%rbp
  8108db:	48 83 ec 10          	sub    $0x10,%rsp
  8108df:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8108e3:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  pcb->callback_arg = arg;
  8108e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8108eb:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8108ef:	48 89 50 20          	mov    %rdx,0x20(%rax)
}
  8108f3:	c9                   	leaveq 
  8108f4:	c3                   	retq   

00000000008108f5 <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
  8108f5:	55                   	push   %rbp
  8108f6:	48 89 e5             	mov    %rsp,%rbp
  8108f9:	48 83 ec 10          	sub    $0x10,%rsp
  8108fd:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  810901:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  pcb->recv = recv;
  810905:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810909:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81090d:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
}
  810914:	c9                   	leaveq 
  810915:	c3                   	retq   

0000000000810916 <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
  810916:	55                   	push   %rbp
  810917:	48 89 e5             	mov    %rsp,%rbp
  81091a:	48 83 ec 10          	sub    $0x10,%rsp
  81091e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  810922:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  pcb->sent = sent;
  810926:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81092a:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81092e:	48 89 90 a0 00 00 00 	mov    %rdx,0xa0(%rax)
}
  810935:	c9                   	leaveq 
  810936:	c3                   	retq   

0000000000810937 <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
  810937:	55                   	push   %rbp
  810938:	48 89 e5             	mov    %rsp,%rbp
  81093b:	48 83 ec 10          	sub    $0x10,%rsp
  81093f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  810943:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  pcb->errf = errf;
  810947:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81094b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81094f:	48 89 90 c8 00 00 00 	mov    %rdx,0xc8(%rax)
}
  810956:	c9                   	leaveq 
  810957:	c3                   	retq   

0000000000810958 <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
  810958:	55                   	push   %rbp
  810959:	48 89 e5             	mov    %rsp,%rbp
  81095c:	48 83 ec 10          	sub    $0x10,%rsp
  810960:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  810964:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  ((struct tcp_pcb_listen *)pcb)->accept = accept;
  810968:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81096c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  810970:	48 89 50 30          	mov    %rdx,0x30(%rax)
}
  810974:	c9                   	leaveq 
  810975:	c3                   	retq   

0000000000810976 <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
  810976:	55                   	push   %rbp
  810977:	48 89 e5             	mov    %rsp,%rbp
  81097a:	48 83 ec 14          	sub    $0x14,%rsp
  81097e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  810982:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  810986:	89 d0                	mov    %edx,%eax
  810988:	88 45 ec             	mov    %al,-0x14(%rbp)
#if LWIP_CALLBACK_API
  pcb->poll = poll;
  81098b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81098f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  810993:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
  81099a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81099e:	0f b6 55 ec          	movzbl -0x14(%rbp),%edx
  8109a2:	88 50 3d             	mov    %dl,0x3d(%rax)
}
  8109a5:	c9                   	leaveq 
  8109a6:	c3                   	retq   

00000000008109a7 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  8109a7:	55                   	push   %rbp
  8109a8:	48 89 e5             	mov    %rsp,%rbp
  8109ab:	48 83 ec 10          	sub    $0x10,%rsp
  8109af:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (pcb->state != CLOSED &&
  8109b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8109b7:	8b 40 18             	mov    0x18(%rax),%eax
  8109ba:	85 c0                	test   %eax,%eax
  8109bc:	0f 84 e5 00 00 00    	je     810aa7 <tcp_pcb_purge+0x100>
     pcb->state != TIME_WAIT &&
  8109c2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8109c6:	8b 40 18             	mov    0x18(%rax),%eax
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
  8109c9:	83 f8 0a             	cmp    $0xa,%eax
  8109cc:	0f 84 d5 00 00 00    	je     810aa7 <tcp_pcb_purge+0x100>
     pcb->state != TIME_WAIT &&
     pcb->state != LISTEN) {
  8109d2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8109d6:	8b 40 18             	mov    0x18(%rax),%eax
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
     pcb->state != TIME_WAIT &&
  8109d9:	83 f8 01             	cmp    $0x1,%eax
  8109dc:	0f 84 c5 00 00 00    	je     810aa7 <tcp_pcb_purge+0x100>
     pcb->state != LISTEN) {

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

    if (pcb->refused_data != NULL) {
  8109e2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8109e6:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  8109ed:	48 85 c0             	test   %rax,%rax
  8109f0:	74 29                	je     810a1b <tcp_pcb_purge+0x74>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
  8109f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8109f6:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  8109fd:	48 89 c7             	mov    %rax,%rdi
  810a00:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  810a07:	00 00 00 
  810a0a:	ff d0                	callq  *%rax
      pcb->refused_data = NULL;
  810a0c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810a10:	48 c7 80 98 00 00 00 	movq   $0x0,0x98(%rax)
  810a17:	00 00 00 00 
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
  810a1b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810a1f:	66 c7 40 3e ff ff    	movw   $0xffff,0x3e(%rax)

    tcp_segs_free(pcb->ooseq);
  810a25:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810a29:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  810a30:	48 89 c7             	mov    %rax,%rdi
  810a33:	48 b8 34 04 81 00 00 	movabs $0x810434,%rax
  810a3a:	00 00 00 
  810a3d:	ff d0                	callq  *%rax
    pcb->ooseq = NULL;
  810a3f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810a43:	48 c7 80 90 00 00 00 	movq   $0x0,0x90(%rax)
  810a4a:	00 00 00 00 
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
  810a4e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810a52:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  810a59:	48 89 c7             	mov    %rax,%rdi
  810a5c:	48 b8 34 04 81 00 00 	movabs $0x810434,%rax
  810a63:	00 00 00 
  810a66:	ff d0                	callq  *%rax
    tcp_segs_free(pcb->unacked);
  810a68:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810a6c:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  810a73:	48 89 c7             	mov    %rax,%rdi
  810a76:	48 b8 34 04 81 00 00 	movabs $0x810434,%rax
  810a7d:	00 00 00 
  810a80:	ff d0                	callq  *%rax
    pcb->unacked = pcb->unsent = NULL;
  810a82:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810a86:	48 c7 80 80 00 00 00 	movq   $0x0,0x80(%rax)
  810a8d:	00 00 00 00 
  810a91:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810a95:	48 8b 90 80 00 00 00 	mov    0x80(%rax),%rdx
  810a9c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810aa0:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
  }
}
  810aa7:	c9                   	leaveq 
  810aa8:	c3                   	retq   

0000000000810aa9 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  810aa9:	55                   	push   %rbp
  810aaa:	48 89 e5             	mov    %rsp,%rbp
  810aad:	48 83 ec 10          	sub    $0x10,%rsp
  810ab1:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  810ab5:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  TCP_RMV(pcblist, pcb);
  810ab9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810abd:	48 8b 00             	mov    (%rax),%rax
  810ac0:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  810ac4:	75 17                	jne    810add <tcp_pcb_remove+0x34>
  810ac6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810aca:	48 8b 00             	mov    (%rax),%rax
  810acd:	48 8b 50 10          	mov    0x10(%rax),%rdx
  810ad1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810ad5:	48 89 10             	mov    %rdx,(%rax)
  810ad8:	e9 8e 00 00 00       	jmpq   810b6b <tcp_pcb_remove+0xc2>
  810add:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810ae1:	48 8b 10             	mov    (%rax),%rdx
  810ae4:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  810aeb:	00 00 00 
  810aee:	48 89 10             	mov    %rdx,(%rax)
  810af1:	eb 66                	jmp    810b59 <tcp_pcb_remove+0xb0>
  810af3:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  810afa:	00 00 00 
  810afd:	48 8b 00             	mov    (%rax),%rax
  810b00:	48 8b 40 10          	mov    0x10(%rax),%rax
  810b04:	48 85 c0             	test   %rax,%rax
  810b07:	74 32                	je     810b3b <tcp_pcb_remove+0x92>
  810b09:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  810b10:	00 00 00 
  810b13:	48 8b 00             	mov    (%rax),%rax
  810b16:	48 8b 40 10          	mov    0x10(%rax),%rax
  810b1a:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  810b1e:	75 1b                	jne    810b3b <tcp_pcb_remove+0x92>
  810b20:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  810b27:	00 00 00 
  810b2a:	48 8b 00             	mov    (%rax),%rax
  810b2d:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  810b31:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  810b35:	48 89 50 10          	mov    %rdx,0x10(%rax)
  810b39:	eb 30                	jmp    810b6b <tcp_pcb_remove+0xc2>
  810b3b:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  810b42:	00 00 00 
  810b45:	48 8b 00             	mov    (%rax),%rax
  810b48:	48 8b 50 10          	mov    0x10(%rax),%rdx
  810b4c:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  810b53:	00 00 00 
  810b56:	48 89 10             	mov    %rdx,(%rax)
  810b59:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  810b60:	00 00 00 
  810b63:	48 8b 00             	mov    (%rax),%rax
  810b66:	48 85 c0             	test   %rax,%rax
  810b69:	75 88                	jne    810af3 <tcp_pcb_remove+0x4a>
  810b6b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810b6f:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  810b76:	00 

  tcp_pcb_purge(pcb);
  810b77:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810b7b:	48 89 c7             	mov    %rax,%rdi
  810b7e:	48 b8 a7 09 81 00 00 	movabs $0x8109a7,%rax
  810b85:	00 00 00 
  810b88:	ff d0                	callq  *%rax
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  810b8a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810b8e:	8b 40 18             	mov    0x18(%rax),%eax
  810b91:	83 f8 0a             	cmp    $0xa,%eax
  810b94:	74 45                	je     810bdb <tcp_pcb_remove+0x132>
     pcb->state != LISTEN &&
  810b96:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810b9a:	8b 40 18             	mov    0x18(%rax),%eax
  TCP_RMV(pcblist, pcb);

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  810b9d:	83 f8 01             	cmp    $0x1,%eax
  810ba0:	74 39                	je     810bdb <tcp_pcb_remove+0x132>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
  810ba2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810ba6:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  810baa:	0f b6 c0             	movzbl %al,%eax
  810bad:	83 e0 01             	and    $0x1,%eax

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
     pcb->state != LISTEN &&
  810bb0:	85 c0                	test   %eax,%eax
  810bb2:	74 27                	je     810bdb <tcp_pcb_remove+0x132>
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
  810bb4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810bb8:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  810bbc:	83 c8 02             	or     $0x2,%eax
  810bbf:	89 c2                	mov    %eax,%edx
  810bc1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810bc5:	88 50 2c             	mov    %dl,0x2c(%rax)
    tcp_output(pcb);
  810bc8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810bcc:	48 89 c7             	mov    %rax,%rdi
  810bcf:	48 b8 3d 3c 81 00 00 	movabs $0x813c3d,%rax
  810bd6:	00 00 00 
  810bd9:	ff d0                	callq  *%rax
  }

  if (pcb->state != LISTEN) {
  810bdb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810bdf:	8b 40 18             	mov    0x18(%rax),%eax
  810be2:	83 f8 01             	cmp    $0x1,%eax
  810be5:	0f 84 ae 00 00 00    	je     810c99 <tcp_pcb_remove+0x1f0>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  810beb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810bef:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  810bf6:	48 85 c0             	test   %rax,%rax
  810bf9:	74 2a                	je     810c25 <tcp_pcb_remove+0x17c>
  810bfb:	48 ba 1e 26 82 00 00 	movabs $0x82261e,%rdx
  810c02:	00 00 00 
  810c05:	be b5 04 00 00       	mov    $0x4b5,%esi
  810c0a:	48 bf 3b 24 82 00 00 	movabs $0x82243b,%rdi
  810c11:	00 00 00 
  810c14:	b8 00 00 00 00       	mov    $0x0,%eax
  810c19:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  810c20:	00 00 00 
  810c23:	ff d1                	callq  *%rcx
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  810c25:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810c29:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  810c30:	48 85 c0             	test   %rax,%rax
  810c33:	74 2a                	je     810c5f <tcp_pcb_remove+0x1b6>
  810c35:	48 ba 36 26 82 00 00 	movabs $0x822636,%rdx
  810c3c:	00 00 00 
  810c3f:	be b6 04 00 00       	mov    $0x4b6,%esi
  810c44:	48 bf 3b 24 82 00 00 	movabs $0x82243b,%rdi
  810c4b:	00 00 00 
  810c4e:	b8 00 00 00 00       	mov    $0x0,%eax
  810c53:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  810c5a:	00 00 00 
  810c5d:	ff d1                	callq  *%rcx
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  810c5f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810c63:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  810c6a:	48 85 c0             	test   %rax,%rax
  810c6d:	74 2a                	je     810c99 <tcp_pcb_remove+0x1f0>
  810c6f:	48 ba 4f 26 82 00 00 	movabs $0x82264f,%rdx
  810c76:	00 00 00 
  810c79:	be b8 04 00 00       	mov    $0x4b8,%esi
  810c7e:	48 bf 3b 24 82 00 00 	movabs $0x82243b,%rdi
  810c85:	00 00 00 
  810c88:	b8 00 00 00 00       	mov    $0x0,%eax
  810c8d:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  810c94:	00 00 00 
  810c97:	ff d1                	callq  *%rcx
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
  810c99:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810c9d:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
  810ca4:	c9                   	leaveq 
  810ca5:	c3                   	retq   

0000000000810ca6 <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(void)
{
  810ca6:	55                   	push   %rbp
  810ca7:	48 89 e5             	mov    %rsp,%rbp
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
  810caa:	48 b8 f4 81 82 00 00 	movabs $0x8281f4,%rax
  810cb1:	00 00 00 
  810cb4:	8b 10                	mov    (%rax),%edx
  810cb6:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  810cbd:	00 00 00 
  810cc0:	8b 00                	mov    (%rax),%eax
  810cc2:	01 c2                	add    %eax,%edx
  810cc4:	48 b8 f4 81 82 00 00 	movabs $0x8281f4,%rax
  810ccb:	00 00 00 
  810cce:	89 10                	mov    %edx,(%rax)
  return iss;
  810cd0:	48 b8 f4 81 82 00 00 	movabs $0x8281f4,%rax
  810cd7:	00 00 00 
  810cda:	8b 00                	mov    (%rax),%eax
}
  810cdc:	5d                   	pop    %rbp
  810cdd:	c3                   	retq   

0000000000810cde <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
  810cde:	55                   	push   %rbp
  810cdf:	48 89 e5             	mov    %rsp,%rbp
  810ce2:	48 83 ec 20          	sub    $0x20,%rsp
  810ce6:	89 f8                	mov    %edi,%eax
  810ce8:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  810cec:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
  810cf0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810cf4:	48 89 c7             	mov    %rax,%rdi
  810cf7:	48 b8 de 0d 81 00 00 	movabs $0x810dde,%rax
  810cfe:	00 00 00 
  810d01:	ff d0                	callq  *%rax
  810d03:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if ((outif != NULL) && (outif->mtu != 0)) {
  810d07:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  810d0c:	74 2d                	je     810d3b <tcp_eff_send_mss+0x5d>
  810d0e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810d12:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  810d16:	66 85 c0             	test   %ax,%ax
  810d19:	74 20                	je     810d3b <tcp_eff_send_mss+0x5d>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
  810d1b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810d1f:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  810d23:	83 e8 28             	sub    $0x28,%eax
  810d26:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * but we only send options with SYN and that is never filled with data! */
    sendmss = LWIP_MIN(sendmss, mss_s);
  810d2a:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  810d2e:	66 39 45 f6          	cmp    %ax,-0xa(%rbp)
  810d32:	66 0f 46 45 f6       	cmovbe -0xa(%rbp),%ax
  810d37:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
  }
  return sendmss;
  810d3b:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
}
  810d3f:	c9                   	leaveq 
  810d40:	c3                   	retq   

0000000000810d41 <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
  810d41:	55                   	push   %rbp
  810d42:	48 89 e5             	mov    %rsp,%rbp
  810d45:	48 83 ec 20          	sub    $0x20,%rsp
  810d49:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  810d4d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  u32_t addr2test;

  addr2test = addr->addr;
  810d51:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810d55:	8b 00                	mov    (%rax),%eax
  810d57:	89 45 fc             	mov    %eax,-0x4(%rbp)
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  810d5a:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  810d5e:	74 06                	je     810d66 <ip_addr_isbroadcast+0x25>
  810d60:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  810d64:	75 07                	jne    810d6d <ip_addr_isbroadcast+0x2c>
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  810d66:	b8 01 00 00 00       	mov    $0x1,%eax
  810d6b:	eb 6f                	jmp    810ddc <ip_addr_isbroadcast+0x9b>
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
  810d6d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810d71:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  810d75:	0f b6 c0             	movzbl %al,%eax
  810d78:	83 e0 02             	and    $0x2,%eax
  810d7b:	85 c0                	test   %eax,%eax
  810d7d:	75 07                	jne    810d86 <ip_addr_isbroadcast+0x45>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  810d7f:	b8 00 00 00 00       	mov    $0x0,%eax
  810d84:	eb 56                	jmp    810ddc <ip_addr_isbroadcast+0x9b>
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
  810d86:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810d8a:	8b 40 08             	mov    0x8(%rax),%eax
  810d8d:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  810d90:	75 07                	jne    810d99 <ip_addr_isbroadcast+0x58>
    return 0;
  810d92:	b8 00 00 00 00       	mov    $0x0,%eax
  810d97:	eb 43                	jmp    810ddc <ip_addr_isbroadcast+0x9b>
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  810d99:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810d9d:	8b 10                	mov    (%rax),%edx
  810d9f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810da3:	8b 40 08             	mov    0x8(%rax),%eax
  810da6:	31 c2                	xor    %eax,%edx
  810da8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810dac:	8b 40 0c             	mov    0xc(%rax),%eax
  810daf:	21 d0                	and    %edx,%eax
  810db1:	85 c0                	test   %eax,%eax
  810db3:	75 22                	jne    810dd7 <ip_addr_isbroadcast+0x96>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
  810db5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810db9:	8b 40 0c             	mov    0xc(%rax),%eax
  810dbc:	f7 d0                	not    %eax
  810dbe:	23 45 fc             	and    -0x4(%rbp),%eax
  810dc1:	89 c2                	mov    %eax,%edx
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
  810dc3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810dc7:	8b 40 0c             	mov    0xc(%rax),%eax
  810dca:	f7 d0                	not    %eax
  else if (addr2test == netif->ip_addr.addr)
    return 0;
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
  810dcc:	39 c2                	cmp    %eax,%edx
  810dce:	75 07                	jne    810dd7 <ip_addr_isbroadcast+0x96>
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  810dd0:	b8 01 00 00 00       	mov    $0x1,%eax
  810dd5:	eb 05                	jmp    810ddc <ip_addr_isbroadcast+0x9b>
  else
    return 0;
  810dd7:	b8 00 00 00 00       	mov    $0x0,%eax
}
  810ddc:	c9                   	leaveq 
  810ddd:	c3                   	retq   

0000000000810dde <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
  810dde:	55                   	push   %rbp
  810ddf:	48 89 e5             	mov    %rsp,%rbp
  810de2:	48 83 ec 20          	sub    $0x20,%rsp
  810de6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  810dea:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  810df1:	00 00 00 
  810df4:	48 8b 00             	mov    (%rax),%rax
  810df7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  810dfb:	eb 44                	jmp    810e41 <ip_route+0x63>
    /* network mask matches? */
    if (netif_is_up(netif)) {
  810dfd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810e01:	48 89 c7             	mov    %rax,%rdi
  810e04:	48 b8 40 d4 80 00 00 	movabs $0x80d440,%rax
  810e0b:	00 00 00 
  810e0e:	ff d0                	callq  *%rax
  810e10:	84 c0                	test   %al,%al
  810e12:	74 22                	je     810e36 <ip_route+0x58>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
  810e14:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810e18:	8b 10                	mov    (%rax),%edx
  810e1a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810e1e:	8b 40 08             	mov    0x8(%rax),%eax
  810e21:	31 c2                	xor    %eax,%edx
  810e23:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810e27:	8b 40 0c             	mov    0xc(%rax),%eax
  810e2a:	21 d0                	and    %edx,%eax
  810e2c:	85 c0                	test   %eax,%eax
  810e2e:	75 06                	jne    810e36 <ip_route+0x58>
        /* return netif on which to forward IP packet */
        return netif;
  810e30:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810e34:	eb 58                	jmp    810e8e <ip_route+0xb0>
ip_route(struct ip_addr *dest)
{
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  810e36:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810e3a:	48 8b 00             	mov    (%rax),%rax
  810e3d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  810e41:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  810e46:	75 b5                	jne    810dfd <ip_route+0x1f>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
  810e48:	48 b8 10 b0 b5 00 00 	movabs $0xb5b010,%rax
  810e4f:	00 00 00 
  810e52:	48 8b 00             	mov    (%rax),%rax
  810e55:	48 85 c0             	test   %rax,%rax
  810e58:	74 20                	je     810e7a <ip_route+0x9c>
  810e5a:	48 b8 10 b0 b5 00 00 	movabs $0xb5b010,%rax
  810e61:	00 00 00 
  810e64:	48 8b 00             	mov    (%rax),%rax
  810e67:	48 89 c7             	mov    %rax,%rdi
  810e6a:	48 b8 40 d4 80 00 00 	movabs $0x80d440,%rax
  810e71:	00 00 00 
  810e74:	ff d0                	callq  *%rax
  810e76:	84 c0                	test   %al,%al
  810e78:	75 07                	jne    810e81 <ip_route+0xa3>
    LWIP_DEBUGF(IP_DEBUG | 2, ("ip_route: No route to 0x%"X32_F"\n", dest->addr));
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  810e7a:	b8 00 00 00 00       	mov    $0x0,%eax
  810e7f:	eb 0d                	jmp    810e8e <ip_route+0xb0>
  }
  /* no matching netif found, use default netif */
  return netif_default;
  810e81:	48 b8 10 b0 b5 00 00 	movabs $0xb5b010,%rax
  810e88:	00 00 00 
  810e8b:	48 8b 00             	mov    (%rax),%rax
}
  810e8e:	c9                   	leaveq 
  810e8f:	c3                   	retq   

0000000000810e90 <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
  810e90:	55                   	push   %rbp
  810e91:	48 89 e5             	mov    %rsp,%rbp
  810e94:	53                   	push   %rbx
  810e95:	48 83 ec 38          	sub    $0x38,%rsp
  810e99:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  810e9d:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  struct ip_hdr *iphdr;
  struct netif *netif;
  u16_t iphdr_hlen;
  u16_t iphdr_len;
#if LWIP_DHCP
  int check_ip_src=1;
  810ea1:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%rbp)

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
  810ea8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810eac:	48 8b 40 08          	mov    0x8(%rax),%rax
  810eb0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if (IPH_V(iphdr) != 4) {
  810eb4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810eb8:	0f b7 00             	movzwl (%rax),%eax
  810ebb:	0f b7 c0             	movzwl %ax,%eax
  810ebe:	89 c7                	mov    %eax,%edi
  810ec0:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  810ec7:	00 00 00 
  810eca:	ff d0                	callq  *%rax
  810ecc:	66 c1 e8 0c          	shr    $0xc,%ax
  810ed0:	66 83 f8 04          	cmp    $0x4,%ax
  810ed4:	74 1d                	je     810ef3 <ip_input+0x63>
    LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
  810ed6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810eda:	48 89 c7             	mov    %rax,%rdi
  810edd:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  810ee4:	00 00 00 
  810ee7:	ff d0                	callq  *%rax
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  810ee9:	b8 00 00 00 00       	mov    $0x0,%eax
  810eee:	e9 19 04 00 00       	jmpq   81130c <ip_input+0x47c>
  }

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
  810ef3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810ef7:	0f b7 00             	movzwl (%rax),%eax
  810efa:	0f b7 c0             	movzwl %ax,%eax
  810efd:	89 c7                	mov    %eax,%edi
  810eff:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  810f06:	00 00 00 
  810f09:	ff d0                	callq  *%rax
  810f0b:	66 c1 e8 08          	shr    $0x8,%ax
  810f0f:	83 e0 0f             	and    $0xf,%eax
  810f12:	66 89 45 d6          	mov    %ax,-0x2a(%rbp)
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
  810f16:	66 c1 65 d6 02       	shlw   $0x2,-0x2a(%rbp)
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
  810f1b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810f1f:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  810f23:	0f b7 c0             	movzwl %ax,%eax
  810f26:	89 c7                	mov    %eax,%edi
  810f28:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  810f2f:	00 00 00 
  810f32:	ff d0                	callq  *%rax
  810f34:	66 89 45 d4          	mov    %ax,-0x2c(%rbp)

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
  810f38:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810f3c:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  810f40:	66 3b 45 d6          	cmp    -0x2a(%rbp),%ax
  810f44:	72 0e                	jb     810f54 <ip_input+0xc4>
  810f46:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810f4a:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  810f4e:	66 3b 45 d4          	cmp    -0x2c(%rbp),%ax
  810f52:	73 1d                	jae    810f71 <ip_input+0xe1>
    if (iphdr_len > p->tot_len)
    LWIP_DEBUGF(IP_DEBUG | 2, ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), "
                               "IP packet dropped.\n",
                               iphdr_len, p->tot_len));
    /* free (drop) packet pbufs */
    pbuf_free(p);
  810f54:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810f58:	48 89 c7             	mov    %rax,%rdi
  810f5b:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  810f62:	00 00 00 
  810f65:	ff d0                	callq  *%rax
    IP_STATS_INC(ip.lenerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipindiscards();
    return ERR_OK;
  810f67:	b8 00 00 00 00       	mov    $0x0,%eax
  810f6c:	e9 9b 03 00 00       	jmpq   81130c <ip_input+0x47c>
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
  810f71:	0f b7 55 d6          	movzwl -0x2a(%rbp),%edx
  810f75:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810f79:	89 d6                	mov    %edx,%esi
  810f7b:	48 89 c7             	mov    %rax,%rdi
  810f7e:	48 b8 01 2b 81 00 00 	movabs $0x812b01,%rax
  810f85:	00 00 00 
  810f88:	ff d0                	callq  *%rax
  810f8a:	66 85 c0             	test   %ax,%ax
  810f8d:	74 1d                	je     810fac <ip_input+0x11c>

    LWIP_DEBUGF(IP_DEBUG | 2, ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
  810f8f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810f93:	48 89 c7             	mov    %rax,%rdi
  810f96:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  810f9d:	00 00 00 
  810fa0:	ff d0                	callq  *%rax
    IP_STATS_INC(ip.chkerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  810fa2:	b8 00 00 00 00       	mov    $0x0,%eax
  810fa7:	e9 60 03 00 00       	jmpq   81130c <ip_input+0x47c>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
  810fac:	0f b7 55 d4          	movzwl -0x2c(%rbp),%edx
  810fb0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810fb4:	89 d6                	mov    %edx,%esi
  810fb6:	48 89 c7             	mov    %rax,%rdi
  810fb9:	48 b8 36 d9 80 00 00 	movabs $0x80d936,%rax
  810fc0:	00 00 00 
  810fc3:	ff d0                	callq  *%rax
#endif /* LWIP_IGMP */
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
  810fc5:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%rbp)
    netif = inp;
  810fcc:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  810fd0:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
          iphdr->dest.addr & netif->netmask.addr,
          netif->ip_addr.addr & netif->netmask.addr,
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
  810fd4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810fd8:	48 89 c7             	mov    %rax,%rdi
  810fdb:	48 b8 40 d4 80 00 00 	movabs $0x80d440,%rax
  810fe2:	00 00 00 
  810fe5:	ff d0                	callq  *%rax
  810fe7:	84 c0                	test   %al,%al
  810fe9:	74 4e                	je     811039 <ip_input+0x1a9>
  810feb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810fef:	48 83 c0 08          	add    $0x8,%rax
  810ff3:	48 85 c0             	test   %rax,%rax
  810ff6:	74 41                	je     811039 <ip_input+0x1a9>
  810ff8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810ffc:	8b 40 08             	mov    0x8(%rax),%eax
  810fff:	85 c0                	test   %eax,%eax
  811001:	74 36                	je     811039 <ip_input+0x1a9>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  811003:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811007:	8b 50 10             	mov    0x10(%rax),%edx
  81100a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81100e:	8b 40 08             	mov    0x8(%rax),%eax
  811011:	39 c2                	cmp    %eax,%edx
  811013:	74 22                	je     811037 <ip_input+0x1a7>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  811015:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811019:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81101d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811021:	48 89 c6             	mov    %rax,%rsi
  811024:	48 89 d7             	mov    %rdx,%rdi
  811027:	48 b8 41 0d 81 00 00 	movabs $0x810d41,%rax
  81102e:	00 00 00 
  811031:	ff d0                	callq  *%rax
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  811033:	84 c0                	test   %al,%al
  811035:	74 02                	je     811039 <ip_input+0x1a9>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
          LWIP_DEBUGF(IP_DEBUG, ("ip_input: packet accepted on interface %c%c\n",
              netif->name[0], netif->name[1]));
          /* break out of for loop */
          break;
  811037:	eb 4b                	jmp    811084 <ip_input+0x1f4>
        }
      }
      if (first) {
  811039:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  81103d:	74 1a                	je     811059 <ip_input+0x1c9>
        first = 0;
  81103f:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
        netif = netif_list;
  811046:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  81104d:	00 00 00 
  811050:	48 8b 00             	mov    (%rax),%rax
  811053:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  811057:	eb 0b                	jmp    811064 <ip_input+0x1d4>
      } else {
        netif = netif->next;
  811059:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81105d:	48 8b 00             	mov    (%rax),%rax
  811060:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      }
      if (netif == inp) {
  811064:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811068:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  81106c:	75 0b                	jne    811079 <ip_input+0x1e9>
        netif = netif->next;
  81106e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811072:	48 8b 00             	mov    (%rax),%rax
  811075:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      }
    } while(netif != NULL);
  811079:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81107e:	0f 85 50 ff ff ff    	jne    810fd4 <ip_input+0x144>
#if LWIP_DHCP
  /* Pass DHCP messages regardless of destination address. DHCP traffic is addressed
   * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
   * According to RFC 1542 section 3.1.1, referred by RFC 2131).
   */
  if (netif == NULL) {
  811084:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  811089:	75 59                	jne    8110e4 <ip_input+0x254>
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
  81108b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81108f:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811093:	0f b7 c0             	movzwl %ax,%eax
  811096:	89 c7                	mov    %eax,%edi
  811098:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  81109f:	00 00 00 
  8110a2:	ff d0                	callq  *%rax
  8110a4:	0f b7 c0             	movzwl %ax,%eax
  8110a7:	0f b6 c0             	movzbl %al,%eax
  8110aa:	83 f8 11             	cmp    $0x11,%eax
  8110ad:	75 35                	jne    8110e4 <ip_input+0x254>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
  8110af:	0f b7 55 d6          	movzwl -0x2a(%rbp),%edx
  8110b3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8110b7:	48 01 d0             	add    %rdx,%rax
  8110ba:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  8110be:	0f b7 c0             	movzwl %ax,%eax
  8110c1:	89 c7                	mov    %eax,%edi
  8110c3:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  8110ca:	00 00 00 
  8110cd:	ff d0                	callq  *%rax
  8110cf:	66 83 f8 44          	cmp    $0x44,%ax
  8110d3:	75 0f                	jne    8110e4 <ip_input+0x254>
        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: DHCP packet accepted.\n"));
        netif = inp;
  8110d5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8110d9:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        check_ip_src = 0;
  8110dd:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
  }
#endif /* LWIP_DHCP */

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
  8110e4:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8110e8:	74 6e                	je     811158 <ip_input+0x2c8>
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  8110ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8110ee:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  8110f2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8110f6:	48 89 c6             	mov    %rax,%rsi
  8110f9:	48 89 d7             	mov    %rdx,%rdi
  8110fc:	48 b8 41 0d 81 00 00 	movabs $0x810d41,%rax
  811103:	00 00 00 
  811106:	ff d0                	callq  *%rax
  811108:	84 c0                	test   %al,%al
  81110a:	75 2f                	jne    81113b <ip_input+0x2ab>
         (ip_addr_ismulticast(&(iphdr->src)))) {
  81110c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811110:	8b 58 0c             	mov    0xc(%rax),%ebx
  811113:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  811118:	48 b8 8c 30 81 00 00 	movabs $0x81308c,%rax
  81111f:	00 00 00 
  811122:	ff d0                	callq  *%rax
  811124:	21 c3                	and    %eax,%ebx
  811126:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  81112b:	48 b8 8c 30 81 00 00 	movabs $0x81308c,%rax
  811132:	00 00 00 
  811135:	ff d0                	callq  *%rax

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  811137:	39 c3                	cmp    %eax,%ebx
  811139:	75 1d                	jne    811158 <ip_input+0x2c8>
         (ip_addr_ismulticast(&(iphdr->src)))) {
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
  81113b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81113f:	48 89 c7             	mov    %rax,%rdi
  811142:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  811149:	00 00 00 
  81114c:	ff d0                	callq  *%rax
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
  81114e:	b8 00 00 00 00       	mov    $0x0,%eax
  811153:	e9 b4 01 00 00       	jmpq   81130c <ip_input+0x47c>
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
  811158:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81115d:	75 1d                	jne    81117c <ip_input+0x2ec>
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
  81115f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811163:	48 89 c7             	mov    %rax,%rdi
  811166:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  81116d:	00 00 00 
  811170:	ff d0                	callq  *%rax
    return ERR_OK;
  811172:	b8 00 00 00 00       	mov    $0x0,%eax
  811177:	e9 90 01 00 00       	jmpq   81130c <ip_input+0x47c>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
  81117c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811180:	0f b7 58 06          	movzwl 0x6(%rax),%ebx
  811184:	bf ff 3f 00 00       	mov    $0x3fff,%edi
  811189:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  811190:	00 00 00 
  811193:	ff d0                	callq  *%rax
  811195:	21 d8                	and    %ebx,%eax
  811197:	66 85 c0             	test   %ax,%ax
  81119a:	74 34                	je     8111d0 <ip_input+0x340>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & htons(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
  81119c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8111a0:	48 89 c7             	mov    %rax,%rdi
  8111a3:	48 b8 e9 1f 81 00 00 	movabs $0x811fe9,%rax
  8111aa:	00 00 00 
  8111ad:	ff d0                	callq  *%rax
  8111af:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    /* packet not fully reassembled yet? */
    if (p == NULL) {
  8111b3:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8111b8:	75 0a                	jne    8111c4 <ip_input+0x334>
      return ERR_OK;
  8111ba:	b8 00 00 00 00       	mov    $0x0,%eax
  8111bf:	e9 48 01 00 00       	jmpq   81130c <ip_input+0x47c>
    }
    iphdr = p->payload;
  8111c4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8111c8:	48 8b 40 08          	mov    0x8(%rax),%rax
  8111cc:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
  8111d0:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8111d4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8111d8:	48 89 d6             	mov    %rdx,%rsi
  8111db:	48 89 c7             	mov    %rax,%rdi
  8111de:	48 b8 33 fd 81 00 00 	movabs $0x81fd33,%rax
  8111e5:	00 00 00 
  8111e8:	ff d0                	callq  *%rax
  8111ea:	84 c0                	test   %al,%al
  8111ec:	0f 85 15 01 00 00    	jne    811307 <ip_input+0x477>
#endif /* LWIP_RAW */
  {

    switch (IPH_PROTO(iphdr)) {
  8111f2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8111f6:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8111fa:	0f b7 c0             	movzwl %ax,%eax
  8111fd:	89 c7                	mov    %eax,%edi
  8111ff:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  811206:	00 00 00 
  811209:	ff d0                	callq  *%rax
  81120b:	0f b7 c0             	movzwl %ax,%eax
  81120e:	0f b6 c0             	movzbl %al,%eax
  811211:	83 f8 06             	cmp    $0x6,%eax
  811214:	74 2b                	je     811241 <ip_input+0x3b1>
  811216:	83 f8 11             	cmp    $0x11,%eax
  811219:	74 07                	je     811222 <ip_input+0x392>
  81121b:	83 f8 01             	cmp    $0x1,%eax
  81121e:	74 40                	je     811260 <ip_input+0x3d0>
  811220:	eb 5d                	jmp    81127f <ip_input+0x3ef>
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
  811222:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  811226:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81122a:	48 89 d6             	mov    %rdx,%rsi
  81122d:	48 89 c7             	mov    %rax,%rdi
  811230:	48 b8 7c 4d 81 00 00 	movabs $0x814d7c,%rax
  811237:	00 00 00 
  81123a:	ff d0                	callq  *%rax
      break;
  81123c:	e9 c6 00 00 00       	jmpq   811307 <ip_input+0x477>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
  811241:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  811245:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811249:	48 89 d6             	mov    %rdx,%rsi
  81124c:	48 89 c7             	mov    %rax,%rdi
  81124f:	48 b8 18 c4 81 00 00 	movabs $0x81c418,%rax
  811256:	00 00 00 
  811259:	ff d0                	callq  *%rax
      break;
  81125b:	e9 a7 00 00 00       	jmpq   811307 <ip_input+0x477>
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
  811260:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  811264:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811268:	48 89 d6             	mov    %rdx,%rsi
  81126b:	48 89 c7             	mov    %rax,%rdi
  81126e:	48 b8 e4 01 82 00 00 	movabs $0x8201e4,%rax
  811275:	00 00 00 
  811278:	ff d0                	callq  *%rax
      break;
  81127a:	e9 88 00 00 00       	jmpq   811307 <ip_input+0x477>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  81127f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811283:	48 8d 50 10          	lea    0x10(%rax),%rdx
  811287:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81128b:	48 89 c6             	mov    %rax,%rsi
  81128e:	48 89 d7             	mov    %rdx,%rdi
  811291:	48 b8 41 0d 81 00 00 	movabs $0x810d41,%rax
  811298:	00 00 00 
  81129b:	ff d0                	callq  *%rax
  81129d:	84 c0                	test   %al,%al
  81129f:	75 53                	jne    8112f4 <ip_input+0x464>
          !ip_addr_ismulticast(&(iphdr->dest))) {
  8112a1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8112a5:	8b 58 10             	mov    0x10(%rax),%ebx
  8112a8:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  8112ad:	48 b8 8c 30 81 00 00 	movabs $0x81308c,%rax
  8112b4:	00 00 00 
  8112b7:	ff d0                	callq  *%rax
  8112b9:	21 c3                	and    %eax,%ebx
  8112bb:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  8112c0:	48 b8 8c 30 81 00 00 	movabs $0x81308c,%rax
  8112c7:	00 00 00 
  8112ca:	ff d0                	callq  *%rax
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  8112cc:	39 c3                	cmp    %eax,%ebx
  8112ce:	74 24                	je     8112f4 <ip_input+0x464>
          !ip_addr_ismulticast(&(iphdr->dest))) {
        p->payload = iphdr;
  8112d0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8112d4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8112d8:	48 89 50 08          	mov    %rdx,0x8(%rax)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
  8112dc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8112e0:	be 02 00 00 00       	mov    $0x2,%esi
  8112e5:	48 89 c7             	mov    %rax,%rdi
  8112e8:	48 b8 07 07 82 00 00 	movabs $0x820707,%rax
  8112ef:	00 00 00 
  8112f2:	ff d0                	callq  *%rax
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
  8112f4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8112f8:	48 89 c7             	mov    %rax,%rdi
  8112fb:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  811302:	00 00 00 
  811305:	ff d0                	callq  *%rax
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinunknownprotos();
    }
  }

  return ERR_OK;
  811307:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81130c:	48 83 c4 38          	add    $0x38,%rsp
  811310:	5b                   	pop    %rbx
  811311:	5d                   	pop    %rbp
  811312:	c3                   	retq   

0000000000811313 <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
  811313:	55                   	push   %rbp
  811314:	48 89 e5             	mov    %rsp,%rbp
  811317:	53                   	push   %rbx
  811318:	48 83 ec 48          	sub    $0x48,%rsp
  81131c:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  811320:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  811324:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  811328:	89 c8                	mov    %ecx,%eax
  81132a:	44 89 c1             	mov    %r8d,%ecx
  81132d:	44 89 ca             	mov    %r9d,%edx
  811330:	88 45 c4             	mov    %al,-0x3c(%rbp)
  811333:	88 4d c0             	mov    %cl,-0x40(%rbp)
  811336:	88 55 bc             	mov    %dl,-0x44(%rbp)
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
  811339:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  81133e:	0f 84 0e 02 00 00    	je     811552 <ip_output_if+0x23f>
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
  811344:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811348:	be 14 00 00 00       	mov    $0x14,%esi
  81134d:	48 89 c7             	mov    %rax,%rdi
  811350:	48 b8 7f db 80 00 00 	movabs $0x80db7f,%rax
  811357:	00 00 00 
  81135a:	ff d0                	callq  *%rax
  81135c:	84 c0                	test   %al,%al
  81135e:	74 0a                	je     81136a <ip_output_if+0x57>
      LWIP_DEBUGF(IP_DEBUG | 2, ("ip_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
  811360:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  811365:	e9 58 02 00 00       	jmpq   8115c2 <ip_output_if+0x2af>
    }

    iphdr = p->payload;
  81136a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81136e:	48 8b 40 08          	mov    0x8(%rax),%rax
  811372:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  811376:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81137a:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81137e:	66 83 f8 13          	cmp    $0x13,%ax
  811382:	77 2a                	ja     8113ae <ip_output_if+0x9b>
  811384:	48 ba 70 26 82 00 00 	movabs $0x822670,%rdx
  81138b:	00 00 00 
  81138e:	be ef 01 00 00       	mov    $0x1ef,%esi
  811393:	48 bf 9d 26 82 00 00 	movabs $0x82269d,%rdi
  81139a:	00 00 00 
  81139d:	b8 00 00 00 00       	mov    $0x0,%eax
  8113a2:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  8113a9:	00 00 00 
  8113ac:	ff d1                	callq  *%rcx
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
  8113ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8113b2:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8113b6:	0f b7 c0             	movzwl %ax,%eax
  8113b9:	89 c7                	mov    %eax,%edi
  8113bb:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  8113c2:	00 00 00 
  8113c5:	ff d0                	callq  *%rax
  8113c7:	0f b6 d0             	movzbl %al,%edx
  8113ca:	0f b6 45 c4          	movzbl -0x3c(%rbp),%eax
  8113ce:	c1 e0 08             	shl    $0x8,%eax
  8113d1:	09 d0                	or     %edx,%eax
  8113d3:	0f b7 c0             	movzwl %ax,%eax
  8113d6:	89 c7                	mov    %eax,%edi
  8113d8:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  8113df:	00 00 00 
  8113e2:	ff d0                	callq  *%rax
  8113e4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8113e8:	66 89 42 08          	mov    %ax,0x8(%rdx)
    IPH_PROTO_SET(iphdr, proto);
  8113ec:	0f b6 5d bc          	movzbl -0x44(%rbp),%ebx
  8113f0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8113f4:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8113f8:	0f b7 c0             	movzwl %ax,%eax
  8113fb:	89 c7                	mov    %eax,%edi
  8113fd:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  811404:	00 00 00 
  811407:	ff d0                	callq  *%rax
  811409:	66 c1 e8 08          	shr    $0x8,%ax
  81140d:	0f b7 c0             	movzwl %ax,%eax
  811410:	c1 e0 08             	shl    $0x8,%eax
  811413:	09 d8                	or     %ebx,%eax
  811415:	0f b7 c0             	movzwl %ax,%eax
  811418:	89 c7                	mov    %eax,%edi
  81141a:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  811421:	00 00 00 
  811424:	ff d0                	callq  *%rax
  811426:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81142a:	66 89 42 08          	mov    %ax,0x8(%rdx)

    ip_addr_set(&(iphdr->dest), dest);
  81142e:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  811433:	74 08                	je     81143d <ip_output_if+0x12a>
  811435:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811439:	8b 00                	mov    (%rax),%eax
  81143b:	eb 05                	jmp    811442 <ip_output_if+0x12f>
  81143d:	b8 00 00 00 00       	mov    $0x0,%eax
  811442:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  811446:	89 42 10             	mov    %eax,0x10(%rdx)

    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);
  811449:	0f b6 45 c0          	movzbl -0x40(%rbp),%eax
  81144d:	80 cc 45             	or     $0x45,%ah
  811450:	0f b7 c0             	movzwl %ax,%eax
  811453:	89 c7                	mov    %eax,%edi
  811455:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  81145c:	00 00 00 
  81145f:	ff d0                	callq  *%rax
  811461:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  811465:	66 89 02             	mov    %ax,(%rdx)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
  811468:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81146c:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  811470:	0f b7 c0             	movzwl %ax,%eax
  811473:	89 c7                	mov    %eax,%edi
  811475:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  81147c:	00 00 00 
  81147f:	ff d0                	callq  *%rax
  811481:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  811485:	66 89 42 02          	mov    %ax,0x2(%rdx)
    IPH_OFFSET_SET(iphdr, 0);
  811489:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81148d:	66 c7 40 06 00 00    	movw   $0x0,0x6(%rax)
    IPH_ID_SET(iphdr, htons(ip_id));
  811493:	48 b8 4e b0 b4 00 00 	movabs $0xb4b04e,%rax
  81149a:	00 00 00 
  81149d:	0f b7 00             	movzwl (%rax),%eax
  8114a0:	0f b7 c0             	movzwl %ax,%eax
  8114a3:	89 c7                	mov    %eax,%edi
  8114a5:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  8114ac:	00 00 00 
  8114af:	ff d0                	callq  *%rax
  8114b1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8114b5:	66 89 42 04          	mov    %ax,0x4(%rdx)
    ++ip_id;
  8114b9:	48 b8 4e b0 b4 00 00 	movabs $0xb4b04e,%rax
  8114c0:	00 00 00 
  8114c3:	0f b7 00             	movzwl (%rax),%eax
  8114c6:	8d 50 01             	lea    0x1(%rax),%edx
  8114c9:	48 b8 4e b0 b4 00 00 	movabs $0xb4b04e,%rax
  8114d0:	00 00 00 
  8114d3:	66 89 10             	mov    %dx,(%rax)

    if (ip_addr_isany(src)) {
  8114d6:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8114db:	74 0a                	je     8114e7 <ip_output_if+0x1d4>
  8114dd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8114e1:	8b 00                	mov    (%rax),%eax
  8114e3:	85 c0                	test   %eax,%eax
  8114e5:	75 24                	jne    81150b <ip_output_if+0x1f8>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
  8114e7:	48 8b 45 10          	mov    0x10(%rbp),%rax
  8114eb:	48 83 c0 08          	add    $0x8,%rax
  8114ef:	48 85 c0             	test   %rax,%rax
  8114f2:	74 09                	je     8114fd <ip_output_if+0x1ea>
  8114f4:	48 8b 45 10          	mov    0x10(%rbp),%rax
  8114f8:	8b 40 08             	mov    0x8(%rax),%eax
  8114fb:	eb 05                	jmp    811502 <ip_output_if+0x1ef>
  8114fd:	b8 00 00 00 00       	mov    $0x0,%eax
  811502:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  811506:	89 42 0c             	mov    %eax,0xc(%rdx)
  811509:	eb 1b                	jmp    811526 <ip_output_if+0x213>
    } else {
      ip_addr_set(&(iphdr->src), src);
  81150b:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  811510:	74 08                	je     81151a <ip_output_if+0x207>
  811512:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811516:	8b 00                	mov    (%rax),%eax
  811518:	eb 05                	jmp    81151f <ip_output_if+0x20c>
  81151a:	b8 00 00 00 00       	mov    $0x0,%eax
  81151f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  811523:	89 42 0c             	mov    %eax,0xc(%rdx)
    }

    IPH_CHKSUM_SET(iphdr, 0);
  811526:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81152a:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  811530:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811534:	be 14 00 00 00       	mov    $0x14,%esi
  811539:	48 89 c7             	mov    %rax,%rdi
  81153c:	48 b8 01 2b 81 00 00 	movabs $0x812b01,%rax
  811543:	00 00 00 
  811546:	ff d0                	callq  *%rax
  811548:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81154c:	66 89 42 0a          	mov    %ax,0xa(%rdx)
  811550:	eb 18                	jmp    81156a <ip_output_if+0x257>
#endif
  } else {
    /* IP header already included in p */
    iphdr = p->payload;
  811552:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811556:	48 8b 40 08          	mov    0x8(%rax),%rax
  81155a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    dest = &(iphdr->dest);
  81155e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811562:	48 83 c0 10          	add    $0x10,%rax
  811566:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
  81156a:	48 8b 45 10          	mov    0x10(%rbp),%rax
  81156e:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  811572:	66 85 c0             	test   %ax,%ax
  811575:	74 32                	je     8115a9 <ip_output_if+0x296>
  811577:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81157b:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  81157f:	48 8b 45 10          	mov    0x10(%rbp),%rax
  811583:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  811587:	66 39 c2             	cmp    %ax,%dx
  81158a:	76 1d                	jbe    8115a9 <ip_output_if+0x296>
    return ip_frag(p,netif,dest);
  81158c:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  811590:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811594:	48 8b 75 10          	mov    0x10(%rbp),%rsi
  811598:	48 89 c7             	mov    %rax,%rdi
  81159b:	48 b8 2f 24 81 00 00 	movabs $0x81242f,%rax
  8115a2:	00 00 00 
  8115a5:	ff d0                	callq  *%rax
  8115a7:	eb 19                	jmp    8115c2 <ip_output_if+0x2af>
  } else
#endif /* (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF) */
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  8115a9:	48 8b 45 10          	mov    0x10(%rbp),%rax
  8115ad:	48 8b 40 20          	mov    0x20(%rax),%rax
  8115b1:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8115b5:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8115b9:	48 89 ce             	mov    %rcx,%rsi
  8115bc:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  8115c0:	ff d0                	callq  *%rax
  }
}
  8115c2:	48 83 c4 48          	add    $0x48,%rsp
  8115c6:	5b                   	pop    %rbx
  8115c7:	5d                   	pop    %rbp
  8115c8:	c3                   	retq   

00000000008115c9 <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
  8115c9:	55                   	push   %rbp
  8115ca:	48 89 e5             	mov    %rsp,%rbp
  8115cd:	48 83 ec 40          	sub    $0x40,%rsp
  8115d1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8115d5:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8115d9:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8115dd:	89 c8                	mov    %ecx,%eax
  8115df:	44 89 c1             	mov    %r8d,%ecx
  8115e2:	44 89 ca             	mov    %r9d,%edx
  8115e5:	88 45 d4             	mov    %al,-0x2c(%rbp)
  8115e8:	88 4d d0             	mov    %cl,-0x30(%rbp)
  8115eb:	88 55 cc             	mov    %dl,-0x34(%rbp)
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
  8115ee:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8115f2:	48 89 c7             	mov    %rax,%rdi
  8115f5:	48 b8 de 0d 81 00 00 	movabs $0x810dde,%rax
  8115fc:	00 00 00 
  8115ff:	ff d0                	callq  *%rax
  811601:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  811605:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81160a:	75 07                	jne    811613 <ip_output+0x4a>
    return ERR_RTE;
  81160c:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  811611:	eb 31                	jmp    811644 <ip_output+0x7b>
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
  811613:	44 0f b6 4d cc       	movzbl -0x34(%rbp),%r9d
  811618:	44 0f b6 45 d0       	movzbl -0x30(%rbp),%r8d
  81161d:	0f b6 4d d4          	movzbl -0x2c(%rbp),%ecx
  811621:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  811625:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  811629:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81162d:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
  811631:	48 89 3c 24          	mov    %rdi,(%rsp)
  811635:	48 89 c7             	mov    %rax,%rdi
  811638:	48 b8 13 13 81 00 00 	movabs $0x811313,%rax
  81163f:	00 00 00 
  811642:	ff d0                	callq  *%rax
}
  811644:	c9                   	leaveq 
  811645:	c3                   	retq   

0000000000811646 <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
  811646:	55                   	push   %rbp
  811647:	48 89 e5             	mov    %rsp,%rbp
  81164a:	48 83 ec 20          	sub    $0x20,%rsp
  struct ip_reassdata *r, *prev = NULL;
  81164e:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  811655:	00 

  r = reassdatagrams;
  811656:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  81165d:	00 00 00 
  811660:	48 8b 00             	mov    (%rax),%rax
  811663:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  while (r != NULL) {
  811667:	eb 60                	jmp    8116c9 <ip_reass_tmr+0x83>
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
  811669:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81166d:	0f b6 40 27          	movzbl 0x27(%rax),%eax
  811671:	84 c0                	test   %al,%al
  811673:	74 27                	je     81169c <ip_reass_tmr+0x56>
      r->timer--;
  811675:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811679:	0f b6 40 27          	movzbl 0x27(%rax),%eax
  81167d:	8d 50 ff             	lea    -0x1(%rax),%edx
  811680:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811684:	88 50 27             	mov    %dl,0x27(%rax)
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
  811687:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81168b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      r = r->next;
  81168f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811693:	48 8b 00             	mov    (%rax),%rax
  811696:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  81169a:	eb 2d                	jmp    8116c9 <ip_reass_tmr+0x83>
    } else {
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
  81169c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8116a0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      /* get the next pointer before freeing */
      r = r->next;
  8116a4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8116a8:	48 8b 00             	mov    (%rax),%rax
  8116ab:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
  8116af:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8116b3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8116b7:	48 89 d6             	mov    %rdx,%rsi
  8116ba:	48 89 c7             	mov    %rax,%rdi
  8116bd:	48 b8 d2 16 81 00 00 	movabs $0x8116d2,%rax
  8116c4:	00 00 00 
  8116c7:	ff d0                	callq  *%rax
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
  8116c9:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8116ce:	75 99                	jne    811669 <ip_reass_tmr+0x23>
      r = r->next;
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
     }
   }
}
  8116d0:	c9                   	leaveq 
  8116d1:	c3                   	retq   

00000000008116d2 <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  8116d2:	55                   	push   %rbp
  8116d3:	48 89 e5             	mov    %rsp,%rbp
  8116d6:	48 83 ec 30          	sub    $0x30,%rsp
  8116da:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8116de:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  int pbufs_freed = 0;
  8116e2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
  8116e9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8116ed:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8116f1:	75 2a                	jne    81171d <ip_reass_free_complete_datagram+0x4b>
  8116f3:	48 ba b8 26 82 00 00 	movabs $0x8226b8,%rdx
  8116fa:	00 00 00 
  8116fd:	be 9a 00 00 00       	mov    $0x9a,%esi
  811702:	48 bf c4 26 82 00 00 	movabs $0x8226c4,%rdi
  811709:	00 00 00 
  81170c:	b8 00 00 00 00       	mov    $0x0,%eax
  811711:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  811718:	00 00 00 
  81171b:	ff d1                	callq  *%rcx
  if (prev != NULL) {
  81171d:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  811722:	74 37                	je     81175b <ip_reass_free_complete_datagram+0x89>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  811724:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811728:	48 8b 00             	mov    (%rax),%rax
  81172b:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  81172f:	74 2a                	je     81175b <ip_reass_free_complete_datagram+0x89>
  811731:	48 ba e1 26 82 00 00 	movabs $0x8226e1,%rdx
  811738:	00 00 00 
  81173b:	be 9c 00 00 00       	mov    $0x9c,%esi
  811740:	48 bf c4 26 82 00 00 	movabs $0x8226c4,%rdi
  811747:	00 00 00 
  81174a:	b8 00 00 00 00       	mov    $0x0,%eax
  81174f:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  811756:	00 00 00 
  811759:	ff d1                	callq  *%rcx
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  81175b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81175f:	48 8b 40 08          	mov    0x8(%rax),%rax
  811763:	48 8b 40 08          	mov    0x8(%rax),%rax
  811767:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if (iprh->start == 0) {
  81176b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81176f:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811773:	66 85 c0             	test   %ax,%ax
  811776:	0f 85 86 00 00 00    	jne    811802 <ip_reass_free_complete_datagram+0x130>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
  81177c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811780:	48 8b 40 08          	mov    0x8(%rax),%rax
  811784:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    ipr->p = iprh->next_pbuf;
  811788:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81178c:	48 8b 10             	mov    (%rax),%rdx
  81178f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811793:	48 89 50 08          	mov    %rdx,0x8(%rax)
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
  811797:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81179b:	48 8d 48 10          	lea    0x10(%rax),%rcx
  81179f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8117a3:	48 8b 40 08          	mov    0x8(%rax),%rax
  8117a7:	ba 14 00 00 00       	mov    $0x14,%edx
  8117ac:	48 89 ce             	mov    %rcx,%rsi
  8117af:	48 89 c7             	mov    %rax,%rdi
  8117b2:	48 b8 12 23 80 00 00 	movabs $0x802312,%rax
  8117b9:	00 00 00 
  8117bc:	ff d0                	callq  *%rax
    icmp_time_exceeded(p, ICMP_TE_FRAG);
  8117be:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8117c2:	be 01 00 00 00       	mov    $0x1,%esi
  8117c7:	48 89 c7             	mov    %rax,%rdi
  8117ca:	48 b8 a3 08 82 00 00 	movabs $0x8208a3,%rax
  8117d1:	00 00 00 
  8117d4:	ff d0                	callq  *%rax
    pbufs_freed += pbuf_clen(p);
  8117d6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8117da:	48 89 c7             	mov    %rax,%rdi
  8117dd:	48 b8 f5 de 80 00 00 	movabs $0x80def5,%rax
  8117e4:	00 00 00 
  8117e7:	ff d0                	callq  *%rax
  8117e9:	0f b6 c0             	movzbl %al,%eax
  8117ec:	01 45 fc             	add    %eax,-0x4(%rbp)
    pbuf_free(p);
  8117ef:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8117f3:	48 89 c7             	mov    %rax,%rdi
  8117f6:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  8117fd:	00 00 00 
  811800:	ff d0                	callq  *%rax
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  811802:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811806:	48 8b 40 08          	mov    0x8(%rax),%rax
  81180a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  while (p != NULL) {
  81180e:	eb 4b                	jmp    81185b <ip_reass_free_complete_datagram+0x189>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
  811810:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811814:	48 8b 40 08          	mov    0x8(%rax),%rax
  811818:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    pcur = p;
  81181c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811820:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
  811824:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811828:	48 8b 00             	mov    (%rax),%rax
  81182b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    pbufs_freed += pbuf_clen(pcur);
  81182f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811833:	48 89 c7             	mov    %rax,%rdi
  811836:	48 b8 f5 de 80 00 00 	movabs $0x80def5,%rax
  81183d:	00 00 00 
  811840:	ff d0                	callq  *%rax
  811842:	0f b6 c0             	movzbl %al,%eax
  811845:	01 45 fc             	add    %eax,-0x4(%rbp)
    pbuf_free(pcur);    
  811848:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81184c:	48 89 c7             	mov    %rax,%rdi
  81184f:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  811856:	00 00 00 
  811859:	ff d0                	callq  *%rax
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
  81185b:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  811860:	75 ae                	jne    811810 <ip_reass_free_complete_datagram+0x13e>
    p = iprh->next_pbuf;
    pbufs_freed += pbuf_clen(pcur);
    pbuf_free(pcur);    
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
  811862:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  811866:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81186a:	48 89 d6             	mov    %rdx,%rsi
  81186d:	48 89 c7             	mov    %rax,%rdi
  811870:	48 b8 d5 1a 81 00 00 	movabs $0x811ad5,%rax
  811877:	00 00 00 
  81187a:	ff d0                	callq  *%rax
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  81187c:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  811883:	00 00 00 
  811886:	0f b7 00             	movzwl (%rax),%eax
  811889:	0f b7 c0             	movzwl %ax,%eax
  81188c:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  81188f:	7d 2a                	jge    8118bb <ip_reass_free_complete_datagram+0x1e9>
  811891:	48 ba f3 26 82 00 00 	movabs $0x8226f3,%rdx
  811898:	00 00 00 
  81189b:	be bd 00 00 00       	mov    $0xbd,%esi
  8118a0:	48 bf c4 26 82 00 00 	movabs $0x8226c4,%rdi
  8118a7:	00 00 00 
  8118aa:	b8 00 00 00 00       	mov    $0x0,%eax
  8118af:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  8118b6:	00 00 00 
  8118b9:	ff d1                	callq  *%rcx
  ip_reass_pbufcount -= pbufs_freed;
  8118bb:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  8118c2:	00 00 00 
  8118c5:	0f b7 10             	movzwl (%rax),%edx
  8118c8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8118cb:	29 c2                	sub    %eax,%edx
  8118cd:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  8118d4:	00 00 00 
  8118d7:	66 89 10             	mov    %dx,(%rax)

  return pbufs_freed;
  8118da:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8118dd:	c9                   	leaveq 
  8118de:	c3                   	retq   

00000000008118df <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
  8118df:	55                   	push   %rbp
  8118e0:	48 89 e5             	mov    %rsp,%rbp
  8118e3:	48 83 ec 40          	sub    $0x40,%rsp
  8118e7:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8118eb:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  /* @todo Can't we simply remove the last datagram in the
   *       linked list behind reassdatagrams?
   */
  struct ip_reassdata *r, *oldest, *prev;
  int pbufs_freed = 0, pbufs_freed_current;
  8118ee:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
  int other_datagrams;

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
  8118f5:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8118fc:	00 
    prev = NULL;
  8118fd:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  811904:	00 
    other_datagrams = 0;
  811905:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
    r = reassdatagrams;
  81190c:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  811913:	00 00 00 
  811916:	48 8b 00             	mov    (%rax),%rax
  811919:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    while (r != NULL) {
  81191d:	e9 89 00 00 00       	jmpq   8119ab <ip_reass_remove_oldest_datagram+0xcc>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
  811922:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811926:	8b 50 1c             	mov    0x1c(%rax),%edx
  811929:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81192d:	8b 40 0c             	mov    0xc(%rax),%eax
  811930:	39 c2                	cmp    %eax,%edx
  811932:	75 27                	jne    81195b <ip_reass_remove_oldest_datagram+0x7c>
  811934:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811938:	8b 50 20             	mov    0x20(%rax),%edx
  81193b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81193f:	8b 40 10             	mov    0x10(%rax),%eax
  811942:	39 c2                	cmp    %eax,%edx
  811944:	75 15                	jne    81195b <ip_reass_remove_oldest_datagram+0x7c>
  811946:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81194a:	0f b7 50 14          	movzwl 0x14(%rax),%edx
  81194e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811952:	0f b7 40 04          	movzwl 0x4(%rax),%eax
  811956:	66 39 c2             	cmp    %ax,%dx
  811959:	74 31                	je     81198c <ip_reass_remove_oldest_datagram+0xad>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
  81195b:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
        if (oldest == NULL) {
  81195f:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  811964:	75 0a                	jne    811970 <ip_reass_remove_oldest_datagram+0x91>
          oldest = r;
  811966:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81196a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  81196e:	eb 1c                	jmp    81198c <ip_reass_remove_oldest_datagram+0xad>
        } else if (r->timer <= oldest->timer) {
  811970:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811974:	0f b6 50 27          	movzbl 0x27(%rax),%edx
  811978:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81197c:	0f b6 40 27          	movzbl 0x27(%rax),%eax
  811980:	38 c2                	cmp    %al,%dl
  811982:	77 08                	ja     81198c <ip_reass_remove_oldest_datagram+0xad>
          /* older than the previous oldest */
          oldest = r;
  811984:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811988:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        }
      }
      if (r->next != NULL) {
  81198c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811990:	48 8b 00             	mov    (%rax),%rax
  811993:	48 85 c0             	test   %rax,%rax
  811996:	74 08                	je     8119a0 <ip_reass_remove_oldest_datagram+0xc1>
        prev = r;
  811998:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81199c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      }
      r = r->next;
  8119a0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8119a4:	48 8b 00             	mov    (%rax),%rax
  8119a7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
  8119ab:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8119b0:	0f 85 6c ff ff ff    	jne    811922 <ip_reass_remove_oldest_datagram+0x43>
      if (r->next != NULL) {
        prev = r;
      }
      r = r->next;
    }
    if (oldest != NULL) {
  8119b6:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8119bb:	74 23                	je     8119e0 <ip_reass_remove_oldest_datagram+0x101>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
  8119bd:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8119c1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8119c5:	48 89 d6             	mov    %rdx,%rsi
  8119c8:	48 89 c7             	mov    %rax,%rdi
  8119cb:	48 b8 d2 16 81 00 00 	movabs $0x8116d2,%rax
  8119d2:	00 00 00 
  8119d5:	ff d0                	callq  *%rax
  8119d7:	89 45 dc             	mov    %eax,-0x24(%rbp)
      pbufs_freed += pbufs_freed_current;
  8119da:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8119dd:	01 45 e4             	add    %eax,-0x1c(%rbp)
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
  8119e0:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8119e3:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  8119e6:	7d 0a                	jge    8119f2 <ip_reass_remove_oldest_datagram+0x113>
  8119e8:	83 7d e0 01          	cmpl   $0x1,-0x20(%rbp)
  8119ec:	0f 8f 03 ff ff ff    	jg     8118f5 <ip_reass_remove_oldest_datagram+0x16>
  return pbufs_freed;
  8119f2:	8b 45 e4             	mov    -0x1c(%rbp),%eax
}
  8119f5:	c9                   	leaveq 
  8119f6:	c3                   	retq   

00000000008119f7 <ip_reass_enqueue_new_datagram>:
 * @param clen number of pbufs needed to enqueue (used for freeing other datagrams if not enough space)
 * @return A pointer to the queue location into which the fragment was enqueued
 */
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
  8119f7:	55                   	push   %rbp
  8119f8:	48 89 e5             	mov    %rsp,%rbp
  8119fb:	48 83 ec 20          	sub    $0x20,%rsp
  8119ff:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  811a03:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = memp_malloc(MEMP_REASSDATA);
  811a06:	bf 05 00 00 00       	mov    $0x5,%edi
  811a0b:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  811a12:	00 00 00 
  811a15:	ff d0                	callq  *%rax
  811a17:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (ipr == NULL) {
  811a1b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  811a20:	75 40                	jne    811a62 <ip_reass_enqueue_new_datagram+0x6b>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
  811a22:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  811a25:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811a29:	89 d6                	mov    %edx,%esi
  811a2b:	48 89 c7             	mov    %rax,%rdi
  811a2e:	48 b8 df 18 81 00 00 	movabs $0x8118df,%rax
  811a35:	00 00 00 
  811a38:	ff d0                	callq  *%rax
  811a3a:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  811a3d:	7c 15                	jl     811a54 <ip_reass_enqueue_new_datagram+0x5d>
      ipr = memp_malloc(MEMP_REASSDATA);
  811a3f:	bf 05 00 00 00       	mov    $0x5,%edi
  811a44:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  811a4b:	00 00 00 
  811a4e:	ff d0                	callq  *%rax
  811a50:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    }
    if (ipr == NULL)
  811a54:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  811a59:	75 07                	jne    811a62 <ip_reass_enqueue_new_datagram+0x6b>
#endif /* IP_REASS_FREE_OLDEST */
    {
      IPFRAG_STATS_INC(ip_frag.memerr);
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
  811a5b:	b8 00 00 00 00       	mov    $0x0,%eax
  811a60:	eb 71                	jmp    811ad3 <ip_reass_enqueue_new_datagram+0xdc>
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
  811a62:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811a66:	ba 28 00 00 00       	mov    $0x28,%edx
  811a6b:	be 00 00 00 00       	mov    $0x0,%esi
  811a70:	48 89 c7             	mov    %rax,%rdi
  811a73:	48 b8 70 21 80 00 00 	movabs $0x802170,%rax
  811a7a:	00 00 00 
  811a7d:	ff d0                	callq  *%rax
  ipr->timer = IP_REASS_MAXAGE;
  811a7f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811a83:	c6 40 27 03          	movb   $0x3,0x27(%rax)

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
  811a87:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  811a8e:	00 00 00 
  811a91:	48 8b 10             	mov    (%rax),%rdx
  811a94:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811a98:	48 89 10             	mov    %rdx,(%rax)
  reassdatagrams = ipr;
  811a9b:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  811aa2:	00 00 00 
  811aa5:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  811aa9:	48 89 10             	mov    %rdx,(%rax)
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
  811aac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811ab0:	48 8d 48 10          	lea    0x10(%rax),%rcx
  811ab4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811ab8:	ba 14 00 00 00       	mov    $0x14,%edx
  811abd:	48 89 c6             	mov    %rax,%rsi
  811ac0:	48 89 cf             	mov    %rcx,%rdi
  811ac3:	48 b8 12 23 80 00 00 	movabs $0x802312,%rax
  811aca:	00 00 00 
  811acd:	ff d0                	callq  *%rax
  return ipr;
  811acf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  811ad3:	c9                   	leaveq 
  811ad4:	c3                   	retq   

0000000000811ad5 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  811ad5:	55                   	push   %rbp
  811ad6:	48 89 e5             	mov    %rsp,%rbp
  811ad9:	48 83 ec 10          	sub    $0x10,%rsp
  811add:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  811ae1:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
  811ae5:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  811aec:	00 00 00 
  811aef:	48 8b 00             	mov    (%rax),%rax
  811af2:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  811af6:	75 16                	jne    811b0e <ip_reass_dequeue_datagram+0x39>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  811af8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811afc:	48 8b 10             	mov    (%rax),%rdx
  811aff:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  811b06:	00 00 00 
  811b09:	48 89 10             	mov    %rdx,(%rax)
  811b0c:	eb 3f                	jmp    811b4d <ip_reass_dequeue_datagram+0x78>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  811b0e:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  811b13:	75 2a                	jne    811b3f <ip_reass_dequeue_datagram+0x6a>
  811b15:	48 ba 0e 27 82 00 00 	movabs $0x82270e,%rdx
  811b1c:	00 00 00 
  811b1f:	be 2a 01 00 00       	mov    $0x12a,%esi
  811b24:	48 bf c4 26 82 00 00 	movabs $0x8226c4,%rdi
  811b2b:	00 00 00 
  811b2e:	b8 00 00 00 00       	mov    $0x0,%eax
  811b33:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  811b3a:	00 00 00 
  811b3d:	ff d1                	callq  *%rcx
    prev->next = ipr->next;
  811b3f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811b43:	48 8b 10             	mov    (%rax),%rdx
  811b46:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811b4a:	48 89 10             	mov    %rdx,(%rax)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
  811b4d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811b51:	48 89 c6             	mov    %rax,%rsi
  811b54:	bf 05 00 00 00       	mov    $0x5,%edi
  811b59:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  811b60:	00 00 00 
  811b63:	ff d0                	callq  *%rax
}
  811b65:	c9                   	leaveq 
  811b66:	c3                   	retq   

0000000000811b67 <ip_reass_chain_frag_into_datagram_and_validate>:
 * @param new_p points to the pbuf for the current fragment
 * @return 0 if invalid, >0 otherwise
 */
static int
ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p)
{
  811b67:	55                   	push   %rbp
  811b68:	48 89 e5             	mov    %rsp,%rbp
  811b6b:	53                   	push   %rbx
  811b6c:	48 83 ec 58          	sub    $0x58,%rsp
  811b70:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  811b74:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  811b78:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  811b7f:	00 
  struct pbuf *q;
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;
  811b80:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%rbp)

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  811b87:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  811b8b:	48 8b 40 08          	mov    0x8(%rax),%rax
  811b8f:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  811b93:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811b97:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  811b9b:	0f b7 c0             	movzwl %ax,%eax
  811b9e:	89 c7                	mov    %eax,%edi
  811ba0:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  811ba7:	00 00 00 
  811baa:	ff d0                	callq  *%rax
  811bac:	89 c3                	mov    %eax,%ebx
  811bae:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811bb2:	0f b7 00             	movzwl (%rax),%eax
  811bb5:	0f b7 c0             	movzwl %ax,%eax
  811bb8:	89 c7                	mov    %eax,%edi
  811bba:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  811bc1:	00 00 00 
  811bc4:	ff d0                	callq  *%rax
  811bc6:	66 c1 e8 08          	shr    $0x8,%ax
  811bca:	83 e0 0f             	and    $0xf,%eax
  811bcd:	89 c2                	mov    %eax,%edx
  811bcf:	b8 00 00 00 00       	mov    $0x0,%eax
  811bd4:	29 d0                	sub    %edx,%eax
  811bd6:	c1 e0 02             	shl    $0x2,%eax
  811bd9:	01 d8                	add    %ebx,%eax
  811bdb:	66 89 45 c6          	mov    %ax,-0x3a(%rbp)
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  811bdf:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811be3:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  811be7:	0f b7 c0             	movzwl %ax,%eax
  811bea:	89 c7                	mov    %eax,%edi
  811bec:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  811bf3:	00 00 00 
  811bf6:	ff d0                	callq  *%rax
  811bf8:	66 25 ff 1f          	and    $0x1fff,%ax
  811bfc:	c1 e0 03             	shl    $0x3,%eax
  811bff:	66 89 45 c4          	mov    %ax,-0x3c(%rbp)
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  811c03:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  811c07:	48 8b 40 08          	mov    0x8(%rax),%rax
  811c0b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  iprh->next_pbuf = NULL;
  811c0f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811c13:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  iprh->start = offset;
  811c1a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811c1e:	0f b7 55 c4          	movzwl -0x3c(%rbp),%edx
  811c22:	66 89 50 08          	mov    %dx,0x8(%rax)
  iprh->end = offset + len;
  811c26:	0f b7 45 c6          	movzwl -0x3a(%rbp),%eax
  811c2a:	0f b7 55 c4          	movzwl -0x3c(%rbp),%edx
  811c2e:	01 c2                	add    %eax,%edx
  811c30:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811c34:	66 89 50 0a          	mov    %dx,0xa(%rax)

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  811c38:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811c3c:	48 8b 40 08          	mov    0x8(%rax),%rax
  811c40:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  811c44:	e9 ed 00 00 00       	jmpq   811d36 <ip_reass_chain_frag_into_datagram_and_validate+0x1cf>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  811c49:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811c4d:	48 8b 40 08          	mov    0x8(%rax),%rax
  811c51:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    if (iprh->start < iprh_tmp->start) {
  811c55:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811c59:	0f b7 50 08          	movzwl 0x8(%rax),%edx
  811c5d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811c61:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811c65:	66 39 c2             	cmp    %ax,%dx
  811c68:	73 62                	jae    811ccc <ip_reass_chain_frag_into_datagram_and_validate+0x165>
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
  811c6a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811c6e:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  811c72:	48 89 10             	mov    %rdx,(%rax)
      if (iprh_prev != NULL) {
  811c75:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  811c7a:	74 42                	je     811cbe <ip_reass_chain_frag_into_datagram_and_validate+0x157>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
  811c7c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811c80:	0f b7 50 08          	movzwl 0x8(%rax),%edx
  811c84:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811c88:	0f b7 40 0a          	movzwl 0xa(%rax),%eax
  811c8c:	66 39 c2             	cmp    %ax,%dx
  811c8f:	0f 82 01 03 00 00    	jb     811f96 <ip_reass_chain_frag_into_datagram_and_validate+0x42f>
  811c95:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811c99:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  811c9d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811ca1:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811ca5:	66 39 c2             	cmp    %ax,%dx
  811ca8:	0f 87 e8 02 00 00    	ja     811f96 <ip_reass_chain_frag_into_datagram_and_validate+0x42f>
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
  811cae:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811cb2:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  811cb6:	48 89 10             	mov    %rdx,(%rax)
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
  811cb9:	e9 83 00 00 00       	jmpq   811d41 <ip_reass_chain_frag_into_datagram_and_validate+0x1da>
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
  811cbe:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811cc2:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  811cc6:	48 89 50 08          	mov    %rdx,0x8(%rax)
      }
      break;
  811cca:	eb 75                	jmp    811d41 <ip_reass_chain_frag_into_datagram_and_validate+0x1da>
    } else if(iprh->start == iprh_tmp->start) {
  811ccc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811cd0:	0f b7 50 08          	movzwl 0x8(%rax),%edx
  811cd4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811cd8:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811cdc:	66 39 c2             	cmp    %ax,%dx
  811cdf:	75 05                	jne    811ce6 <ip_reass_chain_frag_into_datagram_and_validate+0x17f>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
  811ce1:	e9 b0 02 00 00       	jmpq   811f96 <ip_reass_chain_frag_into_datagram_and_validate+0x42f>
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
  811ce6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811cea:	0f b7 50 08          	movzwl 0x8(%rax),%edx
  811cee:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811cf2:	0f b7 40 0a          	movzwl 0xa(%rax),%eax
  811cf6:	66 39 c2             	cmp    %ax,%dx
  811cf9:	73 05                	jae    811d00 <ip_reass_chain_frag_into_datagram_and_validate+0x199>
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
  811cfb:	e9 96 02 00 00       	jmpq   811f96 <ip_reass_chain_frag_into_datagram_and_validate+0x42f>
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
  811d00:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  811d05:	74 1c                	je     811d23 <ip_reass_chain_frag_into_datagram_and_validate+0x1bc>
        if (iprh_prev->end != iprh_tmp->start) {
  811d07:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811d0b:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  811d0f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811d13:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811d17:	66 39 c2             	cmp    %ax,%dx
  811d1a:	74 07                	je     811d23 <ip_reass_chain_frag_into_datagram_and_validate+0x1bc>
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
  811d1c:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
        }
      }
    }
    q = iprh_tmp->next_pbuf;
  811d23:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811d27:	48 8b 00             	mov    (%rax),%rax
  811d2a:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    iprh_prev = iprh_tmp;
  811d2e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811d32:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  811d36:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  811d3b:	0f 85 08 ff ff ff    	jne    811c49 <ip_reass_chain_frag_into_datagram_and_validate+0xe2>
    q = iprh_tmp->next_pbuf;
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
  811d41:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  811d46:	0f 85 b2 00 00 00    	jne    811dfe <ip_reass_chain_frag_into_datagram_and_validate+0x297>
    if (iprh_prev != NULL) {
  811d4c:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  811d51:	74 68                	je     811dbb <ip_reass_chain_frag_into_datagram_and_validate+0x254>
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  811d53:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811d57:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  811d5b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811d5f:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811d63:	66 39 c2             	cmp    %ax,%dx
  811d66:	76 2a                	jbe    811d92 <ip_reass_chain_frag_into_datagram_and_validate+0x22b>
  811d68:	48 ba 27 27 82 00 00 	movabs $0x822727,%rdx
  811d6f:	00 00 00 
  811d72:	be 84 01 00 00       	mov    $0x184,%esi
  811d77:	48 bf c4 26 82 00 00 	movabs $0x8226c4,%rdi
  811d7e:	00 00 00 
  811d81:	b8 00 00 00 00       	mov    $0x0,%eax
  811d86:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  811d8d:	00 00 00 
  811d90:	ff d1                	callq  *%rcx
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
  811d92:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811d96:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  811d9a:	48 89 10             	mov    %rdx,(%rax)
      if (iprh_prev->end != iprh->start) {
  811d9d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811da1:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  811da5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811da9:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811dad:	66 39 c2             	cmp    %ax,%dx
  811db0:	74 4c                	je     811dfe <ip_reass_chain_frag_into_datagram_and_validate+0x297>
        valid = 0;
  811db2:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
  811db9:	eb 43                	jmp    811dfe <ip_reass_chain_frag_into_datagram_and_validate+0x297>
      }
    } else {
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  811dbb:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811dbf:	48 8b 40 08          	mov    0x8(%rax),%rax
  811dc3:	48 85 c0             	test   %rax,%rax
  811dc6:	74 2a                	je     811df2 <ip_reass_chain_frag_into_datagram_and_validate+0x28b>
  811dc8:	48 ba 48 27 82 00 00 	movabs $0x822748,%rdx
  811dcf:	00 00 00 
  811dd2:	be 8d 01 00 00       	mov    $0x18d,%esi
  811dd7:	48 bf c4 26 82 00 00 	movabs $0x8226c4,%rdi
  811dde:	00 00 00 
  811de1:	b8 00 00 00 00       	mov    $0x0,%eax
  811de6:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  811ded:	00 00 00 
  811df0:	ff d1                	callq  *%rcx
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
  811df2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811df6:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  811dfa:	48 89 50 08          	mov    %rdx,0x8(%rax)
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
  811dfe:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811e02:	0f b6 40 26          	movzbl 0x26(%rax),%eax
  811e06:	0f b6 c0             	movzbl %al,%eax
  811e09:	83 e0 01             	and    $0x1,%eax
  811e0c:	85 c0                	test   %eax,%eax
  811e0e:	0f 84 7b 01 00 00    	je     811f8f <ip_reass_chain_frag_into_datagram_and_validate+0x428>
    /* and had no wholes so far */
    if (valid) {
  811e14:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  811e18:	0f 84 6c 01 00 00    	je     811f8a <ip_reass_chain_frag_into_datagram_and_validate+0x423>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
  811e1e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811e22:	48 8b 40 08          	mov    0x8(%rax),%rax
  811e26:	48 8b 40 08          	mov    0x8(%rax),%rax
  811e2a:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811e2e:	66 85 c0             	test   %ax,%ax
  811e31:	74 0c                	je     811e3f <ip_reass_chain_frag_into_datagram_and_validate+0x2d8>
        valid = 0;
  811e33:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
  811e3a:	e9 4b 01 00 00       	jmpq   811f8a <ip_reass_chain_frag_into_datagram_and_validate+0x423>
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
  811e3f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811e43:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        q = iprh->next_pbuf;
  811e47:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811e4b:	48 8b 00             	mov    (%rax),%rax
  811e4e:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        while (q != NULL) {
  811e52:	eb 3d                	jmp    811e91 <ip_reass_chain_frag_into_datagram_and_validate+0x32a>
          iprh = (struct ip_reass_helper*)q->payload;
  811e54:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811e58:	48 8b 40 08          	mov    0x8(%rax),%rax
  811e5c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
          if (iprh_prev->end != iprh->start) {
  811e60:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811e64:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  811e68:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811e6c:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811e70:	66 39 c2             	cmp    %ax,%dx
  811e73:	74 09                	je     811e7e <ip_reass_chain_frag_into_datagram_and_validate+0x317>
            valid = 0;
  811e75:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
            break;
  811e7c:	eb 1a                	jmp    811e98 <ip_reass_chain_frag_into_datagram_and_validate+0x331>
          }
          iprh_prev = iprh;
  811e7e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811e82:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
          q = iprh->next_pbuf;
  811e86:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811e8a:	48 8b 00             	mov    (%rax),%rax
  811e8d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
  811e91:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  811e96:	75 bc                	jne    811e54 <ip_reass_chain_frag_into_datagram_and_validate+0x2ed>
          iprh_prev = iprh;
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
  811e98:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  811e9c:	0f 84 e8 00 00 00    	je     811f8a <ip_reass_chain_frag_into_datagram_and_validate+0x423>
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  811ea2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811ea6:	48 8b 40 08          	mov    0x8(%rax),%rax
  811eaa:	48 85 c0             	test   %rax,%rax
  811ead:	75 2a                	jne    811ed9 <ip_reass_chain_frag_into_datagram_and_validate+0x372>
  811eaf:	48 ba 7f 27 82 00 00 	movabs $0x82277f,%rdx
  811eb6:	00 00 00 
  811eb9:	be ad 01 00 00       	mov    $0x1ad,%esi
  811ebe:	48 bf c4 26 82 00 00 	movabs $0x8226c4,%rdi
  811ec5:	00 00 00 
  811ec8:	b8 00 00 00 00       	mov    $0x0,%eax
  811ecd:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  811ed4:	00 00 00 
  811ed7:	ff d1                	callq  *%rcx
          LWIP_ASSERT("sanity check",
  811ed9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811edd:	48 8b 40 08          	mov    0x8(%rax),%rax
  811ee1:	48 8b 40 08          	mov    0x8(%rax),%rax
  811ee5:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  811ee9:	75 2a                	jne    811f15 <ip_reass_chain_frag_into_datagram_and_validate+0x3ae>
  811eeb:	48 ba 7f 27 82 00 00 	movabs $0x82277f,%rdx
  811ef2:	00 00 00 
  811ef5:	be af 01 00 00       	mov    $0x1af,%esi
  811efa:	48 bf c4 26 82 00 00 	movabs $0x8226c4,%rdi
  811f01:	00 00 00 
  811f04:	b8 00 00 00 00       	mov    $0x0,%eax
  811f09:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  811f10:	00 00 00 
  811f13:	ff d1                	callq  *%rcx
            ((struct ip_reass_helper*)ipr->p->payload) != iprh);
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  811f15:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811f19:	48 8b 00             	mov    (%rax),%rax
  811f1c:	48 85 c0             	test   %rax,%rax
  811f1f:	74 2a                	je     811f4b <ip_reass_chain_frag_into_datagram_and_validate+0x3e4>
  811f21:	48 ba 90 27 82 00 00 	movabs $0x822790,%rdx
  811f28:	00 00 00 
  811f2b:	be b1 01 00 00       	mov    $0x1b1,%esi
  811f30:	48 bf c4 26 82 00 00 	movabs $0x8226c4,%rdi
  811f37:	00 00 00 
  811f3a:	b8 00 00 00 00       	mov    $0x0,%eax
  811f3f:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  811f46:	00 00 00 
  811f49:	ff d1                	callq  *%rcx
            iprh->next_pbuf == NULL);
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  811f4b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811f4f:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  811f53:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811f57:	0f b7 40 24          	movzwl 0x24(%rax),%eax
  811f5b:	66 39 c2             	cmp    %ax,%dx
  811f5e:	74 2a                	je     811f8a <ip_reass_chain_frag_into_datagram_and_validate+0x423>
  811f60:	48 ba b8 27 82 00 00 	movabs $0x8227b8,%rdx
  811f67:	00 00 00 
  811f6a:	be b3 01 00 00       	mov    $0x1b3,%esi
  811f6f:	48 bf c4 26 82 00 00 	movabs $0x8226c4,%rdi
  811f76:	00 00 00 
  811f79:	b8 00 00 00 00       	mov    $0x0,%eax
  811f7e:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  811f85:	00 00 00 
  811f88:	ff d1                	callq  *%rcx
      }
    }
    /* If valid is 0 here, there are some fragments missing in the middle
     * (since MF == 0 has already arrived). Such datagrams simply time out if
     * no more fragments are received... */
    return valid;
  811f8a:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  811f8d:	eb 53                	jmp    811fe2 <ip_reass_chain_frag_into_datagram_and_validate+0x47b>
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
  811f8f:	b8 00 00 00 00       	mov    $0x0,%eax
  811f94:	eb 4c                	jmp    811fe2 <ip_reass_chain_frag_into_datagram_and_validate+0x47b>
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
  811f96:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  811f9d:	00 00 00 
  811fa0:	0f b7 18             	movzwl (%rax),%ebx
  811fa3:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  811fa7:	48 89 c7             	mov    %rax,%rdi
  811faa:	48 b8 f5 de 80 00 00 	movabs $0x80def5,%rax
  811fb1:	00 00 00 
  811fb4:	ff d0                	callq  *%rax
  811fb6:	0f b6 c0             	movzbl %al,%eax
  811fb9:	29 c3                	sub    %eax,%ebx
  811fbb:	89 da                	mov    %ebx,%edx
  811fbd:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  811fc4:	00 00 00 
  811fc7:	66 89 10             	mov    %dx,(%rax)
  pbuf_free(new_p);
  811fca:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  811fce:	48 89 c7             	mov    %rax,%rdi
  811fd1:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  811fd8:	00 00 00 
  811fdb:	ff d0                	callq  *%rax
  return 0;
  811fdd:	b8 00 00 00 00       	mov    $0x0,%eax
#endif /* IP_REASS_CHECK_OVERLAP */
}
  811fe2:	48 83 c4 58          	add    $0x58,%rsp
  811fe6:	5b                   	pop    %rbx
  811fe7:	5d                   	pop    %rbp
  811fe8:	c3                   	retq   

0000000000811fe9 <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
  811fe9:	55                   	push   %rbp
  811fea:	48 89 e5             	mov    %rsp,%rbp
  811fed:	53                   	push   %rbx
  811fee:	48 83 ec 48          	sub    $0x48,%rsp
  811ff2:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  struct ip_hdr *fraghdr;
  struct ip_reassdata *ipr;
  struct ip_reass_helper *iprh;
  u16_t offset, len;
  u8_t clen;
  struct ip_reassdata *ipr_prev = NULL;
  811ff6:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  811ffd:	00 

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
  811ffe:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  812002:	48 8b 40 08          	mov    0x8(%rax),%rax
  812006:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
  81200a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81200e:	0f b7 00             	movzwl (%rax),%eax
  812011:	0f b7 c0             	movzwl %ax,%eax
  812014:	89 c7                	mov    %eax,%edi
  812016:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  81201d:	00 00 00 
  812020:	ff d0                	callq  *%rax
  812022:	66 c1 e8 08          	shr    $0x8,%ax
  812026:	0f b7 c0             	movzwl %ax,%eax
  812029:	83 e0 0f             	and    $0xf,%eax
  81202c:	c1 e0 02             	shl    $0x2,%eax
  81202f:	83 f8 14             	cmp    $0x14,%eax
  812032:	74 05                	je     812039 <ip_reass+0x50>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  812034:	e9 d7 03 00 00       	jmpq   812410 <ip_reass+0x427>
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  812039:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81203d:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  812041:	0f b7 c0             	movzwl %ax,%eax
  812044:	89 c7                	mov    %eax,%edi
  812046:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  81204d:	00 00 00 
  812050:	ff d0                	callq  *%rax
  812052:	66 25 ff 1f          	and    $0x1fff,%ax
  812056:	c1 e0 03             	shl    $0x3,%eax
  812059:	66 89 45 ce          	mov    %ax,-0x32(%rbp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  81205d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812061:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  812065:	0f b7 c0             	movzwl %ax,%eax
  812068:	89 c7                	mov    %eax,%edi
  81206a:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  812071:	00 00 00 
  812074:	ff d0                	callq  *%rax
  812076:	89 c3                	mov    %eax,%ebx
  812078:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81207c:	0f b7 00             	movzwl (%rax),%eax
  81207f:	0f b7 c0             	movzwl %ax,%eax
  812082:	89 c7                	mov    %eax,%edi
  812084:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  81208b:	00 00 00 
  81208e:	ff d0                	callq  *%rax
  812090:	66 c1 e8 08          	shr    $0x8,%ax
  812094:	83 e0 0f             	and    $0xf,%eax
  812097:	89 c2                	mov    %eax,%edx
  812099:	b8 00 00 00 00       	mov    $0x0,%eax
  81209e:	29 d0                	sub    %edx,%eax
  8120a0:	c1 e0 02             	shl    $0x2,%eax
  8120a3:	01 d8                	add    %ebx,%eax
  8120a5:	66 89 45 cc          	mov    %ax,-0x34(%rbp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  8120a9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8120ad:	48 89 c7             	mov    %rax,%rdi
  8120b0:	48 b8 f5 de 80 00 00 	movabs $0x80def5,%rax
  8120b7:	00 00 00 
  8120ba:	ff d0                	callq  *%rax
  8120bc:	88 45 cb             	mov    %al,-0x35(%rbp)
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
  8120bf:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  8120c6:	00 00 00 
  8120c9:	0f b7 00             	movzwl (%rax),%eax
  8120cc:	0f b7 d0             	movzwl %ax,%edx
  8120cf:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  8120d3:	01 d0                	add    %edx,%eax
  8120d5:	83 f8 0a             	cmp    $0xa,%eax
  8120d8:	7e 3d                	jle    812117 <ip_reass+0x12e>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  8120da:	0f b6 55 cb          	movzbl -0x35(%rbp),%edx
  8120de:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8120e2:	89 d6                	mov    %edx,%esi
  8120e4:	48 89 c7             	mov    %rax,%rdi
  8120e7:	48 b8 df 18 81 00 00 	movabs $0x8118df,%rax
  8120ee:	00 00 00 
  8120f1:	ff d0                	callq  *%rax
  8120f3:	85 c0                	test   %eax,%eax
  8120f5:	74 1b                	je     812112 <ip_reass+0x129>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
  8120f7:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  8120fe:	00 00 00 
  812101:	0f b7 00             	movzwl (%rax),%eax
  812104:	0f b7 d0             	movzwl %ax,%edx
  812107:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  81210b:	01 d0                	add    %edx,%eax

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  81210d:	83 f8 0a             	cmp    $0xa,%eax
  812110:	7e 05                	jle    812117 <ip_reass+0x12e>
      LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: Overflow condition: pbufct=%d, clen=%d, MAX=%d\n",
        ip_reass_pbufcount, clen, IP_REASS_MAX_PBUFS));
      IPFRAG_STATS_INC(ip_frag.memerr);
      /* @todo: send ICMP time exceeded here? */
      /* drop this pbuf */
      goto nullreturn;
  812112:	e9 f9 02 00 00       	jmpq   812410 <ip_reass+0x427>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  812117:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  81211e:	00 00 00 
  812121:	48 8b 00             	mov    (%rax),%rax
  812124:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  812128:	eb 4e                	jmp    812178 <ip_reass+0x18f>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  81212a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81212e:	8b 50 1c             	mov    0x1c(%rax),%edx
  812131:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812135:	8b 40 0c             	mov    0xc(%rax),%eax
  812138:	39 c2                	cmp    %eax,%edx
  81213a:	75 29                	jne    812165 <ip_reass+0x17c>
  81213c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812140:	8b 50 20             	mov    0x20(%rax),%edx
  812143:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812147:	8b 40 10             	mov    0x10(%rax),%eax
  81214a:	39 c2                	cmp    %eax,%edx
  81214c:	75 17                	jne    812165 <ip_reass+0x17c>
  81214e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812152:	0f b7 50 14          	movzwl 0x14(%rax),%edx
  812156:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81215a:	0f b7 40 04          	movzwl 0x4(%rax),%eax
  81215e:	66 39 c2             	cmp    %ax,%dx
  812161:	75 02                	jne    812165 <ip_reass+0x17c>
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: matching previous fragment ID=%"X16_F"\n",
        ntohs(IPH_ID(fraghdr))));
      IPFRAG_STATS_INC(ip_frag.cachehit);
      break;
  812163:	eb 1a                	jmp    81217f <ip_reass+0x196>
    }
    ipr_prev = ipr;
  812165:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812169:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  81216d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812171:	48 8b 00             	mov    (%rax),%rax
  812174:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  812178:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81217d:	75 ab                	jne    81212a <ip_reass+0x141>
      break;
    }
    ipr_prev = ipr;
  }

  if (ipr == NULL) {
  81217f:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  812184:	75 29                	jne    8121af <ip_reass+0x1c6>
  /* Enqueue a new datagram into the datagram queue */
    ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
  812186:	0f b6 55 cb          	movzbl -0x35(%rbp),%edx
  81218a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81218e:	89 d6                	mov    %edx,%esi
  812190:	48 89 c7             	mov    %rax,%rdi
  812193:	48 b8 f7 19 81 00 00 	movabs $0x8119f7,%rax
  81219a:	00 00 00 
  81219d:	ff d0                	callq  *%rax
  81219f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
  8121a3:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8121a8:	75 72                	jne    81221c <ip_reass+0x233>
      goto nullreturn;
  8121aa:	e9 61 02 00 00       	jmpq   812410 <ip_reass+0x427>
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  8121af:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8121b3:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  8121b7:	0f b7 c0             	movzwl %ax,%eax
  8121ba:	89 c7                	mov    %eax,%edi
  8121bc:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  8121c3:	00 00 00 
  8121c6:	ff d0                	callq  *%rax
  8121c8:	0f b7 c0             	movzwl %ax,%eax
  8121cb:	25 ff 1f 00 00       	and    $0x1fff,%eax
  8121d0:	85 c0                	test   %eax,%eax
  8121d2:	75 48                	jne    81221c <ip_reass+0x233>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
  8121d4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8121d8:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  8121dc:	0f b7 c0             	movzwl %ax,%eax
  8121df:	89 c7                	mov    %eax,%edi
  8121e1:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  8121e8:	00 00 00 
  8121eb:	ff d0                	callq  *%rax
  8121ed:	0f b7 c0             	movzwl %ax,%eax
  8121f0:	25 ff 1f 00 00       	and    $0x1fff,%eax
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  8121f5:	85 c0                	test   %eax,%eax
  8121f7:	74 23                	je     81221c <ip_reass+0x233>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
  8121f9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8121fd:	48 8d 48 10          	lea    0x10(%rax),%rcx
  812201:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812205:	ba 14 00 00 00       	mov    $0x14,%edx
  81220a:	48 89 c6             	mov    %rax,%rsi
  81220d:	48 89 cf             	mov    %rcx,%rdi
  812210:	48 b8 12 23 80 00 00 	movabs $0x802312,%rax
  812217:	00 00 00 
  81221a:	ff d0                	callq  *%rax
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
  81221c:	0f b6 55 cb          	movzbl -0x35(%rbp),%edx
  812220:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  812227:	00 00 00 
  81222a:	0f b7 00             	movzwl (%rax),%eax
  81222d:	01 c2                	add    %eax,%edx
  81222f:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  812236:	00 00 00 
  812239:	66 89 10             	mov    %dx,(%rax)

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
  81223c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812240:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  812244:	0f b7 c0             	movzwl %ax,%eax
  812247:	89 c7                	mov    %eax,%edi
  812249:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  812250:	00 00 00 
  812253:	ff d0                	callq  *%rax
  812255:	0f b7 c0             	movzwl %ax,%eax
  812258:	25 00 20 00 00       	and    $0x2000,%eax
  81225d:	85 c0                	test   %eax,%eax
  81225f:	75 26                	jne    812287 <ip_reass+0x29e>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
  812261:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812265:	0f b6 40 26          	movzbl 0x26(%rax),%eax
  812269:	83 c8 01             	or     $0x1,%eax
  81226c:	89 c2                	mov    %eax,%edx
  81226e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812272:	88 50 26             	mov    %dl,0x26(%rax)
    ipr->datagram_len = offset + len;
  812275:	0f b7 45 cc          	movzwl -0x34(%rbp),%eax
  812279:	0f b7 55 ce          	movzwl -0x32(%rbp),%edx
  81227d:	01 c2                	add    %eax,%edx
  81227f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812283:	66 89 50 24          	mov    %dx,0x24(%rax)
     ("ip_reass: last fragment seen, total len %"S16_F"\n",
      ipr->datagram_len));
  }
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
  812287:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  81228b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81228f:	48 89 d6             	mov    %rdx,%rsi
  812292:	48 89 c7             	mov    %rax,%rdi
  812295:	48 b8 67 1b 81 00 00 	movabs $0x811b67,%rax
  81229c:	00 00 00 
  81229f:	ff d0                	callq  *%rax
  8122a1:	85 c0                	test   %eax,%eax
  8122a3:	0f 84 60 01 00 00    	je     812409 <ip_reass+0x420>
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
  8122a9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8122ad:	0f b7 40 24          	movzwl 0x24(%rax),%eax
  8122b1:	8d 50 14             	lea    0x14(%rax),%edx
  8122b4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8122b8:	66 89 50 24          	mov    %dx,0x24(%rax)

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
  8122bc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8122c0:	48 8b 40 08          	mov    0x8(%rax),%rax
  8122c4:	48 8b 40 08          	mov    0x8(%rax),%rax
  8122c8:	48 8b 00             	mov    (%rax),%rax
  8122cb:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
  8122cf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8122d3:	48 8b 40 08          	mov    0x8(%rax),%rax
  8122d7:	48 8b 40 08          	mov    0x8(%rax),%rax
  8122db:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
  8122df:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8122e3:	48 8d 48 10          	lea    0x10(%rax),%rcx
  8122e7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8122eb:	ba 14 00 00 00       	mov    $0x14,%edx
  8122f0:	48 89 ce             	mov    %rcx,%rsi
  8122f3:	48 89 c7             	mov    %rax,%rdi
  8122f6:	48 b8 12 23 80 00 00 	movabs $0x802312,%rax
  8122fd:	00 00 00 
  812300:	ff d0                	callq  *%rax
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
  812302:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812306:	0f b7 40 24          	movzwl 0x24(%rax),%eax
  81230a:	0f b7 c0             	movzwl %ax,%eax
  81230d:	89 c7                	mov    %eax,%edi
  81230f:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  812316:	00 00 00 
  812319:	ff d0                	callq  *%rax
  81231b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  81231f:	66 89 42 02          	mov    %ax,0x2(%rdx)
    IPH_OFFSET_SET(fraghdr, 0);
  812323:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812327:	66 c7 40 06 00 00    	movw   $0x0,0x6(%rax)
    IPH_CHKSUM_SET(fraghdr, 0);
  81232d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812331:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
  812337:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81233b:	be 14 00 00 00       	mov    $0x14,%esi
  812340:	48 89 c7             	mov    %rax,%rdi
  812343:	48 b8 01 2b 81 00 00 	movabs $0x812b01,%rax
  81234a:	00 00 00 
  81234d:	ff d0                	callq  *%rax
  81234f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  812353:	66 89 42 0a          	mov    %ax,0xa(%rdx)

    p = ipr->p;
  812357:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81235b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81235f:	48 89 45 b8          	mov    %rax,-0x48(%rbp)

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  812363:	eb 49                	jmp    8123ae <ip_reass+0x3c5>
      iprh = (struct ip_reass_helper*)r->payload;
  812365:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812369:	48 8b 40 08          	mov    0x8(%rax),%rax
  81236d:	48 89 45 c0          	mov    %rax,-0x40(%rbp)

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
  812371:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812375:	be ec ff ff ff       	mov    $0xffffffec,%esi
  81237a:	48 89 c7             	mov    %rax,%rdi
  81237d:	48 b8 7f db 80 00 00 	movabs $0x80db7f,%rax
  812384:	00 00 00 
  812387:	ff d0                	callq  *%rax
      pbuf_cat(p, r);
  812389:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81238d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  812391:	48 89 d6             	mov    %rdx,%rsi
  812394:	48 89 c7             	mov    %rax,%rdi
  812397:	48 b8 4b df 80 00 00 	movabs $0x80df4b,%rax
  81239e:	00 00 00 
  8123a1:	ff d0                	callq  *%rax
      r = iprh->next_pbuf;
  8123a3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8123a7:	48 8b 00             	mov    (%rax),%rax
  8123aa:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  8123ae:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8123b3:	75 b0                	jne    812365 <ip_reass+0x37c>
      pbuf_header(r, -IP_HLEN);
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
  8123b5:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8123b9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8123bd:	48 89 d6             	mov    %rdx,%rsi
  8123c0:	48 89 c7             	mov    %rax,%rdi
  8123c3:	48 b8 d5 1a 81 00 00 	movabs $0x811ad5,%rax
  8123ca:	00 00 00 
  8123cd:	ff d0                	callq  *%rax

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
  8123cf:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  8123d6:	00 00 00 
  8123d9:	0f b7 18             	movzwl (%rax),%ebx
  8123dc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8123e0:	48 89 c7             	mov    %rax,%rdi
  8123e3:	48 b8 f5 de 80 00 00 	movabs $0x80def5,%rax
  8123ea:	00 00 00 
  8123ed:	ff d0                	callq  *%rax
  8123ef:	0f b6 c0             	movzbl %al,%eax
  8123f2:	29 c3                	sub    %eax,%ebx
  8123f4:	89 da                	mov    %ebx,%edx
  8123f6:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  8123fd:	00 00 00 
  812400:	66 89 10             	mov    %dx,(%rax)

    /* Return the pbuf chain */
    return p;
  812403:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  812407:	eb 1f                	jmp    812428 <ip_reass+0x43f>
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
  812409:	b8 00 00 00 00       	mov    $0x0,%eax
  81240e:	eb 18                	jmp    812428 <ip_reass+0x43f>

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  812410:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  812414:	48 89 c7             	mov    %rax,%rdi
  812417:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  81241e:	00 00 00 
  812421:	ff d0                	callq  *%rax
  return NULL;
  812423:	b8 00 00 00 00       	mov    $0x0,%eax
}
  812428:	48 83 c4 48          	add    $0x48,%rsp
  81242c:	5b                   	pop    %rbx
  81242d:	5d                   	pop    %rbp
  81242e:	c3                   	retq   

000000000081242f <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
  81242f:	55                   	push   %rbp
  812430:	48 89 e5             	mov    %rsp,%rbp
  812433:	48 83 ec 50          	sub    $0x50,%rsp
  812437:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  81243b:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  81243f:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  812443:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  812447:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  81244b:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
  u16_t ofo, omf;
  u16_t last;
  u16_t poff = IP_HLEN;
  81244f:	66 c7 45 fa 14 00    	movw   $0x14,-0x6(%rbp)
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  812455:	ba 02 00 00 00       	mov    $0x2,%edx
  81245a:	be 00 00 00 00       	mov    $0x0,%esi
  81245f:	bf 02 00 00 00       	mov    $0x2,%edi
  812464:	48 b8 61 d4 80 00 00 	movabs $0x80d461,%rax
  81246b:	00 00 00 
  81246e:	ff d0                	callq  *%rax
  812470:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if (rambuf == NULL) {
  812474:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  812479:	75 0a                	jne    812485 <ip_frag+0x56>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  81247b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  812480:	e9 7f 02 00 00       	jmpq   812704 <ip_frag+0x2d5>
  }
  rambuf->tot_len = rambuf->len = mtu;
  812485:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812489:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  81248d:	66 89 50 12          	mov    %dx,0x12(%rax)
  812491:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812495:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  812499:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81249d:	66 89 50 10          	mov    %dx,0x10(%rax)
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
  8124a1:	48 b8 80 b0 b4 00 00 	movabs $0xb4b080,%rax
  8124a8:	00 00 00 
  8124ab:	48 83 c0 03          	add    $0x3,%rax
  8124af:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  8124b3:	48 89 c2             	mov    %rax,%rdx
  8124b6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8124ba:	48 89 50 08          	mov    %rdx,0x8(%rax)

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  8124be:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8124c2:	48 8b 40 08          	mov    0x8(%rax),%rax
  8124c6:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  SMEMCPY(iphdr, p->payload, IP_HLEN);
  8124ca:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8124ce:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8124d2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8124d6:	ba 14 00 00 00       	mov    $0x14,%edx
  8124db:	48 89 ce             	mov    %rcx,%rsi
  8124de:	48 89 c7             	mov    %rax,%rdi
  8124e1:	48 b8 12 23 80 00 00 	movabs $0x802312,%rax
  8124e8:	00 00 00 
  8124eb:	ff d0                	callq  *%rax
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  8124ed:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8124f1:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  8124f5:	0f b7 c0             	movzwl %ax,%eax
  8124f8:	89 c7                	mov    %eax,%edi
  8124fa:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  812501:	00 00 00 
  812504:	ff d0                	callq  *%rax
  812506:	66 89 45 f8          	mov    %ax,-0x8(%rbp)
  ofo = tmp & IP_OFFMASK;
  81250a:	0f b7 45 f8          	movzwl -0x8(%rbp),%eax
  81250e:	66 25 ff 1f          	and    $0x1fff,%ax
  812512:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
  omf = tmp & IP_MF;
  812516:	0f b7 45 f8          	movzwl -0x8(%rbp),%eax
  81251a:	66 25 00 20          	and    $0x2000,%ax
  81251e:	66 89 45 de          	mov    %ax,-0x22(%rbp)

  left = p->tot_len - IP_HLEN;
  812522:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812526:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81252a:	83 e8 14             	sub    $0x14,%eax
  81252d:	66 89 45 fe          	mov    %ax,-0x2(%rbp)

  nfb = (mtu - IP_HLEN) / 8;
  812531:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  812535:	83 e8 14             	sub    $0x14,%eax
  812538:	8d 50 07             	lea    0x7(%rax),%edx
  81253b:	85 c0                	test   %eax,%eax
  81253d:	0f 48 c2             	cmovs  %edx,%eax
  812540:	c1 f8 03             	sar    $0x3,%eax
  812543:	66 89 45 dc          	mov    %ax,-0x24(%rbp)

  while (left) {
  812547:	e9 95 01 00 00       	jmpq   8126e1 <ip_frag+0x2b2>
    last = (left <= mtu - IP_HLEN);
  81254c:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  812550:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  812554:	83 ea 14             	sub    $0x14,%edx
  812557:	39 d0                	cmp    %edx,%eax
  812559:	0f 9e c0             	setle  %al
  81255c:	0f b6 c0             	movzbl %al,%eax
  81255f:	66 89 45 da          	mov    %ax,-0x26(%rbp)

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
  812563:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
  812567:	66 25 ff 1f          	and    $0x1fff,%ax
  81256b:	66 0b 45 de          	or     -0x22(%rbp),%ax
  81256f:	66 89 45 f8          	mov    %ax,-0x8(%rbp)
    if (!last)
  812573:	66 83 7d da 00       	cmpw   $0x0,-0x26(%rbp)
  812578:	75 06                	jne    812580 <ip_frag+0x151>
      tmp = tmp | IP_MF;
  81257a:	66 81 4d f8 00 20    	orw    $0x2000,-0x8(%rbp)

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  812580:	66 83 7d da 00       	cmpw   $0x0,-0x26(%rbp)
  812585:	75 09                	jne    812590 <ip_frag+0x161>
  812587:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  81258b:	c1 e0 03             	shl    $0x3,%eax
  81258e:	eb 04                	jmp    812594 <ip_frag+0x165>
  812590:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  812594:	66 89 45 d8          	mov    %ax,-0x28(%rbp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  812598:	0f b7 4d fa          	movzwl -0x6(%rbp),%ecx
  81259c:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  8125a0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8125a4:	48 8d 70 14          	lea    0x14(%rax),%rsi
  8125a8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8125ac:	48 89 c7             	mov    %rax,%rdi
  8125af:	48 b8 4e e4 80 00 00 	movabs $0x80e44e,%rax
  8125b6:	00 00 00 
  8125b9:	ff d0                	callq  *%rax
  8125bb:	66 01 45 fa          	add    %ax,-0x6(%rbp)
    }
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
  8125bf:	0f b7 45 f8          	movzwl -0x8(%rbp),%eax
  8125c3:	89 c7                	mov    %eax,%edi
  8125c5:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  8125cc:	00 00 00 
  8125cf:	ff d0                	callq  *%rax
  8125d1:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8125d5:	66 89 42 06          	mov    %ax,0x6(%rdx)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  8125d9:	0f b7 45 d8          	movzwl -0x28(%rbp),%eax
  8125dd:	83 c0 14             	add    $0x14,%eax
  8125e0:	0f b7 c0             	movzwl %ax,%eax
  8125e3:	89 c7                	mov    %eax,%edi
  8125e5:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  8125ec:	00 00 00 
  8125ef:	ff d0                	callq  *%rax
  8125f1:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8125f5:	66 89 42 02          	mov    %ax,0x2(%rdx)
    IPH_CHKSUM_SET(iphdr, 0);
  8125f9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8125fd:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  812603:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812607:	be 14 00 00 00       	mov    $0x14,%esi
  81260c:	48 89 c7             	mov    %rax,%rdi
  81260f:	48 b8 01 2b 81 00 00 	movabs $0x812b01,%rax
  812616:	00 00 00 
  812619:	ff d0                	callq  *%rax
  81261b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81261f:	66 89 42 0a          	mov    %ax,0xa(%rdx)

#if IP_FRAG_USES_STATIC_BUF
    if (last)
  812623:	66 83 7d da 00       	cmpw   $0x0,-0x26(%rbp)
  812628:	74 1f                	je     812649 <ip_frag+0x21a>
      pbuf_realloc(rambuf, left + IP_HLEN);
  81262a:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  81262e:	83 c0 14             	add    $0x14,%eax
  812631:	0f b7 d0             	movzwl %ax,%edx
  812634:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812638:	89 d6                	mov    %edx,%esi
  81263a:	48 89 c7             	mov    %rax,%rdi
  81263d:	48 b8 36 d9 80 00 00 	movabs $0x80d936,%rax
  812644:	00 00 00 
  812647:	ff d0                	callq  *%rax
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
  812649:	ba 00 00 00 00       	mov    $0x0,%edx
  81264e:	be 00 00 00 00       	mov    $0x0,%esi
  812653:	bf 02 00 00 00       	mov    $0x2,%edi
  812658:	48 b8 61 d4 80 00 00 	movabs $0x80d461,%rax
  81265f:	00 00 00 
  812662:	ff d0                	callq  *%rax
  812664:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    if (header != NULL) {
  812668:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  81266d:	74 58                	je     8126c7 <ip_frag+0x298>
      pbuf_chain(header, rambuf);
  81266f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  812673:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812677:	48 89 d6             	mov    %rdx,%rsi
  81267a:	48 89 c7             	mov    %rax,%rdi
  81267d:	48 b8 6a e0 80 00 00 	movabs $0x80e06a,%rax
  812684:	00 00 00 
  812687:	ff d0                	callq  *%rax
      netif->output(netif, header, dest);
  812689:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81268d:	48 8b 40 20          	mov    0x20(%rax),%rax
  812691:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  812695:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  812699:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  81269d:	48 89 cf             	mov    %rcx,%rdi
  8126a0:	ff d0                	callq  *%rax
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
  8126a2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8126a6:	48 89 c7             	mov    %rax,%rdi
  8126a9:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  8126b0:	00 00 00 
  8126b3:	ff d0                	callq  *%rax
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
  8126b5:	0f b7 45 d8          	movzwl -0x28(%rbp),%eax
  8126b9:	66 29 45 fe          	sub    %ax,-0x2(%rbp)
    ofo += nfb;
  8126bd:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  8126c1:	66 01 45 fc          	add    %ax,-0x4(%rbp)
  8126c5:	eb 1a                	jmp    8126e1 <ip_frag+0x2b2>
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
  8126c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8126cb:	48 89 c7             	mov    %rax,%rdi
  8126ce:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  8126d5:	00 00 00 
  8126d8:	ff d0                	callq  *%rax
      return ERR_MEM;
  8126da:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8126df:	eb 23                	jmp    812704 <ip_frag+0x2d5>

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
  8126e1:	66 83 7d fe 00       	cmpw   $0x0,-0x2(%rbp)
  8126e6:	0f 85 60 fe ff ff    	jne    81254c <ip_frag+0x11d>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
  8126ec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8126f0:	48 89 c7             	mov    %rax,%rdi
  8126f3:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  8126fa:	00 00 00 
  8126fd:	ff d0                	callq  *%rax
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
  8126ff:	b8 00 00 00 00       	mov    $0x0,%eax
}
  812704:	c9                   	leaveq 
  812705:	c3                   	retq   

0000000000812706 <lwip_standard_chksum>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
  812706:	55                   	push   %rbp
  812707:	48 89 e5             	mov    %rsp,%rbp
  81270a:	48 83 ec 30          	sub    $0x30,%rsp
  81270e:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  812712:	89 f0                	mov    %esi,%eax
  812714:	66 89 45 d4          	mov    %ax,-0x2c(%rbp)
  u32_t acc;
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  812718:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  81271f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  812723:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  while (len > 1) {
  812727:	eb 35                	jmp    81275e <lwip_standard_chksum+0x58>
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
  812729:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81272d:	0f b6 00             	movzbl (%rax),%eax
  812730:	0f b6 c0             	movzbl %al,%eax
  812733:	c1 e0 08             	shl    $0x8,%eax
  812736:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
    octetptr++;
  81273a:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
    /* declare second octet as least significant */
    src |= (*octetptr);
  81273f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812743:	0f b6 00             	movzbl (%rax),%eax
  812746:	0f b6 c0             	movzbl %al,%eax
  812749:	66 09 45 ee          	or     %ax,-0x12(%rbp)
    octetptr++;
  81274d:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
    acc += src;
  812752:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  812756:	01 45 fc             	add    %eax,-0x4(%rbp)
    len -= 2;
  812759:	66 83 6d d4 02       	subw   $0x2,-0x2c(%rbp)
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  81275e:	66 83 7d d4 01       	cmpw   $0x1,-0x2c(%rbp)
  812763:	77 c4                	ja     812729 <lwip_standard_chksum+0x23>
    src |= (*octetptr);
    octetptr++;
    acc += src;
    len -= 2;
  }
  if (len > 0) {
  812765:	66 83 7d d4 00       	cmpw   $0x0,-0x2c(%rbp)
  81276a:	74 18                	je     812784 <lwip_standard_chksum+0x7e>
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
  81276c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812770:	0f b6 00             	movzbl (%rax),%eax
  812773:	0f b6 c0             	movzbl %al,%eax
  812776:	c1 e0 08             	shl    $0x8,%eax
  812779:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
    acc += src;
  81277d:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  812781:	01 45 fc             	add    %eax,-0x4(%rbp)
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
  812784:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812787:	c1 e8 10             	shr    $0x10,%eax
  81278a:	89 c2                	mov    %eax,%edx
  81278c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81278f:	0f b7 c0             	movzwl %ax,%eax
  812792:	01 d0                	add    %edx,%eax
  812794:	89 45 fc             	mov    %eax,-0x4(%rbp)
  if ((acc & 0xffff0000) != 0) {
  812797:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81279a:	66 b8 00 00          	mov    $0x0,%ax
  81279e:	85 c0                	test   %eax,%eax
  8127a0:	74 13                	je     8127b5 <lwip_standard_chksum+0xaf>
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
  8127a2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8127a5:	c1 e8 10             	shr    $0x10,%eax
  8127a8:	89 c2                	mov    %eax,%edx
  8127aa:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8127ad:	0f b7 c0             	movzwl %ax,%eax
  8127b0:	01 d0                	add    %edx,%eax
  8127b2:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
  8127b5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8127b8:	0f b7 c0             	movzwl %ax,%eax
  8127bb:	89 c7                	mov    %eax,%edi
  8127bd:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  8127c4:	00 00 00 
  8127c7:	ff d0                	callq  *%rax
}
  8127c9:	c9                   	leaveq 
  8127ca:	c3                   	retq   

00000000008127cb <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
  8127cb:	55                   	push   %rbp
  8127cc:	48 89 e5             	mov    %rsp,%rbp
  8127cf:	48 83 ec 40          	sub    $0x40,%rsp
  8127d3:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8127d7:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8127db:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8127df:	89 c8                	mov    %ecx,%eax
  8127e1:	44 89 c2             	mov    %r8d,%edx
  8127e4:	88 45 c4             	mov    %al,-0x3c(%rbp)
  8127e7:	66 89 55 c0          	mov    %dx,-0x40(%rbp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  8127eb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  swapped = 0;
  8127f2:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  8127f6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8127fa:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8127fe:	eb 7d                	jmp    81287d <inet_chksum_pseudo+0xb2>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
  812800:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812804:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  812808:	0f b7 d0             	movzwl %ax,%edx
  81280b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81280f:	48 8b 40 08          	mov    0x8(%rax),%rax
  812813:	89 d6                	mov    %edx,%esi
  812815:	48 89 c7             	mov    %rax,%rdi
  812818:	48 b8 06 27 81 00 00 	movabs $0x812706,%rax
  81281f:	00 00 00 
  812822:	ff d0                	callq  *%rax
  812824:	0f b7 c0             	movzwl %ax,%eax
  812827:	01 45 fc             	add    %eax,-0x4(%rbp)
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
  81282a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81282d:	c1 e8 10             	shr    $0x10,%eax
  812830:	89 c2                	mov    %eax,%edx
  812832:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812835:	0f b7 c0             	movzwl %ax,%eax
  812838:	01 d0                	add    %edx,%eax
  81283a:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (q->len % 2 != 0) {
  81283d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812841:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  812845:	83 e0 01             	and    $0x1,%eax
  812848:	66 85 c0             	test   %ax,%ax
  81284b:	74 25                	je     812872 <inet_chksum_pseudo+0xa7>
      swapped = 1 - swapped;
  81284d:	b8 01 00 00 00       	mov    $0x1,%eax
  812852:	2a 45 ef             	sub    -0x11(%rbp),%al
  812855:	88 45 ef             	mov    %al,-0x11(%rbp)
      acc = SWAP_BYTES_IN_WORD(acc);
  812858:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81285b:	c1 e0 08             	shl    $0x8,%eax
  81285e:	0f b7 c0             	movzwl %ax,%eax
  812861:	8b 55 fc             	mov    -0x4(%rbp),%edx
  812864:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  81286a:	c1 ea 08             	shr    $0x8,%edx
  81286d:	09 d0                	or     %edx,%eax
  81286f:	89 45 fc             	mov    %eax,-0x4(%rbp)
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  812872:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812876:	48 8b 00             	mov    (%rax),%rax
  812879:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  81287d:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  812882:	0f 85 78 ff ff ff    	jne    812800 <inet_chksum_pseudo+0x35>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  812888:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  81288c:	74 1a                	je     8128a8 <inet_chksum_pseudo+0xdd>
    acc = SWAP_BYTES_IN_WORD(acc);
  81288e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812891:	c1 e0 08             	shl    $0x8,%eax
  812894:	0f b7 c0             	movzwl %ax,%eax
  812897:	8b 55 fc             	mov    -0x4(%rbp),%edx
  81289a:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  8128a0:	c1 ea 08             	shr    $0x8,%edx
  8128a3:	09 d0                	or     %edx,%eax
  8128a5:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }
  acc += (src->addr & 0xffffUL);
  8128a8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8128ac:	8b 00                	mov    (%rax),%eax
  8128ae:	0f b7 c0             	movzwl %ax,%eax
  8128b1:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += ((src->addr >> 16) & 0xffffUL);
  8128b4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8128b8:	8b 00                	mov    (%rax),%eax
  8128ba:	c1 e8 10             	shr    $0x10,%eax
  8128bd:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (dest->addr & 0xffffUL);
  8128c0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8128c4:	8b 00                	mov    (%rax),%eax
  8128c6:	0f b7 c0             	movzwl %ax,%eax
  8128c9:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += ((dest->addr >> 16) & 0xffffUL);
  8128cc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8128d0:	8b 00                	mov    (%rax),%eax
  8128d2:	c1 e8 10             	shr    $0x10,%eax
  8128d5:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (u32_t)htons((u16_t)proto);
  8128d8:	0f b6 45 c4          	movzbl -0x3c(%rbp),%eax
  8128dc:	89 c7                	mov    %eax,%edi
  8128de:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  8128e5:	00 00 00 
  8128e8:	ff d0                	callq  *%rax
  8128ea:	0f b7 c0             	movzwl %ax,%eax
  8128ed:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (u32_t)htons(proto_len);
  8128f0:	0f b7 45 c0          	movzwl -0x40(%rbp),%eax
  8128f4:	89 c7                	mov    %eax,%edi
  8128f6:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  8128fd:	00 00 00 
  812900:	ff d0                	callq  *%rax
  812902:	0f b7 c0             	movzwl %ax,%eax
  812905:	01 45 fc             	add    %eax,-0x4(%rbp)

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  812908:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81290b:	c1 e8 10             	shr    $0x10,%eax
  81290e:	89 c2                	mov    %eax,%edx
  812910:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812913:	0f b7 c0             	movzwl %ax,%eax
  812916:	01 d0                	add    %edx,%eax
  812918:	89 45 fc             	mov    %eax,-0x4(%rbp)
  acc = FOLD_U32T(acc);
  81291b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81291e:	c1 e8 10             	shr    $0x10,%eax
  812921:	89 c2                	mov    %eax,%edx
  812923:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812926:	0f b7 c0             	movzwl %ax,%eax
  812929:	01 d0                	add    %edx,%eax
  81292b:	89 45 fc             	mov    %eax,-0x4(%rbp)
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  81292e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812931:	f7 d0                	not    %eax
}
  812933:	c9                   	leaveq 
  812934:	c3                   	retq   

0000000000812935 <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
  812935:	55                   	push   %rbp
  812936:	48 89 e5             	mov    %rsp,%rbp
  812939:	48 83 ec 50          	sub    $0x50,%rsp
  81293d:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  812941:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  812945:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  812949:	89 c8                	mov    %ecx,%eax
  81294b:	44 89 c1             	mov    %r8d,%ecx
  81294e:	44 89 ca             	mov    %r9d,%edx
  812951:	88 45 c4             	mov    %al,-0x3c(%rbp)
  812954:	66 89 4d c0          	mov    %cx,-0x40(%rbp)
  812958:	66 89 55 bc          	mov    %dx,-0x44(%rbp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  81295c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  swapped = 0;
  812963:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  812967:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81296b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  81296f:	e9 ce 00 00 00       	jmpq   812a42 <inet_chksum_pseudo_partial+0x10d>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    chklen = q->len;
  812974:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812978:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81297c:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
    if (chklen > chksum_len) {
  812980:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  812984:	66 3b 45 bc          	cmp    -0x44(%rbp),%ax
  812988:	76 08                	jbe    812992 <inet_chksum_pseudo_partial+0x5d>
      chklen = chksum_len;
  81298a:	0f b7 45 bc          	movzwl -0x44(%rbp),%eax
  81298e:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
  812992:	0f b7 55 ec          	movzwl -0x14(%rbp),%edx
  812996:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81299a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81299e:	89 d6                	mov    %edx,%esi
  8129a0:	48 89 c7             	mov    %rax,%rdi
  8129a3:	48 b8 06 27 81 00 00 	movabs $0x812706,%rax
  8129aa:	00 00 00 
  8129ad:	ff d0                	callq  *%rax
  8129af:	0f b7 c0             	movzwl %ax,%eax
  8129b2:	01 45 fc             	add    %eax,-0x4(%rbp)
    chksum_len -= chklen;
  8129b5:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  8129b9:	66 29 45 bc          	sub    %ax,-0x44(%rbp)
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  8129bd:	66 81 7d bc fe 7f    	cmpw   $0x7ffe,-0x44(%rbp)
  8129c3:	76 2a                	jbe    8129ef <inet_chksum_pseudo_partial+0xba>
  8129c5:	48 ba e8 27 82 00 00 	movabs $0x8227e8,%rdx
  8129cc:	00 00 00 
  8129cf:	be 61 01 00 00       	mov    $0x161,%esi
  8129d4:	48 bf f8 27 82 00 00 	movabs $0x8227f8,%rdi
  8129db:	00 00 00 
  8129de:	b8 00 00 00 00       	mov    $0x0,%eax
  8129e3:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  8129ea:	00 00 00 
  8129ed:	ff d1                	callq  *%rcx
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
  8129ef:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8129f2:	c1 e8 10             	shr    $0x10,%eax
  8129f5:	89 c2                	mov    %eax,%edx
  8129f7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8129fa:	0f b7 c0             	movzwl %ax,%eax
  8129fd:	01 d0                	add    %edx,%eax
  8129ff:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (q->len % 2 != 0) {
  812a02:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812a06:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  812a0a:	83 e0 01             	and    $0x1,%eax
  812a0d:	66 85 c0             	test   %ax,%ax
  812a10:	74 25                	je     812a37 <inet_chksum_pseudo_partial+0x102>
      swapped = 1 - swapped;
  812a12:	b8 01 00 00 00       	mov    $0x1,%eax
  812a17:	2a 45 ef             	sub    -0x11(%rbp),%al
  812a1a:	88 45 ef             	mov    %al,-0x11(%rbp)
      acc = SWAP_BYTES_IN_WORD(acc);
  812a1d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812a20:	c1 e0 08             	shl    $0x8,%eax
  812a23:	0f b7 c0             	movzwl %ax,%eax
  812a26:	8b 55 fc             	mov    -0x4(%rbp),%edx
  812a29:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  812a2f:	c1 ea 08             	shr    $0x8,%edx
  812a32:	09 d0                	or     %edx,%eax
  812a34:	89 45 fc             	mov    %eax,-0x4(%rbp)
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  812a37:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812a3b:	48 8b 00             	mov    (%rax),%rax
  812a3e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  812a42:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  812a47:	74 0b                	je     812a54 <inet_chksum_pseudo_partial+0x11f>
  812a49:	66 83 7d bc 00       	cmpw   $0x0,-0x44(%rbp)
  812a4e:	0f 85 20 ff ff ff    	jne    812974 <inet_chksum_pseudo_partial+0x3f>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  812a54:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  812a58:	74 1a                	je     812a74 <inet_chksum_pseudo_partial+0x13f>
    acc = SWAP_BYTES_IN_WORD(acc);
  812a5a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812a5d:	c1 e0 08             	shl    $0x8,%eax
  812a60:	0f b7 c0             	movzwl %ax,%eax
  812a63:	8b 55 fc             	mov    -0x4(%rbp),%edx
  812a66:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  812a6c:	c1 ea 08             	shr    $0x8,%edx
  812a6f:	09 d0                	or     %edx,%eax
  812a71:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }
  acc += (src->addr & 0xffffUL);
  812a74:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812a78:	8b 00                	mov    (%rax),%eax
  812a7a:	0f b7 c0             	movzwl %ax,%eax
  812a7d:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += ((src->addr >> 16) & 0xffffUL);
  812a80:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812a84:	8b 00                	mov    (%rax),%eax
  812a86:	c1 e8 10             	shr    $0x10,%eax
  812a89:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (dest->addr & 0xffffUL);
  812a8c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812a90:	8b 00                	mov    (%rax),%eax
  812a92:	0f b7 c0             	movzwl %ax,%eax
  812a95:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += ((dest->addr >> 16) & 0xffffUL);
  812a98:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812a9c:	8b 00                	mov    (%rax),%eax
  812a9e:	c1 e8 10             	shr    $0x10,%eax
  812aa1:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (u32_t)htons((u16_t)proto);
  812aa4:	0f b6 45 c4          	movzbl -0x3c(%rbp),%eax
  812aa8:	89 c7                	mov    %eax,%edi
  812aaa:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  812ab1:	00 00 00 
  812ab4:	ff d0                	callq  *%rax
  812ab6:	0f b7 c0             	movzwl %ax,%eax
  812ab9:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (u32_t)htons(proto_len);
  812abc:	0f b7 45 c0          	movzwl -0x40(%rbp),%eax
  812ac0:	89 c7                	mov    %eax,%edi
  812ac2:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  812ac9:	00 00 00 
  812acc:	ff d0                	callq  *%rax
  812ace:	0f b7 c0             	movzwl %ax,%eax
  812ad1:	01 45 fc             	add    %eax,-0x4(%rbp)

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  812ad4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812ad7:	c1 e8 10             	shr    $0x10,%eax
  812ada:	89 c2                	mov    %eax,%edx
  812adc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812adf:	0f b7 c0             	movzwl %ax,%eax
  812ae2:	01 d0                	add    %edx,%eax
  812ae4:	89 45 fc             	mov    %eax,-0x4(%rbp)
  acc = FOLD_U32T(acc);
  812ae7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812aea:	c1 e8 10             	shr    $0x10,%eax
  812aed:	89 c2                	mov    %eax,%edx
  812aef:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812af2:	0f b7 c0             	movzwl %ax,%eax
  812af5:	01 d0                	add    %edx,%eax
  812af7:	89 45 fc             	mov    %eax,-0x4(%rbp)
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  812afa:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812afd:	f7 d0                	not    %eax
}
  812aff:	c9                   	leaveq 
  812b00:	c3                   	retq   

0000000000812b01 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
  812b01:	55                   	push   %rbp
  812b02:	48 89 e5             	mov    %rsp,%rbp
  812b05:	48 83 ec 10          	sub    $0x10,%rsp
  812b09:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  812b0d:	89 f0                	mov    %esi,%eax
  812b0f:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  return ~LWIP_CHKSUM(dataptr, len);
  812b13:	0f b7 55 f4          	movzwl -0xc(%rbp),%edx
  812b17:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812b1b:	89 d6                	mov    %edx,%esi
  812b1d:	48 89 c7             	mov    %rax,%rdi
  812b20:	48 b8 06 27 81 00 00 	movabs $0x812706,%rax
  812b27:	00 00 00 
  812b2a:	ff d0                	callq  *%rax
  812b2c:	f7 d0                	not    %eax
}
  812b2e:	c9                   	leaveq 
  812b2f:	c3                   	retq   

0000000000812b30 <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
  812b30:	55                   	push   %rbp
  812b31:	48 89 e5             	mov    %rsp,%rbp
  812b34:	48 83 ec 30          	sub    $0x30,%rsp
  812b38:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  812b3c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  swapped = 0;
  812b43:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  for(q = p; q != NULL; q = q->next) {
  812b47:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  812b4b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  812b4f:	eb 7d                	jmp    812bce <inet_chksum_pbuf+0x9e>
    acc += LWIP_CHKSUM(q->payload, q->len);
  812b51:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812b55:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  812b59:	0f b7 d0             	movzwl %ax,%edx
  812b5c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812b60:	48 8b 40 08          	mov    0x8(%rax),%rax
  812b64:	89 d6                	mov    %edx,%esi
  812b66:	48 89 c7             	mov    %rax,%rdi
  812b69:	48 b8 06 27 81 00 00 	movabs $0x812706,%rax
  812b70:	00 00 00 
  812b73:	ff d0                	callq  *%rax
  812b75:	0f b7 c0             	movzwl %ax,%eax
  812b78:	01 45 fc             	add    %eax,-0x4(%rbp)
    acc = FOLD_U32T(acc);
  812b7b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812b7e:	c1 e8 10             	shr    $0x10,%eax
  812b81:	89 c2                	mov    %eax,%edx
  812b83:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812b86:	0f b7 c0             	movzwl %ax,%eax
  812b89:	01 d0                	add    %edx,%eax
  812b8b:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (q->len % 2 != 0) {
  812b8e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812b92:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  812b96:	83 e0 01             	and    $0x1,%eax
  812b99:	66 85 c0             	test   %ax,%ax
  812b9c:	74 25                	je     812bc3 <inet_chksum_pbuf+0x93>
      swapped = 1 - swapped;
  812b9e:	b8 01 00 00 00       	mov    $0x1,%eax
  812ba3:	2a 45 ef             	sub    -0x11(%rbp),%al
  812ba6:	88 45 ef             	mov    %al,-0x11(%rbp)
      acc = SWAP_BYTES_IN_WORD(acc);
  812ba9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812bac:	c1 e0 08             	shl    $0x8,%eax
  812baf:	0f b7 c0             	movzwl %ax,%eax
  812bb2:	8b 55 fc             	mov    -0x4(%rbp),%edx
  812bb5:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  812bbb:	c1 ea 08             	shr    $0x8,%edx
  812bbe:	09 d0                	or     %edx,%eax
  812bc0:	89 45 fc             	mov    %eax,-0x4(%rbp)
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  812bc3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812bc7:	48 8b 00             	mov    (%rax),%rax
  812bca:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  812bce:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  812bd3:	0f 85 78 ff ff ff    	jne    812b51 <inet_chksum_pbuf+0x21>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
  812bd9:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  812bdd:	74 1a                	je     812bf9 <inet_chksum_pbuf+0xc9>
    acc = SWAP_BYTES_IN_WORD(acc);
  812bdf:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812be2:	c1 e0 08             	shl    $0x8,%eax
  812be5:	0f b7 c0             	movzwl %ax,%eax
  812be8:	8b 55 fc             	mov    -0x4(%rbp),%edx
  812beb:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  812bf1:	c1 ea 08             	shr    $0x8,%edx
  812bf4:	09 d0                	or     %edx,%eax
  812bf6:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }
  return (u16_t)~(acc & 0xffffUL);
  812bf9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812bfc:	f7 d0                	not    %eax
}
  812bfe:	c9                   	leaveq 
  812bff:	c3                   	retq   

0000000000812c00 <inet_addr>:
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
u32_t
inet_addr(const char *cp)
{
  812c00:	55                   	push   %rbp
  812c01:	48 89 e5             	mov    %rsp,%rbp
  812c04:	48 83 ec 20          	sub    $0x20,%rsp
  812c08:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct in_addr val;

  if (inet_aton(cp, &val)) {
  812c0c:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  812c10:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812c14:	48 89 d6             	mov    %rdx,%rsi
  812c17:	48 89 c7             	mov    %rax,%rdi
  812c1a:	48 b8 36 2c 81 00 00 	movabs $0x812c36,%rax
  812c21:	00 00 00 
  812c24:	ff d0                	callq  *%rax
  812c26:	85 c0                	test   %eax,%eax
  812c28:	74 05                	je     812c2f <inet_addr+0x2f>
    return (val.s_addr);
  812c2a:	8b 45 f0             	mov    -0x10(%rbp),%eax
  812c2d:	eb 05                	jmp    812c34 <inet_addr+0x34>
  }
  return (INADDR_NONE);
  812c2f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  812c34:	c9                   	leaveq 
  812c35:	c3                   	retq   

0000000000812c36 <inet_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
inet_aton(const char *cp, struct in_addr *addr)
{
  812c36:	55                   	push   %rbp
  812c37:	48 89 e5             	mov    %rsp,%rbp
  812c3a:	48 83 ec 40          	sub    $0x40,%rsp
  812c3e:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  812c42:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  u32_t val;
  int base, n, c;
  u32_t parts[4];
  u32_t *pp = parts;
  812c46:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  812c4a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

  c = *cp;
  812c4e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812c52:	0f b6 00             	movzbl (%rax),%eax
  812c55:	0f be c0             	movsbl %al,%eax
  812c58:	89 45 f4             	mov    %eax,-0xc(%rbp)
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
  812c5b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812c5e:	3c 2f                	cmp    $0x2f,%al
  812c60:	76 07                	jbe    812c69 <inet_aton+0x33>
  812c62:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812c65:	3c 39                	cmp    $0x39,%al
  812c67:	76 0a                	jbe    812c73 <inet_aton+0x3d>
      return (0);
  812c69:	b8 00 00 00 00       	mov    $0x0,%eax
  812c6e:	e9 68 02 00 00       	jmpq   812edb <inet_aton+0x2a5>
    val = 0;
  812c73:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    base = 10;
  812c7a:	c7 45 f8 0a 00 00 00 	movl   $0xa,-0x8(%rbp)
    if (c == '0') {
  812c81:	83 7d f4 30          	cmpl   $0x30,-0xc(%rbp)
  812c85:	75 40                	jne    812cc7 <inet_aton+0x91>
      c = *++cp;
  812c87:	48 83 45 c8 01       	addq   $0x1,-0x38(%rbp)
  812c8c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812c90:	0f b6 00             	movzbl (%rax),%eax
  812c93:	0f be c0             	movsbl %al,%eax
  812c96:	89 45 f4             	mov    %eax,-0xc(%rbp)
      if (c == 'x' || c == 'X') {
  812c99:	83 7d f4 78          	cmpl   $0x78,-0xc(%rbp)
  812c9d:	74 06                	je     812ca5 <inet_aton+0x6f>
  812c9f:	83 7d f4 58          	cmpl   $0x58,-0xc(%rbp)
  812ca3:	75 1b                	jne    812cc0 <inet_aton+0x8a>
        base = 16;
  812ca5:	c7 45 f8 10 00 00 00 	movl   $0x10,-0x8(%rbp)
        c = *++cp;
  812cac:	48 83 45 c8 01       	addq   $0x1,-0x38(%rbp)
  812cb1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812cb5:	0f b6 00             	movzbl (%rax),%eax
  812cb8:	0f be c0             	movsbl %al,%eax
  812cbb:	89 45 f4             	mov    %eax,-0xc(%rbp)
  812cbe:	eb 07                	jmp    812cc7 <inet_aton+0x91>
      } else
        base = 8;
  812cc0:	c7 45 f8 08 00 00 00 	movl   $0x8,-0x8(%rbp)
    }
    for (;;) {
      if (isdigit(c)) {
  812cc7:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812cca:	3c 2f                	cmp    $0x2f,%al
  812ccc:	76 2f                	jbe    812cfd <inet_aton+0xc7>
  812cce:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812cd1:	3c 39                	cmp    $0x39,%al
  812cd3:	77 28                	ja     812cfd <inet_aton+0xc7>
        val = (val * base) + (int)(c - '0');
  812cd5:	8b 45 f8             	mov    -0x8(%rbp),%eax
  812cd8:	0f af 45 fc          	imul   -0x4(%rbp),%eax
  812cdc:	89 c2                	mov    %eax,%edx
  812cde:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812ce1:	01 d0                	add    %edx,%eax
  812ce3:	83 e8 30             	sub    $0x30,%eax
  812ce6:	89 45 fc             	mov    %eax,-0x4(%rbp)
        c = *++cp;
  812ce9:	48 83 45 c8 01       	addq   $0x1,-0x38(%rbp)
  812cee:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812cf2:	0f b6 00             	movzbl (%rax),%eax
  812cf5:	0f be c0             	movsbl %al,%eax
  812cf8:	89 45 f4             	mov    %eax,-0xc(%rbp)
      } else if (base == 16 && isxdigit(c)) {
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
        c = *++cp;
      } else
        break;
    }
  812cfb:	eb ca                	jmp    812cc7 <inet_aton+0x91>
    }
    for (;;) {
      if (isdigit(c)) {
        val = (val * base) + (int)(c - '0');
        c = *++cp;
      } else if (base == 16 && isxdigit(c)) {
  812cfd:	83 7d f8 10          	cmpl   $0x10,-0x8(%rbp)
  812d01:	75 72                	jne    812d75 <inet_aton+0x13f>
  812d03:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812d06:	3c 2f                	cmp    $0x2f,%al
  812d08:	76 07                	jbe    812d11 <inet_aton+0xdb>
  812d0a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812d0d:	3c 39                	cmp    $0x39,%al
  812d0f:	76 1c                	jbe    812d2d <inet_aton+0xf7>
  812d11:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812d14:	3c 60                	cmp    $0x60,%al
  812d16:	76 07                	jbe    812d1f <inet_aton+0xe9>
  812d18:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812d1b:	3c 66                	cmp    $0x66,%al
  812d1d:	76 0e                	jbe    812d2d <inet_aton+0xf7>
  812d1f:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812d22:	3c 40                	cmp    $0x40,%al
  812d24:	76 4f                	jbe    812d75 <inet_aton+0x13f>
  812d26:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812d29:	3c 46                	cmp    $0x46,%al
  812d2b:	77 48                	ja     812d75 <inet_aton+0x13f>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
  812d2d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812d30:	c1 e0 04             	shl    $0x4,%eax
  812d33:	89 c2                	mov    %eax,%edx
  812d35:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812d38:	8d 48 0a             	lea    0xa(%rax),%ecx
  812d3b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812d3e:	3c 60                	cmp    $0x60,%al
  812d40:	76 0e                	jbe    812d50 <inet_aton+0x11a>
  812d42:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812d45:	3c 7a                	cmp    $0x7a,%al
  812d47:	77 07                	ja     812d50 <inet_aton+0x11a>
  812d49:	b8 61 00 00 00       	mov    $0x61,%eax
  812d4e:	eb 05                	jmp    812d55 <inet_aton+0x11f>
  812d50:	b8 41 00 00 00       	mov    $0x41,%eax
  812d55:	29 c1                	sub    %eax,%ecx
  812d57:	89 c8                	mov    %ecx,%eax
  812d59:	09 d0                	or     %edx,%eax
  812d5b:	89 45 fc             	mov    %eax,-0x4(%rbp)
        c = *++cp;
  812d5e:	48 83 45 c8 01       	addq   $0x1,-0x38(%rbp)
  812d63:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812d67:	0f b6 00             	movzbl (%rax),%eax
  812d6a:	0f be c0             	movsbl %al,%eax
  812d6d:	89 45 f4             	mov    %eax,-0xc(%rbp)
      } else
        break;
    }
  812d70:	e9 52 ff ff ff       	jmpq   812cc7 <inet_aton+0x91>
    if (c == '.') {
  812d75:	83 7d f4 2e          	cmpl   $0x2e,-0xc(%rbp)
  812d79:	75 40                	jne    812dbb <inet_aton+0x185>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
  812d7b:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  812d7f:	48 83 c0 0c          	add    $0xc,%rax
  812d83:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  812d87:	72 0a                	jb     812d93 <inet_aton+0x15d>
        return (0);
  812d89:	b8 00 00 00 00       	mov    $0x0,%eax
  812d8e:	e9 48 01 00 00       	jmpq   812edb <inet_aton+0x2a5>
      *pp++ = val;
  812d93:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812d97:	48 8d 50 04          	lea    0x4(%rax),%rdx
  812d9b:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  812d9f:	8b 55 fc             	mov    -0x4(%rbp),%edx
  812da2:	89 10                	mov    %edx,(%rax)
      c = *++cp;
  812da4:	48 83 45 c8 01       	addq   $0x1,-0x38(%rbp)
  812da9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812dad:	0f b6 00             	movzbl (%rax),%eax
  812db0:	0f be c0             	movsbl %al,%eax
  812db3:	89 45 f4             	mov    %eax,-0xc(%rbp)
    } else
      break;
  }
  812db6:	e9 a0 fe ff ff       	jmpq   812c5b <inet_aton+0x25>
      if (pp >= parts + 3)
        return (0);
      *pp++ = val;
      c = *++cp;
    } else
      break;
  812dbb:	90                   	nop
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  812dbc:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  812dc0:	74 3c                	je     812dfe <inet_aton+0x1c8>
  812dc2:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812dc5:	3c 1f                	cmp    $0x1f,%al
  812dc7:	76 2b                	jbe    812df4 <inet_aton+0x1be>
  812dc9:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812dcc:	84 c0                	test   %al,%al
  812dce:	78 24                	js     812df4 <inet_aton+0x1be>
  812dd0:	83 7d f4 20          	cmpl   $0x20,-0xc(%rbp)
  812dd4:	74 28                	je     812dfe <inet_aton+0x1c8>
  812dd6:	83 7d f4 0c          	cmpl   $0xc,-0xc(%rbp)
  812dda:	74 22                	je     812dfe <inet_aton+0x1c8>
  812ddc:	83 7d f4 0a          	cmpl   $0xa,-0xc(%rbp)
  812de0:	74 1c                	je     812dfe <inet_aton+0x1c8>
  812de2:	83 7d f4 0d          	cmpl   $0xd,-0xc(%rbp)
  812de6:	74 16                	je     812dfe <inet_aton+0x1c8>
  812de8:	83 7d f4 09          	cmpl   $0x9,-0xc(%rbp)
  812dec:	74 10                	je     812dfe <inet_aton+0x1c8>
  812dee:	83 7d f4 0b          	cmpl   $0xb,-0xc(%rbp)
  812df2:	74 0a                	je     812dfe <inet_aton+0x1c8>
    return (0);
  812df4:	b8 00 00 00 00       	mov    $0x0,%eax
  812df9:	e9 dd 00 00 00       	jmpq   812edb <inet_aton+0x2a5>
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  n = pp - parts + 1;
  812dfe:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  812e02:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  812e06:	48 29 c2             	sub    %rax,%rdx
  812e09:	48 89 d0             	mov    %rdx,%rax
  812e0c:	48 c1 f8 02          	sar    $0x2,%rax
  812e10:	83 c0 01             	add    $0x1,%eax
  812e13:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  switch (n) {
  812e16:	83 7d e4 04          	cmpl   $0x4,-0x1c(%rbp)
  812e1a:	0f 87 98 00 00 00    	ja     812eb8 <inet_aton+0x282>
  812e20:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  812e23:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  812e2a:	00 
  812e2b:	48 b8 20 28 82 00 00 	movabs $0x822820,%rax
  812e32:	00 00 00 
  812e35:	48 01 d0             	add    %rdx,%rax
  812e38:	48 8b 00             	mov    (%rax),%rax
  812e3b:	ff e0                	jmpq   *%rax

  case 0:
    return (0);       /* initial nondigit */
  812e3d:	b8 00 00 00 00       	mov    $0x0,%eax
  812e42:	e9 94 00 00 00       	jmpq   812edb <inet_aton+0x2a5>

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
  812e47:	81 7d fc ff ff ff 00 	cmpl   $0xffffff,-0x4(%rbp)
  812e4e:	76 0a                	jbe    812e5a <inet_aton+0x224>
      return (0);
  812e50:	b8 00 00 00 00       	mov    $0x0,%eax
  812e55:	e9 81 00 00 00       	jmpq   812edb <inet_aton+0x2a5>
    val |= parts[0] << 24;
  812e5a:	8b 45 d0             	mov    -0x30(%rbp),%eax
  812e5d:	c1 e0 18             	shl    $0x18,%eax
  812e60:	09 45 fc             	or     %eax,-0x4(%rbp)
    break;
  812e63:	eb 53                	jmp    812eb8 <inet_aton+0x282>

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
  812e65:	81 7d fc ff ff 00 00 	cmpl   $0xffff,-0x4(%rbp)
  812e6c:	76 07                	jbe    812e75 <inet_aton+0x23f>
      return (0);
  812e6e:	b8 00 00 00 00       	mov    $0x0,%eax
  812e73:	eb 66                	jmp    812edb <inet_aton+0x2a5>
    val |= (parts[0] << 24) | (parts[1] << 16);
  812e75:	8b 45 d0             	mov    -0x30(%rbp),%eax
  812e78:	c1 e0 18             	shl    $0x18,%eax
  812e7b:	89 c2                	mov    %eax,%edx
  812e7d:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  812e80:	c1 e0 10             	shl    $0x10,%eax
  812e83:	09 d0                	or     %edx,%eax
  812e85:	09 45 fc             	or     %eax,-0x4(%rbp)
    break;
  812e88:	eb 2e                	jmp    812eb8 <inet_aton+0x282>

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
  812e8a:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%rbp)
  812e91:	76 07                	jbe    812e9a <inet_aton+0x264>
      return (0);
  812e93:	b8 00 00 00 00       	mov    $0x0,%eax
  812e98:	eb 41                	jmp    812edb <inet_aton+0x2a5>
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
  812e9a:	8b 45 d0             	mov    -0x30(%rbp),%eax
  812e9d:	c1 e0 18             	shl    $0x18,%eax
  812ea0:	89 c2                	mov    %eax,%edx
  812ea2:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  812ea5:	c1 e0 10             	shl    $0x10,%eax
  812ea8:	09 c2                	or     %eax,%edx
  812eaa:	8b 45 d8             	mov    -0x28(%rbp),%eax
  812ead:	c1 e0 08             	shl    $0x8,%eax
  812eb0:	09 d0                	or     %edx,%eax
  812eb2:	09 45 fc             	or     %eax,-0x4(%rbp)
    break;
  812eb5:	eb 01                	jmp    812eb8 <inet_aton+0x282>

  case 0:
    return (0);       /* initial nondigit */

  case 1:             /* a -- 32 bits */
    break;
  812eb7:	90                   	nop
    if (val > 0xff)
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
    break;
  }
  if (addr)
  812eb8:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  812ebd:	74 17                	je     812ed6 <inet_aton+0x2a0>
    addr->s_addr = htonl(val);
  812ebf:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812ec2:	89 c7                	mov    %eax,%edi
  812ec4:	48 b8 54 30 81 00 00 	movabs $0x813054,%rax
  812ecb:	00 00 00 
  812ece:	ff d0                	callq  *%rax
  812ed0:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  812ed4:	89 02                	mov    %eax,(%rdx)
  return (1);
  812ed6:	b8 01 00 00 00       	mov    $0x1,%eax
}
  812edb:	c9                   	leaveq 
  812edc:	c3                   	retq   

0000000000812edd <inet_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
  812edd:	55                   	push   %rbp
  812ede:	48 89 e5             	mov    %rsp,%rbp
  812ee1:	48 83 ec 30          	sub    $0x30,%rsp
  812ee5:	89 7d d0             	mov    %edi,-0x30(%rbp)
  static char str[16];
  u32_t s_addr = addr.s_addr;
  812ee8:	8b 45 d0             	mov    -0x30(%rbp),%eax
  812eeb:	89 45 e8             	mov    %eax,-0x18(%rbp)
  u8_t *ap;
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  812eee:	48 b8 60 b6 b4 00 00 	movabs $0xb4b660,%rax
  812ef5:	00 00 00 
  812ef8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  ap = (u8_t *)&s_addr;
  812efc:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  812f00:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  for(n = 0; n < 4; n++) {
  812f04:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  812f08:	e9 e0 00 00 00       	jmpq   812fed <inet_ntoa+0x110>
    i = 0;
  812f0d:	c6 45 ee 00          	movb   $0x0,-0x12(%rbp)
    do {
      rem = *ap % (u8_t)10;
  812f11:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812f15:	0f b6 08             	movzbl (%rax),%ecx
  812f18:	0f b6 d1             	movzbl %cl,%edx
  812f1b:	89 d0                	mov    %edx,%eax
  812f1d:	c1 e0 02             	shl    $0x2,%eax
  812f20:	01 d0                	add    %edx,%eax
  812f22:	c1 e0 03             	shl    $0x3,%eax
  812f25:	01 d0                	add    %edx,%eax
  812f27:	8d 14 85 00 00 00 00 	lea    0x0(,%rax,4),%edx
  812f2e:	01 d0                	add    %edx,%eax
  812f30:	66 c1 e8 08          	shr    $0x8,%ax
  812f34:	c0 e8 03             	shr    $0x3,%al
  812f37:	88 45 ed             	mov    %al,-0x13(%rbp)
  812f3a:	0f b6 55 ed          	movzbl -0x13(%rbp),%edx
  812f3e:	89 d0                	mov    %edx,%eax
  812f40:	c1 e0 02             	shl    $0x2,%eax
  812f43:	01 d0                	add    %edx,%eax
  812f45:	01 c0                	add    %eax,%eax
  812f47:	29 c1                	sub    %eax,%ecx
  812f49:	89 c8                	mov    %ecx,%eax
  812f4b:	88 45 ed             	mov    %al,-0x13(%rbp)
      *ap /= (u8_t)10;
  812f4e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812f52:	0f b6 00             	movzbl (%rax),%eax
  812f55:	0f b6 d0             	movzbl %al,%edx
  812f58:	89 d0                	mov    %edx,%eax
  812f5a:	c1 e0 02             	shl    $0x2,%eax
  812f5d:	01 d0                	add    %edx,%eax
  812f5f:	c1 e0 03             	shl    $0x3,%eax
  812f62:	01 d0                	add    %edx,%eax
  812f64:	8d 14 85 00 00 00 00 	lea    0x0(,%rax,4),%edx
  812f6b:	01 d0                	add    %edx,%eax
  812f6d:	66 c1 e8 08          	shr    $0x8,%ax
  812f71:	89 c2                	mov    %eax,%edx
  812f73:	c0 ea 03             	shr    $0x3,%dl
  812f76:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812f7a:	88 10                	mov    %dl,(%rax)
      inv[i++] = '0' + rem;
  812f7c:	0f b6 45 ee          	movzbl -0x12(%rbp),%eax
  812f80:	8d 50 01             	lea    0x1(%rax),%edx
  812f83:	88 55 ee             	mov    %dl,-0x12(%rbp)
  812f86:	0f b6 c0             	movzbl %al,%eax
  812f89:	0f b6 55 ed          	movzbl -0x13(%rbp),%edx
  812f8d:	83 c2 30             	add    $0x30,%edx
  812f90:	48 98                	cltq   
  812f92:	88 54 05 e0          	mov    %dl,-0x20(%rbp,%rax,1)
    } while(*ap);
  812f96:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812f9a:	0f b6 00             	movzbl (%rax),%eax
  812f9d:	84 c0                	test   %al,%al
  812f9f:	0f 85 6c ff ff ff    	jne    812f11 <inet_ntoa+0x34>
    while(i--)
  812fa5:	eb 1a                	jmp    812fc1 <inet_ntoa+0xe4>
      *rp++ = inv[i];
  812fa7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812fab:	48 8d 50 01          	lea    0x1(%rax),%rdx
  812faf:	48 89 55 f8          	mov    %rdx,-0x8(%rbp)
  812fb3:	0f b6 55 ee          	movzbl -0x12(%rbp),%edx
  812fb7:	48 63 d2             	movslq %edx,%rdx
  812fba:	0f b6 54 15 e0       	movzbl -0x20(%rbp,%rdx,1),%edx
  812fbf:	88 10                	mov    %dl,(%rax)
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
  812fc1:	0f b6 45 ee          	movzbl -0x12(%rbp),%eax
  812fc5:	8d 50 ff             	lea    -0x1(%rax),%edx
  812fc8:	88 55 ee             	mov    %dl,-0x12(%rbp)
  812fcb:	84 c0                	test   %al,%al
  812fcd:	75 d8                	jne    812fa7 <inet_ntoa+0xca>
      *rp++ = inv[i];
    *rp++ = '.';
  812fcf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812fd3:	48 8d 50 01          	lea    0x1(%rax),%rdx
  812fd7:	48 89 55 f8          	mov    %rdx,-0x8(%rbp)
  812fdb:	c6 00 2e             	movb   $0x2e,(%rax)
    ap++;
  812fde:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
  812fe3:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  812fe7:	83 c0 01             	add    $0x1,%eax
  812fea:	88 45 ef             	mov    %al,-0x11(%rbp)
  812fed:	80 7d ef 03          	cmpb   $0x3,-0x11(%rbp)
  812ff1:	0f 86 16 ff ff ff    	jbe    812f0d <inet_ntoa+0x30>
    while(i--)
      *rp++ = inv[i];
    *rp++ = '.';
    ap++;
  }
  *--rp = 0;
  812ff7:	48 83 6d f8 01       	subq   $0x1,-0x8(%rbp)
  812ffc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  813000:	c6 00 00             	movb   $0x0,(%rax)
  return str;
  813003:	48 b8 60 b6 b4 00 00 	movabs $0xb4b660,%rax
  81300a:	00 00 00 
}
  81300d:	c9                   	leaveq 
  81300e:	c3                   	retq   

000000000081300f <htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
  81300f:	55                   	push   %rbp
  813010:	48 89 e5             	mov    %rsp,%rbp
  813013:	48 83 ec 04          	sub    $0x4,%rsp
  813017:	89 f8                	mov    %edi,%eax
  813019:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  81301d:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
  813021:	c1 e0 08             	shl    $0x8,%eax
  813024:	89 c2                	mov    %eax,%edx
  813026:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
  81302a:	66 c1 e8 08          	shr    $0x8,%ax
  81302e:	09 d0                	or     %edx,%eax
}
  813030:	c9                   	leaveq 
  813031:	c3                   	retq   

0000000000813032 <ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
ntohs(u16_t n)
{
  813032:	55                   	push   %rbp
  813033:	48 89 e5             	mov    %rsp,%rbp
  813036:	48 83 ec 08          	sub    $0x8,%rsp
  81303a:	89 f8                	mov    %edi,%eax
  81303c:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
  return htons(n);
  813040:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
  813044:	89 c7                	mov    %eax,%edi
  813046:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  81304d:	00 00 00 
  813050:	ff d0                	callq  *%rax
}
  813052:	c9                   	leaveq 
  813053:	c3                   	retq   

0000000000813054 <htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  813054:	55                   	push   %rbp
  813055:	48 89 e5             	mov    %rsp,%rbp
  813058:	48 83 ec 04          	sub    $0x4,%rsp
  81305c:	89 7d fc             	mov    %edi,-0x4(%rbp)
  return ((n & 0xff) << 24) |
  81305f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  813062:	c1 e0 18             	shl    $0x18,%eax
  813065:	89 c2                	mov    %eax,%edx
    ((n & 0xff00) << 8) |
  813067:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81306a:	25 00 ff 00 00       	and    $0xff00,%eax
  81306f:	c1 e0 08             	shl    $0x8,%eax
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
  813072:	09 c2                	or     %eax,%edx
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
  813074:	8b 45 fc             	mov    -0x4(%rbp),%eax
  813077:	25 00 00 ff 00       	and    $0xff0000,%eax
  81307c:	48 c1 e8 08          	shr    $0x8,%rax
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
  813080:	09 c2                	or     %eax,%edx
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
  813082:	8b 45 fc             	mov    -0x4(%rbp),%eax
  813085:	c1 e8 18             	shr    $0x18,%eax
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
  813088:	09 d0                	or     %edx,%eax
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
}
  81308a:	c9                   	leaveq 
  81308b:	c3                   	retq   

000000000081308c <ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
ntohl(u32_t n)
{
  81308c:	55                   	push   %rbp
  81308d:	48 89 e5             	mov    %rsp,%rbp
  813090:	48 83 ec 08          	sub    $0x8,%rsp
  813094:	89 7d fc             	mov    %edi,-0x4(%rbp)
  return htonl(n);
  813097:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81309a:	89 c7                	mov    %eax,%edi
  81309c:	48 b8 54 30 81 00 00 	movabs $0x813054,%rax
  8130a3:	00 00 00 
  8130a6:	ff d0                	callq  *%rax
}
  8130a8:	c9                   	leaveq 
  8130a9:	c3                   	retq   

00000000008130aa <tcp_send_ctrl>:
 * @param flags the flags to set in the segment header
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_ctrl(struct tcp_pcb *pcb, u8_t flags)
{
  8130aa:	55                   	push   %rbp
  8130ab:	48 89 e5             	mov    %rsp,%rbp
  8130ae:	48 83 ec 20          	sub    $0x20,%rsp
  8130b2:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8130b6:	89 f0                	mov    %esi,%eax
  8130b8:	88 45 f4             	mov    %al,-0xc(%rbp)
  /* no data, no length, flags, copy=1, no optdata, no optdatalen */
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, NULL, 0);
  8130bb:	0f b6 55 f4          	movzbl -0xc(%rbp),%edx
  8130bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8130c3:	c7 04 24 00 00 00 00 	movl   $0x0,(%rsp)
  8130ca:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8130d0:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  8130d6:	89 d1                	mov    %edx,%ecx
  8130d8:	ba 00 00 00 00       	mov    $0x0,%edx
  8130dd:	be 00 00 00 00       	mov    $0x0,%esi
  8130e2:	48 89 c7             	mov    %rax,%rdi
  8130e5:	48 b8 87 31 81 00 00 	movabs $0x813187,%rax
  8130ec:	00 00 00 
  8130ef:	ff d0                	callq  *%rax
}
  8130f1:	c9                   	leaveq 
  8130f2:	c3                   	retq   

00000000008130f3 <tcp_write>:
 * 
 * @see tcp_write()
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  8130f3:	55                   	push   %rbp
  8130f4:	48 89 e5             	mov    %rsp,%rbp
  8130f7:	48 83 ec 20          	sub    $0x20,%rsp
  8130fb:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8130ff:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  813103:	89 c8                	mov    %ecx,%eax
  813105:	66 89 55 ec          	mov    %dx,-0x14(%rbp)
  813109:	88 45 e8             	mov    %al,-0x18(%rbp)
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
  81310c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  813110:	8b 40 18             	mov    0x18(%rax),%eax
  813113:	83 f8 04             	cmp    $0x4,%eax
  813116:	74 24                	je     81313c <tcp_write+0x49>
     pcb->state == CLOSE_WAIT ||
  813118:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81311c:	8b 40 18             	mov    0x18(%rax),%eax
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
  81311f:	83 f8 07             	cmp    $0x7,%eax
  813122:	74 18                	je     81313c <tcp_write+0x49>
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
  813124:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  813128:	8b 40 18             	mov    0x18(%rax),%eax
{
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
     pcb->state == CLOSE_WAIT ||
  81312b:	83 f8 02             	cmp    $0x2,%eax
  81312e:	74 0c                	je     81313c <tcp_write+0x49>
     pcb->state == SYN_SENT ||
     pcb->state == SYN_RCVD) {
  813130:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  813134:	8b 40 18             	mov    0x18(%rax),%eax
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
  813137:	83 f8 03             	cmp    $0x3,%eax
  81313a:	75 44                	jne    813180 <tcp_write+0x8d>
     pcb->state == SYN_RCVD) {
    if (len > 0) {
  81313c:	66 83 7d ec 00       	cmpw   $0x0,-0x14(%rbp)
  813141:	74 36                	je     813179 <tcp_write+0x86>
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
  813143:	0f b6 4d e8          	movzbl -0x18(%rbp),%ecx
  813147:	0f b7 55 ec          	movzwl -0x14(%rbp),%edx
  81314b:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  81314f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  813153:	c7 04 24 00 00 00 00 	movl   $0x0,(%rsp)
  81315a:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  813160:	41 89 c8             	mov    %ecx,%r8d
  813163:	b9 00 00 00 00       	mov    $0x0,%ecx
  813168:	48 89 c7             	mov    %rax,%rdi
  81316b:	48 b8 87 31 81 00 00 	movabs $0x813187,%rax
  813172:	00 00 00 
  813175:	ff d0                	callq  *%rax
  813177:	eb 0c                	jmp    813185 <tcp_write+0x92>
    }
    return ERR_OK;
  813179:	b8 00 00 00 00       	mov    $0x0,%eax
  81317e:	eb 05                	jmp    813185 <tcp_write+0x92>
  } else {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | 3, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  813180:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  }
}
  813185:	c9                   	leaveq 
  813186:	c3                   	retq   

0000000000813187 <tcp_enqueue>:
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
  u8_t flags, u8_t apiflags,
  u8_t *optdata, u8_t optlen)
{
  813187:	55                   	push   %rbp
  813188:	48 89 e5             	mov    %rsp,%rbp
  81318b:	41 54                	push   %r12
  81318d:	53                   	push   %rbx
  81318e:	48 83 ec 70          	sub    $0x70,%rsp
  813192:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  813196:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  81319a:	89 c8                	mov    %ecx,%eax
  81319c:	44 89 c6             	mov    %r8d,%esi
  81319f:	4c 89 4d 88          	mov    %r9,-0x78(%rbp)
  8131a3:	8b 4d 10             	mov    0x10(%rbp),%ecx
  8131a6:	66 89 55 9c          	mov    %dx,-0x64(%rbp)
  8131aa:	88 45 98             	mov    %al,-0x68(%rbp)
  8131ad:	40 88 75 94          	mov    %sil,-0x6c(%rbp)
  8131b1:	88 4d 90             	mov    %cl,-0x70(%rbp)
  void *ptr;
  u16_t queuelen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_enqueue(pcb=%p, arg=%p, len=%"U16_F", flags=%"X16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)flags, (u16_t)apiflags));
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  8131b4:	66 83 7d 9c 00       	cmpw   $0x0,-0x64(%rbp)
  8131b9:	74 30                	je     8131eb <tcp_enqueue+0x64>
  8131bb:	80 7d 90 00          	cmpb   $0x0,-0x70(%rbp)
  8131bf:	74 2a                	je     8131eb <tcp_enqueue+0x64>
  8131c1:	48 ba 48 28 82 00 00 	movabs $0x822848,%rdx
  8131c8:	00 00 00 
  8131cb:	be 91 00 00 00       	mov    $0x91,%esi
  8131d0:	48 bf 87 28 82 00 00 	movabs $0x822887,%rdi
  8131d7:	00 00 00 
  8131da:	b8 00 00 00 00       	mov    $0x0,%eax
  8131df:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  8131e6:	00 00 00 
  8131e9:	ff d1                	callq  *%rcx
      ((len == 0) || (optlen == 0)), return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  8131eb:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  8131f0:	74 31                	je     813223 <tcp_enqueue+0x9c>
  8131f2:	48 83 7d 88 00       	cmpq   $0x0,-0x78(%rbp)
  8131f7:	74 2a                	je     813223 <tcp_enqueue+0x9c>
  8131f9:	48 ba a0 28 82 00 00 	movabs $0x8228a0,%rdx
  813200:	00 00 00 
  813203:	be 93 00 00 00       	mov    $0x93,%esi
  813208:	48 bf 87 28 82 00 00 	movabs $0x822887,%rdi
  81320f:	00 00 00 
  813212:	b8 00 00 00 00       	mov    $0x0,%eax
  813217:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81321e:	00 00 00 
  813221:	ff d1                	callq  *%rcx
      ((arg == NULL) || (optdata == NULL)), return ERR_ARG;);
  /* fail on too much data */
  if (len > pcb->snd_buf) {
  813223:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813227:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  81322b:	66 3b 45 9c          	cmp    -0x64(%rbp),%ax
  81322f:	73 1e                	jae    81324f <tcp_enqueue+0xc8>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n", len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
  813231:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813235:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813239:	83 c8 80             	or     $0xffffff80,%eax
  81323c:	89 c2                	mov    %eax,%edx
  81323e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813242:	88 50 2c             	mov    %dl,0x2c(%rax)
    return ERR_MEM;
  813245:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81324a:	e9 e5 09 00 00       	jmpq   813c34 <tcp_enqueue+0xaad>
  }
  left = len;
  81324f:	0f b7 45 9c          	movzwl -0x64(%rbp),%eax
  813253:	66 89 45 d2          	mov    %ax,-0x2e(%rbp)
  ptr = arg;
  813257:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  81325b:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
  81325f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813263:	8b 40 74             	mov    0x74(%rax),%eax
  813266:	89 45 d4             	mov    %eax,-0x2c(%rbp)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
  813269:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81326d:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  813271:	66 89 45 c6          	mov    %ax,-0x3a(%rbp)
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  813275:	66 83 7d c6 1f       	cmpw   $0x1f,-0x3a(%rbp)
  81327a:	77 07                	ja     813283 <tcp_enqueue+0xfc>
  81327c:	66 83 7d c6 fc       	cmpw   $0xfffc,-0x3a(%rbp)
  813281:	76 1e                	jbe    8132a1 <tcp_enqueue+0x11a>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
  813283:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813287:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81328b:	83 c8 80             	or     $0xffffff80,%eax
  81328e:	89 c2                	mov    %eax,%edx
  813290:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813294:	88 50 2c             	mov    %dl,0x2c(%rax)
    return ERR_MEM;
  813297:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81329c:	e9 93 09 00 00       	jmpq   813c34 <tcp_enqueue+0xaad>
  }
  if (queuelen != 0) {
  8132a1:	66 83 7d c6 00       	cmpw   $0x0,-0x3a(%rbp)
  8132a6:	74 4e                	je     8132f6 <tcp_enqueue+0x16f>
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  8132a8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8132ac:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8132b3:	48 85 c0             	test   %rax,%rax
  8132b6:	0f 85 84 00 00 00    	jne    813340 <tcp_enqueue+0x1b9>
  8132bc:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8132c0:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8132c7:	48 85 c0             	test   %rax,%rax
  8132ca:	75 74                	jne    813340 <tcp_enqueue+0x1b9>
  8132cc:	48 ba e8 28 82 00 00 	movabs $0x8228e8,%rdx
  8132d3:	00 00 00 
  8132d6:	be af 00 00 00       	mov    $0xaf,%esi
  8132db:	48 bf 87 28 82 00 00 	movabs $0x822887,%rdi
  8132e2:	00 00 00 
  8132e5:	b8 00 00 00 00       	mov    $0x0,%eax
  8132ea:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  8132f1:	00 00 00 
  8132f4:	ff d1                	callq  *%rcx
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  8132f6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8132fa:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  813301:	48 85 c0             	test   %rax,%rax
  813304:	75 10                	jne    813316 <tcp_enqueue+0x18f>
  813306:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81330a:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813311:	48 85 c0             	test   %rax,%rax
  813314:	74 2a                	je     813340 <tcp_enqueue+0x1b9>
  813316:	48 ba 28 29 82 00 00 	movabs $0x822928,%rdx
  81331d:	00 00 00 
  813320:	be b2 00 00 00       	mov    $0xb2,%esi
  813325:	48 bf 87 28 82 00 00 	movabs $0x822887,%rdi
  81332c:	00 00 00 
  81332f:	b8 00 00 00 00       	mov    $0x0,%eax
  813334:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81333b:	00 00 00 
  81333e:	ff d1                	callq  *%rcx
      pcb->unacked == NULL && pcb->unsent == NULL);
  }

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  813340:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  813347:	00 
  813348:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81334c:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  813350:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813354:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  seglen = 0;
  813358:	66 c7 45 d0 00 00    	movw   $0x0,-0x30(%rbp)
  while (queue == NULL || left > 0) {
  81335e:	e9 f9 04 00 00       	jmpq   81385c <tcp_enqueue+0x6d5>

    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;
  813363:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813367:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  81336b:	0f b7 45 d2          	movzwl -0x2e(%rbp),%eax
  81336f:	66 39 c2             	cmp    %ax,%dx
  813372:	0f 46 c2             	cmovbe %edx,%eax
  813375:	66 89 45 d0          	mov    %ax,-0x30(%rbp)

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  813379:	bf 04 00 00 00       	mov    $0x4,%edi
  81337e:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  813385:	00 00 00 
  813388:	ff d0                	callq  *%rax
  81338a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if (seg == NULL) {
  81338e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  813393:	75 05                	jne    81339a <tcp_enqueue+0x213>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
  813395:	e9 10 08 00 00       	jmpq   813baa <tcp_enqueue+0xa23>
    }
    seg->next = NULL;
  81339a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81339e:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    seg->p = NULL;
  8133a5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8133a9:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8133b0:	00 

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
  8133b1:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8133b6:	75 0a                	jne    8133c2 <tcp_enqueue+0x23b>
      queue = seg;
  8133b8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8133bc:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8133c0:	eb 3c                	jmp    8133fe <tcp_enqueue+0x277>
    }
    /* subsequent segments of to-be-queued data */
    else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("useg != NULL", useg != NULL);
  8133c2:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8133c7:	75 2a                	jne    8133f3 <tcp_enqueue+0x26c>
  8133c9:	48 ba 5c 29 82 00 00 	movabs $0x82295c,%rdx
  8133d0:	00 00 00 
  8133d3:	be cf 00 00 00       	mov    $0xcf,%esi
  8133d8:	48 bf 87 28 82 00 00 	movabs $0x822887,%rdi
  8133df:	00 00 00 
  8133e2:	b8 00 00 00 00       	mov    $0x0,%eax
  8133e7:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  8133ee:	00 00 00 
  8133f1:	ff d1                	callq  *%rcx
      useg->next = seg;
  8133f3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8133f7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8133fb:	48 89 10             	mov    %rdx,(%rax)
    }
    /* remember last segment of to-be-queued data for next iteration */
    useg = seg;
  8133fe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813402:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
     * and data copied into pbuf, otherwise data comes from
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
  813406:	48 83 7d 88 00       	cmpq   $0x0,-0x78(%rbp)
  81340b:	0f 84 ac 00 00 00    	je     8134bd <tcp_enqueue+0x336>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  813411:	0f b6 45 90          	movzbl -0x70(%rbp),%eax
  813415:	ba 00 00 00 00       	mov    $0x0,%edx
  81341a:	89 c6                	mov    %eax,%esi
  81341c:	bf 00 00 00 00       	mov    $0x0,%edi
  813421:	48 b8 61 d4 80 00 00 	movabs $0x80d461,%rax
  813428:	00 00 00 
  81342b:	ff d0                	callq  *%rax
  81342d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  813431:	48 89 42 08          	mov    %rax,0x8(%rdx)
  813435:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813439:	48 8b 40 08          	mov    0x8(%rax),%rax
  81343d:	48 85 c0             	test   %rax,%rax
  813440:	75 05                	jne    813447 <tcp_enqueue+0x2c0>
        goto memerr;
  813442:	e9 63 07 00 00       	jmpq   813baa <tcp_enqueue+0xa23>
      }
      LWIP_ASSERT("check that first pbuf can hold optlen",
  813447:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81344b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81344f:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  813453:	0f b6 45 90          	movzbl -0x70(%rbp),%eax
  813457:	66 39 c2             	cmp    %ax,%dx
  81345a:	73 2a                	jae    813486 <tcp_enqueue+0x2ff>
  81345c:	48 ba 70 29 82 00 00 	movabs $0x822970,%rdx
  813463:	00 00 00 
  813466:	be e0 00 00 00       	mov    $0xe0,%esi
  81346b:	48 bf 87 28 82 00 00 	movabs $0x822887,%rdi
  813472:	00 00 00 
  813475:	b8 00 00 00 00       	mov    $0x0,%eax
  81347a:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  813481:	00 00 00 
  813484:	ff d1                	callq  *%rcx
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
  813486:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81348a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81348e:	48 89 c7             	mov    %rax,%rdi
  813491:	48 b8 f5 de 80 00 00 	movabs $0x80def5,%rax
  813498:	00 00 00 
  81349b:	ff d0                	callq  *%rax
  81349d:	0f b6 c0             	movzbl %al,%eax
  8134a0:	66 01 45 c6          	add    %ax,-0x3a(%rbp)
      seg->dataptr = seg->p->payload;
  8134a4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8134a8:	48 8b 40 08          	mov    0x8(%rax),%rax
  8134ac:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8134b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8134b4:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8134b8:	e9 ba 01 00 00       	jmpq   813677 <tcp_enqueue+0x4f0>
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  8134bd:	0f b6 45 94          	movzbl -0x6c(%rbp),%eax
  8134c1:	83 e0 01             	and    $0x1,%eax
  8134c4:	85 c0                	test   %eax,%eax
  8134c6:	0f 84 d6 00 00 00    	je     8135a2 <tcp_enqueue+0x41b>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
  8134cc:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  8134d0:	ba 00 00 00 00       	mov    $0x0,%edx
  8134d5:	89 c6                	mov    %eax,%esi
  8134d7:	bf 00 00 00 00       	mov    $0x0,%edi
  8134dc:	48 b8 61 d4 80 00 00 	movabs $0x80d461,%rax
  8134e3:	00 00 00 
  8134e6:	ff d0                	callq  *%rax
  8134e8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8134ec:	48 89 42 08          	mov    %rax,0x8(%rdx)
  8134f0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8134f4:	48 8b 40 08          	mov    0x8(%rax),%rax
  8134f8:	48 85 c0             	test   %rax,%rax
  8134fb:	75 05                	jne    813502 <tcp_enqueue+0x37b>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
  8134fd:	e9 a8 06 00 00       	jmpq   813baa <tcp_enqueue+0xa23>
      }
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  813502:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813506:	48 8b 40 08          	mov    0x8(%rax),%rax
  81350a:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81350e:	66 3b 45 d0          	cmp    -0x30(%rbp),%ax
  813512:	73 2a                	jae    81353e <tcp_enqueue+0x3b7>
  813514:	48 ba 98 29 82 00 00 	movabs $0x822998,%rdx
  81351b:	00 00 00 
  81351e:	be eb 00 00 00       	mov    $0xeb,%esi
  813523:	48 bf 87 28 82 00 00 	movabs $0x822887,%rdi
  81352a:	00 00 00 
  81352d:	b8 00 00 00 00       	mov    $0x0,%eax
  813532:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  813539:	00 00 00 
  81353c:	ff d1                	callq  *%rcx
                  (seg->p->len >= seglen));
      queuelen += pbuf_clen(seg->p);
  81353e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813542:	48 8b 40 08          	mov    0x8(%rax),%rax
  813546:	48 89 c7             	mov    %rax,%rdi
  813549:	48 b8 f5 de 80 00 00 	movabs $0x80def5,%rax
  813550:	00 00 00 
  813553:	ff d0                	callq  *%rax
  813555:	0f b6 c0             	movzbl %al,%eax
  813558:	66 01 45 c6          	add    %ax,-0x3a(%rbp)
      if (arg != NULL) {
  81355c:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  813561:	74 26                	je     813589 <tcp_enqueue+0x402>
        MEMCPY(seg->p->payload, ptr, seglen);
  813563:	0f b7 55 d0          	movzwl -0x30(%rbp),%edx
  813567:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81356b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81356f:	48 8b 40 08          	mov    0x8(%rax),%rax
  813573:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  813577:	48 89 ce             	mov    %rcx,%rsi
  81357a:	48 89 c7             	mov    %rax,%rdi
  81357d:	48 b8 12 23 80 00 00 	movabs $0x802312,%rax
  813584:	00 00 00 
  813587:	ff d0                	callq  *%rax
      }
      seg->dataptr = seg->p->payload;
  813589:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81358d:	48 8b 40 08          	mov    0x8(%rax),%rax
  813591:	48 8b 50 08          	mov    0x8(%rax),%rdx
  813595:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813599:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81359d:	e9 d5 00 00 00       	jmpq   813677 <tcp_enqueue+0x4f0>
      /* First, allocate a pbuf for holding the data.
       * since the referenced data is available at least until it is sent out on the
       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM
       * instead of PBUF_REF here.
       */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
  8135a2:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  8135a6:	ba 01 00 00 00       	mov    $0x1,%edx
  8135ab:	89 c6                	mov    %eax,%esi
  8135ad:	bf 00 00 00 00       	mov    $0x0,%edi
  8135b2:	48 b8 61 d4 80 00 00 	movabs $0x80d461,%rax
  8135b9:	00 00 00 
  8135bc:	ff d0                	callq  *%rax
  8135be:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  8135c2:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8135c7:	75 05                	jne    8135ce <tcp_enqueue+0x447>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
  8135c9:	e9 dc 05 00 00       	jmpq   813baa <tcp_enqueue+0xa23>
      }
      ++queuelen;
  8135ce:	66 83 45 c6 01       	addw   $0x1,-0x3a(%rbp)
      /* reference the non-volatile payload data */
      p->payload = ptr;
  8135d3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8135d7:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8135db:	48 89 50 08          	mov    %rdx,0x8(%rax)
      seg->dataptr = ptr;
  8135df:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8135e3:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8135e7:	48 89 50 10          	mov    %rdx,0x10(%rax)

      /* Second, allocate a pbuf for the headers. */
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_RAM)) == NULL) {
  8135eb:	ba 00 00 00 00       	mov    $0x0,%edx
  8135f0:	be 00 00 00 00       	mov    $0x0,%esi
  8135f5:	bf 00 00 00 00       	mov    $0x0,%edi
  8135fa:	48 b8 61 d4 80 00 00 	movabs $0x80d461,%rax
  813601:	00 00 00 
  813604:	ff d0                	callq  *%rax
  813606:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81360a:	48 89 42 08          	mov    %rax,0x8(%rdx)
  81360e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813612:	48 8b 40 08          	mov    0x8(%rax),%rax
  813616:	48 85 c0             	test   %rax,%rax
  813619:	75 18                	jne    813633 <tcp_enqueue+0x4ac>
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p);
  81361b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81361f:	48 89 c7             	mov    %rax,%rdi
  813622:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  813629:	00 00 00 
  81362c:	ff d0                	callq  *%rax
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for header pbuf\n"));
        goto memerr;
  81362e:	e9 77 05 00 00       	jmpq   813baa <tcp_enqueue+0xa23>
      }
      queuelen += pbuf_clen(seg->p);
  813633:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813637:	48 8b 40 08          	mov    0x8(%rax),%rax
  81363b:	48 89 c7             	mov    %rax,%rdi
  81363e:	48 b8 f5 de 80 00 00 	movabs $0x80def5,%rax
  813645:	00 00 00 
  813648:	ff d0                	callq  *%rax
  81364a:	0f b6 c0             	movzbl %al,%eax
  81364d:	66 01 45 c6          	add    %ax,-0x3a(%rbp)

      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(seg->p/*header*/, p/*data*/);
  813651:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813655:	48 8b 40 08          	mov    0x8(%rax),%rax
  813659:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  81365d:	48 89 d6             	mov    %rdx,%rsi
  813660:	48 89 c7             	mov    %rax,%rdi
  813663:	48 b8 4b df 80 00 00 	movabs $0x80df4b,%rax
  81366a:	00 00 00 
  81366d:	ff d0                	callq  *%rax
      p = NULL;
  81366f:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  813676:	00 
    }

    /* Now that there are more segments queued, we check again if the
    length of the queue exceeds the configured maximum or overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  813677:	66 83 7d c6 20       	cmpw   $0x20,-0x3a(%rbp)
  81367c:	77 07                	ja     813685 <tcp_enqueue+0x4fe>
  81367e:	66 83 7d c6 fc       	cmpw   $0xfffc,-0x3a(%rbp)
  813683:	76 05                	jbe    81368a <tcp_enqueue+0x503>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      goto memerr;
  813685:	e9 20 05 00 00       	jmpq   813baa <tcp_enqueue+0xa23>
    }

    seg->len = seglen;
  81368a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81368e:	0f b7 55 d0          	movzwl -0x30(%rbp),%edx
  813692:	66 89 50 18          	mov    %dx,0x18(%rax)

    /* build TCP header */
    if (pbuf_header(seg->p, TCP_HLEN)) {
  813696:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81369a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81369e:	be 14 00 00 00       	mov    $0x14,%esi
  8136a3:	48 89 c7             	mov    %rax,%rdi
  8136a6:	48 b8 7f db 80 00 00 	movabs $0x80db7f,%rax
  8136ad:	00 00 00 
  8136b0:	ff d0                	callq  *%rax
  8136b2:	84 c0                	test   %al,%al
  8136b4:	74 05                	je     8136bb <tcp_enqueue+0x534>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: no room for TCP header in pbuf.\n"));
      TCP_STATS_INC(tcp.err);
      goto memerr;
  8136b6:	e9 ef 04 00 00       	jmpq   813baa <tcp_enqueue+0xa23>
    }
    seg->tcphdr = seg->p->payload;
  8136bb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8136bf:	48 8b 40 08          	mov    0x8(%rax),%rax
  8136c3:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8136c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8136cb:	48 89 50 20          	mov    %rdx,0x20(%rax)
    seg->tcphdr->src = htons(pcb->local_port);
  8136cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8136d3:	48 8b 58 20          	mov    0x20(%rax),%rbx
  8136d7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8136db:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  8136df:	0f b7 c0             	movzwl %ax,%eax
  8136e2:	89 c7                	mov    %eax,%edi
  8136e4:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  8136eb:	00 00 00 
  8136ee:	ff d0                	callq  *%rax
  8136f0:	66 89 03             	mov    %ax,(%rbx)
    seg->tcphdr->dest = htons(pcb->remote_port);
  8136f3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8136f7:	48 8b 58 20          	mov    0x20(%rax),%rbx
  8136fb:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8136ff:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  813703:	0f b7 c0             	movzwl %ax,%eax
  813706:	89 c7                	mov    %eax,%edi
  813708:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  81370f:	00 00 00 
  813712:	ff d0                	callq  *%rax
  813714:	66 89 43 02          	mov    %ax,0x2(%rbx)
    seg->tcphdr->seqno = htonl(seqno);
  813718:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81371c:	48 8b 58 20          	mov    0x20(%rax),%rbx
  813720:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  813723:	89 c7                	mov    %eax,%edi
  813725:	48 b8 54 30 81 00 00 	movabs $0x813054,%rax
  81372c:	00 00 00 
  81372f:	ff d0                	callq  *%rax
  813731:	89 43 04             	mov    %eax,0x4(%rbx)
    seg->tcphdr->urgp = 0;
  813734:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813738:	48 8b 40 20          	mov    0x20(%rax),%rax
  81373c:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  813742:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813746:	48 8b 58 20          	mov    0x20(%rax),%rbx
  81374a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81374e:	48 8b 40 20          	mov    0x20(%rax),%rax
  813752:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813756:	0f b7 c0             	movzwl %ax,%eax
  813759:	89 c7                	mov    %eax,%edi
  81375b:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  813762:	00 00 00 
  813765:	ff d0                	callq  *%rax
  813767:	83 e0 c0             	and    $0xffffffc0,%eax
  81376a:	89 c2                	mov    %eax,%edx
  81376c:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
  813770:	09 d0                	or     %edx,%eax
  813772:	0f b7 c0             	movzwl %ax,%eax
  813775:	89 c7                	mov    %eax,%edi
  813777:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  81377e:	00 00 00 
  813781:	ff d0                	callq  *%rax
  813783:	66 89 43 0c          	mov    %ax,0xc(%rbx)
    /* don't fill in tcphdr->ackno and tcphdr->wnd until later */

    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
  813787:	48 83 7d 88 00       	cmpq   $0x0,-0x78(%rbp)
  81378c:	75 42                	jne    8137d0 <tcp_enqueue+0x649>
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
  81378e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813792:	48 8b 58 20          	mov    0x20(%rax),%rbx
  813796:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81379a:	48 8b 40 20          	mov    0x20(%rax),%rax
  81379e:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8137a2:	0f b7 c0             	movzwl %ax,%eax
  8137a5:	89 c7                	mov    %eax,%edi
  8137a7:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  8137ae:	00 00 00 
  8137b1:	ff d0                	callq  *%rax
  8137b3:	83 e0 3f             	and    $0x3f,%eax
  8137b6:	80 cc 50             	or     $0x50,%ah
  8137b9:	0f b7 c0             	movzwl %ax,%eax
  8137bc:	89 c7                	mov    %eax,%edi
  8137be:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  8137c5:	00 00 00 
  8137c8:	ff d0                	callq  *%rax
  8137ca:	66 89 43 0c          	mov    %ax,0xc(%rbx)
  8137ce:	eb 75                	jmp    813845 <tcp_enqueue+0x6be>
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  8137d0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8137d4:	48 8b 58 20          	mov    0x20(%rax),%rbx
  8137d8:	0f b6 45 90          	movzbl -0x70(%rbp),%eax
  8137dc:	c0 e8 02             	shr    $0x2,%al
  8137df:	0f b6 c0             	movzbl %al,%eax
  8137e2:	83 c0 05             	add    $0x5,%eax
  8137e5:	c1 e0 0c             	shl    $0xc,%eax
  8137e8:	41 89 c4             	mov    %eax,%r12d
  8137eb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8137ef:	48 8b 40 20          	mov    0x20(%rax),%rax
  8137f3:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8137f7:	0f b7 c0             	movzwl %ax,%eax
  8137fa:	89 c7                	mov    %eax,%edi
  8137fc:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  813803:	00 00 00 
  813806:	ff d0                	callq  *%rax
  813808:	83 e0 3f             	and    $0x3f,%eax
  81380b:	44 09 e0             	or     %r12d,%eax
  81380e:	0f b7 c0             	movzwl %ax,%eax
  813811:	89 c7                	mov    %eax,%edi
  813813:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  81381a:	00 00 00 
  81381d:	ff d0                	callq  *%rax
  81381f:	66 89 43 0c          	mov    %ax,0xc(%rbx)
      /* Copy options into data portion of segment.
       Options can thus only be sent in non data carrying
       segments such as SYN|ACK. */
      SMEMCPY(seg->dataptr, optdata, optlen);
  813823:	0f b6 55 90          	movzbl -0x70(%rbp),%edx
  813827:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81382b:	48 8b 40 10          	mov    0x10(%rax),%rax
  81382f:	48 8b 4d 88          	mov    -0x78(%rbp),%rcx
  813833:	48 89 ce             	mov    %rcx,%rsi
  813836:	48 89 c7             	mov    %rax,%rdi
  813839:	48 b8 12 23 80 00 00 	movabs $0x802312,%rax
  813840:	00 00 00 
  813843:	ff d0                	callq  *%rax
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_enqueue: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
  813845:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  813849:	66 29 45 d2          	sub    %ax,-0x2e(%rbp)
    seqno += seglen;
  81384d:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  813851:	01 45 d4             	add    %eax,-0x2c(%rbp)
    ptr = (void *)((u8_t *)ptr + seglen);
  813854:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  813858:	48 01 45 c8          	add    %rax,-0x38(%rbp)

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  seglen = 0;
  while (queue == NULL || left > 0) {
  81385c:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  813861:	0f 84 fc fa ff ff    	je     813363 <tcp_enqueue+0x1dc>
  813867:	66 83 7d d2 00       	cmpw   $0x0,-0x2e(%rbp)
  81386c:	0f 85 f1 fa ff ff    	jne    813363 <tcp_enqueue+0x1dc>
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
  813872:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813876:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81387d:	48 85 c0             	test   %rax,%rax
  813880:	75 0a                	jne    81388c <tcp_enqueue+0x705>
    useg = NULL;
  813882:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  813889:	00 
  81388a:	eb 28                	jmp    8138b4 <tcp_enqueue+0x72d>
  }
  else {
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
  81388c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813890:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813897:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  81389b:	eb 0b                	jmp    8138a8 <tcp_enqueue+0x721>
  81389d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8138a1:	48 8b 00             	mov    (%rax),%rax
  8138a4:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8138a8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8138ac:	48 8b 00             	mov    (%rax),%rax
  8138af:	48 85 c0             	test   %rax,%rax
  8138b2:	75 e9                	jne    81389d <tcp_enqueue+0x716>
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  8138b4:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8138b9:	0f 84 94 01 00 00    	je     813a53 <tcp_enqueue+0x8cc>
    TCP_TCPLEN(useg) != 0 &&
  8138bf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8138c3:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8138c7:	0f b7 d8             	movzwl %ax,%ebx
  8138ca:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8138ce:	48 8b 40 20          	mov    0x20(%rax),%rax
  8138d2:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8138d6:	0f b7 c0             	movzwl %ax,%eax
  8138d9:	89 c7                	mov    %eax,%edi
  8138db:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  8138e2:	00 00 00 
  8138e5:	ff d0                	callq  *%rax
  8138e7:	0f b7 c0             	movzwl %ax,%eax
  8138ea:	83 e0 01             	and    $0x1,%eax
  8138ed:	85 c0                	test   %eax,%eax
  8138ef:	75 27                	jne    813918 <tcp_enqueue+0x791>
  8138f1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8138f5:	48 8b 40 20          	mov    0x20(%rax),%rax
  8138f9:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8138fd:	0f b7 c0             	movzwl %ax,%eax
  813900:	89 c7                	mov    %eax,%edi
  813902:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  813909:	00 00 00 
  81390c:	ff d0                	callq  *%rax
  81390e:	0f b7 c0             	movzwl %ax,%eax
  813911:	83 e0 02             	and    $0x2,%eax
  813914:	85 c0                	test   %eax,%eax
  813916:	74 07                	je     81391f <tcp_enqueue+0x798>
  813918:	b8 01 00 00 00       	mov    $0x1,%eax
  81391d:	eb 05                	jmp    813924 <tcp_enqueue+0x79d>
  81391f:	b8 00 00 00 00       	mov    $0x0,%eax
  813924:	01 d8                	add    %ebx,%eax
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  813926:	85 c0                	test   %eax,%eax
  813928:	0f 84 25 01 00 00    	je     813a53 <tcp_enqueue+0x8cc>
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  81392e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813932:	48 8b 40 20          	mov    0x20(%rax),%rax
  813936:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81393a:	0f b7 c0             	movzwl %ax,%eax
  81393d:	89 c7                	mov    %eax,%edi
  81393f:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  813946:	00 00 00 
  813949:	ff d0                	callq  *%rax
  81394b:	0f b7 c0             	movzwl %ax,%eax
  81394e:	83 e0 03             	and    $0x3,%eax
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
  813951:	85 c0                	test   %eax,%eax
  813953:	0f 85 fa 00 00 00    	jne    813a53 <tcp_enqueue+0x8cc>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    !(flags & (TCP_SYN | TCP_FIN)) &&
  813959:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
  81395d:	83 e0 03             	and    $0x3,%eax

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  813960:	85 c0                	test   %eax,%eax
  813962:	0f 85 eb 00 00 00    	jne    813a53 <tcp_enqueue+0x8cc>
    !(flags & (TCP_SYN | TCP_FIN)) &&
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
  813968:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81396c:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  813970:	0f b7 d0             	movzwl %ax,%edx
  813973:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813977:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81397b:	0f b7 c0             	movzwl %ax,%eax
  81397e:	01 c2                	add    %eax,%edx
  813980:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813984:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  813988:	0f b7 c0             	movzwl %ax,%eax
  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    !(flags & (TCP_SYN | TCP_FIN)) &&
  81398b:	39 c2                	cmp    %eax,%edx
  81398d:	0f 8f c0 00 00 00    	jg     813a53 <tcp_enqueue+0x8cc>
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
    /* Remove TCP header from first segment of our to-be-queued list */
    if(pbuf_header(queue->p, -TCP_HLEN)) {
  813993:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813997:	48 8b 40 08          	mov    0x8(%rax),%rax
  81399b:	be ec ff ff ff       	mov    $0xffffffec,%esi
  8139a0:	48 89 c7             	mov    %rax,%rdi
  8139a3:	48 b8 7f db 80 00 00 	movabs $0x80db7f,%rax
  8139aa:	00 00 00 
  8139ad:	ff d0                	callq  *%rax
  8139af:	84 c0                	test   %al,%al
  8139b1:	74 2a                	je     8139dd <tcp_enqueue+0x856>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  8139b3:	48 ba cb 29 82 00 00 	movabs $0x8229cb,%rdx
  8139ba:	00 00 00 
  8139bd:	be 53 01 00 00       	mov    $0x153,%esi
  8139c2:	48 bf 87 28 82 00 00 	movabs $0x822887,%rdi
  8139c9:	00 00 00 
  8139cc:	b8 00 00 00 00       	mov    $0x0,%eax
  8139d1:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  8139d8:	00 00 00 
  8139db:	ff d1                	callq  *%rcx
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    pbuf_cat(useg->p, queue->p);
  8139dd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8139e1:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8139e5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8139e9:	48 8b 40 08          	mov    0x8(%rax),%rax
  8139ed:	48 89 d6             	mov    %rdx,%rsi
  8139f0:	48 89 c7             	mov    %rax,%rdi
  8139f3:	48 b8 4b df 80 00 00 	movabs $0x80df4b,%rax
  8139fa:	00 00 00 
  8139fd:	ff d0                	callq  *%rax
    useg->len += queue->len;
  8139ff:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813a03:	0f b7 50 18          	movzwl 0x18(%rax),%edx
  813a07:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813a0b:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  813a0f:	01 c2                	add    %eax,%edx
  813a11:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813a15:	66 89 50 18          	mov    %dx,0x18(%rax)
    useg->next = queue->next;
  813a19:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813a1d:	48 8b 10             	mov    (%rax),%rdx
  813a20:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813a24:	48 89 10             	mov    %rdx,(%rax)

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("tcp_enqueue: chaining segments, new len %"U16_F"\n", useg->len));
    if (seg == queue) {
  813a27:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813a2b:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  813a2f:	75 08                	jne    813a39 <tcp_enqueue+0x8b2>
      seg = NULL;
  813a31:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  813a38:	00 
    }
    memp_free(MEMP_TCP_SEG, queue);
  813a39:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813a3d:	48 89 c6             	mov    %rax,%rsi
  813a40:	bf 04 00 00 00       	mov    $0x4,%edi
  813a45:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  813a4c:	00 00 00 
  813a4f:	ff d0                	callq  *%rax
  813a51:	eb 23                	jmp    813a76 <tcp_enqueue+0x8ef>
  }
  else {
    /* empty list */
    if (useg == NULL) {
  813a53:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  813a58:	75 11                	jne    813a6b <tcp_enqueue+0x8e4>
      /* initialize list with this segment */
      pcb->unsent = queue;
  813a5a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813a5e:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  813a62:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
  813a69:	eb 0b                	jmp    813a76 <tcp_enqueue+0x8ef>
    }
    /* enqueue segment */
    else {
      useg->next = queue;
  813a6b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813a6f:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  813a73:	48 89 10             	mov    %rdx,(%rax)
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
  813a76:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
  813a7a:	83 e0 02             	and    $0x2,%eax
  813a7d:	85 c0                	test   %eax,%eax
  813a7f:	75 0b                	jne    813a8c <tcp_enqueue+0x905>
  813a81:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
  813a85:	83 e0 01             	and    $0x1,%eax
  813a88:	85 c0                	test   %eax,%eax
  813a8a:	74 05                	je     813a91 <tcp_enqueue+0x90a>
    ++len;
  813a8c:	66 83 45 9c 01       	addw   $0x1,-0x64(%rbp)
  }
  if (flags & TCP_FIN) {
  813a91:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
  813a95:	83 e0 01             	and    $0x1,%eax
  813a98:	85 c0                	test   %eax,%eax
  813a9a:	74 14                	je     813ab0 <tcp_enqueue+0x929>
    pcb->flags |= TF_FIN;
  813a9c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813aa0:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813aa4:	83 c8 20             	or     $0x20,%eax
  813aa7:	89 c2                	mov    %eax,%edx
  813aa9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813aad:	88 50 2c             	mov    %dl,0x2c(%rax)
  }
  pcb->snd_lbb += len;
  813ab0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813ab4:	8b 50 74             	mov    0x74(%rax),%edx
  813ab7:	0f b7 45 9c          	movzwl -0x64(%rbp),%eax
  813abb:	01 c2                	add    %eax,%edx
  813abd:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813ac1:	89 50 74             	mov    %edx,0x74(%rax)

  pcb->snd_buf -= len;
  813ac4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813ac8:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  813acc:	66 2b 45 9c          	sub    -0x64(%rbp),%ax
  813ad0:	89 c2                	mov    %eax,%edx
  813ad2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813ad6:	66 89 50 7a          	mov    %dx,0x7a(%rax)

  /* update number of segments on the queues */
  pcb->snd_queuelen = queuelen;
  813ada:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813ade:	0f b7 55 c6          	movzwl -0x3a(%rbp),%edx
  813ae2:	66 89 50 7c          	mov    %dx,0x7c(%rax)
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
  813ae6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813aea:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  813aee:	66 85 c0             	test   %ax,%ax
  813af1:	74 4a                	je     813b3d <tcp_enqueue+0x9b6>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  813af3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813af7:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  813afe:	48 85 c0             	test   %rax,%rax
  813b01:	75 3a                	jne    813b3d <tcp_enqueue+0x9b6>
  813b03:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813b07:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813b0e:	48 85 c0             	test   %rax,%rax
  813b11:	75 2a                	jne    813b3d <tcp_enqueue+0x9b6>
  813b13:	48 ba e0 29 82 00 00 	movabs $0x8229e0,%rdx
  813b1a:	00 00 00 
  813b1d:	be 7b 01 00 00       	mov    $0x17b,%esi
  813b22:	48 bf 87 28 82 00 00 	movabs $0x822887,%rdi
  813b29:	00 00 00 
  813b2c:	b8 00 00 00 00       	mov    $0x0,%eax
  813b31:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  813b38:	00 00 00 
  813b3b:	ff d1                	callq  *%rcx
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  813b3d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  813b42:	74 5c                	je     813ba0 <tcp_enqueue+0xa19>
  813b44:	66 83 7d d0 00       	cmpw   $0x0,-0x30(%rbp)
  813b49:	74 55                	je     813ba0 <tcp_enqueue+0xa19>
  813b4b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813b4f:	48 8b 40 20          	mov    0x20(%rax),%rax
  813b53:	48 85 c0             	test   %rax,%rax
  813b56:	74 48                	je     813ba0 <tcp_enqueue+0xa19>
  813b58:	0f b6 45 94          	movzbl -0x6c(%rbp),%eax
  813b5c:	83 e0 02             	and    $0x2,%eax
  813b5f:	85 c0                	test   %eax,%eax
  813b61:	75 3d                	jne    813ba0 <tcp_enqueue+0xa19>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  813b63:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813b67:	48 8b 58 20          	mov    0x20(%rax),%rbx
  813b6b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813b6f:	48 8b 40 20          	mov    0x20(%rax),%rax
  813b73:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813b77:	0f b7 c0             	movzwl %ax,%eax
  813b7a:	89 c7                	mov    %eax,%edi
  813b7c:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  813b83:	00 00 00 
  813b86:	ff d0                	callq  *%rax
  813b88:	83 c8 08             	or     $0x8,%eax
  813b8b:	0f b7 c0             	movzwl %ax,%eax
  813b8e:	89 c7                	mov    %eax,%edi
  813b90:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  813b97:	00 00 00 
  813b9a:	ff d0                	callq  *%rax
  813b9c:	66 89 43 0c          	mov    %ax,0xc(%rbx)
  }

  return ERR_OK;
  813ba0:	b8 00 00 00 00       	mov    $0x0,%eax
  813ba5:	e9 8a 00 00 00       	jmpq   813c34 <tcp_enqueue+0xaad>
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
  813baa:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813bae:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813bb2:	83 c8 80             	or     $0xffffff80,%eax
  813bb5:	89 c2                	mov    %eax,%edx
  813bb7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813bbb:	88 50 2c             	mov    %dl,0x2c(%rax)
  TCP_STATS_INC(tcp.memerr);

  if (queue != NULL) {
  813bbe:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  813bc3:	74 13                	je     813bd8 <tcp_enqueue+0xa51>
    tcp_segs_free(queue);
  813bc5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813bc9:	48 89 c7             	mov    %rax,%rdi
  813bcc:	48 b8 34 04 81 00 00 	movabs $0x810434,%rax
  813bd3:	00 00 00 
  813bd6:	ff d0                	callq  *%rax
  }
  if (pcb->snd_queuelen != 0) {
  813bd8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813bdc:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  813be0:	66 85 c0             	test   %ax,%ax
  813be3:	74 4a                	je     813c2f <tcp_enqueue+0xaa8>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  813be5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813be9:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  813bf0:	48 85 c0             	test   %rax,%rax
  813bf3:	75 3a                	jne    813c2f <tcp_enqueue+0xaa8>
  813bf5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813bf9:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813c00:	48 85 c0             	test   %rax,%rax
  813c03:	75 2a                	jne    813c2f <tcp_enqueue+0xaa8>
  813c05:	48 ba e0 29 82 00 00 	movabs $0x8229e0,%rdx
  813c0c:	00 00 00 
  813c0f:	be 8e 01 00 00       	mov    $0x18e,%esi
  813c14:	48 bf 87 28 82 00 00 	movabs $0x822887,%rdi
  813c1b:	00 00 00 
  813c1e:	b8 00 00 00 00       	mov    $0x0,%eax
  813c23:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  813c2a:	00 00 00 
  813c2d:	ff d1                	callq  *%rcx
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
  813c2f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  813c34:	48 83 c4 70          	add    $0x70,%rsp
  813c38:	5b                   	pop    %rbx
  813c39:	41 5c                	pop    %r12
  813c3b:	5d                   	pop    %rbp
  813c3c:	c3                   	retq   

0000000000813c3d <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  813c3d:	55                   	push   %rbp
  813c3e:	48 89 e5             	mov    %rsp,%rbp
  813c41:	41 54                	push   %r12
  813c43:	53                   	push   %rbx
  813c44:	48 83 ec 40          	sub    $0x40,%rsp
  813c48:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
  813c4c:	48 b8 50 b0 b5 00 00 	movabs $0xb5b050,%rax
  813c53:	00 00 00 
  813c56:	48 8b 00             	mov    (%rax),%rax
  813c59:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  813c5d:	75 0a                	jne    813c69 <tcp_output+0x2c>
    return ERR_OK;
  813c5f:	b8 00 00 00 00       	mov    $0x0,%eax
  813c64:	e9 c0 06 00 00       	jmpq   814329 <tcp_output+0x6ec>
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  813c69:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813c6d:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  813c71:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813c75:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  813c79:	66 39 c2             	cmp    %ax,%dx
  813c7c:	0f 46 c2             	cmovbe %edx,%eax
  813c7f:	0f b7 c0             	movzwl %ax,%eax
  813c82:	89 45 dc             	mov    %eax,-0x24(%rbp)

  seg = pcb->unsent;
  813c85:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813c89:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813c90:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  813c94:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813c98:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  813c9f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  if (useg != NULL) {
  813ca3:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  813ca8:	74 19                	je     813cc3 <tcp_output+0x86>
    for (; useg->next != NULL; useg = useg->next);
  813caa:	eb 0b                	jmp    813cb7 <tcp_output+0x7a>
  813cac:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813cb0:	48 8b 00             	mov    (%rax),%rax
  813cb3:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  813cb7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813cbb:	48 8b 00             	mov    (%rax),%rax
  813cbe:	48 85 c0             	test   %rax,%rax
  813cc1:	75 e9                	jne    813cac <tcp_output+0x6f>
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  813cc3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813cc7:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813ccb:	0f b6 c0             	movzbl %al,%eax
  813cce:	83 e0 02             	and    $0x2,%eax
  813cd1:	85 c0                	test   %eax,%eax
  813cd3:	0f 84 49 02 00 00    	je     813f22 <tcp_output+0x2e5>
  813cd9:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  813cde:	74 3a                	je     813d1a <tcp_output+0xdd>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
  813ce0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813ce4:	48 8b 40 20          	mov    0x20(%rax),%rax
  813ce8:	8b 40 04             	mov    0x4(%rax),%eax
  813ceb:	89 c7                	mov    %eax,%edi
  813ced:	48 b8 8c 30 81 00 00 	movabs $0x81308c,%rax
  813cf4:	00 00 00 
  813cf7:	ff d0                	callq  *%rax
  813cf9:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  813cfd:	8b 52 54             	mov    0x54(%rdx),%edx
  813d00:	29 d0                	sub    %edx,%eax
  813d02:	89 c2                	mov    %eax,%edx
  813d04:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813d08:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  813d0c:	0f b7 c0             	movzwl %ax,%eax
  813d0f:	01 d0                	add    %edx,%eax
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
  813d11:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  813d14:	0f 86 08 02 00 00    	jbe    813f22 <tcp_output+0x2e5>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  813d1a:	ba 00 00 00 00       	mov    $0x0,%edx
  813d1f:	be 14 00 00 00       	mov    $0x14,%esi
  813d24:	bf 01 00 00 00       	mov    $0x1,%edi
  813d29:	48 b8 61 d4 80 00 00 	movabs $0x80d461,%rax
  813d30:	00 00 00 
  813d33:	ff d0                	callq  *%rax
  813d35:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    if (p == NULL) {
  813d39:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  813d3e:	75 0a                	jne    813d4a <tcp_output+0x10d>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
  813d40:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  813d45:	e9 df 05 00 00       	jmpq   814329 <tcp_output+0x6ec>
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
    /* remove ACK flags from the PCB, as we send an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  813d4a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813d4e:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813d52:	83 e0 fc             	and    $0xfffffffc,%eax
  813d55:	89 c2                	mov    %eax,%edx
  813d57:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813d5b:	88 50 2c             	mov    %dl,0x2c(%rax)

    tcphdr = p->payload;
  813d5e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813d62:	48 8b 40 08          	mov    0x8(%rax),%rax
  813d66:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    tcphdr->src = htons(pcb->local_port);
  813d6a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813d6e:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  813d72:	0f b7 c0             	movzwl %ax,%eax
  813d75:	89 c7                	mov    %eax,%edi
  813d77:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  813d7e:	00 00 00 
  813d81:	ff d0                	callq  *%rax
  813d83:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  813d87:	66 89 02             	mov    %ax,(%rdx)
    tcphdr->dest = htons(pcb->remote_port);
  813d8a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813d8e:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  813d92:	0f b7 c0             	movzwl %ax,%eax
  813d95:	89 c7                	mov    %eax,%edi
  813d97:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  813d9e:	00 00 00 
  813da1:	ff d0                	callq  *%rax
  813da3:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  813da7:	66 89 42 02          	mov    %ax,0x2(%rdx)
    tcphdr->seqno = htonl(pcb->snd_nxt);
  813dab:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813daf:	8b 40 60             	mov    0x60(%rax),%eax
  813db2:	89 c7                	mov    %eax,%edi
  813db4:	48 b8 54 30 81 00 00 	movabs $0x813054,%rax
  813dbb:	00 00 00 
  813dbe:	ff d0                	callq  *%rax
  813dc0:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  813dc4:	89 42 04             	mov    %eax,0x4(%rdx)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
  813dc7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813dcb:	8b 40 30             	mov    0x30(%rax),%eax
  813dce:	89 c7                	mov    %eax,%edi
  813dd0:	48 b8 54 30 81 00 00 	movabs $0x813054,%rax
  813dd7:	00 00 00 
  813dda:	ff d0                	callq  *%rax
  813ddc:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  813de0:	89 42 08             	mov    %eax,0x8(%rdx)
    TCPH_FLAGS_SET(tcphdr, TCP_ACK);
  813de3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813de7:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813deb:	0f b7 c0             	movzwl %ax,%eax
  813dee:	89 c7                	mov    %eax,%edi
  813df0:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  813df7:	00 00 00 
  813dfa:	ff d0                	callq  *%rax
  813dfc:	83 e0 c0             	and    $0xffffffc0,%eax
  813dff:	83 c8 10             	or     $0x10,%eax
  813e02:	0f b7 c0             	movzwl %ax,%eax
  813e05:	89 c7                	mov    %eax,%edi
  813e07:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  813e0e:	00 00 00 
  813e11:	ff d0                	callq  *%rax
  813e13:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  813e17:	66 89 42 0c          	mov    %ax,0xc(%rdx)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  813e1b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813e1f:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  813e23:	0f b7 c0             	movzwl %ax,%eax
  813e26:	89 c7                	mov    %eax,%edi
  813e28:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  813e2f:	00 00 00 
  813e32:	ff d0                	callq  *%rax
  813e34:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  813e38:	66 89 42 0e          	mov    %ax,0xe(%rdx)
    tcphdr->urgp = 0;
  813e3c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813e40:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
    TCPH_HDRLEN_SET(tcphdr, 5);
  813e46:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813e4a:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813e4e:	0f b7 c0             	movzwl %ax,%eax
  813e51:	89 c7                	mov    %eax,%edi
  813e53:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  813e5a:	00 00 00 
  813e5d:	ff d0                	callq  *%rax
  813e5f:	83 e0 3f             	and    $0x3f,%eax
  813e62:	80 cc 50             	or     $0x50,%ah
  813e65:	0f b7 c0             	movzwl %ax,%eax
  813e68:	89 c7                	mov    %eax,%edi
  813e6a:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  813e71:	00 00 00 
  813e74:	ff d0                	callq  *%rax
  813e76:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  813e7a:	66 89 42 0c          	mov    %ax,0xc(%rdx)

    tcphdr->chksum = 0;
  813e7e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813e82:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
          IP_PROTO_TCP, p->tot_len);
  813e88:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813e8c:	0f b7 40 10          	movzwl 0x10(%rax),%eax
    tcphdr->urgp = 0;
    TCPH_HDRLEN_SET(tcphdr, 5);

    tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
  813e90:	0f b7 c8             	movzwl %ax,%ecx
  813e93:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813e97:	48 8d 50 04          	lea    0x4(%rax),%rdx
  813e9b:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  813e9f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813ea3:	41 89 c8             	mov    %ecx,%r8d
  813ea6:	b9 06 00 00 00       	mov    $0x6,%ecx
  813eab:	48 89 c7             	mov    %rax,%rdi
  813eae:	48 b8 cb 27 81 00 00 	movabs $0x8127cb,%rax
  813eb5:	00 00 00 
  813eb8:	ff d0                	callq  *%rax
  813eba:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  813ebe:	66 89 42 10          	mov    %ax,0x10(%rdx)
                     pcb->tos, IP_PROTO_TCP, netif);
        netif->addr_hint = NULL;
      }
    }
#else /* LWIP_NETIF_HWADDRHINT*/
    ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  813ec2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813ec6:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  813eca:	0f b6 c8             	movzbl %al,%ecx
  813ecd:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813ed1:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  813ed5:	0f b6 d0             	movzbl %al,%edx
  813ed8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813edc:	48 8d 78 04          	lea    0x4(%rax),%rdi
  813ee0:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  813ee4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813ee8:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  813eee:	41 89 c8             	mov    %ecx,%r8d
  813ef1:	89 d1                	mov    %edx,%ecx
  813ef3:	48 89 fa             	mov    %rdi,%rdx
  813ef6:	48 89 c7             	mov    %rax,%rdi
  813ef9:	48 b8 c9 15 81 00 00 	movabs $0x8115c9,%rax
  813f00:	00 00 00 
  813f03:	ff d0                	callq  *%rax
        IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
    pbuf_free(p);
  813f05:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813f09:	48 89 c7             	mov    %rax,%rdi
  813f0c:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  813f13:	00 00 00 
  813f16:	ff d0                	callq  *%rax

    return ERR_OK;
  813f18:	b8 00 00 00 00       	mov    $0x0,%eax
  813f1d:	e9 07 04 00 00       	jmpq   814329 <tcp_output+0x6ec>
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  813f22:	e9 39 03 00 00       	jmpq   814260 <tcp_output+0x623>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
  813f27:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813f2b:	48 8b 40 20          	mov    0x20(%rax),%rax
  813f2f:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813f33:	0f b7 c0             	movzwl %ax,%eax
  813f36:	89 c7                	mov    %eax,%edi
  813f38:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  813f3f:	00 00 00 
  813f42:	ff d0                	callq  *%rax
  813f44:	0f b7 c0             	movzwl %ax,%eax
  813f47:	83 e0 04             	and    $0x4,%eax
  813f4a:	85 c0                	test   %eax,%eax
  813f4c:	74 2a                	je     813f78 <tcp_output+0x33b>
  813f4e:	48 ba 00 2a 82 00 00 	movabs $0x822a00,%rdx
  813f55:	00 00 00 
  813f58:	be 06 02 00 00       	mov    $0x206,%esi
  813f5d:	48 bf 87 28 82 00 00 	movabs $0x822887,%rdi
  813f64:	00 00 00 
  813f67:	b8 00 00 00 00       	mov    $0x0,%eax
  813f6c:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  813f73:	00 00 00 
  813f76:	ff d1                	callq  *%rcx
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  813f78:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813f7c:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  813f83:	48 85 c0             	test   %rax,%rax
  813f86:	74 35                	je     813fbd <tcp_output+0x380>
  813f88:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813f8c:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813f90:	0f b6 c0             	movzbl %al,%eax
  813f93:	83 e0 40             	and    $0x40,%eax
  813f96:	85 c0                	test   %eax,%eax
  813f98:	75 23                	jne    813fbd <tcp_output+0x380>
  813f9a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813f9e:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813fa5:	48 85 c0             	test   %rax,%rax
  813fa8:	74 1a                	je     813fc4 <tcp_output+0x387>
  813faa:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813fae:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813fb5:	48 8b 00             	mov    (%rax),%rax
  813fb8:	48 85 c0             	test   %rax,%rax
  813fbb:	74 07                	je     813fc4 <tcp_output+0x387>
  813fbd:	b8 01 00 00 00       	mov    $0x1,%eax
  813fc2:	eb 05                	jmp    813fc9 <tcp_output+0x38c>
  813fc4:	b8 00 00 00 00       	mov    $0x0,%eax
  813fc9:	85 c0                	test   %eax,%eax
  813fcb:	75 19                	jne    813fe6 <tcp_output+0x3a9>
      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
  813fcd:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813fd1:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813fd5:	0f b6 c0             	movzbl %al,%eax
  813fd8:	25 a0 00 00 00       	and    $0xa0,%eax
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  813fdd:	85 c0                	test   %eax,%eax
  813fdf:	75 05                	jne    813fe6 <tcp_output+0x3a9>
      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
      break;
  813fe1:	e9 bb 02 00 00       	jmpq   8142a1 <tcp_output+0x664>
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
  813fe6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813fea:	48 8b 10             	mov    (%rax),%rdx
  813fed:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813ff1:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)

    if (pcb->state != SYN_SENT) {
  813ff8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813ffc:	8b 40 18             	mov    0x18(%rax),%eax
  813fff:	83 f8 02             	cmp    $0x2,%eax
  814002:	74 51                	je     814055 <tcp_output+0x418>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
  814004:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814008:	48 8b 58 20          	mov    0x20(%rax),%rbx
  81400c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814010:	48 8b 40 20          	mov    0x20(%rax),%rax
  814014:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  814018:	0f b7 c0             	movzwl %ax,%eax
  81401b:	89 c7                	mov    %eax,%edi
  81401d:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  814024:	00 00 00 
  814027:	ff d0                	callq  *%rax
  814029:	83 c8 10             	or     $0x10,%eax
  81402c:	0f b7 c0             	movzwl %ax,%eax
  81402f:	89 c7                	mov    %eax,%edi
  814031:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  814038:	00 00 00 
  81403b:	ff d0                	callq  *%rax
  81403d:	66 89 43 0c          	mov    %ax,0xc(%rbx)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  814041:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  814045:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  814049:	83 e0 fc             	and    $0xfffffffc,%eax
  81404c:	89 c2                	mov    %eax,%edx
  81404e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  814052:	88 50 2c             	mov    %dl,0x2c(%rax)
    }

    tcp_output_segment(seg, pcb);
  814055:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  814059:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81405d:	48 89 d6             	mov    %rdx,%rsi
  814060:	48 89 c7             	mov    %rax,%rdi
  814063:	48 b8 32 43 81 00 00 	movabs $0x814332,%rax
  81406a:	00 00 00 
  81406d:	ff d0                	callq  *%rax
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  81406f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814073:	48 8b 40 20          	mov    0x20(%rax),%rax
  814077:	8b 40 04             	mov    0x4(%rax),%eax
  81407a:	89 c7                	mov    %eax,%edi
  81407c:	48 b8 8c 30 81 00 00 	movabs $0x81308c,%rax
  814083:	00 00 00 
  814086:	ff d0                	callq  *%rax
  814088:	89 c3                	mov    %eax,%ebx
  81408a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81408e:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  814092:	44 0f b7 e0          	movzwl %ax,%r12d
  814096:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81409a:	48 8b 40 20          	mov    0x20(%rax),%rax
  81409e:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8140a2:	0f b7 c0             	movzwl %ax,%eax
  8140a5:	89 c7                	mov    %eax,%edi
  8140a7:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  8140ae:	00 00 00 
  8140b1:	ff d0                	callq  *%rax
  8140b3:	0f b7 c0             	movzwl %ax,%eax
  8140b6:	83 e0 01             	and    $0x1,%eax
  8140b9:	85 c0                	test   %eax,%eax
  8140bb:	75 27                	jne    8140e4 <tcp_output+0x4a7>
  8140bd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8140c1:	48 8b 40 20          	mov    0x20(%rax),%rax
  8140c5:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8140c9:	0f b7 c0             	movzwl %ax,%eax
  8140cc:	89 c7                	mov    %eax,%edi
  8140ce:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  8140d5:	00 00 00 
  8140d8:	ff d0                	callq  *%rax
  8140da:	0f b7 c0             	movzwl %ax,%eax
  8140dd:	83 e0 02             	and    $0x2,%eax
  8140e0:	85 c0                	test   %eax,%eax
  8140e2:	74 07                	je     8140eb <tcp_output+0x4ae>
  8140e4:	b8 01 00 00 00       	mov    $0x1,%eax
  8140e9:	eb 05                	jmp    8140f0 <tcp_output+0x4b3>
  8140eb:	b8 00 00 00 00       	mov    $0x0,%eax
  8140f0:	44 01 e0             	add    %r12d,%eax
  8140f3:	8d 14 03             	lea    (%rbx,%rax,1),%edx
  8140f6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8140fa:	89 50 60             	mov    %edx,0x60(%rax)
    if (TCP_SEQ_LT(pcb->snd_max, pcb->snd_nxt)) {
  8140fd:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  814101:	8b 50 64             	mov    0x64(%rax),%edx
  814104:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  814108:	8b 40 60             	mov    0x60(%rax),%eax
  81410b:	29 c2                	sub    %eax,%edx
  81410d:	89 d0                	mov    %edx,%eax
  81410f:	85 c0                	test   %eax,%eax
  814111:	79 0e                	jns    814121 <tcp_output+0x4e4>
      pcb->snd_max = pcb->snd_nxt;
  814113:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  814117:	8b 50 60             	mov    0x60(%rax),%edx
  81411a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81411e:	89 50 64             	mov    %edx,0x64(%rax)
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
  814121:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814125:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  814129:	0f b7 d8             	movzwl %ax,%ebx
  81412c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814130:	48 8b 40 20          	mov    0x20(%rax),%rax
  814134:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  814138:	0f b7 c0             	movzwl %ax,%eax
  81413b:	89 c7                	mov    %eax,%edi
  81413d:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  814144:	00 00 00 
  814147:	ff d0                	callq  *%rax
  814149:	0f b7 c0             	movzwl %ax,%eax
  81414c:	83 e0 01             	and    $0x1,%eax
  81414f:	85 c0                	test   %eax,%eax
  814151:	75 27                	jne    81417a <tcp_output+0x53d>
  814153:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814157:	48 8b 40 20          	mov    0x20(%rax),%rax
  81415b:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81415f:	0f b7 c0             	movzwl %ax,%eax
  814162:	89 c7                	mov    %eax,%edi
  814164:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  81416b:	00 00 00 
  81416e:	ff d0                	callq  *%rax
  814170:	0f b7 c0             	movzwl %ax,%eax
  814173:	83 e0 02             	and    $0x2,%eax
  814176:	85 c0                	test   %eax,%eax
  814178:	74 07                	je     814181 <tcp_output+0x544>
  81417a:	b8 01 00 00 00       	mov    $0x1,%eax
  81417f:	eb 05                	jmp    814186 <tcp_output+0x549>
  814181:	b8 00 00 00 00       	mov    $0x0,%eax
  814186:	01 d8                	add    %ebx,%eax
  814188:	85 c0                	test   %eax,%eax
  81418a:	0f 8e ae 00 00 00    	jle    81423e <tcp_output+0x601>
      seg->next = NULL;
  814190:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814194:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
  81419b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81419f:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8141a6:	48 85 c0             	test   %rax,%rax
  8141a9:	75 1c                	jne    8141c7 <tcp_output+0x58a>
        pcb->unacked = seg;
  8141ab:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8141af:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8141b3:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
        useg = seg;
  8141ba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8141be:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8141c2:	e9 8a 00 00 00       	jmpq   814251 <tcp_output+0x614>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather at the head. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
  8141c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8141cb:	48 8b 40 20          	mov    0x20(%rax),%rax
  8141cf:	8b 40 04             	mov    0x4(%rax),%eax
  8141d2:	89 c7                	mov    %eax,%edi
  8141d4:	48 b8 8c 30 81 00 00 	movabs $0x81308c,%rax
  8141db:	00 00 00 
  8141de:	ff d0                	callq  *%rax
  8141e0:	89 c3                	mov    %eax,%ebx
  8141e2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8141e6:	48 8b 40 20          	mov    0x20(%rax),%rax
  8141ea:	8b 40 04             	mov    0x4(%rax),%eax
  8141ed:	89 c7                	mov    %eax,%edi
  8141ef:	48 b8 8c 30 81 00 00 	movabs $0x81308c,%rax
  8141f6:	00 00 00 
  8141f9:	ff d0                	callq  *%rax
  8141fb:	29 c3                	sub    %eax,%ebx
  8141fd:	89 d8                	mov    %ebx,%eax
  8141ff:	85 c0                	test   %eax,%eax
  814201:	79 23                	jns    814226 <tcp_output+0x5e9>
          /* add segment to head of unacked list */
          seg->next = pcb->unacked;
  814203:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  814207:	48 8b 90 88 00 00 00 	mov    0x88(%rax),%rdx
  81420e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814212:	48 89 10             	mov    %rdx,(%rax)
          pcb->unacked = seg;
  814215:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  814219:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81421d:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
  814224:	eb 2b                	jmp    814251 <tcp_output+0x614>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
  814226:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81422a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81422e:	48 89 10             	mov    %rdx,(%rax)
          useg = useg->next;
  814231:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  814235:	48 8b 00             	mov    (%rax),%rax
  814238:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  81423c:	eb 13                	jmp    814251 <tcp_output+0x614>
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
  81423e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814242:	48 89 c7             	mov    %rax,%rdi
  814245:	48 b8 7c 04 81 00 00 	movabs $0x81047c,%rax
  81424c:	00 00 00 
  81424f:	ff d0                	callq  *%rax
    }
    seg = pcb->unsent;
  814251:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  814255:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81425c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  814260:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  814265:	74 3a                	je     8142a1 <tcp_output+0x664>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
  814267:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81426b:	48 8b 40 20          	mov    0x20(%rax),%rax
  81426f:	8b 40 04             	mov    0x4(%rax),%eax
  814272:	89 c7                	mov    %eax,%edi
  814274:	48 b8 8c 30 81 00 00 	movabs $0x81308c,%rax
  81427b:	00 00 00 
  81427e:	ff d0                	callq  *%rax
  814280:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  814284:	8b 52 54             	mov    0x54(%rdx),%edx
  814287:	29 d0                	sub    %edx,%eax
  814289:	89 c2                	mov    %eax,%edx
  81428b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81428f:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  814293:	0f b7 c0             	movzwl %ax,%eax
  814296:	01 d0                	add    %edx,%eax
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  814298:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  81429b:	0f 86 86 fc ff ff    	jbe    813f27 <tcp_output+0x2ea>
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  8142a1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8142a6:	74 68                	je     814310 <tcp_output+0x6d3>
  8142a8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8142ac:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  8142b3:	84 c0                	test   %al,%al
  8142b5:	75 59                	jne    814310 <tcp_output+0x6d3>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
  8142b7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8142bb:	48 8b 40 20          	mov    0x20(%rax),%rax
  8142bf:	8b 40 04             	mov    0x4(%rax),%eax
  8142c2:	89 c7                	mov    %eax,%edi
  8142c4:	48 b8 8c 30 81 00 00 	movabs $0x81308c,%rax
  8142cb:	00 00 00 
  8142ce:	ff d0                	callq  *%rax
  8142d0:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8142d4:	8b 52 54             	mov    0x54(%rdx),%edx
  8142d7:	29 d0                	sub    %edx,%eax
  8142d9:	89 c2                	mov    %eax,%edx
  8142db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8142df:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8142e3:	0f b7 c0             	movzwl %ax,%eax
  8142e6:	01 c2                	add    %eax,%edx
  8142e8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8142ec:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  8142f0:	0f b7 c0             	movzwl %ax,%eax
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  8142f3:	39 c2                	cmp    %eax,%edx
  8142f5:	76 19                	jbe    814310 <tcp_output+0x6d3>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
    /* prepare for persist timer */
    pcb->persist_cnt = 0;
  8142f7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8142fb:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  814302:	00 00 00 
    pcb->persist_backoff = 1;
  814305:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  814309:	c6 80 d8 00 00 00 01 	movb   $0x1,0xd8(%rax)
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
  814310:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  814314:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  814318:	83 e0 7f             	and    $0x7f,%eax
  81431b:	89 c2                	mov    %eax,%edx
  81431d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  814321:	88 50 2c             	mov    %dl,0x2c(%rax)
  return ERR_OK;
  814324:	b8 00 00 00 00       	mov    $0x0,%eax
}
  814329:	48 83 c4 40          	add    $0x40,%rsp
  81432d:	5b                   	pop    %rbx
  81432e:	41 5c                	pop    %r12
  814330:	5d                   	pop    %rbp
  814331:	c3                   	retq   

0000000000814332 <tcp_output_segment>:
 * @param seg the tcp_seg to send
 * @param pcb the tcp_pcb for the TCP connection used to send the segment
 */
static void
tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb)
{
  814332:	55                   	push   %rbp
  814333:	48 89 e5             	mov    %rsp,%rbp
  814336:	53                   	push   %rbx
  814337:	48 83 ec 28          	sub    $0x28,%rsp
  81433b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  81433f:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
  814343:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814347:	48 8b 58 20          	mov    0x20(%rax),%rbx
  81434b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81434f:	8b 40 30             	mov    0x30(%rax),%eax
  814352:	89 c7                	mov    %eax,%edi
  814354:	48 b8 54 30 81 00 00 	movabs $0x813054,%rax
  81435b:	00 00 00 
  81435e:	ff d0                	callq  *%rax
  814360:	89 43 08             	mov    %eax,0x8(%rbx)

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  814363:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814367:	48 8b 58 20          	mov    0x20(%rax),%rbx
  81436b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81436f:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  814373:	0f b7 c0             	movzwl %ax,%eax
  814376:	89 c7                	mov    %eax,%edi
  814378:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  81437f:	00 00 00 
  814382:	ff d0                	callq  *%rax
  814384:	66 89 43 0e          	mov    %ax,0xe(%rbx)

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
  814388:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81438c:	48 85 c0             	test   %rax,%rax
  81438f:	74 0a                	je     81439b <tcp_output_segment+0x69>
  814391:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  814395:	8b 00                	mov    (%rax),%eax
  814397:	85 c0                	test   %eax,%eax
  814399:	75 48                	jne    8143e3 <tcp_output_segment+0xb1>
    netif = ip_route(&(pcb->remote_ip));
  81439b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81439f:	48 83 c0 04          	add    $0x4,%rax
  8143a3:	48 89 c7             	mov    %rax,%rdi
  8143a6:	48 b8 de 0d 81 00 00 	movabs $0x810dde,%rax
  8143ad:	00 00 00 
  8143b0:	ff d0                	callq  *%rax
  8143b2:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if (netif == NULL) {
  8143b6:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8143bb:	75 05                	jne    8143c2 <tcp_output_segment+0x90>
      return;
  8143bd:	e9 7f 01 00 00       	jmpq   814541 <tcp_output_segment+0x20f>
    }
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  8143c2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8143c6:	48 83 c0 08          	add    $0x8,%rax
  8143ca:	48 85 c0             	test   %rax,%rax
  8143cd:	74 09                	je     8143d8 <tcp_output_segment+0xa6>
  8143cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8143d3:	8b 40 08             	mov    0x8(%rax),%eax
  8143d6:	eb 05                	jmp    8143dd <tcp_output_segment+0xab>
  8143d8:	b8 00 00 00 00       	mov    $0x0,%eax
  8143dd:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8143e1:	89 02                	mov    %eax,(%rdx)
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
  8143e3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8143e7:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  8143eb:	66 83 f8 ff          	cmp    $0xffff,%ax
  8143ef:	75 0a                	jne    8143fb <tcp_output_segment+0xc9>
    pcb->rtime = 0;
  8143f1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8143f5:	66 c7 40 3e 00 00    	movw   $0x0,0x3e(%rax)

  if (pcb->rttest == 0) {
  8143fb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8143ff:	8b 40 44             	mov    0x44(%rax),%eax
  814402:	85 c0                	test   %eax,%eax
  814404:	75 33                	jne    814439 <tcp_output_segment+0x107>
    pcb->rttest = tcp_ticks;
  814406:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  81440d:	00 00 00 
  814410:	8b 10                	mov    (%rax),%edx
  814412:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  814416:	89 50 44             	mov    %edx,0x44(%rax)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
  814419:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81441d:	48 8b 40 20          	mov    0x20(%rax),%rax
  814421:	8b 40 04             	mov    0x4(%rax),%eax
  814424:	89 c7                	mov    %eax,%edi
  814426:	48 b8 8c 30 81 00 00 	movabs $0x81308c,%rax
  81442d:	00 00 00 
  814430:	ff d0                	callq  *%rax
  814432:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  814436:	89 42 48             	mov    %eax,0x48(%rdx)
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
  814439:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81443d:	48 8b 40 20          	mov    0x20(%rax),%rax
  814441:	48 89 c2             	mov    %rax,%rdx
  814444:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814448:	48 8b 40 08          	mov    0x8(%rax),%rax
  81444c:	48 8b 40 08          	mov    0x8(%rax),%rax
  814450:	48 29 c2             	sub    %rax,%rdx
  814453:	48 89 d0             	mov    %rdx,%rax
  814456:	66 89 45 e6          	mov    %ax,-0x1a(%rbp)

  seg->p->len -= len;
  81445a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81445e:	48 8b 40 08          	mov    0x8(%rax),%rax
  814462:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  814466:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81446a:	0f b7 52 12          	movzwl 0x12(%rdx),%edx
  81446e:	66 2b 55 e6          	sub    -0x1a(%rbp),%dx
  814472:	66 89 50 12          	mov    %dx,0x12(%rax)
  seg->p->tot_len -= len;
  814476:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81447a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81447e:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  814482:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  814486:	0f b7 52 10          	movzwl 0x10(%rdx),%edx
  81448a:	66 2b 55 e6          	sub    -0x1a(%rbp),%dx
  81448e:	66 89 50 10          	mov    %dx,0x10(%rax)

  seg->p->payload = seg->tcphdr;
  814492:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814496:	48 8b 40 08          	mov    0x8(%rax),%rax
  81449a:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81449e:	48 8b 52 20          	mov    0x20(%rdx),%rdx
  8144a2:	48 89 50 08          	mov    %rdx,0x8(%rax)

  seg->tcphdr->chksum = 0;
  8144a6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8144aa:	48 8b 40 20          	mov    0x20(%rax),%rax
  8144ae:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  8144b4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8144b8:	48 8b 58 20          	mov    0x20(%rax),%rbx
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
  8144bc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8144c0:	48 8b 40 08          	mov    0x8(%rax),%rax
  8144c4:	0f b7 40 10          	movzwl 0x10(%rax),%eax

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  8144c8:	0f b7 c8             	movzwl %ax,%ecx
  8144cb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8144cf:	48 8d 50 04          	lea    0x4(%rax),%rdx
  8144d3:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8144d7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8144db:	48 8b 40 08          	mov    0x8(%rax),%rax
  8144df:	41 89 c8             	mov    %ecx,%r8d
  8144e2:	b9 06 00 00 00       	mov    $0x6,%ecx
  8144e7:	48 89 c7             	mov    %rax,%rdi
  8144ea:	48 b8 cb 27 81 00 00 	movabs $0x8127cb,%rax
  8144f1:	00 00 00 
  8144f4:	ff d0                	callq  *%rax
  8144f6:	66 89 43 10          	mov    %ax,0x10(%rbx)
                   pcb->tos, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  8144fa:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8144fe:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  814502:	0f b6 c8             	movzbl %al,%ecx
  814505:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  814509:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  81450d:	0f b6 d0             	movzbl %al,%edx
  814510:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  814514:	48 8d 78 04          	lea    0x4(%rax),%rdi
  814518:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  81451c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814520:	48 8b 40 08          	mov    0x8(%rax),%rax
  814524:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  81452a:	41 89 c8             	mov    %ecx,%r8d
  81452d:	89 d1                	mov    %edx,%ecx
  81452f:	48 89 fa             	mov    %rdi,%rdx
  814532:	48 89 c7             	mov    %rax,%rdi
  814535:	48 b8 c9 15 81 00 00 	movabs $0x8115c9,%rax
  81453c:	00 00 00 
  81453f:	ff d0                	callq  *%rax
      IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
}
  814541:	48 83 c4 28          	add    $0x28,%rsp
  814545:	5b                   	pop    %rbx
  814546:	5d                   	pop    %rbp
  814547:	c3                   	retq   

0000000000814548 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  814548:	55                   	push   %rbp
  814549:	48 89 e5             	mov    %rsp,%rbp
  81454c:	48 83 ec 30          	sub    $0x30,%rsp
  814550:	89 7d ec             	mov    %edi,-0x14(%rbp)
  814553:	89 75 e8             	mov    %esi,-0x18(%rbp)
  814556:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  81455a:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
  81455e:	44 89 c2             	mov    %r8d,%edx
  814561:	44 89 c8             	mov    %r9d,%eax
  814564:	66 89 55 d4          	mov    %dx,-0x2c(%rbp)
  814568:	66 89 45 d0          	mov    %ax,-0x30(%rbp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  81456c:	ba 00 00 00 00       	mov    $0x0,%edx
  814571:	be 14 00 00 00       	mov    $0x14,%esi
  814576:	bf 01 00 00 00       	mov    $0x1,%edi
  81457b:	48 b8 61 d4 80 00 00 	movabs $0x80d461,%rax
  814582:	00 00 00 
  814585:	ff d0                	callq  *%rax
  814587:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (p == NULL) {
  81458b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  814590:	75 05                	jne    814597 <tcp_rst+0x4f>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  814592:	e9 b9 01 00 00       	jmpq   814750 <tcp_rst+0x208>
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  814597:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81459b:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81459f:	66 83 f8 13          	cmp    $0x13,%ax
  8145a3:	77 2a                	ja     8145cf <tcp_rst+0x87>
  8145a5:	48 ba 18 2a 82 00 00 	movabs $0x822a18,%rdx
  8145ac:	00 00 00 
  8145af:	be bf 02 00 00       	mov    $0x2bf,%esi
  8145b4:	48 bf 87 28 82 00 00 	movabs $0x822887,%rdi
  8145bb:	00 00 00 
  8145be:	b8 00 00 00 00       	mov    $0x0,%eax
  8145c3:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  8145ca:	00 00 00 
  8145cd:	ff d1                	callq  *%rcx
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  8145cf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8145d3:	48 8b 40 08          	mov    0x8(%rax),%rax
  8145d7:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  tcphdr->src = htons(local_port);
  8145db:	0f b7 45 d4          	movzwl -0x2c(%rbp),%eax
  8145df:	89 c7                	mov    %eax,%edi
  8145e1:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  8145e8:	00 00 00 
  8145eb:	ff d0                	callq  *%rax
  8145ed:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8145f1:	66 89 02             	mov    %ax,(%rdx)
  tcphdr->dest = htons(remote_port);
  8145f4:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  8145f8:	89 c7                	mov    %eax,%edi
  8145fa:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  814601:	00 00 00 
  814604:	ff d0                	callq  *%rax
  814606:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81460a:	66 89 42 02          	mov    %ax,0x2(%rdx)
  tcphdr->seqno = htonl(seqno);
  81460e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  814611:	89 c7                	mov    %eax,%edi
  814613:	48 b8 54 30 81 00 00 	movabs $0x813054,%rax
  81461a:	00 00 00 
  81461d:	ff d0                	callq  *%rax
  81461f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  814623:	89 42 04             	mov    %eax,0x4(%rdx)
  tcphdr->ackno = htonl(ackno);
  814626:	8b 45 e8             	mov    -0x18(%rbp),%eax
  814629:	89 c7                	mov    %eax,%edi
  81462b:	48 b8 54 30 81 00 00 	movabs $0x813054,%rax
  814632:	00 00 00 
  814635:	ff d0                	callq  *%rax
  814637:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81463b:	89 42 08             	mov    %eax,0x8(%rdx)
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
  81463e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814642:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  814646:	0f b7 c0             	movzwl %ax,%eax
  814649:	89 c7                	mov    %eax,%edi
  81464b:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  814652:	00 00 00 
  814655:	ff d0                	callq  *%rax
  814657:	83 e0 c0             	and    $0xffffffc0,%eax
  81465a:	83 c8 14             	or     $0x14,%eax
  81465d:	0f b7 c0             	movzwl %ax,%eax
  814660:	89 c7                	mov    %eax,%edi
  814662:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  814669:	00 00 00 
  81466c:	ff d0                	callq  *%rax
  81466e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  814672:	66 89 42 0c          	mov    %ax,0xc(%rdx)
  tcphdr->wnd = htons(TCP_WND);
  814676:	bf c0 5d 00 00       	mov    $0x5dc0,%edi
  81467b:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  814682:	00 00 00 
  814685:	ff d0                	callq  *%rax
  814687:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81468b:	66 89 42 0e          	mov    %ax,0xe(%rdx)
  tcphdr->urgp = 0;
  81468f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814693:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
  TCPH_HDRLEN_SET(tcphdr, 5);
  814699:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81469d:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8146a1:	0f b7 c0             	movzwl %ax,%eax
  8146a4:	89 c7                	mov    %eax,%edi
  8146a6:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  8146ad:	00 00 00 
  8146b0:	ff d0                	callq  *%rax
  8146b2:	83 e0 3f             	and    $0x3f,%eax
  8146b5:	80 cc 50             	or     $0x50,%ah
  8146b8:	0f b7 c0             	movzwl %ax,%eax
  8146bb:	89 c7                	mov    %eax,%edi
  8146bd:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  8146c4:	00 00 00 
  8146c7:	ff d0                	callq  *%rax
  8146c9:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8146cd:	66 89 42 0c          	mov    %ax,0xc(%rdx)

  tcphdr->chksum = 0;
  8146d1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8146d5:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
              IP_PROTO_TCP, p->tot_len);
  8146db:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8146df:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  tcphdr->urgp = 0;
  TCPH_HDRLEN_SET(tcphdr, 5);

  tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
  8146e3:	0f b7 c8             	movzwl %ax,%ecx
  8146e6:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8146ea:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  8146ee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8146f2:	41 89 c8             	mov    %ecx,%r8d
  8146f5:	b9 06 00 00 00       	mov    $0x6,%ecx
  8146fa:	48 89 c7             	mov    %rax,%rdi
  8146fd:	48 b8 cb 27 81 00 00 	movabs $0x8127cb,%rax
  814704:	00 00 00 
  814707:	ff d0                	callq  *%rax
  814709:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81470d:	66 89 42 10          	mov    %ax,0x10(%rdx)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  814711:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  814715:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  814719:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81471d:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  814723:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  814729:	b9 ff 00 00 00       	mov    $0xff,%ecx
  81472e:	48 89 c7             	mov    %rax,%rdi
  814731:	48 b8 c9 15 81 00 00 	movabs $0x8115c9,%rax
  814738:	00 00 00 
  81473b:	ff d0                	callq  *%rax
  pbuf_free(p);
  81473d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814741:	48 89 c7             	mov    %rax,%rdi
  814744:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  81474b:	00 00 00 
  81474e:	ff d0                	callq  *%rax
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
  814750:	c9                   	leaveq 
  814751:	c3                   	retq   

0000000000814752 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  814752:	55                   	push   %rbp
  814753:	48 89 e5             	mov    %rsp,%rbp
  814756:	48 83 ec 20          	sub    $0x20,%rsp
  81475a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  81475e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814762:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  814769:	48 85 c0             	test   %rax,%rax
  81476c:	75 05                	jne    814773 <tcp_rexmit_rto+0x21>
    return;
  81476e:	e9 b6 00 00 00       	jmpq   814829 <tcp_rexmit_rto+0xd7>
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  814773:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814777:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81477e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  814782:	eb 0b                	jmp    81478f <tcp_rexmit_rto+0x3d>
  814784:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814788:	48 8b 00             	mov    (%rax),%rax
  81478b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  81478f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814793:	48 8b 00             	mov    (%rax),%rax
  814796:	48 85 c0             	test   %rax,%rax
  814799:	75 e9                	jne    814784 <tcp_rexmit_rto+0x32>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  81479b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81479f:	48 8b 90 80 00 00 00 	mov    0x80(%rax),%rdx
  8147a6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8147aa:	48 89 10             	mov    %rdx,(%rax)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  8147ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8147b1:	48 8b 90 88 00 00 00 	mov    0x88(%rax),%rdx
  8147b8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8147bc:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  8147c3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8147c7:	48 c7 80 88 00 00 00 	movq   $0x0,0x88(%rax)
  8147ce:	00 00 00 00 

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  8147d2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8147d6:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8147dd:	48 8b 40 20          	mov    0x20(%rax),%rax
  8147e1:	8b 40 04             	mov    0x4(%rax),%eax
  8147e4:	89 c7                	mov    %eax,%edi
  8147e6:	48 b8 8c 30 81 00 00 	movabs $0x81308c,%rax
  8147ed:	00 00 00 
  8147f0:	ff d0                	callq  *%rax
  8147f2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8147f6:	89 42 60             	mov    %eax,0x60(%rdx)
  /* increment number of retransmissions */
  ++pcb->nrtx;
  8147f9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8147fd:	0f b6 40 52          	movzbl 0x52(%rax),%eax
  814801:	8d 50 01             	lea    0x1(%rax),%edx
  814804:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814808:	88 50 52             	mov    %dl,0x52(%rax)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
  81480b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81480f:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%rax)

  /* Do the actual retransmission */
  tcp_output(pcb);
  814816:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81481a:	48 89 c7             	mov    %rax,%rdi
  81481d:	48 b8 3d 3c 81 00 00 	movabs $0x813c3d,%rax
  814824:	00 00 00 
  814827:	ff d0                	callq  *%rax
}
  814829:	c9                   	leaveq 
  81482a:	c3                   	retq   

000000000081482b <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
  81482b:	55                   	push   %rbp
  81482c:	48 89 e5             	mov    %rsp,%rbp
  81482f:	48 83 ec 20          	sub    $0x20,%rsp
  814833:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  814837:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81483b:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  814842:	48 85 c0             	test   %rax,%rax
  814845:	75 05                	jne    81484c <tcp_rexmit+0x21>
    return;
  814847:	e9 a7 00 00 00       	jmpq   8148f3 <tcp_rexmit+0xc8>
  }

  /* Move the first unacked segment to the unsent queue */
  seg = pcb->unacked->next;
  81484c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814850:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  814857:	48 8b 00             	mov    (%rax),%rax
  81485a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  pcb->unacked->next = pcb->unsent;
  81485e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814862:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  814869:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81486d:	48 8b 92 80 00 00 00 	mov    0x80(%rdx),%rdx
  814874:	48 89 10             	mov    %rdx,(%rax)
  pcb->unsent = pcb->unacked;
  814877:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81487b:	48 8b 90 88 00 00 00 	mov    0x88(%rax),%rdx
  814882:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814886:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
  pcb->unacked = seg;
  81488d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814891:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  814895:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  81489c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8148a0:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8148a7:	48 8b 40 20          	mov    0x20(%rax),%rax
  8148ab:	8b 40 04             	mov    0x4(%rax),%eax
  8148ae:	89 c7                	mov    %eax,%edi
  8148b0:	48 b8 8c 30 81 00 00 	movabs $0x81308c,%rax
  8148b7:	00 00 00 
  8148ba:	ff d0                	callq  *%rax
  8148bc:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8148c0:	89 42 60             	mov    %eax,0x60(%rdx)

  ++pcb->nrtx;
  8148c3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8148c7:	0f b6 40 52          	movzbl 0x52(%rax),%eax
  8148cb:	8d 50 01             	lea    0x1(%rax),%edx
  8148ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8148d2:	88 50 52             	mov    %dl,0x52(%rax)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
  8148d5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8148d9:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%rax)

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
  8148e0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8148e4:	48 89 c7             	mov    %rax,%rdi
  8148e7:	48 b8 3d 3c 81 00 00 	movabs $0x813c3d,%rax
  8148ee:	00 00 00 
  8148f1:	ff d0                	callq  *%rax
}
  8148f3:	c9                   	leaveq 
  8148f4:	c3                   	retq   

00000000008148f5 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
  8148f5:	55                   	push   %rbp
  8148f6:	48 89 e5             	mov    %rsp,%rbp
  8148f9:	48 83 ec 20          	sub    $0x20,%rsp
  8148fd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  814901:	ba 00 00 00 00       	mov    $0x0,%edx
  814906:	be 14 00 00 00       	mov    $0x14,%esi
  81490b:	bf 01 00 00 00       	mov    $0x1,%edi
  814910:	48 b8 61 d4 80 00 00 	movabs $0x80d461,%rax
  814917:	00 00 00 
  81491a:	ff d0                	callq  *%rax
  81491c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
   
  if(p == NULL) {
  814920:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  814925:	75 05                	jne    81492c <tcp_keepalive+0x37>
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  814927:	e9 ec 01 00 00       	jmpq   814b18 <tcp_keepalive+0x223>
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  81492c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814930:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  814934:	66 83 f8 13          	cmp    $0x13,%ax
  814938:	77 2a                	ja     814964 <tcp_keepalive+0x6f>
  81493a:	48 ba 18 2a 82 00 00 	movabs $0x822a18,%rdx
  814941:	00 00 00 
  814944:	be 3b 03 00 00       	mov    $0x33b,%esi
  814949:	48 bf 87 28 82 00 00 	movabs $0x822887,%rdi
  814950:	00 00 00 
  814953:	b8 00 00 00 00       	mov    $0x0,%eax
  814958:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81495f:	00 00 00 
  814962:	ff d1                	callq  *%rcx
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  814964:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814968:	48 8b 40 08          	mov    0x8(%rax),%rax
  81496c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  tcphdr->src = htons(pcb->local_port);
  814970:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814974:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  814978:	0f b7 c0             	movzwl %ax,%eax
  81497b:	89 c7                	mov    %eax,%edi
  81497d:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  814984:	00 00 00 
  814987:	ff d0                	callq  *%rax
  814989:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81498d:	66 89 02             	mov    %ax,(%rdx)
  tcphdr->dest = htons(pcb->remote_port);
  814990:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814994:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  814998:	0f b7 c0             	movzwl %ax,%eax
  81499b:	89 c7                	mov    %eax,%edi
  81499d:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  8149a4:	00 00 00 
  8149a7:	ff d0                	callq  *%rax
  8149a9:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8149ad:	66 89 42 02          	mov    %ax,0x2(%rdx)
  tcphdr->seqno = htonl(pcb->snd_nxt - 1);
  8149b1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8149b5:	8b 40 60             	mov    0x60(%rax),%eax
  8149b8:	83 e8 01             	sub    $0x1,%eax
  8149bb:	89 c7                	mov    %eax,%edi
  8149bd:	48 b8 54 30 81 00 00 	movabs $0x813054,%rax
  8149c4:	00 00 00 
  8149c7:	ff d0                	callq  *%rax
  8149c9:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8149cd:	89 42 04             	mov    %eax,0x4(%rdx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  8149d0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8149d4:	8b 40 30             	mov    0x30(%rax),%eax
  8149d7:	89 c7                	mov    %eax,%edi
  8149d9:	48 b8 54 30 81 00 00 	movabs $0x813054,%rax
  8149e0:	00 00 00 
  8149e3:	ff d0                	callq  *%rax
  8149e5:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8149e9:	89 42 08             	mov    %eax,0x8(%rdx)
  TCPH_FLAGS_SET(tcphdr, 0);
  8149ec:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8149f0:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8149f4:	0f b7 c0             	movzwl %ax,%eax
  8149f7:	89 c7                	mov    %eax,%edi
  8149f9:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  814a00:	00 00 00 
  814a03:	ff d0                	callq  *%rax
  814a05:	0f b7 c0             	movzwl %ax,%eax
  814a08:	25 c0 ff 00 00       	and    $0xffc0,%eax
  814a0d:	89 c7                	mov    %eax,%edi
  814a0f:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  814a16:	00 00 00 
  814a19:	ff d0                	callq  *%rax
  814a1b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  814a1f:	66 89 42 0c          	mov    %ax,0xc(%rdx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  814a23:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814a27:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  814a2b:	0f b7 c0             	movzwl %ax,%eax
  814a2e:	89 c7                	mov    %eax,%edi
  814a30:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  814a37:	00 00 00 
  814a3a:	ff d0                	callq  *%rax
  814a3c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  814a40:	66 89 42 0e          	mov    %ax,0xe(%rdx)
  tcphdr->urgp = 0;
  814a44:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814a48:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
  TCPH_HDRLEN_SET(tcphdr, 5);
  814a4e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814a52:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  814a56:	0f b7 c0             	movzwl %ax,%eax
  814a59:	89 c7                	mov    %eax,%edi
  814a5b:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  814a62:	00 00 00 
  814a65:	ff d0                	callq  *%rax
  814a67:	83 e0 3f             	and    $0x3f,%eax
  814a6a:	80 cc 50             	or     $0x50,%ah
  814a6d:	0f b7 c0             	movzwl %ax,%eax
  814a70:	89 c7                	mov    %eax,%edi
  814a72:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  814a79:	00 00 00 
  814a7c:	ff d0                	callq  *%rax
  814a7e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  814a82:	66 89 42 0c          	mov    %ax,0xc(%rdx)

  tcphdr->chksum = 0;
  814a86:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814a8a:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
                                      IP_PROTO_TCP, p->tot_len);
  814a90:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814a94:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  tcphdr->urgp = 0;
  TCPH_HDRLEN_SET(tcphdr, 5);

  tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  814a98:	0f b7 c8             	movzwl %ax,%ecx
  814a9b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814a9f:	48 8d 50 04          	lea    0x4(%rax),%rdx
  814aa3:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  814aa7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814aab:	41 89 c8             	mov    %ecx,%r8d
  814aae:	b9 06 00 00 00       	mov    $0x6,%ecx
  814ab3:	48 89 c7             	mov    %rax,%rdi
  814ab6:	48 b8 cb 27 81 00 00 	movabs $0x8127cb,%rax
  814abd:	00 00 00 
  814ac0:	ff d0                	callq  *%rax
  814ac2:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  814ac6:	66 89 42 10          	mov    %ax,0x10(%rdx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  814aca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814ace:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  814ad2:	0f b6 d0             	movzbl %al,%edx
  814ad5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814ad9:	48 8d 78 04          	lea    0x4(%rax),%rdi
  814add:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  814ae1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814ae5:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  814aeb:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  814af1:	89 d1                	mov    %edx,%ecx
  814af3:	48 89 fa             	mov    %rdi,%rdx
  814af6:	48 89 c7             	mov    %rax,%rdi
  814af9:	48 b8 c9 15 81 00 00 	movabs $0x8115c9,%rax
  814b00:	00 00 00 
  814b03:	ff d0                	callq  *%rax
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  814b05:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814b09:	48 89 c7             	mov    %rax,%rdi
  814b0c:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  814b13:	00 00 00 
  814b16:	ff d0                	callq  *%rax

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  814b18:	c9                   	leaveq 
  814b19:	c3                   	retq   

0000000000814b1a <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
  814b1a:	55                   	push   %rbp
  814b1b:	48 89 e5             	mov    %rsp,%rbp
  814b1e:	48 83 ec 30          	sub    $0x30,%rsp
  814b22:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
  814b26:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814b2a:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  814b31:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  if(seg == NULL)
  814b35:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  814b3a:	75 0f                	jne    814b4b <tcp_zero_window_probe+0x31>
    seg = pcb->unsent;
  814b3c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814b40:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  814b47:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  if(seg == NULL)
  814b4b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  814b50:	75 05                	jne    814b57 <tcp_zero_window_probe+0x3d>
    return;
  814b52:	e9 23 02 00 00       	jmpq   814d7a <tcp_zero_window_probe+0x260>

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
  814b57:	ba 00 00 00 00       	mov    $0x0,%edx
  814b5c:	be 15 00 00 00       	mov    $0x15,%esi
  814b61:	bf 01 00 00 00       	mov    $0x1,%edi
  814b66:	48 b8 61 d4 80 00 00 	movabs $0x80d461,%rax
  814b6d:	00 00 00 
  814b70:	ff d0                	callq  *%rax
  814b72:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
   
  if(p == NULL) {
  814b76:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  814b7b:	75 05                	jne    814b82 <tcp_zero_window_probe+0x68>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  814b7d:	e9 f8 01 00 00       	jmpq   814d7a <tcp_zero_window_probe+0x260>
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  814b82:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814b86:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  814b8a:	66 83 f8 13          	cmp    $0x13,%ax
  814b8e:	77 2a                	ja     814bba <tcp_zero_window_probe+0xa0>
  814b90:	48 ba 18 2a 82 00 00 	movabs $0x822a18,%rdx
  814b97:	00 00 00 
  814b9a:	be 8e 03 00 00       	mov    $0x38e,%esi
  814b9f:	48 bf 87 28 82 00 00 	movabs $0x822887,%rdi
  814ba6:	00 00 00 
  814ba9:	b8 00 00 00 00       	mov    $0x0,%eax
  814bae:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  814bb5:	00 00 00 
  814bb8:	ff d1                	callq  *%rcx
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  814bba:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814bbe:	48 8b 40 08          	mov    0x8(%rax),%rax
  814bc2:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  tcphdr->src = htons(pcb->local_port);
  814bc6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814bca:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  814bce:	0f b7 c0             	movzwl %ax,%eax
  814bd1:	89 c7                	mov    %eax,%edi
  814bd3:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  814bda:	00 00 00 
  814bdd:	ff d0                	callq  *%rax
  814bdf:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  814be3:	66 89 02             	mov    %ax,(%rdx)
  tcphdr->dest = htons(pcb->remote_port);
  814be6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814bea:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  814bee:	0f b7 c0             	movzwl %ax,%eax
  814bf1:	89 c7                	mov    %eax,%edi
  814bf3:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  814bfa:	00 00 00 
  814bfd:	ff d0                	callq  *%rax
  814bff:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  814c03:	66 89 42 02          	mov    %ax,0x2(%rdx)
  tcphdr->seqno = seg->tcphdr->seqno;
  814c07:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814c0b:	48 8b 40 20          	mov    0x20(%rax),%rax
  814c0f:	8b 50 04             	mov    0x4(%rax),%edx
  814c12:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814c16:	89 50 04             	mov    %edx,0x4(%rax)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  814c19:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814c1d:	8b 40 30             	mov    0x30(%rax),%eax
  814c20:	89 c7                	mov    %eax,%edi
  814c22:	48 b8 54 30 81 00 00 	movabs $0x813054,%rax
  814c29:	00 00 00 
  814c2c:	ff d0                	callq  *%rax
  814c2e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  814c32:	89 42 08             	mov    %eax,0x8(%rdx)
  TCPH_FLAGS_SET(tcphdr, 0);
  814c35:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814c39:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  814c3d:	0f b7 c0             	movzwl %ax,%eax
  814c40:	89 c7                	mov    %eax,%edi
  814c42:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  814c49:	00 00 00 
  814c4c:	ff d0                	callq  *%rax
  814c4e:	0f b7 c0             	movzwl %ax,%eax
  814c51:	25 c0 ff 00 00       	and    $0xffc0,%eax
  814c56:	89 c7                	mov    %eax,%edi
  814c58:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  814c5f:	00 00 00 
  814c62:	ff d0                	callq  *%rax
  814c64:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  814c68:	66 89 42 0c          	mov    %ax,0xc(%rdx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  814c6c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814c70:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  814c74:	0f b7 c0             	movzwl %ax,%eax
  814c77:	89 c7                	mov    %eax,%edi
  814c79:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  814c80:	00 00 00 
  814c83:	ff d0                	callq  *%rax
  814c85:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  814c89:	66 89 42 0e          	mov    %ax,0xe(%rdx)
  tcphdr->urgp = 0;
  814c8d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814c91:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
  TCPH_HDRLEN_SET(tcphdr, 5);
  814c97:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814c9b:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  814c9f:	0f b7 c0             	movzwl %ax,%eax
  814ca2:	89 c7                	mov    %eax,%edi
  814ca4:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  814cab:	00 00 00 
  814cae:	ff d0                	callq  *%rax
  814cb0:	83 e0 3f             	and    $0x3f,%eax
  814cb3:	80 cc 50             	or     $0x50,%ah
  814cb6:	0f b7 c0             	movzwl %ax,%eax
  814cb9:	89 c7                	mov    %eax,%edi
  814cbb:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  814cc2:	00 00 00 
  814cc5:	ff d0                	callq  *%rax
  814cc7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  814ccb:	66 89 42 0c          	mov    %ax,0xc(%rdx)

  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
  814ccf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814cd3:	48 8b 40 08          	mov    0x8(%rax),%rax
  814cd7:	48 8d 50 14          	lea    0x14(%rax),%rdx
  814cdb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814cdf:	48 8b 40 10          	mov    0x10(%rax),%rax
  814ce3:	0f b6 00             	movzbl (%rax),%eax
  814ce6:	88 02                	mov    %al,(%rdx)

  tcphdr->chksum = 0;
  814ce8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814cec:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
                                      IP_PROTO_TCP, p->tot_len);
  814cf2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814cf6:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;

  tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  814cfa:	0f b7 c8             	movzwl %ax,%ecx
  814cfd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814d01:	48 8d 50 04          	lea    0x4(%rax),%rdx
  814d05:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  814d09:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814d0d:	41 89 c8             	mov    %ecx,%r8d
  814d10:	b9 06 00 00 00       	mov    $0x6,%ecx
  814d15:	48 89 c7             	mov    %rax,%rdi
  814d18:	48 b8 cb 27 81 00 00 	movabs $0x8127cb,%rax
  814d1f:	00 00 00 
  814d22:	ff d0                	callq  *%rax
  814d24:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  814d28:	66 89 42 10          	mov    %ax,0x10(%rdx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  814d2c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814d30:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  814d34:	0f b6 d0             	movzbl %al,%edx
  814d37:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814d3b:	48 8d 78 04          	lea    0x4(%rax),%rdi
  814d3f:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  814d43:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814d47:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  814d4d:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  814d53:	89 d1                	mov    %edx,%ecx
  814d55:	48 89 fa             	mov    %rdi,%rdx
  814d58:	48 89 c7             	mov    %rax,%rdi
  814d5b:	48 b8 c9 15 81 00 00 	movabs $0x8115c9,%rax
  814d62:	00 00 00 
  814d65:	ff d0                	callq  *%rax
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  814d67:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814d6b:	48 89 c7             	mov    %rax,%rdi
  814d6e:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  814d75:	00 00 00 
  814d78:	ff d0                	callq  *%rax

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  814d7a:	c9                   	leaveq 
  814d7b:	c3                   	retq   

0000000000814d7c <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
  814d7c:	55                   	push   %rbp
  814d7d:	48 89 e5             	mov    %rsp,%rbp
  814d80:	53                   	push   %rbx
  814d81:	48 83 ec 58          	sub    $0x58,%rsp
  814d85:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  814d89:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = p->payload;
  814d8d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814d91:	48 8b 40 08          	mov    0x8(%rax),%rax
  814d95:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
  814d99:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814d9d:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  814da1:	0f b7 d8             	movzwl %ax,%ebx
  814da4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814da8:	0f b7 00             	movzwl (%rax),%eax
  814dab:	0f b7 c0             	movzwl %ax,%eax
  814dae:	89 c7                	mov    %eax,%edi
  814db0:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  814db7:	00 00 00 
  814dba:	ff d0                	callq  *%rax
  814dbc:	66 c1 e8 08          	shr    $0x8,%ax
  814dc0:	0f b7 c0             	movzwl %ax,%eax
  814dc3:	83 e0 0f             	and    $0xf,%eax
  814dc6:	83 c0 02             	add    $0x2,%eax
  814dc9:	c1 e0 02             	shl    $0x2,%eax
  814dcc:	39 c3                	cmp    %eax,%ebx
  814dce:	7c 40                	jl     814e10 <udp_input+0x94>
  814dd0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814dd4:	0f b7 00             	movzwl (%rax),%eax
  814dd7:	0f b7 c0             	movzwl %ax,%eax
  814dda:	89 c7                	mov    %eax,%edi
  814ddc:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  814de3:	00 00 00 
  814de6:	ff d0                	callq  *%rax
  814de8:	66 c1 e8 08          	shr    $0x8,%ax
  814dec:	83 e0 0f             	and    $0xf,%eax
  814def:	c1 e0 02             	shl    $0x2,%eax
  814df2:	f7 d8                	neg    %eax
  814df4:	0f bf d0             	movswl %ax,%edx
  814df7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814dfb:	89 d6                	mov    %edx,%esi
  814dfd:	48 89 c7             	mov    %rax,%rdi
  814e00:	48 b8 7f db 80 00 00 	movabs $0x80db7f,%rax
  814e07:	00 00 00 
  814e0a:	ff d0                	callq  *%rax
  814e0c:	84 c0                	test   %al,%al
  814e0e:	74 18                	je     814e28 <udp_input+0xac>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
  814e10:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814e14:	48 89 c7             	mov    %rax,%rdi
  814e17:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  814e1e:	00 00 00 
  814e21:	ff d0                	callq  *%rax
    goto end;
  814e23:	e9 62 04 00 00       	jmpq   81528a <udp_input+0x50e>
  }

  udphdr = (struct udp_hdr *)p->payload;
  814e28:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814e2c:	48 8b 40 08          	mov    0x8(%rax),%rax
  814e30:	48 89 45 c0          	mov    %rax,-0x40(%rbp)

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
  814e34:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  814e38:	0f b7 00             	movzwl (%rax),%eax
  814e3b:	0f b7 c0             	movzwl %ax,%eax
  814e3e:	89 c7                	mov    %eax,%edi
  814e40:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  814e47:	00 00 00 
  814e4a:	ff d0                	callq  *%rax
  814e4c:	66 89 45 be          	mov    %ax,-0x42(%rbp)
  dest = ntohs(udphdr->dest);
  814e50:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  814e54:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  814e58:	0f b7 c0             	movzwl %ax,%eax
  814e5b:	89 c7                	mov    %eax,%edi
  814e5d:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  814e64:	00 00 00 
  814e67:	ff d0                	callq  *%rax
  814e69:	66 89 45 bc          	mov    %ax,-0x44(%rbp)
               ip4_addr3(&iphdr->dest), ip4_addr4(&iphdr->dest), ntohs(udphdr->dest),
               ip4_addr1(&iphdr->src), ip4_addr2(&iphdr->src),
               ip4_addr3(&iphdr->src), ip4_addr4(&iphdr->src), ntohs(udphdr->src)));

#if LWIP_DHCP
  pcb = NULL;
  814e6d:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  814e74:	00 
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
  814e75:	66 83 7d bc 44       	cmpw   $0x44,-0x44(%rbp)
  814e7a:	0f 85 8c 00 00 00    	jne    814f0c <udp_input+0x190>
    /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    if (src == DHCP_SERVER_PORT) {
  814e80:	66 83 7d be 43       	cmpw   $0x43,-0x42(%rbp)
  814e85:	0f 85 d3 01 00 00    	jne    81505e <udp_input+0x2e2>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
  814e8b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814e8f:	48 8b 40 38          	mov    0x38(%rax),%rax
  814e93:	48 85 c0             	test   %rax,%rax
  814e96:	0f 84 c2 01 00 00    	je     81505e <udp_input+0x2e2>
  814e9c:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814ea0:	48 8b 40 38          	mov    0x38(%rax),%rax
  814ea4:	48 8b 40 08          	mov    0x8(%rax),%rax
  814ea8:	48 85 c0             	test   %rax,%rax
  814eab:	0f 84 ad 01 00 00    	je     81505e <udp_input+0x2e2>
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  814eb1:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814eb5:	48 8b 40 38          	mov    0x38(%rax),%rax
  814eb9:	48 8b 40 08          	mov    0x8(%rax),%rax
  814ebd:	48 83 c0 04          	add    $0x4,%rax
  814ec1:	48 85 c0             	test   %rax,%rax
  814ec4:	74 31                	je     814ef7 <udp_input+0x17b>
  814ec6:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814eca:	48 8b 40 38          	mov    0x38(%rax),%rax
  814ece:	48 8b 40 08          	mov    0x8(%rax),%rax
  814ed2:	8b 40 04             	mov    0x4(%rax),%eax
  814ed5:	85 c0                	test   %eax,%eax
  814ed7:	74 1e                	je     814ef7 <udp_input+0x17b>
           ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &(iphdr->src)))) {
  814ed9:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814edd:	48 8b 40 38          	mov    0x38(%rax),%rax
  814ee1:	48 8b 40 08          	mov    0x8(%rax),%rax
  814ee5:	8b 50 04             	mov    0x4(%rax),%edx
  814ee8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814eec:	8b 40 0c             	mov    0xc(%rax),%eax
    if (src == DHCP_SERVER_PORT) {
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  814eef:	39 c2                	cmp    %eax,%edx
  814ef1:	0f 85 67 01 00 00    	jne    81505e <udp_input+0x2e2>
           ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &(iphdr->src)))) {
          pcb = inp->dhcp->pcb;
  814ef7:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814efb:	48 8b 40 38          	mov    0x38(%rax),%rax
  814eff:	48 8b 40 08          	mov    0x8(%rax),%rax
  814f03:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  814f07:	e9 52 01 00 00       	jmpq   81505e <udp_input+0x2e2>
      }
    }
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
  814f0c:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  814f13:	00 
    local_match = 0;
  814f14:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
    uncon_pcb = NULL;
  814f18:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  814f1f:	00 
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  814f20:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  814f27:	00 00 00 
  814f2a:	48 8b 00             	mov    (%rax),%rax
  814f2d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  814f31:	e9 0e 01 00 00       	jmpq   815044 <udp_input+0x2c8>
      local_match = 0;
  814f36:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  814f3a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814f3e:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  814f42:	66 3b 45 bc          	cmp    -0x44(%rbp),%ax
  814f46:	75 6b                	jne    814fb3 <udp_input+0x237>
          (ip_addr_isany(&pcb->local_ip) ||
  814f48:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  814f4c:	48 85 c0             	test   %rax,%rax
  814f4f:	74 3d                	je     814f8e <udp_input+0x212>
          (ip_addr_isany(&pcb->local_ip) ||
  814f51:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814f55:	8b 00                	mov    (%rax),%eax
  814f57:	85 c0                	test   %eax,%eax
  814f59:	74 33                	je     814f8e <udp_input+0x212>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
  814f5b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814f5f:	8b 10                	mov    (%rax),%edx
  814f61:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814f65:	8b 40 10             	mov    0x10(%rax),%eax
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
          (ip_addr_isany(&pcb->local_ip) ||
  814f68:	39 c2                	cmp    %eax,%edx
  814f6a:	74 22                	je     814f8e <udp_input+0x212>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  814f6c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814f70:	48 8d 50 10          	lea    0x10(%rax),%rdx
  814f74:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814f78:	48 89 c6             	mov    %rax,%rsi
  814f7b:	48 89 d7             	mov    %rdx,%rdi
  814f7e:	48 b8 41 0d 81 00 00 	movabs $0x810d41,%rax
  814f85:	00 00 00 
  814f88:	ff d0                	callq  *%rax
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
  814f8a:	84 c0                	test   %al,%al
  814f8c:	74 25                	je     814fb3 <udp_input+0x237>
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
        local_match = 1;
  814f8e:	c6 45 d7 01          	movb   $0x1,-0x29(%rbp)
        if ((uncon_pcb == NULL) && 
  814f92:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  814f97:	75 1a                	jne    814fb3 <udp_input+0x237>
            ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
  814f99:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814f9d:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  814fa1:	0f b6 c0             	movzbl %al,%eax
  814fa4:	83 e0 04             	and    $0x4,%eax
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
        local_match = 1;
        if ((uncon_pcb == NULL) && 
  814fa7:	85 c0                	test   %eax,%eax
  814fa9:	75 08                	jne    814fb3 <udp_input+0x237>
            ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
  814fab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814faf:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
  814fb3:	80 7d d7 00          	cmpb   $0x0,-0x29(%rbp)
  814fb7:	74 77                	je     815030 <udp_input+0x2b4>
          (pcb->remote_port == src) &&
  814fb9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814fbd:	0f b7 40 1c          	movzwl 0x1c(%rax),%eax
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
  814fc1:	66 3b 45 be          	cmp    -0x42(%rbp),%ax
  814fc5:	75 69                	jne    815030 <udp_input+0x2b4>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
  814fc7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814fcb:	48 83 c0 04          	add    $0x4,%rax
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
  814fcf:	48 85 c0             	test   %rax,%rax
  814fd2:	74 1d                	je     814ff1 <udp_input+0x275>
          (ip_addr_isany(&pcb->remote_ip) ||
  814fd4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814fd8:	8b 40 04             	mov    0x4(%rax),%eax
  814fdb:	85 c0                	test   %eax,%eax
  814fdd:	74 12                	je     814ff1 <udp_input+0x275>
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
  814fdf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814fe3:	8b 50 04             	mov    0x4(%rax),%edx
  814fe6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814fea:	8b 40 0c             	mov    0xc(%rax),%eax
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
  814fed:	39 c2                	cmp    %eax,%edx
  814fef:	75 3f                	jne    815030 <udp_input+0x2b4>
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
  814ff1:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  814ff6:	74 36                	je     81502e <udp_input+0x2b2>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
  814ff8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814ffc:	48 8b 50 10          	mov    0x10(%rax),%rdx
  815000:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  815004:	48 89 50 10          	mov    %rdx,0x10(%rax)
          pcb->next = udp_pcbs;
  815008:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  81500f:	00 00 00 
  815012:	48 8b 10             	mov    (%rax),%rdx
  815015:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815019:	48 89 50 10          	mov    %rdx,0x10(%rax)
          udp_pcbs = pcb;
  81501d:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  815024:	00 00 00 
  815027:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81502b:	48 89 10             	mov    %rdx,(%rax)
        } else {
          UDP_STATS_INC(udp.cachehit);
        }
        break;
  81502e:	eb 1f                	jmp    81504f <udp_input+0x2d3>
      }
      prev = pcb;
  815030:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815034:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  815038:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81503c:	48 8b 40 10          	mov    0x10(%rax),%rax
  815040:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  815044:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815049:	0f 85 e7 fe ff ff    	jne    814f36 <udp_input+0x1ba>
        break;
      }
      prev = pcb;
    }
    /* no fully matching pcb found? then look for an unconnected pcb */
    if (pcb == NULL) {
  81504f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815054:	75 08                	jne    81505e <udp_input+0x2e2>
      pcb = uncon_pcb;
  815056:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81505a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  81505e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815063:	75 16                	jne    81507b <udp_input+0x2ff>
  815065:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  815069:	8b 50 08             	mov    0x8(%rax),%edx
  81506c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  815070:	8b 40 10             	mov    0x10(%rax),%eax
  815073:	39 c2                	cmp    %eax,%edx
  815075:	0f 85 fc 01 00 00    	jne    815277 <udp_input+0x4fb>
#endif /* CHECKSUM_CHECK_UDP */
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
  81507b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81507f:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  815083:	66 85 c0             	test   %ax,%ax
  815086:	74 53                	je     8150db <udp_input+0x35f>
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
                               (struct ip_addr *)&(iphdr->dest),
                               IP_PROTO_UDP, p->tot_len) != 0) {
  815088:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81508c:	0f b7 40 10          	movzwl 0x10(%rax),%eax
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  815090:	0f b7 c8             	movzwl %ax,%ecx
  815093:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  815097:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81509b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81509f:	48 8d 70 0c          	lea    0xc(%rax),%rsi
  8150a3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8150a7:	41 89 c8             	mov    %ecx,%r8d
  8150aa:	b9 11 00 00 00       	mov    $0x11,%ecx
  8150af:	48 89 c7             	mov    %rax,%rdi
  8150b2:	48 b8 cb 27 81 00 00 	movabs $0x8127cb,%rax
  8150b9:	00 00 00 
  8150bc:	ff d0                	callq  *%rax
  8150be:	66 85 c0             	test   %ax,%ax
  8150c1:	74 18                	je     8150db <udp_input+0x35f>
          LWIP_DEBUGF(UDP_DEBUG | 2,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
          UDP_STATS_INC(udp.drop);
          snmp_inc_udpinerrors();
          pbuf_free(p);
  8150c3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8150c7:	48 89 c7             	mov    %rax,%rdi
  8150ca:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  8150d1:	00 00 00 
  8150d4:	ff d0                	callq  *%rax
          goto end;
  8150d6:	e9 af 01 00 00       	jmpq   81528a <udp_input+0x50e>
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
  8150db:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8150df:	be f8 ff ff ff       	mov    $0xfffffff8,%esi
  8150e4:	48 89 c7             	mov    %rax,%rdi
  8150e7:	48 b8 7f db 80 00 00 	movabs $0x80db7f,%rax
  8150ee:	00 00 00 
  8150f1:	ff d0                	callq  *%rax
  8150f3:	84 c0                	test   %al,%al
  8150f5:	74 2a                	je     815121 <udp_input+0x3a5>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  8150f7:	48 ba 48 2a 82 00 00 	movabs $0x822a48,%rdx
  8150fe:	00 00 00 
  815101:	be 0b 01 00 00       	mov    $0x10b,%esi
  815106:	48 bf 5c 2a 82 00 00 	movabs $0x822a5c,%rdi
  81510d:	00 00 00 
  815110:	b8 00 00 00 00       	mov    $0x0,%eax
  815115:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81511c:	00 00 00 
  81511f:	ff d1                	callq  *%rcx
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
  815121:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815126:	74 51                	je     815179 <udp_input+0x3fd>
      snmp_inc_udpindatagrams();
      /* callback */
      if (pcb->recv != NULL) {
  815128:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81512c:	48 8b 40 20          	mov    0x20(%rax),%rax
  815130:	48 85 c0             	test   %rax,%rax
  815133:	74 2c                	je     815161 <udp_input+0x3e5>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
  815135:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815139:	48 8b 40 20          	mov    0x20(%rax),%rax
  81513d:	44 0f b7 45 be       	movzwl -0x42(%rbp),%r8d
  815142:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  815146:	48 8d 4a 0c          	lea    0xc(%rdx),%rcx
  81514a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81514e:	48 8b 7a 28          	mov    0x28(%rdx),%rdi
  815152:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  815156:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  81515a:	ff d0                	callq  *%rax
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
  81515c:	e9 29 01 00 00       	jmpq   81528a <udp_input+0x50e>
      if (pcb->recv != NULL) {
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
  815161:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  815165:	48 89 c7             	mov    %rax,%rdi
  815168:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  81516f:	00 00 00 
  815172:	ff d0                	callq  *%rax
        goto end;
  815174:	e9 11 01 00 00       	jmpq   81528a <udp_input+0x50e>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  815179:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81517d:	48 8d 50 10          	lea    0x10(%rax),%rdx
  815181:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  815185:	48 89 c6             	mov    %rax,%rsi
  815188:	48 89 d7             	mov    %rdx,%rdi
  81518b:	48 b8 41 0d 81 00 00 	movabs $0x810d41,%rax
  815192:	00 00 00 
  815195:	ff d0                	callq  *%rax
  815197:	84 c0                	test   %al,%al
  815199:	0f 85 c3 00 00 00    	jne    815262 <udp_input+0x4e6>
          !ip_addr_ismulticast(&iphdr->dest)) {
  81519f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8151a3:	8b 58 10             	mov    0x10(%rax),%ebx
  8151a6:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  8151ab:	48 b8 8c 30 81 00 00 	movabs $0x81308c,%rax
  8151b2:	00 00 00 
  8151b5:	ff d0                	callq  *%rax
  8151b7:	21 c3                	and    %eax,%ebx
  8151b9:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  8151be:	48 b8 8c 30 81 00 00 	movabs $0x81308c,%rax
  8151c5:	00 00 00 
  8151c8:	ff d0                	callq  *%rax
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  8151ca:	39 c3                	cmp    %eax,%ebx
  8151cc:	0f 84 90 00 00 00    	je     815262 <udp_input+0x4e6>
          !ip_addr_ismulticast(&iphdr->dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
  8151d2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8151d6:	0f b7 00             	movzwl (%rax),%eax
  8151d9:	0f b7 c0             	movzwl %ax,%eax
  8151dc:	89 c7                	mov    %eax,%edi
  8151de:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  8151e5:	00 00 00 
  8151e8:	ff d0                	callq  *%rax
  8151ea:	66 c1 e8 08          	shr    $0x8,%ax
  8151ee:	0f b7 c0             	movzwl %ax,%eax
  8151f1:	83 e0 0f             	and    $0xf,%eax
  8151f4:	83 c0 02             	add    $0x2,%eax
  8151f7:	c1 e0 02             	shl    $0x2,%eax
  8151fa:	0f bf d0             	movswl %ax,%edx
  8151fd:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  815201:	89 d6                	mov    %edx,%esi
  815203:	48 89 c7             	mov    %rax,%rdi
  815206:	48 b8 7f db 80 00 00 	movabs $0x80db7f,%rax
  81520d:	00 00 00 
  815210:	ff d0                	callq  *%rax
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  815212:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  815216:	48 8b 40 08          	mov    0x8(%rax),%rax
  81521a:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  81521e:	74 2a                	je     81524a <udp_input+0x4ce>
  815220:	48 ba 70 2a 82 00 00 	movabs $0x822a70,%rdx
  815227:	00 00 00 
  81522a:	be 26 01 00 00       	mov    $0x126,%esi
  81522f:	48 bf 5c 2a 82 00 00 	movabs $0x822a5c,%rdi
  815236:	00 00 00 
  815239:	b8 00 00 00 00       	mov    $0x0,%eax
  81523e:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  815245:	00 00 00 
  815248:	ff d1                	callq  *%rcx
        icmp_dest_unreach(p, ICMP_DUR_PORT);
  81524a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81524e:	be 03 00 00 00       	mov    $0x3,%esi
  815253:	48 89 c7             	mov    %rax,%rdi
  815256:	48 b8 07 07 82 00 00 	movabs $0x820707,%rax
  81525d:	00 00 00 
  815260:	ff d0                	callq  *%rax
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
  815262:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  815266:	48 89 c7             	mov    %rax,%rdi
  815269:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  815270:	00 00 00 
  815273:	ff d0                	callq  *%rax
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
  815275:	eb 13                	jmp    81528a <udp_input+0x50e>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
    }
  } else {
    pbuf_free(p);
  815277:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81527b:	48 89 c7             	mov    %rax,%rdi
  81527e:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  815285:	00 00 00 
  815288:	ff d0                	callq  *%rax
  }
end:
  PERF_STOP("udp_input");
}
  81528a:	48 83 c4 58          	add    $0x58,%rsp
  81528e:	5b                   	pop    %rbx
  81528f:	5d                   	pop    %rbp
  815290:	c3                   	retq   

0000000000815291 <udp_send>:
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
  815291:	55                   	push   %rbp
  815292:	48 89 e5             	mov    %rsp,%rbp
  815295:	48 83 ec 10          	sub    $0x10,%rsp
  815299:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81529d:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
  8152a1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8152a5:	0f b7 40 1c          	movzwl 0x1c(%rax),%eax
  8152a9:	0f b7 d0             	movzwl %ax,%edx
  8152ac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8152b0:	48 8d 78 04          	lea    0x4(%rax),%rdi
  8152b4:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8152b8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8152bc:	89 d1                	mov    %edx,%ecx
  8152be:	48 89 fa             	mov    %rdi,%rdx
  8152c1:	48 89 c7             	mov    %rax,%rdi
  8152c4:	48 b8 d2 52 81 00 00 	movabs $0x8152d2,%rax
  8152cb:	00 00 00 
  8152ce:	ff d0                	callq  *%rax
}
  8152d0:	c9                   	leaveq 
  8152d1:	c3                   	retq   

00000000008152d2 <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port)
{
  8152d2:	55                   	push   %rbp
  8152d3:	48 89 e5             	mov    %rsp,%rbp
  8152d6:	48 83 ec 30          	sub    $0x30,%rsp
  8152da:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8152de:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8152e2:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8152e6:	89 c8                	mov    %ecx,%eax
  8152e8:	66 89 45 d4          	mov    %ax,-0x2c(%rbp)

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(dst_ip);
  8152ec:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8152f0:	48 89 c7             	mov    %rax,%rdi
  8152f3:	48 b8 de 0d 81 00 00 	movabs $0x810dde,%rax
  8152fa:	00 00 00 
  8152fd:	ff d0                	callq  *%rax
  8152ff:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
  815303:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  815308:	75 07                	jne    815311 <udp_sendto+0x3f>
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
  81530a:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  81530f:	eb 26                	jmp    815337 <udp_sendto+0x65>
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
  815311:	0f b7 4d d4          	movzwl -0x2c(%rbp),%ecx
  815315:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
  815319:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81531d:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  815321:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815325:	49 89 f8             	mov    %rdi,%r8
  815328:	48 89 c7             	mov    %rax,%rdi
  81532b:	48 b8 39 53 81 00 00 	movabs $0x815339,%rax
  815332:	00 00 00 
  815335:	ff d0                	callq  *%rax
}
  815337:	c9                   	leaveq 
  815338:	c3                   	retq   

0000000000815339 <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port, struct netif *netif)
{
  815339:	55                   	push   %rbp
  81533a:	48 89 e5             	mov    %rsp,%rbp
  81533d:	48 83 ec 50          	sub    $0x50,%rsp
  815341:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  815345:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  815349:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  81534d:	89 c8                	mov    %ecx,%eax
  81534f:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
  815353:	66 89 45 c4          	mov    %ax,-0x3c(%rbp)
  struct ip_addr *src_ip;
  err_t err;
  struct pbuf *q; /* q will be sent down the stack */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
  815357:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81535b:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  81535f:	66 85 c0             	test   %ax,%ax
  815362:	75 37                	jne    81539b <udp_sendto_if+0x62>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  815364:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  815368:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  81536c:	0f b7 d0             	movzwl %ax,%edx
  81536f:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  815373:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  815377:	48 89 ce             	mov    %rcx,%rsi
  81537a:	48 89 c7             	mov    %rax,%rdi
  81537d:	48 b8 ea 55 81 00 00 	movabs $0x8155ea,%rax
  815384:	00 00 00 
  815387:	ff d0                	callq  *%rax
  815389:	88 45 ef             	mov    %al,-0x11(%rbp)
    if (err != ERR_OK) {
  81538c:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  815390:	74 09                	je     81539b <udp_sendto_if+0x62>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: forced port bind failed\n"));
      return err;
  815392:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  815396:	e9 4d 02 00 00       	jmpq   8155e8 <udp_sendto_if+0x2af>
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
  81539b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81539f:	be 08 00 00 00       	mov    $0x8,%esi
  8153a4:	48 89 c7             	mov    %rax,%rdi
  8153a7:	48 b8 7f db 80 00 00 	movabs $0x80db7f,%rax
  8153ae:	00 00 00 
  8153b1:	ff d0                	callq  *%rax
  8153b3:	84 c0                	test   %al,%al
  8153b5:	74 4c                	je     815403 <udp_sendto_if+0xca>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
  8153b7:	ba 00 00 00 00       	mov    $0x0,%edx
  8153bc:	be 08 00 00 00       	mov    $0x8,%esi
  8153c1:	bf 01 00 00 00       	mov    $0x1,%edi
  8153c6:	48 b8 61 d4 80 00 00 	movabs $0x80d461,%rax
  8153cd:	00 00 00 
  8153d0:	ff d0                	callq  *%rax
  8153d2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  8153d6:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8153db:	75 0a                	jne    8153e7 <udp_sendto_if+0xae>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
  8153dd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8153e2:	e9 01 02 00 00       	jmpq   8155e8 <udp_sendto_if+0x2af>
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  8153e7:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8153eb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8153ef:	48 89 d6             	mov    %rdx,%rsi
  8153f2:	48 89 c7             	mov    %rax,%rdi
  8153f5:	48 b8 6a e0 80 00 00 	movabs $0x80e06a,%rax
  8153fc:	00 00 00 
  8153ff:	ff d0                	callq  *%rax
  815401:	eb 08                	jmp    81540b <udp_sendto_if+0xd2>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
  815403:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  815407:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  81540b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81540f:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  815413:	66 83 f8 07          	cmp    $0x7,%ax
  815417:	77 2a                	ja     815443 <udp_sendto_if+0x10a>
  815419:	48 ba 88 2a 82 00 00 	movabs $0x822a88,%rdx
  815420:	00 00 00 
  815423:	be b3 01 00 00       	mov    $0x1b3,%esi
  815428:	48 bf 5c 2a 82 00 00 	movabs $0x822a5c,%rdi
  81542f:	00 00 00 
  815432:	b8 00 00 00 00       	mov    $0x0,%eax
  815437:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81543e:	00 00 00 
  815441:	ff d1                	callq  *%rcx
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = q->payload;
  815443:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  815447:	48 8b 40 08          	mov    0x8(%rax),%rax
  81544b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  udphdr->src = htons(pcb->local_port);
  81544f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  815453:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  815457:	0f b7 c0             	movzwl %ax,%eax
  81545a:	89 c7                	mov    %eax,%edi
  81545c:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  815463:	00 00 00 
  815466:	ff d0                	callq  *%rax
  815468:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81546c:	66 89 02             	mov    %ax,(%rdx)
  udphdr->dest = htons(dst_port);
  81546f:	0f b7 45 c4          	movzwl -0x3c(%rbp),%eax
  815473:	89 c7                	mov    %eax,%edi
  815475:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  81547c:	00 00 00 
  81547f:	ff d0                	callq  *%rax
  815481:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  815485:	66 89 42 02          	mov    %ax,0x2(%rdx)
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
  815489:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81548d:	66 c7 40 06 00 00    	movw   $0x0,0x6(%rax)

  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
  815493:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  815497:	48 85 c0             	test   %rax,%rax
  81549a:	74 0a                	je     8154a6 <udp_sendto_if+0x16d>
  81549c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8154a0:	8b 00                	mov    (%rax),%eax
  8154a2:	85 c0                	test   %eax,%eax
  8154a4:	75 0e                	jne    8154b4 <udp_sendto_if+0x17b>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  8154a6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8154aa:	48 83 c0 08          	add    $0x8,%rax
  8154ae:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8154b2:	eb 48                	jmp    8154fc <udp_sendto_if+0x1c3>
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  8154b4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8154b8:	8b 10                	mov    (%rax),%edx
  8154ba:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8154be:	8b 40 08             	mov    0x8(%rax),%eax
  8154c1:	39 c2                	cmp    %eax,%edx
  8154c3:	74 2f                	je     8154f4 <udp_sendto_if+0x1bb>
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
  8154c5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8154c9:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8154cd:	74 1b                	je     8154ea <udp_sendto_if+0x1b1>
        /* free the header pbuf */
        pbuf_free(q);
  8154cf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8154d3:	48 89 c7             	mov    %rax,%rdi
  8154d6:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  8154dd:	00 00 00 
  8154e0:	ff d0                	callq  *%rax
        q = NULL;
  8154e2:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8154e9:	00 
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
  8154ea:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  8154ef:	e9 f4 00 00 00       	jmpq   8155e8 <udp_sendto_if+0x2af>
    }
    /* use UDP PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
  8154f4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8154f8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
#endif /* LWIP_NETIF_HWADDRHINT*/
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
  8154fc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  815500:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  815504:	0f b7 c0             	movzwl %ax,%eax
  815507:	89 c7                	mov    %eax,%edi
  815509:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  815510:	00 00 00 
  815513:	ff d0                	callq  *%rax
  815515:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  815519:	66 89 42 04          	mov    %ax,0x4(%rdx)
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
  81551d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  815521:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  815525:	0f b6 c0             	movzbl %al,%eax
  815528:	83 e0 01             	and    $0x1,%eax
  81552b:	85 c0                	test   %eax,%eax
  81552d:	75 4d                	jne    81557c <udp_sendto_if+0x243>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  81552f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  815533:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  815537:	0f b7 c8             	movzwl %ax,%ecx
  81553a:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81553e:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  815542:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  815546:	41 89 c8             	mov    %ecx,%r8d
  815549:	b9 11 00 00 00       	mov    $0x11,%ecx
  81554e:	48 89 c7             	mov    %rax,%rdi
  815551:	48 b8 cb 27 81 00 00 	movabs $0x8127cb,%rax
  815558:	00 00 00 
  81555b:	ff d0                	callq  *%rax
  81555d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  815561:	66 89 42 06          	mov    %ax,0x6(%rdx)
      /* chksum zero must become 0xffff, as zero means 'no checksum' */
      if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
  815565:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  815569:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  81556d:	66 85 c0             	test   %ax,%ax
  815570:	75 0a                	jne    81557c <udp_sendto_if+0x243>
  815572:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  815576:	66 c7 40 06 ff ff    	movw   $0xffff,0x6(%rax)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
#if LWIP_NETIF_HWADDRHINT
    netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);    
  81557c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  815580:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  815584:	44 0f b6 c0          	movzbl %al,%r8d
  815588:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81558c:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  815590:	0f b6 c8             	movzbl %al,%ecx
  815593:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  815597:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  81559b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81559f:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8155a3:	48 89 3c 24          	mov    %rdi,(%rsp)
  8155a7:	41 b9 11 00 00 00    	mov    $0x11,%r9d
  8155ad:	48 89 c7             	mov    %rax,%rdi
  8155b0:	48 b8 13 13 81 00 00 	movabs $0x811313,%rax
  8155b7:	00 00 00 
  8155ba:	ff d0                	callq  *%rax
  8155bc:	88 45 ef             	mov    %al,-0x11(%rbp)
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
  8155bf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8155c3:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8155c7:	74 1b                	je     8155e4 <udp_sendto_if+0x2ab>
    /* free the header pbuf */
    pbuf_free(q);
  8155c9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8155cd:	48 89 c7             	mov    %rax,%rdi
  8155d0:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  8155d7:	00 00 00 
  8155da:	ff d0                	callq  *%rax
    q = NULL;
  8155dc:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8155e3:	00 
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
  8155e4:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
}
  8155e8:	c9                   	leaveq 
  8155e9:	c3                   	retq   

00000000008155ea <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  8155ea:	55                   	push   %rbp
  8155eb:	48 89 e5             	mov    %rsp,%rbp
  8155ee:	48 83 ec 30          	sub    $0x30,%rsp
  8155f2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8155f6:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8155fa:	89 d0                	mov    %edx,%eax
  8155fc:	66 89 45 dc          	mov    %ax,-0x24(%rbp)

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  815600:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  815604:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  81560b:	00 00 00 
  81560e:	48 8b 00             	mov    (%rax),%rax
  815611:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  815615:	eb 4a                	jmp    815661 <udp_bind+0x77>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
  815617:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81561b:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  81561f:	75 34                	jne    815655 <udp_bind+0x6b>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
  815621:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  815625:	74 2a                	je     815651 <udp_bind+0x67>
  815627:	48 ba b6 2a 82 00 00 	movabs $0x822ab6,%rdx
  81562e:	00 00 00 
  815631:	be 42 02 00 00       	mov    $0x242,%esi
  815636:	48 bf 5c 2a 82 00 00 	movabs $0x822a5c,%rdi
  81563d:	00 00 00 
  815640:	b8 00 00 00 00       	mov    $0x0,%eax
  815645:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81564c:	00 00 00 
  81564f:	ff d1                	callq  *%rcx
      /* pcb already in list, just rebind */
      rebind = 1;
  815651:	c6 45 f7 01          	movb   $0x1,-0x9(%rbp)
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  815655:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815659:	48 8b 40 10          	mov    0x10(%rax),%rax
  81565d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  815661:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  815666:	75 af                	jne    815617 <udp_bind+0x2d>
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
  815668:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81566d:	74 08                	je     815677 <udp_bind+0x8d>
  81566f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  815673:	8b 00                	mov    (%rax),%eax
  815675:	eb 05                	jmp    81567c <udp_bind+0x92>
  815677:	b8 00 00 00 00       	mov    $0x0,%eax
  81567c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  815680:	89 02                	mov    %eax,(%rdx)

  /* no port specified? */
  if (port == 0) {
  815682:	66 83 7d dc 00       	cmpw   $0x0,-0x24(%rbp)
  815687:	75 6e                	jne    8156f7 <udp_bind+0x10d>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
  815689:	66 c7 45 dc 00 10    	movw   $0x1000,-0x24(%rbp)
    ipcb = udp_pcbs;
  81568f:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  815696:	00 00 00 
  815699:	48 8b 00             	mov    (%rax),%rax
  81569c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  8156a0:	eb 38                	jmp    8156da <udp_bind+0xf0>
      if (ipcb->local_port == port) {
  8156a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8156a6:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  8156aa:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  8156ae:	75 1e                	jne    8156ce <udp_bind+0xe4>
        /* port is already used by another udp_pcb */
        port++;
  8156b0:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  8156b4:	83 c0 01             	add    $0x1,%eax
  8156b7:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
  8156bb:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8156c2:	00 00 00 
  8156c5:	48 8b 00             	mov    (%rax),%rax
  8156c8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8156cc:	eb 0c                	jmp    8156da <udp_bind+0xf0>
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
  8156ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8156d2:	48 8b 40 10          	mov    0x10(%rax),%rax
  8156d6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  8156da:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8156df:	74 08                	je     8156e9 <udp_bind+0xff>
  8156e1:	66 81 7d dc ff 7f    	cmpw   $0x7fff,-0x24(%rbp)
  8156e7:	75 b9                	jne    8156a2 <udp_bind+0xb8>
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
    }
    if (ipcb != NULL) {
  8156e9:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8156ee:	74 07                	je     8156f7 <udp_bind+0x10d>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
  8156f0:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  8156f5:	eb 3d                	jmp    815734 <udp_bind+0x14a>
    }
  }
  pcb->local_port = port;
  8156f7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8156fb:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  8156ff:	66 89 50 1a          	mov    %dx,0x1a(%rax)
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
  815703:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  815707:	75 26                	jne    81572f <udp_bind+0x145>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
  815709:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  815710:	00 00 00 
  815713:	48 8b 10             	mov    (%rax),%rdx
  815716:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81571a:	48 89 50 10          	mov    %rdx,0x10(%rax)
    udp_pcbs = pcb;
  81571e:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  815725:	00 00 00 
  815728:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81572c:	48 89 10             	mov    %rdx,(%rax)
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
  81572f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  815734:	c9                   	leaveq 
  815735:	c3                   	retq   

0000000000815736 <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  815736:	55                   	push   %rbp
  815737:	48 89 e5             	mov    %rsp,%rbp
  81573a:	48 83 ec 30          	sub    $0x30,%rsp
  81573e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  815742:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  815746:	89 d0                	mov    %edx,%eax
  815748:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
  81574c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815750:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  815754:	66 85 c0             	test   %ax,%ax
  815757:	75 37                	jne    815790 <udp_connect+0x5a>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  815759:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81575d:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  815761:	0f b7 d0             	movzwl %ax,%edx
  815764:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  815768:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81576c:	48 89 ce             	mov    %rcx,%rsi
  81576f:	48 89 c7             	mov    %rax,%rdi
  815772:	48 b8 ea 55 81 00 00 	movabs $0x8155ea,%rax
  815779:	00 00 00 
  81577c:	ff d0                	callq  *%rax
  81577e:	88 45 f7             	mov    %al,-0x9(%rbp)
    if (err != ERR_OK)
  815781:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  815785:	74 09                	je     815790 <udp_connect+0x5a>
      return err;
  815787:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  81578b:	e9 9d 00 00 00       	jmpq   81582d <udp_connect+0xf7>
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  815790:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  815795:	74 08                	je     81579f <udp_connect+0x69>
  815797:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81579b:	8b 00                	mov    (%rax),%eax
  81579d:	eb 05                	jmp    8157a4 <udp_connect+0x6e>
  81579f:	b8 00 00 00 00       	mov    $0x0,%eax
  8157a4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8157a8:	89 42 04             	mov    %eax,0x4(%rdx)
  pcb->remote_port = port;
  8157ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8157af:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  8157b3:	66 89 50 1c          	mov    %dx,0x1c(%rax)
  pcb->flags |= UDP_FLAGS_CONNECTED;
  8157b7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8157bb:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  8157bf:	83 c8 04             	or     $0x4,%eax
  8157c2:	89 c2                	mov    %eax,%edx
  8157c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8157c8:	88 50 18             	mov    %dl,0x18(%rax)
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  8157cb:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8157d2:	00 00 00 
  8157d5:	48 8b 00             	mov    (%rax),%rax
  8157d8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8157dc:	eb 1d                	jmp    8157fb <udp_connect+0xc5>
    if (pcb == ipcb) {
  8157de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8157e2:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8157e6:	75 07                	jne    8157ef <udp_connect+0xb9>
      /* already on the list, just return */
      return ERR_OK;
  8157e8:	b8 00 00 00 00       	mov    $0x0,%eax
  8157ed:	eb 3e                	jmp    81582d <udp_connect+0xf7>
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  8157ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8157f3:	48 8b 40 10          	mov    0x10(%rax),%rax
  8157f7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8157fb:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  815800:	75 dc                	jne    8157de <udp_connect+0xa8>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  815802:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  815809:	00 00 00 
  81580c:	48 8b 10             	mov    (%rax),%rdx
  81580f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815813:	48 89 50 10          	mov    %rdx,0x10(%rax)
  udp_pcbs = pcb;
  815817:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  81581e:	00 00 00 
  815821:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  815825:	48 89 10             	mov    %rdx,(%rax)
  return ERR_OK;
  815828:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81582d:	c9                   	leaveq 
  81582e:	c3                   	retq   

000000000081582f <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
  81582f:	55                   	push   %rbp
  815830:	48 89 e5             	mov    %rsp,%rbp
  815833:	48 83 ec 08          	sub    $0x8,%rsp
  815837:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
  81583b:	48 b8 68 26 82 00 00 	movabs $0x822668,%rax
  815842:	00 00 00 
  815845:	8b 10                	mov    (%rax),%edx
  815847:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81584b:	89 50 04             	mov    %edx,0x4(%rax)
  pcb->remote_port = 0;
  81584e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815852:	66 c7 40 1c 00 00    	movw   $0x0,0x1c(%rax)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
  815858:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81585c:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  815860:	83 e0 fb             	and    $0xfffffffb,%eax
  815863:	89 c2                	mov    %eax,%edx
  815865:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815869:	88 50 18             	mov    %dl,0x18(%rax)
}
  81586c:	c9                   	leaveq 
  81586d:	c3                   	retq   

000000000081586e <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
  81586e:	55                   	push   %rbp
  81586f:	48 89 e5             	mov    %rsp,%rbp
  815872:	48 83 ec 18          	sub    $0x18,%rsp
  815876:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81587a:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  81587e:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  /* remember recv() callback and user data */
  pcb->recv = recv;
  815882:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815886:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81588a:	48 89 50 20          	mov    %rdx,0x20(%rax)
  pcb->recv_arg = recv_arg;
  81588e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815892:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  815896:	48 89 50 28          	mov    %rdx,0x28(%rax)
}
  81589a:	c9                   	leaveq 
  81589b:	c3                   	retq   

000000000081589c <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
  81589c:	55                   	push   %rbp
  81589d:	48 89 e5             	mov    %rsp,%rbp
  8158a0:	48 83 ec 20          	sub    $0x20,%rsp
  8158a4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
  8158a8:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8158af:	00 00 00 
  8158b2:	48 8b 00             	mov    (%rax),%rax
  8158b5:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8158b9:	75 20                	jne    8158db <udp_remove+0x3f>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
  8158bb:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8158c2:	00 00 00 
  8158c5:	48 8b 00             	mov    (%rax),%rax
  8158c8:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8158cc:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8158d3:	00 00 00 
  8158d6:	48 89 10             	mov    %rdx,(%rax)
  8158d9:	eb 51                	jmp    81592c <udp_remove+0x90>
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  8158db:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8158e2:	00 00 00 
  8158e5:	48 8b 00             	mov    (%rax),%rax
  8158e8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8158ec:	eb 37                	jmp    815925 <udp_remove+0x89>
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  8158ee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8158f2:	48 8b 40 10          	mov    0x10(%rax),%rax
  8158f6:	48 85 c0             	test   %rax,%rax
  8158f9:	74 1e                	je     815919 <udp_remove+0x7d>
  8158fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8158ff:	48 8b 40 10          	mov    0x10(%rax),%rax
  815903:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  815907:	75 10                	jne    815919 <udp_remove+0x7d>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  815909:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81590d:	48 8b 50 10          	mov    0x10(%rax),%rdx
  815911:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815915:	48 89 50 10          	mov    %rdx,0x10(%rax)
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  815919:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81591d:	48 8b 40 10          	mov    0x10(%rax),%rax
  815921:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  815925:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81592a:	75 c2                	jne    8158ee <udp_remove+0x52>
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
  81592c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815930:	48 89 c6             	mov    %rax,%rsi
  815933:	bf 01 00 00 00       	mov    $0x1,%edi
  815938:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  81593f:	00 00 00 
  815942:	ff d0                	callq  *%rax
}
  815944:	c9                   	leaveq 
  815945:	c3                   	retq   

0000000000815946 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
  815946:	55                   	push   %rbp
  815947:	48 89 e5             	mov    %rsp,%rbp
  81594a:	48 83 ec 10          	sub    $0x10,%rsp
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
  81594e:	bf 01 00 00 00       	mov    $0x1,%edi
  815953:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  81595a:	00 00 00 
  81595d:	ff d0                	callq  *%rax
  81595f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
  815963:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  815968:	74 25                	je     81598f <udp_new+0x49>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
  81596a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81596e:	ba 30 00 00 00       	mov    $0x30,%edx
  815973:	be 00 00 00 00       	mov    $0x0,%esi
  815978:	48 89 c7             	mov    %rax,%rdi
  81597b:	48 b8 70 21 80 00 00 	movabs $0x802170,%rax
  815982:	00 00 00 
  815985:	ff d0                	callq  *%rax
    pcb->ttl = UDP_TTL;
  815987:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81598b:	c6 40 0b ff          	movb   $0xff,0xb(%rax)
  }
  return pcb;
  81598f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  815993:	c9                   	leaveq 
  815994:	c3                   	retq   

0000000000815995 <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
  815995:	55                   	push   %rbp
  815996:	48 89 e5             	mov    %rsp,%rbp
  815999:	48 83 ec 20          	sub    $0x20,%rsp
  81599d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  8159a1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8159a6:	75 2a                	jne    8159d2 <free_etharp_q+0x3d>
  8159a8:	48 ba d4 2a 82 00 00 	movabs $0x822ad4,%rdx
  8159af:	00 00 00 
  8159b2:	be 94 00 00 00       	mov    $0x94,%esi
  8159b7:	48 bf de 2a 82 00 00 	movabs $0x822ade,%rdi
  8159be:	00 00 00 
  8159c1:	b8 00 00 00 00       	mov    $0x0,%eax
  8159c6:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  8159cd:	00 00 00 
  8159d0:	ff d1                	callq  *%rcx
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  8159d2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8159d6:	48 8b 40 08          	mov    0x8(%rax),%rax
  8159da:	48 85 c0             	test   %rax,%rax
  8159dd:	75 2a                	jne    815a09 <free_etharp_q+0x74>
  8159df:	48 ba f6 2a 82 00 00 	movabs $0x822af6,%rdx
  8159e6:	00 00 00 
  8159e9:	be 95 00 00 00       	mov    $0x95,%esi
  8159ee:	48 bf de 2a 82 00 00 	movabs $0x822ade,%rdi
  8159f5:	00 00 00 
  8159f8:	b8 00 00 00 00       	mov    $0x0,%eax
  8159fd:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  815a04:	00 00 00 
  815a07:	ff d1                	callq  *%rcx
  while (q) {
  815a09:	eb 79                	jmp    815a84 <free_etharp_q+0xef>
    r = q;
  815a0b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815a0f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    q = q->next;
  815a13:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815a17:	48 8b 00             	mov    (%rax),%rax
  815a1a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  815a1e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815a22:	48 8b 40 08          	mov    0x8(%rax),%rax
  815a26:	48 85 c0             	test   %rax,%rax
  815a29:	75 2a                	jne    815a55 <free_etharp_q+0xc0>
  815a2b:	48 ba 03 2b 82 00 00 	movabs $0x822b03,%rdx
  815a32:	00 00 00 
  815a35:	be 99 00 00 00       	mov    $0x99,%esi
  815a3a:	48 bf de 2a 82 00 00 	movabs $0x822ade,%rdi
  815a41:	00 00 00 
  815a44:	b8 00 00 00 00       	mov    $0x0,%eax
  815a49:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  815a50:	00 00 00 
  815a53:	ff d1                	callq  *%rcx
    pbuf_free(r->p);
  815a55:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815a59:	48 8b 40 08          	mov    0x8(%rax),%rax
  815a5d:	48 89 c7             	mov    %rax,%rdi
  815a60:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  815a67:	00 00 00 
  815a6a:	ff d0                	callq  *%rax
    memp_free(MEMP_ARP_QUEUE, r);
  815a6c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815a70:	48 89 c6             	mov    %rax,%rsi
  815a73:	bf 0a 00 00 00       	mov    $0xa,%edi
  815a78:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  815a7f:	00 00 00 
  815a82:	ff d0                	callq  *%rax
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
  815a84:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815a89:	75 80                	jne    815a0b <free_etharp_q+0x76>
    q = q->next;
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
    memp_free(MEMP_ARP_QUEUE, r);
  }
}
  815a8b:	c9                   	leaveq 
  815a8c:	c3                   	retq   

0000000000815a8d <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL microseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
  815a8d:	55                   	push   %rbp
  815a8e:	48 89 e5             	mov    %rsp,%rbp
  815a91:	48 83 ec 10          	sub    $0x10,%rsp
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  815a95:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  815a99:	e9 df 01 00 00       	jmpq   815c7d <etharp_tmr+0x1f0>
    arp_table[i].ctime++;
  815a9e:	0f b6 55 ff          	movzbl -0x1(%rbp),%edx
  815aa2:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  815aa9:	00 00 00 
  815aac:	48 63 ca             	movslq %edx,%rcx
  815aaf:	48 89 c8             	mov    %rcx,%rax
  815ab2:	48 c1 e0 02          	shl    $0x2,%rax
  815ab6:	48 01 c8             	add    %rcx,%rax
  815ab9:	48 c1 e0 03          	shl    $0x3,%rax
  815abd:	48 01 f0             	add    %rsi,%rax
  815ac0:	48 83 c0 10          	add    $0x10,%rax
  815ac4:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  815ac8:	8d 48 01             	lea    0x1(%rax),%ecx
  815acb:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  815ad2:	00 00 00 
  815ad5:	48 63 d2             	movslq %edx,%rdx
  815ad8:	48 89 d0             	mov    %rdx,%rax
  815adb:	48 c1 e0 02          	shl    $0x2,%rax
  815adf:	48 01 d0             	add    %rdx,%rax
  815ae2:	48 c1 e0 03          	shl    $0x3,%rax
  815ae6:	48 01 f0             	add    %rsi,%rax
  815ae9:	48 83 c0 10          	add    $0x10,%rax
  815aed:	88 48 08             	mov    %cl,0x8(%rax)
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  815af0:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815af4:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815afb:	00 00 00 
  815afe:	48 63 d0             	movslq %eax,%rdx
  815b01:	48 89 d0             	mov    %rdx,%rax
  815b04:	48 c1 e0 02          	shl    $0x2,%rax
  815b08:	48 01 d0             	add    %rdx,%rax
  815b0b:	48 c1 e0 03          	shl    $0x3,%rax
  815b0f:	48 01 c8             	add    %rcx,%rax
  815b12:	48 83 c0 10          	add    $0x10,%rax
  815b16:	8b 40 04             	mov    0x4(%rax),%eax
  815b19:	83 f8 02             	cmp    $0x2,%eax
  815b1c:	75 2e                	jne    815b4c <etharp_tmr+0xbf>
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
  815b1e:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815b22:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815b29:	00 00 00 
  815b2c:	48 63 d0             	movslq %eax,%rdx
  815b2f:	48 89 d0             	mov    %rdx,%rax
  815b32:	48 c1 e0 02          	shl    $0x2,%rax
  815b36:	48 01 d0             	add    %rdx,%rax
  815b39:	48 c1 e0 03          	shl    $0x3,%rax
  815b3d:	48 01 c8             	add    %rcx,%rax
  815b40:	48 83 c0 10          	add    $0x10,%rax
  815b44:	0f b6 40 08          	movzbl 0x8(%rax),%eax

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  815b48:	3c ef                	cmp    $0xef,%al
  815b4a:	77 64                	ja     815bb0 <etharp_tmr+0x123>
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
  815b4c:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815b50:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815b57:	00 00 00 
  815b5a:	48 63 d0             	movslq %eax,%rdx
  815b5d:	48 89 d0             	mov    %rdx,%rax
  815b60:	48 c1 e0 02          	shl    $0x2,%rax
  815b64:	48 01 d0             	add    %rdx,%rax
  815b67:	48 c1 e0 03          	shl    $0x3,%rax
  815b6b:	48 01 c8             	add    %rcx,%rax
  815b6e:	48 83 c0 10          	add    $0x10,%rax
  815b72:	8b 40 04             	mov    0x4(%rax),%eax
  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
  815b75:	83 f8 01             	cmp    $0x1,%eax
  815b78:	0f 85 e6 00 00 00    	jne    815c64 <etharp_tmr+0x1d7>
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
         (arp_table[i].ctime >= ARP_MAXPENDING))) {
  815b7e:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815b82:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815b89:	00 00 00 
  815b8c:	48 63 d0             	movslq %eax,%rdx
  815b8f:	48 89 d0             	mov    %rdx,%rax
  815b92:	48 c1 e0 02          	shl    $0x2,%rax
  815b96:	48 01 d0             	add    %rdx,%rax
  815b99:	48 c1 e0 03          	shl    $0x3,%rax
  815b9d:	48 01 c8             	add    %rcx,%rax
  815ba0:	48 83 c0 10          	add    $0x10,%rax
  815ba4:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
  815ba8:	3c 01                	cmp    $0x1,%al
  815baa:	0f 86 b4 00 00 00    	jbe    815c64 <etharp_tmr+0x1d7>
      /* clean up entries that have just been expired */
      /* remove from SNMP ARP index tree */
      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
#if ARP_QUEUEING
      /* and empty packet queue */
      if (arp_table[i].q != NULL) {
  815bb0:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815bb4:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815bbb:	00 00 00 
  815bbe:	48 63 d0             	movslq %eax,%rdx
  815bc1:	48 89 d0             	mov    %rdx,%rax
  815bc4:	48 c1 e0 02          	shl    $0x2,%rax
  815bc8:	48 01 d0             	add    %rdx,%rax
  815bcb:	48 c1 e0 03          	shl    $0x3,%rax
  815bcf:	48 01 c8             	add    %rcx,%rax
  815bd2:	48 8b 00             	mov    (%rax),%rax
  815bd5:	48 85 c0             	test   %rax,%rax
  815bd8:	74 5d                	je     815c37 <etharp_tmr+0x1aa>
        /* remove all queued packets */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
        free_etharp_q(arp_table[i].q);
  815bda:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815bde:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815be5:	00 00 00 
  815be8:	48 63 d0             	movslq %eax,%rdx
  815beb:	48 89 d0             	mov    %rdx,%rax
  815bee:	48 c1 e0 02          	shl    $0x2,%rax
  815bf2:	48 01 d0             	add    %rdx,%rax
  815bf5:	48 c1 e0 03          	shl    $0x3,%rax
  815bf9:	48 01 c8             	add    %rcx,%rax
  815bfc:	48 8b 00             	mov    (%rax),%rax
  815bff:	48 89 c7             	mov    %rax,%rdi
  815c02:	48 b8 95 59 81 00 00 	movabs $0x815995,%rax
  815c09:	00 00 00 
  815c0c:	ff d0                	callq  *%rax
        arp_table[i].q = NULL;
  815c0e:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815c12:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815c19:	00 00 00 
  815c1c:	48 63 d0             	movslq %eax,%rdx
  815c1f:	48 89 d0             	mov    %rdx,%rax
  815c22:	48 c1 e0 02          	shl    $0x2,%rax
  815c26:	48 01 d0             	add    %rdx,%rax
  815c29:	48 c1 e0 03          	shl    $0x3,%rax
  815c2d:	48 01 c8             	add    %rcx,%rax
  815c30:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
      }
#endif
      /* recycle entry for re-use */      
      arp_table[i].state = ETHARP_STATE_EMPTY;
  815c37:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815c3b:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815c42:	00 00 00 
  815c45:	48 63 d0             	movslq %eax,%rdx
  815c48:	48 89 d0             	mov    %rdx,%rax
  815c4b:	48 c1 e0 02          	shl    $0x2,%rax
  815c4f:	48 01 d0             	add    %rdx,%rax
  815c52:	48 c1 e0 03          	shl    $0x3,%rax
  815c56:	48 01 c8             	add    %rcx,%rax
  815c59:	48 83 c0 10          	add    $0x10,%rax
  815c5d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    }
#if ARP_QUEUEING
    /* still pending entry? (not expired) */
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
  815c64:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815c68:	48 63 d0             	movslq %eax,%rdx
  815c6b:	48 89 d0             	mov    %rdx,%rax
  815c6e:	48 c1 e0 02          	shl    $0x2,%rax
  815c72:	48 01 d0             	add    %rdx,%rax
  815c75:	48 c1 e0 03          	shl    $0x3,%rax
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  815c79:	80 45 ff 01          	addb   $0x1,-0x1(%rbp)
  815c7d:	80 7d ff 09          	cmpb   $0x9,-0x1(%rbp)
  815c81:	0f 86 17 fe ff ff    	jbe    815a9e <etharp_tmr+0x11>
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
        /* resend an ARP query here? */
    }
#endif
  }
}
  815c87:	c9                   	leaveq 
  815c88:	c3                   	retq   

0000000000815c89 <find_entry>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
  815c89:	55                   	push   %rbp
  815c8a:	48 89 e5             	mov    %rsp,%rbp
  815c8d:	48 83 ec 20          	sub    $0x20,%rsp
  815c91:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  815c95:	89 f0                	mov    %esi,%eax
  815c97:	88 45 e4             	mov    %al,-0x1c(%rbp)
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
  815c9a:	c6 45 ff 0a          	movb   $0xa,-0x1(%rbp)
  815c9e:	c6 45 fe 0a          	movb   $0xa,-0x2(%rbp)
  s8_t empty = ARP_TABLE_SIZE;
  815ca2:	c6 45 fd 0a          	movb   $0xa,-0x3(%rbp)
  u8_t i = 0, age_pending = 0, age_stable = 0;
  815ca6:	c6 45 fc 00          	movb   $0x0,-0x4(%rbp)
  815caa:	c6 45 fb 00          	movb   $0x0,-0x5(%rbp)
  815cae:	c6 45 fa 00          	movb   $0x0,-0x6(%rbp)
#if ARP_QUEUEING
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
  815cb2:	c6 45 f9 0a          	movb   $0xa,-0x7(%rbp)
  /* its age */
  u8_t age_queue = 0;
  815cb6:	c6 45 f8 00          	movb   $0x0,-0x8(%rbp)
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
  815cba:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815cbf:	0f 84 87 00 00 00    	je     815d4c <find_entry+0xc3>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
  815cc5:	48 b8 10 b8 b4 00 00 	movabs $0xb4b810,%rax
  815ccc:	00 00 00 
  815ccf:	0f b6 00             	movzbl (%rax),%eax
  815cd2:	0f b6 c0             	movzbl %al,%eax
  815cd5:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815cdc:	00 00 00 
  815cdf:	48 63 d0             	movslq %eax,%rdx
  815ce2:	48 89 d0             	mov    %rdx,%rax
  815ce5:	48 c1 e0 02          	shl    $0x2,%rax
  815ce9:	48 01 d0             	add    %rdx,%rax
  815cec:	48 c1 e0 03          	shl    $0x3,%rax
  815cf0:	48 01 c8             	add    %rcx,%rax
  815cf3:	48 83 c0 10          	add    $0x10,%rax
  815cf7:	8b 40 04             	mov    0x4(%rax),%eax
  815cfa:	83 f8 02             	cmp    $0x2,%eax
  815cfd:	75 4d                	jne    815d4c <find_entry+0xc3>
      /* the cached entry is stable */
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
  815cff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815d03:	8b 08                	mov    (%rax),%ecx
  815d05:	48 b8 10 b8 b4 00 00 	movabs $0xb4b810,%rax
  815d0c:	00 00 00 
  815d0f:	0f b6 00             	movzbl (%rax),%eax
  815d12:	0f b6 c0             	movzbl %al,%eax
  815d15:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  815d1c:	00 00 00 
  815d1f:	48 63 d0             	movslq %eax,%rdx
  815d22:	48 89 d0             	mov    %rdx,%rax
  815d25:	48 c1 e0 02          	shl    $0x2,%rax
  815d29:	48 01 d0             	add    %rdx,%rax
  815d2c:	48 c1 e0 03          	shl    $0x3,%rax
  815d30:	48 01 f0             	add    %rsi,%rax
  815d33:	8b 40 08             	mov    0x8(%rax),%eax
  815d36:	39 c1                	cmp    %eax,%ecx
  815d38:	75 12                	jne    815d4c <find_entry+0xc3>
        /* cached entry was the right one! */
        ETHARP_STATS_INC(etharp.cachehit);
        return etharp_cached_entry;
  815d3a:	48 b8 10 b8 b4 00 00 	movabs $0xb4b810,%rax
  815d41:	00 00 00 
  815d44:	0f b6 00             	movzbl (%rax),%eax
  815d47:	e9 cf 04 00 00       	jmpq   81621b <find_entry+0x592>
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  815d4c:	c6 45 fc 00          	movb   $0x0,-0x4(%rbp)
  815d50:	e9 aa 02 00 00       	jmpq   815fff <find_entry+0x376>
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  815d55:	80 7d fd 0a          	cmpb   $0xa,-0x3(%rbp)
  815d59:	75 39                	jne    815d94 <find_entry+0x10b>
  815d5b:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815d5f:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815d66:	00 00 00 
  815d69:	48 63 d0             	movslq %eax,%rdx
  815d6c:	48 89 d0             	mov    %rdx,%rax
  815d6f:	48 c1 e0 02          	shl    $0x2,%rax
  815d73:	48 01 d0             	add    %rdx,%rax
  815d76:	48 c1 e0 03          	shl    $0x3,%rax
  815d7a:	48 01 c8             	add    %rcx,%rax
  815d7d:	48 83 c0 10          	add    $0x10,%rax
  815d81:	8b 40 04             	mov    0x4(%rax),%eax
  815d84:	85 c0                	test   %eax,%eax
  815d86:	75 0c                	jne    815d94 <find_entry+0x10b>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
  815d88:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815d8c:	88 45 fd             	mov    %al,-0x3(%rbp)
  815d8f:	e9 67 02 00 00       	jmpq   815ffb <find_entry+0x372>
    }
    /* pending entry? */
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  815d94:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815d98:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815d9f:	00 00 00 
  815da2:	48 63 d0             	movslq %eax,%rdx
  815da5:	48 89 d0             	mov    %rdx,%rax
  815da8:	48 c1 e0 02          	shl    $0x2,%rax
  815dac:	48 01 d0             	add    %rdx,%rax
  815daf:	48 c1 e0 03          	shl    $0x3,%rax
  815db3:	48 01 c8             	add    %rcx,%rax
  815db6:	48 83 c0 10          	add    $0x10,%rax
  815dba:	8b 40 04             	mov    0x4(%rax),%eax
  815dbd:	83 f8 01             	cmp    $0x1,%eax
  815dc0:	0f 85 51 01 00 00    	jne    815f17 <find_entry+0x28e>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  815dc6:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815dcb:	74 48                	je     815e15 <find_entry+0x18c>
  815dcd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815dd1:	8b 08                	mov    (%rax),%ecx
  815dd3:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815dd7:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  815dde:	00 00 00 
  815de1:	48 63 d0             	movslq %eax,%rdx
  815de4:	48 89 d0             	mov    %rdx,%rax
  815de7:	48 c1 e0 02          	shl    $0x2,%rax
  815deb:	48 01 d0             	add    %rdx,%rax
  815dee:	48 c1 e0 03          	shl    $0x3,%rax
  815df2:	48 01 f0             	add    %rsi,%rax
  815df5:	8b 40 08             	mov    0x8(%rax),%eax
  815df8:	39 c1                	cmp    %eax,%ecx
  815dfa:	75 19                	jne    815e15 <find_entry+0x18c>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching pending entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  815dfc:	48 b8 10 b8 b4 00 00 	movabs $0xb4b810,%rax
  815e03:	00 00 00 
  815e06:	0f b6 55 fc          	movzbl -0x4(%rbp),%edx
  815e0a:	88 10                	mov    %dl,(%rax)
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  815e0c:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815e10:	e9 06 04 00 00       	jmpq   81621b <find_entry+0x592>
#if ARP_QUEUEING
      /* pending with queued packets? */
      } else if (arp_table[i].q != NULL) {
  815e15:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815e19:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815e20:	00 00 00 
  815e23:	48 63 d0             	movslq %eax,%rdx
  815e26:	48 89 d0             	mov    %rdx,%rax
  815e29:	48 c1 e0 02          	shl    $0x2,%rax
  815e2d:	48 01 d0             	add    %rdx,%rax
  815e30:	48 c1 e0 03          	shl    $0x3,%rax
  815e34:	48 01 c8             	add    %rcx,%rax
  815e37:	48 8b 00             	mov    (%rax),%rax
  815e3a:	48 85 c0             	test   %rax,%rax
  815e3d:	74 6c                	je     815eab <find_entry+0x222>
        if (arp_table[i].ctime >= age_queue) {
  815e3f:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815e43:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815e4a:	00 00 00 
  815e4d:	48 63 d0             	movslq %eax,%rdx
  815e50:	48 89 d0             	mov    %rdx,%rax
  815e53:	48 c1 e0 02          	shl    $0x2,%rax
  815e57:	48 01 d0             	add    %rdx,%rax
  815e5a:	48 c1 e0 03          	shl    $0x3,%rax
  815e5e:	48 01 c8             	add    %rcx,%rax
  815e61:	48 83 c0 10          	add    $0x10,%rax
  815e65:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  815e69:	3a 45 f8             	cmp    -0x8(%rbp),%al
  815e6c:	0f 82 89 01 00 00    	jb     815ffb <find_entry+0x372>
          old_queue = i;
  815e72:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815e76:	88 45 f9             	mov    %al,-0x7(%rbp)
          age_queue = arp_table[i].ctime;
  815e79:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815e7d:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815e84:	00 00 00 
  815e87:	48 63 d0             	movslq %eax,%rdx
  815e8a:	48 89 d0             	mov    %rdx,%rax
  815e8d:	48 c1 e0 02          	shl    $0x2,%rax
  815e91:	48 01 d0             	add    %rdx,%rax
  815e94:	48 c1 e0 03          	shl    $0x3,%rax
  815e98:	48 01 c8             	add    %rcx,%rax
  815e9b:	48 83 c0 10          	add    $0x10,%rax
  815e9f:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  815ea3:	88 45 f8             	mov    %al,-0x8(%rbp)
  815ea6:	e9 50 01 00 00       	jmpq   815ffb <find_entry+0x372>
        }
#endif
      /* pending without queued packets? */
      } else {
        if (arp_table[i].ctime >= age_pending) {
  815eab:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815eaf:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815eb6:	00 00 00 
  815eb9:	48 63 d0             	movslq %eax,%rdx
  815ebc:	48 89 d0             	mov    %rdx,%rax
  815ebf:	48 c1 e0 02          	shl    $0x2,%rax
  815ec3:	48 01 d0             	add    %rdx,%rax
  815ec6:	48 c1 e0 03          	shl    $0x3,%rax
  815eca:	48 01 c8             	add    %rcx,%rax
  815ecd:	48 83 c0 10          	add    $0x10,%rax
  815ed1:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  815ed5:	3a 45 fb             	cmp    -0x5(%rbp),%al
  815ed8:	0f 82 1d 01 00 00    	jb     815ffb <find_entry+0x372>
          old_pending = i;
  815ede:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815ee2:	88 45 ff             	mov    %al,-0x1(%rbp)
          age_pending = arp_table[i].ctime;
  815ee5:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815ee9:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815ef0:	00 00 00 
  815ef3:	48 63 d0             	movslq %eax,%rdx
  815ef6:	48 89 d0             	mov    %rdx,%rax
  815ef9:	48 c1 e0 02          	shl    $0x2,%rax
  815efd:	48 01 d0             	add    %rdx,%rax
  815f00:	48 c1 e0 03          	shl    $0x3,%rax
  815f04:	48 01 c8             	add    %rcx,%rax
  815f07:	48 83 c0 10          	add    $0x10,%rax
  815f0b:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  815f0f:	88 45 fb             	mov    %al,-0x5(%rbp)
  815f12:	e9 e4 00 00 00       	jmpq   815ffb <find_entry+0x372>
        }
      }        
    }
    /* stable entry? */
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  815f17:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815f1b:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815f22:	00 00 00 
  815f25:	48 63 d0             	movslq %eax,%rdx
  815f28:	48 89 d0             	mov    %rdx,%rax
  815f2b:	48 c1 e0 02          	shl    $0x2,%rax
  815f2f:	48 01 d0             	add    %rdx,%rax
  815f32:	48 c1 e0 03          	shl    $0x3,%rax
  815f36:	48 01 c8             	add    %rcx,%rax
  815f39:	48 83 c0 10          	add    $0x10,%rax
  815f3d:	8b 40 04             	mov    0x4(%rax),%eax
  815f40:	83 f8 02             	cmp    $0x2,%eax
  815f43:	0f 85 b2 00 00 00    	jne    815ffb <find_entry+0x372>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  815f49:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815f4e:	74 48                	je     815f98 <find_entry+0x30f>
  815f50:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815f54:	8b 08                	mov    (%rax),%ecx
  815f56:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815f5a:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  815f61:	00 00 00 
  815f64:	48 63 d0             	movslq %eax,%rdx
  815f67:	48 89 d0             	mov    %rdx,%rax
  815f6a:	48 c1 e0 02          	shl    $0x2,%rax
  815f6e:	48 01 d0             	add    %rdx,%rax
  815f71:	48 c1 e0 03          	shl    $0x3,%rax
  815f75:	48 01 f0             	add    %rsi,%rax
  815f78:	8b 40 08             	mov    0x8(%rax),%eax
  815f7b:	39 c1                	cmp    %eax,%ecx
  815f7d:	75 19                	jne    815f98 <find_entry+0x30f>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching stable entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  815f7f:	48 b8 10 b8 b4 00 00 	movabs $0xb4b810,%rax
  815f86:	00 00 00 
  815f89:	0f b6 55 fc          	movzbl -0x4(%rbp),%edx
  815f8d:	88 10                	mov    %dl,(%rax)
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  815f8f:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815f93:	e9 83 02 00 00       	jmpq   81621b <find_entry+0x592>
      /* remember entry with oldest stable entry in oldest, its age in maxtime */
      } else if (arp_table[i].ctime >= age_stable) {
  815f98:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815f9c:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815fa3:	00 00 00 
  815fa6:	48 63 d0             	movslq %eax,%rdx
  815fa9:	48 89 d0             	mov    %rdx,%rax
  815fac:	48 c1 e0 02          	shl    $0x2,%rax
  815fb0:	48 01 d0             	add    %rdx,%rax
  815fb3:	48 c1 e0 03          	shl    $0x3,%rax
  815fb7:	48 01 c8             	add    %rcx,%rax
  815fba:	48 83 c0 10          	add    $0x10,%rax
  815fbe:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  815fc2:	3a 45 fa             	cmp    -0x6(%rbp),%al
  815fc5:	72 34                	jb     815ffb <find_entry+0x372>
        old_stable = i;
  815fc7:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815fcb:	88 45 fe             	mov    %al,-0x2(%rbp)
        age_stable = arp_table[i].ctime;
  815fce:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815fd2:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815fd9:	00 00 00 
  815fdc:	48 63 d0             	movslq %eax,%rdx
  815fdf:	48 89 d0             	mov    %rdx,%rax
  815fe2:	48 c1 e0 02          	shl    $0x2,%rax
  815fe6:	48 01 d0             	add    %rdx,%rax
  815fe9:	48 c1 e0 03          	shl    $0x3,%rax
  815fed:	48 01 c8             	add    %rcx,%rax
  815ff0:	48 83 c0 10          	add    $0x10,%rax
  815ff4:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  815ff8:	88 45 fa             	mov    %al,-0x6(%rbp)
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  815ffb:	80 45 fc 01          	addb   $0x1,-0x4(%rbp)
  815fff:	80 7d fc 09          	cmpb   $0x9,-0x4(%rbp)
  816003:	0f 86 4c fd ff ff    	jbe    815d55 <find_entry+0xcc>
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  816009:	80 7d fd 0a          	cmpb   $0xa,-0x3(%rbp)
  81600d:	75 0b                	jne    81601a <find_entry+0x391>
  81600f:	0f b6 45 e4          	movzbl -0x1c(%rbp),%eax
  816013:	83 e0 01             	and    $0x1,%eax
  816016:	85 c0                	test   %eax,%eax
  816018:	74 0b                	je     816025 <find_entry+0x39c>
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  81601a:	0f b6 45 e4          	movzbl -0x1c(%rbp),%eax
  81601e:	83 e0 02             	and    $0x2,%eax
  816021:	85 c0                	test   %eax,%eax
  816023:	74 0a                	je     81602f <find_entry+0x3a6>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
  816025:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81602a:	e9 ec 01 00 00       	jmpq   81621b <find_entry+0x592>
   * 
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
  81602f:	80 7d fd 09          	cmpb   $0x9,-0x3(%rbp)
  816033:	7f 0c                	jg     816041 <find_entry+0x3b8>
    i = empty;
  816035:	0f b6 45 fd          	movzbl -0x3(%rbp),%eax
  816039:	88 45 fc             	mov    %al,-0x4(%rbp)
  81603c:	e9 ea 00 00 00       	jmpq   81612b <find_entry+0x4a2>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  }
  /* 2) found recyclable stable entry? */
  else if (old_stable < ARP_TABLE_SIZE) {
  816041:	80 7d fe 09          	cmpb   $0x9,-0x2(%rbp)
  816045:	7f 5f                	jg     8160a6 <find_entry+0x41d>
    /* recycle oldest stable*/
    i = old_stable;
  816047:	0f b6 45 fe          	movzbl -0x2(%rbp),%eax
  81604b:	88 45 fc             	mov    %al,-0x4(%rbp)
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
  81604e:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  816052:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816059:	00 00 00 
  81605c:	48 63 d0             	movslq %eax,%rdx
  81605f:	48 89 d0             	mov    %rdx,%rax
  816062:	48 c1 e0 02          	shl    $0x2,%rax
  816066:	48 01 d0             	add    %rdx,%rax
  816069:	48 c1 e0 03          	shl    $0x3,%rax
  81606d:	48 01 c8             	add    %rcx,%rax
  816070:	48 8b 00             	mov    (%rax),%rax
  816073:	48 85 c0             	test   %rax,%rax
  816076:	0f 84 af 00 00 00    	je     81612b <find_entry+0x4a2>
  81607c:	48 ba 10 2b 82 00 00 	movabs $0x822b10,%rdx
  816083:	00 00 00 
  816086:	be 76 01 00 00       	mov    $0x176,%esi
  81608b:	48 bf de 2a 82 00 00 	movabs $0x822ade,%rdi
  816092:	00 00 00 
  816095:	b8 00 00 00 00       	mov    $0x0,%eax
  81609a:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  8160a1:	00 00 00 
  8160a4:	ff d1                	callq  *%rcx
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
  8160a6:	80 7d ff 09          	cmpb   $0x9,-0x1(%rbp)
  8160aa:	7f 09                	jg     8160b5 <find_entry+0x42c>
    /* recycle oldest pending */
    i = old_pending;
  8160ac:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  8160b0:	88 45 fc             	mov    %al,-0x4(%rbp)
  8160b3:	eb 76                	jmp    81612b <find_entry+0x4a2>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
#if ARP_QUEUEING
  /* 4) found recyclable pending entry with queued packets? */
  } else if (old_queue < ARP_TABLE_SIZE) {
  8160b5:	80 7d f9 09          	cmpb   $0x9,-0x7(%rbp)
  8160b9:	7f 66                	jg     816121 <find_entry+0x498>
    /* recycle oldest pending */
    i = old_queue;
  8160bb:	0f b6 45 f9          	movzbl -0x7(%rbp),%eax
  8160bf:	88 45 fc             	mov    %al,-0x4(%rbp)
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
  8160c2:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  8160c6:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8160cd:	00 00 00 
  8160d0:	48 63 d0             	movslq %eax,%rdx
  8160d3:	48 89 d0             	mov    %rdx,%rax
  8160d6:	48 c1 e0 02          	shl    $0x2,%rax
  8160da:	48 01 d0             	add    %rdx,%rax
  8160dd:	48 c1 e0 03          	shl    $0x3,%rax
  8160e1:	48 01 c8             	add    %rcx,%rax
  8160e4:	48 8b 00             	mov    (%rax),%rax
  8160e7:	48 89 c7             	mov    %rax,%rdi
  8160ea:	48 b8 95 59 81 00 00 	movabs $0x815995,%rax
  8160f1:	00 00 00 
  8160f4:	ff d0                	callq  *%rax
    arp_table[i].q = NULL;
  8160f6:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  8160fa:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816101:	00 00 00 
  816104:	48 63 d0             	movslq %eax,%rdx
  816107:	48 89 d0             	mov    %rdx,%rax
  81610a:	48 c1 e0 02          	shl    $0x2,%rax
  81610e:	48 01 d0             	add    %rdx,%rax
  816111:	48 c1 e0 03          	shl    $0x3,%rax
  816115:	48 01 c8             	add    %rcx,%rax
  816118:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  81611f:	eb 0a                	jmp    81612b <find_entry+0x4a2>
#endif
    /* no empty or recyclable entries found */
  } else {
    return (s8_t)ERR_MEM;
  816121:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  816126:	e9 f0 00 00 00       	jmpq   81621b <find_entry+0x592>
  }

  /* { empty or recyclable entry found } */
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  81612b:	80 7d fc 09          	cmpb   $0x9,-0x4(%rbp)
  81612f:	76 2a                	jbe    81615b <find_entry+0x4d2>
  816131:	48 ba 27 2b 82 00 00 	movabs $0x822b27,%rdx
  816138:	00 00 00 
  81613b:	be 8c 01 00 00       	mov    $0x18c,%esi
  816140:	48 bf de 2a 82 00 00 	movabs $0x822ade,%rdi
  816147:	00 00 00 
  81614a:	b8 00 00 00 00       	mov    $0x0,%eax
  81614f:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  816156:	00 00 00 
  816159:	ff d1                	callq  *%rcx

  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  81615b:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  81615f:	48 63 d0             	movslq %eax,%rdx
  816162:	48 89 d0             	mov    %rdx,%rax
  816165:	48 c1 e0 02          	shl    $0x2,%rax
  816169:	48 01 d0             	add    %rdx,%rax
  81616c:	48 c1 e0 03          	shl    $0x3,%rax
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
  816170:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  816174:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  81617b:	00 00 00 
  81617e:	48 63 d0             	movslq %eax,%rdx
  816181:	48 89 d0             	mov    %rdx,%rax
  816184:	48 c1 e0 02          	shl    $0x2,%rax
  816188:	48 01 d0             	add    %rdx,%rax
  81618b:	48 c1 e0 03          	shl    $0x3,%rax
  81618f:	48 01 c8             	add    %rcx,%rax
  816192:	48 83 c0 10          	add    $0x10,%rax
  816196:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)

  /* IP address given? */
  if (ipaddr != NULL) {
  81619d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8161a2:	74 39                	je     8161dd <find_entry+0x554>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
  8161a4:	0f b6 4d fc          	movzbl -0x4(%rbp),%ecx
  8161a8:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8161ad:	74 08                	je     8161b7 <find_entry+0x52e>
  8161af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8161b3:	8b 10                	mov    (%rax),%edx
  8161b5:	eb 05                	jmp    8161bc <find_entry+0x533>
  8161b7:	ba 00 00 00 00       	mov    $0x0,%edx
  8161bc:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  8161c3:	00 00 00 
  8161c6:	48 63 c9             	movslq %ecx,%rcx
  8161c9:	48 89 c8             	mov    %rcx,%rax
  8161cc:	48 c1 e0 02          	shl    $0x2,%rax
  8161d0:	48 01 c8             	add    %rcx,%rax
  8161d3:	48 c1 e0 03          	shl    $0x3,%rax
  8161d7:	48 01 f0             	add    %rsi,%rax
  8161da:	89 50 08             	mov    %edx,0x8(%rax)
  }
  arp_table[i].ctime = 0;
  8161dd:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  8161e1:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8161e8:	00 00 00 
  8161eb:	48 63 d0             	movslq %eax,%rdx
  8161ee:	48 89 d0             	mov    %rdx,%rax
  8161f1:	48 c1 e0 02          	shl    $0x2,%rax
  8161f5:	48 01 d0             	add    %rdx,%rax
  8161f8:	48 c1 e0 03          	shl    $0x3,%rax
  8161fc:	48 01 c8             	add    %rcx,%rax
  8161ff:	48 83 c0 10          	add    $0x10,%rax
  816203:	c6 40 08 00          	movb   $0x0,0x8(%rax)
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
  816207:	48 b8 10 b8 b4 00 00 	movabs $0xb4b810,%rax
  81620e:	00 00 00 
  816211:	0f b6 55 fc          	movzbl -0x4(%rbp),%edx
  816215:	88 10                	mov    %dl,(%rax)
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
  816217:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
}
  81621b:	c9                   	leaveq 
  81621c:	c3                   	retq   

000000000081621d <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  81621d:	55                   	push   %rbp
  81621e:	48 89 e5             	mov    %rsp,%rbp
  816221:	48 83 ec 30          	sub    $0x30,%rsp
  816225:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  816229:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81622d:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  816231:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  struct eth_hdr *ethhdr = p->payload;
  816235:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816239:	48 8b 40 08          	mov    0x8(%rax),%rax
  81623d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  816241:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  816245:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  816249:	3c 06                	cmp    $0x6,%al
  81624b:	74 2a                	je     816277 <etharp_send_ip+0x5a>
  81624d:	48 ba 40 2b 82 00 00 	movabs $0x822b40,%rdx
  816254:	00 00 00 
  816257:	be b4 01 00 00       	mov    $0x1b4,%esi
  81625c:	48 bf de 2a 82 00 00 	movabs $0x822ade,%rdi
  816263:	00 00 00 
  816266:	b8 00 00 00 00       	mov    $0x0,%eax
  81626b:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  816272:	00 00 00 
  816275:	ff d1                	callq  *%rcx
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  816277:	c6 45 ff 06          	movb   $0x6,-0x1(%rbp)
  while(k > 0) {
  81627b:	eb 43                	jmp    8162c0 <etharp_send_ip+0xa3>
    k--;
  81627d:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  816281:	83 e8 01             	sub    $0x1,%eax
  816284:	88 45 ff             	mov    %al,-0x1(%rbp)
    ethhdr->dest.addr[k] = dst->addr[k];
  816287:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  81628b:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  81628f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  816293:	48 98                	cltq   
  816295:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  816299:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81629d:	48 63 c6             	movslq %esi,%rax
  8162a0:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
    ethhdr->src.addr[k]  = src->addr[k];
  8162a3:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  8162a7:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  8162ab:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8162af:	48 98                	cltq   
  8162b1:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  8162b5:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8162b9:	48 63 c6             	movslq %esi,%rax
  8162bc:	88 4c 02 06          	mov    %cl,0x6(%rdx,%rax,1)
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
  8162c0:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  8162c4:	75 b7                	jne    81627d <etharp_send_ip+0x60>
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
    ethhdr->src.addr[k]  = src->addr[k];
  }
  ethhdr->type = htons(ETHTYPE_IP);
  8162c6:	bf 00 08 00 00       	mov    $0x800,%edi
  8162cb:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  8162d2:	00 00 00 
  8162d5:	ff d0                	callq  *%rax
  8162d7:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8162db:	66 89 42 0c          	mov    %ax,0xc(%rdx)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
  8162df:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8162e3:	48 8b 40 28          	mov    0x28(%rax),%rax
  8162e7:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8162eb:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8162ef:	48 89 ce             	mov    %rcx,%rsi
  8162f2:	48 89 d7             	mov    %rdx,%rdi
  8162f5:	ff d0                	callq  *%rax
}
  8162f7:	c9                   	leaveq 
  8162f8:	c3                   	retq   

00000000008162f9 <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
  8162f9:	55                   	push   %rbp
  8162fa:	48 89 e5             	mov    %rsp,%rbp
  8162fd:	53                   	push   %rbx
  8162fe:	48 83 ec 48          	sub    $0x48,%rsp
  816302:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  816306:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  81630a:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  81630e:	89 c8                	mov    %ecx,%eax
  816310:	88 45 b4             	mov    %al,-0x4c(%rbp)
  s8_t i;
  u8_t k;
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 3, ("update_arp_entry()\n"));
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  816313:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  816317:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  81631b:	3c 06                	cmp    $0x6,%al
  81631d:	74 2a                	je     816349 <update_arp_entry+0x50>
  81631f:	48 ba 88 2b 82 00 00 	movabs $0x822b88,%rdx
  816326:	00 00 00 
  816329:	be da 01 00 00       	mov    $0x1da,%esi
  81632e:	48 bf de 2a 82 00 00 	movabs $0x822ade,%rdi
  816335:	00 00 00 
  816338:	b8 00 00 00 00       	mov    $0x0,%eax
  81633d:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  816344:	00 00 00 
  816347:	ff d1                	callq  *%rcx
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  816349:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  81634e:	74 56                	je     8163a6 <update_arp_entry+0xad>
  816350:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  816354:	8b 00                	mov    (%rax),%eax
  816356:	85 c0                	test   %eax,%eax
  816358:	74 4c                	je     8163a6 <update_arp_entry+0xad>
      ip_addr_isbroadcast(ipaddr, netif) ||
  81635a:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81635e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  816362:	48 89 d6             	mov    %rdx,%rsi
  816365:	48 89 c7             	mov    %rax,%rdi
  816368:	48 b8 41 0d 81 00 00 	movabs $0x810d41,%rax
  81636f:	00 00 00 
  816372:	ff d0                	callq  *%rax
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  816374:	84 c0                	test   %al,%al
  816376:	75 2e                	jne    8163a6 <update_arp_entry+0xad>
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
  816378:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81637c:	8b 18                	mov    (%rax),%ebx
  81637e:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  816383:	48 b8 8c 30 81 00 00 	movabs $0x81308c,%rax
  81638a:	00 00 00 
  81638d:	ff d0                	callq  *%rax
  81638f:	21 c3                	and    %eax,%ebx
  816391:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  816396:	48 b8 8c 30 81 00 00 	movabs $0x81308c,%rax
  81639d:	00 00 00 
  8163a0:	ff d0                	callq  *%rax
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
  8163a2:	39 c3                	cmp    %eax,%ebx
  8163a4:	75 0a                	jne    8163b0 <update_arp_entry+0xb7>
      ip_addr_ismulticast(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  8163a6:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  8163ab:	e9 f0 01 00 00       	jmpq   8165a0 <update_arp_entry+0x2a7>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
  8163b0:	0f b6 55 b4          	movzbl -0x4c(%rbp),%edx
  8163b4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8163b8:	89 d6                	mov    %edx,%esi
  8163ba:	48 89 c7             	mov    %rax,%rdi
  8163bd:	48 b8 89 5c 81 00 00 	movabs $0x815c89,%rax
  8163c4:	00 00 00 
  8163c7:	ff d0                	callq  *%rax
  8163c9:	88 45 ee             	mov    %al,-0x12(%rbp)
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
  8163cc:	80 7d ee 00          	cmpb   $0x0,-0x12(%rbp)
  8163d0:	79 09                	jns    8163db <update_arp_entry+0xe2>
    return (err_t)i;
  8163d2:	0f b6 45 ee          	movzbl -0x12(%rbp),%eax
  8163d6:	e9 c5 01 00 00       	jmpq   8165a0 <update_arp_entry+0x2a7>
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
  8163db:	0f be 45 ee          	movsbl -0x12(%rbp),%eax
  8163df:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8163e6:	00 00 00 
  8163e9:	48 63 d0             	movslq %eax,%rdx
  8163ec:	48 89 d0             	mov    %rdx,%rax
  8163ef:	48 c1 e0 02          	shl    $0x2,%rax
  8163f3:	48 01 d0             	add    %rdx,%rax
  8163f6:	48 c1 e0 03          	shl    $0x3,%rax
  8163fa:	48 01 c8             	add    %rcx,%rax
  8163fd:	48 83 c0 10          	add    $0x10,%rax
  816401:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%rax)
  /* record network interface */
  arp_table[i].netif = netif;
  816408:	0f be 45 ee          	movsbl -0x12(%rbp),%eax
  81640c:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816413:	00 00 00 
  816416:	48 63 d0             	movslq %eax,%rdx
  816419:	48 89 d0             	mov    %rdx,%rax
  81641c:	48 c1 e0 02          	shl    $0x2,%rax
  816420:	48 01 d0             	add    %rdx,%rax
  816423:	48 c1 e0 03          	shl    $0x3,%rax
  816427:	48 01 c8             	add    %rcx,%rax
  81642a:	48 8d 50 20          	lea    0x20(%rax),%rdx
  81642e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  816432:	48 89 02             	mov    %rax,(%rdx)
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  816435:	c6 45 ef 06          	movb   $0x6,-0x11(%rbp)
  while (k > 0) {
  816439:	eb 48                	jmp    816483 <update_arp_entry+0x18a>
    k--;
  81643b:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81643f:	83 e8 01             	sub    $0x1,%eax
  816442:	88 45 ef             	mov    %al,-0x11(%rbp)
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  816445:	44 0f be 45 ee       	movsbl -0x12(%rbp),%r8d
  81644a:	0f b6 7d ef          	movzbl -0x11(%rbp),%edi
  81644e:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  816452:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  816456:	48 98                	cltq   
  816458:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  81645c:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  816463:	00 00 00 
  816466:	48 63 ff             	movslq %edi,%rdi
  816469:	49 63 d0             	movslq %r8d,%rdx
  81646c:	48 89 d0             	mov    %rdx,%rax
  81646f:	48 c1 e0 02          	shl    $0x2,%rax
  816473:	48 01 d0             	add    %rdx,%rax
  816476:	48 c1 e0 03          	shl    $0x3,%rax
  81647a:	48 01 f8             	add    %rdi,%rax
  81647d:	48 01 f0             	add    %rsi,%rax
  816480:	88 48 0c             	mov    %cl,0xc(%rax)
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
  816483:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  816487:	75 b2                	jne    81643b <update_arp_entry+0x142>
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
  816489:	0f be 45 ee          	movsbl -0x12(%rbp),%eax
  81648d:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816494:	00 00 00 
  816497:	48 63 d0             	movslq %eax,%rdx
  81649a:	48 89 d0             	mov    %rdx,%rax
  81649d:	48 c1 e0 02          	shl    $0x2,%rax
  8164a1:	48 01 d0             	add    %rdx,%rax
  8164a4:	48 c1 e0 03          	shl    $0x3,%rax
  8164a8:	48 01 c8             	add    %rcx,%rax
  8164ab:	48 83 c0 10          	add    $0x10,%rax
  8164af:	c6 40 08 00          	movb   $0x0,0x8(%rax)
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  8164b3:	e9 b5 00 00 00       	jmpq   81656d <update_arp_entry+0x274>
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
  8164b8:	0f be 45 ee          	movsbl -0x12(%rbp),%eax
  8164bc:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8164c3:	00 00 00 
  8164c6:	48 63 d0             	movslq %eax,%rdx
  8164c9:	48 89 d0             	mov    %rdx,%rax
  8164cc:	48 c1 e0 02          	shl    $0x2,%rax
  8164d0:	48 01 d0             	add    %rdx,%rax
  8164d3:	48 c1 e0 03          	shl    $0x3,%rax
  8164d7:	48 01 c8             	add    %rcx,%rax
  8164da:	48 8b 00             	mov    (%rax),%rax
  8164dd:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    /* pop first item off the queue */
    arp_table[i].q = q->next;
  8164e1:	0f be 55 ee          	movsbl -0x12(%rbp),%edx
  8164e5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8164e9:	48 8b 08             	mov    (%rax),%rcx
  8164ec:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  8164f3:	00 00 00 
  8164f6:	48 63 d2             	movslq %edx,%rdx
  8164f9:	48 89 d0             	mov    %rdx,%rax
  8164fc:	48 c1 e0 02          	shl    $0x2,%rax
  816500:	48 01 d0             	add    %rdx,%rax
  816503:	48 c1 e0 03          	shl    $0x3,%rax
  816507:	48 01 f0             	add    %rsi,%rax
  81650a:	48 89 08             	mov    %rcx,(%rax)
    /* get the packet pointer */
    p = q->p;
  81650d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816511:	48 8b 40 08          	mov    0x8(%rax),%rax
  816515:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
  816519:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81651d:	48 89 c6             	mov    %rax,%rsi
  816520:	bf 0a 00 00 00       	mov    $0xa,%edi
  816525:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  81652c:	00 00 00 
  81652f:	ff d0                	callq  *%rax
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  816531:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  816535:	48 8d 78 41          	lea    0x41(%rax),%rdi
  816539:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  81653d:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  816541:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  816545:	48 89 d1             	mov    %rdx,%rcx
  816548:	48 89 fa             	mov    %rdi,%rdx
  81654b:	48 89 c7             	mov    %rax,%rdi
  81654e:	48 b8 1d 62 81 00 00 	movabs $0x81621d,%rax
  816555:	00 00 00 
  816558:	ff d0                	callq  *%rax
    /* free the queued IP packet */
    pbuf_free(p);
  81655a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81655e:	48 89 c7             	mov    %rax,%rdi
  816561:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  816568:	00 00 00 
  81656b:	ff d0                	callq  *%rax
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  81656d:	0f be 45 ee          	movsbl -0x12(%rbp),%eax
  816571:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816578:	00 00 00 
  81657b:	48 63 d0             	movslq %eax,%rdx
  81657e:	48 89 d0             	mov    %rdx,%rax
  816581:	48 c1 e0 02          	shl    $0x2,%rax
  816585:	48 01 d0             	add    %rdx,%rax
  816588:	48 c1 e0 03          	shl    $0x3,%rax
  81658c:	48 01 c8             	add    %rcx,%rax
  81658f:	48 8b 00             	mov    (%rax),%rax
  816592:	48 85 c0             	test   %rax,%rax
  816595:	0f 85 1d ff ff ff    	jne    8164b8 <update_arp_entry+0x1bf>
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
    /* free the queued IP packet */
    pbuf_free(p);
  }
#endif
  return ERR_OK;
  81659b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8165a0:	48 83 c4 48          	add    $0x48,%rsp
  8165a4:	5b                   	pop    %rbx
  8165a5:	5d                   	pop    %rbp
  8165a6:	c3                   	retq   

00000000008165a7 <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
  8165a7:	55                   	push   %rbp
  8165a8:	48 89 e5             	mov    %rsp,%rbp
  8165ab:	48 83 ec 30          	sub    $0x30,%rsp
  8165af:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8165b3:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8165b7:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8165bb:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
  8165bf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8165c3:	be 02 00 00 00       	mov    $0x2,%esi
  8165c8:	48 89 c7             	mov    %rax,%rdi
  8165cb:	48 b8 89 5c 81 00 00 	movabs $0x815c89,%rax
  8165d2:	00 00 00 
  8165d5:	ff d0                	callq  *%rax
  8165d7:	88 45 ff             	mov    %al,-0x1(%rbp)
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
  8165da:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  8165de:	0f 88 8e 00 00 00    	js     816672 <etharp_find_addr+0xcb>
  8165e4:	0f be 45 ff          	movsbl -0x1(%rbp),%eax
  8165e8:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8165ef:	00 00 00 
  8165f2:	48 63 d0             	movslq %eax,%rdx
  8165f5:	48 89 d0             	mov    %rdx,%rax
  8165f8:	48 c1 e0 02          	shl    $0x2,%rax
  8165fc:	48 01 d0             	add    %rdx,%rax
  8165ff:	48 c1 e0 03          	shl    $0x3,%rax
  816603:	48 01 c8             	add    %rcx,%rax
  816606:	48 83 c0 10          	add    $0x10,%rax
  81660a:	8b 40 04             	mov    0x4(%rax),%eax
  81660d:	83 f8 02             	cmp    $0x2,%eax
  816610:	75 60                	jne    816672 <etharp_find_addr+0xcb>
      *eth_ret = &arp_table[i].ethaddr;
  816612:	0f be 45 ff          	movsbl -0x1(%rbp),%eax
  816616:	48 63 d0             	movslq %eax,%rdx
  816619:	48 89 d0             	mov    %rdx,%rax
  81661c:	48 c1 e0 02          	shl    $0x2,%rax
  816620:	48 01 d0             	add    %rdx,%rax
  816623:	48 c1 e0 03          	shl    $0x3,%rax
  816627:	48 ba 80 b6 b4 00 00 	movabs $0xb4b680,%rdx
  81662e:	00 00 00 
  816631:	48 01 d0             	add    %rdx,%rax
  816634:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  816638:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81663c:	48 89 10             	mov    %rdx,(%rax)
      *ip_ret = &arp_table[i].ipaddr;
  81663f:	0f be 45 ff          	movsbl -0x1(%rbp),%eax
  816643:	48 63 d0             	movslq %eax,%rdx
  816646:	48 89 d0             	mov    %rdx,%rax
  816649:	48 c1 e0 02          	shl    $0x2,%rax
  81664d:	48 01 d0             	add    %rdx,%rax
  816650:	48 c1 e0 03          	shl    $0x3,%rax
  816654:	48 ba 80 b6 b4 00 00 	movabs $0xb4b680,%rdx
  81665b:	00 00 00 
  81665e:	48 01 d0             	add    %rdx,%rax
  816661:	48 8d 50 08          	lea    0x8(%rax),%rdx
  816665:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  816669:	48 89 10             	mov    %rdx,(%rax)
      return i;
  81666c:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  816670:	eb 05                	jmp    816677 <etharp_find_addr+0xd0>
  }
  return -1;
  816672:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  816677:	c9                   	leaveq 
  816678:	c3                   	retq   

0000000000816679 <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
  816679:	55                   	push   %rbp
  81667a:	48 89 e5             	mov    %rsp,%rbp
  81667d:	48 83 ec 20          	sub    $0x20,%rsp
  816681:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  816685:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct ethip_hdr *hdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  816689:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81668e:	75 2a                	jne    8166ba <etharp_ip_input+0x41>
  816690:	48 ba af 2b 82 00 00 	movabs $0x822baf,%rdx
  816697:	00 00 00 
  81669a:	be 49 02 00 00       	mov    $0x249,%esi
  81669f:	48 bf de 2a 82 00 00 	movabs $0x822ade,%rdi
  8166a6:	00 00 00 
  8166a9:	b8 00 00 00 00       	mov    $0x0,%eax
  8166ae:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  8166b5:	00 00 00 
  8166b8:	ff d1                	callq  *%rcx
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  8166ba:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8166be:	48 8b 40 08          	mov    0x8(%rax),%rax
  8166c2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
  8166c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8166ca:	8b 50 1c             	mov    0x1c(%rax),%edx
  8166cd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8166d1:	8b 40 08             	mov    0x8(%rax),%eax
  8166d4:	31 c2                	xor    %eax,%edx
  8166d6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8166da:	8b 40 0c             	mov    0xc(%rax),%eax
  8166dd:	21 d0                	and    %edx,%eax
  8166df:	85 c0                	test   %eax,%eax
  8166e1:	74 02                	je     8166e5 <etharp_ip_input+0x6c>
    /* do nothing */
    return;
  8166e3:	eb 28                	jmp    81670d <etharp_ip_input+0x94>

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
  8166e5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8166e9:	48 8d 50 06          	lea    0x6(%rax),%rdx
  8166ed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8166f1:	48 8d 70 1c          	lea    0x1c(%rax),%rsi
  8166f5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8166f9:	b9 00 00 00 00       	mov    $0x0,%ecx
  8166fe:	48 89 c7             	mov    %rax,%rdi
  816701:	48 b8 f9 62 81 00 00 	movabs $0x8162f9,%rax
  816708:	00 00 00 
  81670b:	ff d0                	callq  *%rax
}
  81670d:	c9                   	leaveq 
  81670e:	c3                   	retq   

000000000081670f <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
  81670f:	55                   	push   %rbp
  816710:	48 89 e5             	mov    %rsp,%rbp
  816713:	53                   	push   %rbx
  816714:	48 83 ec 58          	sub    $0x58,%rsp
  816718:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  81671c:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  816720:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  816724:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  816729:	75 2a                	jne    816755 <etharp_arp_input+0x46>
  81672b:	48 ba af 2b 82 00 00 	movabs $0x822baf,%rdx
  816732:	00 00 00 
  816735:	be 76 02 00 00       	mov    $0x276,%esi
  81673a:	48 bf de 2a 82 00 00 	movabs $0x822ade,%rdi
  816741:	00 00 00 
  816744:	b8 00 00 00 00       	mov    $0x0,%eax
  816749:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  816750:	00 00 00 
  816753:	ff d1                	callq  *%rcx
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < sizeof(struct etharp_hdr)) {
  816755:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  816759:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81675d:	66 83 f8 29          	cmp    $0x29,%ax
  816761:	77 18                	ja     81677b <etharp_arp_input+0x6c>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1, ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len, (s16_t)sizeof(struct etharp_hdr)));
    ETHARP_STATS_INC(etharp.lenerr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  816763:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  816767:	48 89 c7             	mov    %rax,%rdi
  81676a:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  816771:	00 00 00 
  816774:	ff d0                	callq  *%rax
    return;
  816776:	e9 d3 02 00 00       	jmpq   816a4e <etharp_arp_input+0x33f>
  }

  hdr = p->payload;
  81677b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81677f:	48 8b 40 08          	mov    0x8(%rax),%rax
  816783:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  816787:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81678b:	0f b7 58 0e          	movzwl 0xe(%rax),%ebx
  81678f:	bf 01 00 00 00       	mov    $0x1,%edi
  816794:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  81679b:	00 00 00 
  81679e:	ff d0                	callq  *%rax
  8167a0:	66 39 c3             	cmp    %ax,%bx
  8167a3:	75 5a                	jne    8167ff <etharp_arp_input+0xf0>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  8167a5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8167a9:	0f b7 58 12          	movzwl 0x12(%rax),%ebx
  8167ad:	bf 04 06 00 00       	mov    $0x604,%edi
  8167b2:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  8167b9:	00 00 00 
  8167bc:	ff d0                	callq  *%rax
  }

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  8167be:	66 39 c3             	cmp    %ax,%bx
  8167c1:	75 3c                	jne    8167ff <etharp_arp_input+0xf0>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
  8167c3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8167c7:	0f b7 58 10          	movzwl 0x10(%rax),%ebx
  8167cb:	bf 00 08 00 00       	mov    $0x800,%edi
  8167d0:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  8167d7:	00 00 00 
  8167da:	ff d0                	callq  *%rax

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  8167dc:	66 39 c3             	cmp    %ax,%bx
  8167df:	75 1e                	jne    8167ff <etharp_arp_input+0xf0>
      (hdr->proto != htons(ETHTYPE_IP)) ||
      (hdr->ethhdr.type != htons(ETHTYPE_ARP)))  {
  8167e1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8167e5:	0f b7 58 0c          	movzwl 0xc(%rax),%ebx
  8167e9:	bf 06 08 00 00       	mov    $0x806,%edi
  8167ee:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  8167f5:	00 00 00 
  8167f8:	ff d0                	callq  *%rax
  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
  8167fa:	66 39 c3             	cmp    %ax,%bx
  8167fd:	74 18                	je     816817 <etharp_arp_input+0x108>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), hdr->ethhdr.type));
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  8167ff:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  816803:	48 89 c7             	mov    %rax,%rdi
  816806:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  81680d:	00 00 00 
  816810:	ff d0                	callq  *%rax
    return;
  816812:	e9 37 02 00 00       	jmpq   816a4e <etharp_arp_input+0x33f>
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  816817:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81681b:	48 8d 48 1c          	lea    0x1c(%rax),%rcx
  81681f:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  816823:	ba 04 00 00 00       	mov    $0x4,%edx
  816828:	48 89 ce             	mov    %rcx,%rsi
  81682b:	48 89 c7             	mov    %rax,%rdi
  81682e:	48 b8 12 23 80 00 00 	movabs $0x802312,%rax
  816835:	00 00 00 
  816838:	ff d0                	callq  *%rax
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
  81683a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81683e:	48 8d 48 26          	lea    0x26(%rax),%rcx
  816842:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  816846:	ba 04 00 00 00       	mov    $0x4,%edx
  81684b:	48 89 ce             	mov    %rcx,%rsi
  81684e:	48 89 c7             	mov    %rax,%rdi
  816851:	48 b8 12 23 80 00 00 	movabs $0x802312,%rax
  816858:	00 00 00 
  81685b:	ff d0                	callq  *%rax

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
  81685d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816861:	8b 40 08             	mov    0x8(%rax),%eax
  816864:	85 c0                	test   %eax,%eax
  816866:	75 06                	jne    81686e <etharp_arp_input+0x15f>
    for_us = 0;
  816868:	c6 45 ee 00          	movb   $0x0,-0x12(%rbp)
  81686c:	eb 12                	jmp    816880 <etharp_arp_input+0x171>
  } else {
    /* ARP packet directed to us? */
    for_us = ip_addr_cmp(&dipaddr, &(netif->ip_addr));
  81686e:	8b 55 c0             	mov    -0x40(%rbp),%edx
  816871:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816875:	8b 40 08             	mov    0x8(%rax),%eax
  816878:	39 c2                	cmp    %eax,%edx
  81687a:	0f 94 c0             	sete   %al
  81687d:	88 45 ee             	mov    %al,-0x12(%rbp)
  }

  /* ARP message directed to us? */
  if (for_us) {
  816880:	80 7d ee 00          	cmpb   $0x0,-0x12(%rbp)
  816884:	74 26                	je     8168ac <etharp_arp_input+0x19d>
    /* add IP address in ARP cache; assume requester wants to talk to us.
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  816886:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81688a:	48 8d 50 16          	lea    0x16(%rax),%rdx
  81688e:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  816892:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816896:	b9 01 00 00 00       	mov    $0x1,%ecx
  81689b:	48 89 c7             	mov    %rax,%rdi
  81689e:	48 b8 f9 62 81 00 00 	movabs $0x8162f9,%rax
  8168a5:	00 00 00 
  8168a8:	ff d0                	callq  *%rax
  8168aa:	eb 24                	jmp    8168d0 <etharp_arp_input+0x1c1>
  /* ARP message not directed to us? */
  } else {
    /* update the source IP address in the cache, if present */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  8168ac:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8168b0:	48 8d 50 16          	lea    0x16(%rax),%rdx
  8168b4:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8168b8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8168bc:	b9 00 00 00 00       	mov    $0x0,%ecx
  8168c1:	48 89 c7             	mov    %rax,%rdi
  8168c4:	48 b8 f9 62 81 00 00 	movabs $0x8162f9,%rax
  8168cb:	00 00 00 
  8168ce:	ff d0                	callq  *%rax
  }

  /* now act on the message itself */
  switch (htons(hdr->opcode)) {
  8168d0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8168d4:	0f b7 40 14          	movzwl 0x14(%rax),%eax
  8168d8:	0f b7 c0             	movzwl %ax,%eax
  8168db:	89 c7                	mov    %eax,%edi
  8168dd:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  8168e4:	00 00 00 
  8168e7:	ff d0                	callq  *%rax
  8168e9:	0f b7 c0             	movzwl %ax,%eax
  8168ec:	83 f8 01             	cmp    $0x1,%eax
  8168ef:	74 0e                	je     8168ff <etharp_arp_input+0x1f0>
  8168f1:	83 f8 02             	cmp    $0x2,%eax
  8168f4:	0f 84 26 01 00 00    	je     816a20 <etharp_arp_input+0x311>
#endif
    break;
  default:
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  8168fa:	e9 3c 01 00 00       	jmpq   816a3b <etharp_arp_input+0x32c>
     * reply. In any case, we time-stamp any existing ARP entry,
     * and possiby send out an IP packet that was queued on it. */

    LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
    /* ARP request for our address? */
    if (for_us) {
  8168ff:	80 7d ee 00          	cmpb   $0x0,-0x12(%rbp)
  816903:	0f 84 15 01 00 00    	je     816a1e <etharp_arp_input+0x30f>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
  816909:	bf 02 00 00 00       	mov    $0x2,%edi
  81690e:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  816915:	00 00 00 
  816918:	ff d0                	callq  *%rax
  81691a:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81691e:	66 89 42 14          	mov    %ax,0x14(%rdx)

      hdr->dipaddr = hdr->sipaddr;
  816922:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816926:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81692a:	8b 52 1c             	mov    0x1c(%rdx),%edx
  81692d:	89 50 26             	mov    %edx,0x26(%rax)
      hdr->sipaddr = *(struct ip_addr2 *)&netif->ip_addr;
  816930:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816934:	48 8d 50 08          	lea    0x8(%rax),%rdx
  816938:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81693c:	8b 12                	mov    (%rdx),%edx
  81693e:	89 50 1c             	mov    %edx,0x1c(%rax)

      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  816941:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816945:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  816949:	3c 06                	cmp    $0x6,%al
  81694b:	74 2a                	je     816977 <etharp_arp_input+0x268>
  81694d:	48 ba 40 2b 82 00 00 	movabs $0x822b40,%rdx
  816954:	00 00 00 
  816957:	be c8 02 00 00       	mov    $0x2c8,%esi
  81695c:	48 bf de 2a 82 00 00 	movabs $0x822ade,%rdi
  816963:	00 00 00 
  816966:	b8 00 00 00 00       	mov    $0x0,%eax
  81696b:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  816972:	00 00 00 
  816975:	ff d1                	callq  *%rcx
                  (netif->hwaddr_len == ETHARP_HWADDR_LEN));
      i = ETHARP_HWADDR_LEN;
  816977:	c6 45 ef 06          	movb   $0x6,-0x11(%rbp)
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
  81697b:	eb 7f                	jmp    8169fc <etharp_arp_input+0x2ed>
        i--;
  81697d:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  816981:	83 e8 01             	sub    $0x1,%eax
  816984:	88 45 ef             	mov    %al,-0x11(%rbp)
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
  816987:	0f b6 75 ef          	movzbl -0x11(%rbp),%esi
  81698b:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81698f:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  816993:	48 98                	cltq   
  816995:	0f b6 4c 02 16       	movzbl 0x16(%rdx,%rax,1),%ecx
  81699a:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81699e:	48 63 c6             	movslq %esi,%rax
  8169a1:	88 4c 02 20          	mov    %cl,0x20(%rdx,%rax,1)
#if LWIP_AUTOIP
        hdr->ethhdr.dest.addr[i] = ethdst_hwaddr[i];
#else  /* LWIP_AUTOIP */
        hdr->ethhdr.dest.addr[i] = hdr->shwaddr.addr[i];
  8169a5:	0f b6 75 ef          	movzbl -0x11(%rbp),%esi
  8169a9:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8169ad:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8169b1:	48 98                	cltq   
  8169b3:	0f b6 4c 02 16       	movzbl 0x16(%rdx,%rax,1),%ecx
  8169b8:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8169bc:	48 63 c6             	movslq %esi,%rax
  8169bf:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
#endif /* LWIP_AUTOIP */
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
  8169c2:	0f b6 75 ef          	movzbl -0x11(%rbp),%esi
  8169c6:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8169ca:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8169ce:	48 98                	cltq   
  8169d0:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  8169d4:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8169d8:	48 63 c6             	movslq %esi,%rax
  8169db:	88 4c 02 16          	mov    %cl,0x16(%rdx,%rax,1)
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
  8169df:	0f b6 75 ef          	movzbl -0x11(%rbp),%esi
  8169e3:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8169e7:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8169eb:	48 98                	cltq   
  8169ed:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  8169f1:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8169f5:	48 63 c6             	movslq %esi,%rax
  8169f8:	88 4c 02 06          	mov    %cl,0x6(%rdx,%rax,1)
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
  8169fc:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  816a00:	0f 85 77 ff ff ff    	jne    81697d <etharp_arp_input+0x26e>

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
  816a06:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816a0a:	48 8b 40 28          	mov    0x28(%rax),%rax
  816a0e:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  816a12:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  816a16:	48 89 ce             	mov    %rcx,%rsi
  816a19:	48 89 d7             	mov    %rdx,%rdi
  816a1c:	ff d0                	callq  *%rax
    /* request was not directed to us */
    } else {
      /* { for_us == 0 and netif->ip_addr.addr != 0 } */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"));
    }
    break;
  816a1e:	eb 1b                	jmp    816a3b <etharp_arp_input+0x32c>
#if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
    /* DHCP wants to know about ARP replies from any host with an
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
  816a20:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  816a24:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816a28:	48 89 d6             	mov    %rdx,%rsi
  816a2b:	48 89 c7             	mov    %rax,%rdi
  816a2e:	48 b8 68 a3 80 00 00 	movabs $0x80a368,%rax
  816a35:	00 00 00 
  816a38:	ff d0                	callq  *%rax
#endif
    break;
  816a3a:	90                   	nop
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
  816a3b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  816a3f:	48 89 c7             	mov    %rax,%rdi
  816a42:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  816a49:	00 00 00 
  816a4c:	ff d0                	callq  *%rax
}
  816a4e:	48 83 c4 58          	add    $0x58,%rsp
  816a52:	5b                   	pop    %rbx
  816a53:	5d                   	pop    %rbp
  816a54:	c3                   	retq   

0000000000816a55 <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, struct ip_addr *ipaddr)
{
  816a55:	55                   	push   %rbp
  816a56:	48 89 e5             	mov    %rsp,%rbp
  816a59:	53                   	push   %rbx
  816a5a:	48 83 ec 38          	sub    $0x38,%rsp
  816a5e:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  816a62:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  816a66:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  struct eth_addr *dest, mcastaddr;

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
  816a6a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  816a6e:	be 0e 00 00 00       	mov    $0xe,%esi
  816a73:	48 89 c7             	mov    %rax,%rdi
  816a76:	48 b8 7f db 80 00 00 	movabs $0x80db7f,%rax
  816a7d:	00 00 00 
  816a80:	ff d0                	callq  *%rax
  816a82:	84 c0                	test   %al,%al
  816a84:	74 0a                	je     816a90 <etharp_output+0x3b>
    /* bail out */
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_output: could not allocate room for header.\n"));
    LINK_STATS_INC(link.lenerr);
    return ERR_BUF;
  816a86:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  816a8b:	e9 50 01 00 00       	jmpq   816be0 <etharp_output+0x18b>
  }

  /* assume unresolved Ethernet address */
  dest = NULL;
  816a90:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  816a97:	00 
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  816a98:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  816a9c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  816aa0:	48 89 d6             	mov    %rdx,%rsi
  816aa3:	48 89 c7             	mov    %rax,%rdi
  816aa6:	48 b8 41 0d 81 00 00 	movabs $0x810d41,%rax
  816aad:	00 00 00 
  816ab0:	ff d0                	callq  *%rax
  816ab2:	84 c0                	test   %al,%al
  816ab4:	74 13                	je     816ac9 <etharp_output+0x74>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  816ab6:	48 b8 c8 2a 82 00 00 	movabs $0x822ac8,%rax
  816abd:	00 00 00 
  816ac0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  816ac4:	e9 ee 00 00 00       	jmpq   816bb7 <etharp_output+0x162>
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
  816ac9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  816acd:	8b 18                	mov    (%rax),%ebx
  816acf:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  816ad4:	48 b8 8c 30 81 00 00 	movabs $0x81308c,%rax
  816adb:	00 00 00 
  816ade:	ff d0                	callq  *%rax
  816ae0:	21 c3                	and    %eax,%ebx
  816ae2:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  816ae7:	48 b8 8c 30 81 00 00 	movabs $0x81308c,%rax
  816aee:	00 00 00 
  816af1:	ff d0                	callq  *%rax
  816af3:	39 c3                	cmp    %eax,%ebx
  816af5:	75 64                	jne    816b5b <etharp_output+0x106>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = 0x01;
  816af7:	c6 45 e0 01          	movb   $0x1,-0x20(%rbp)
    mcastaddr.addr[1] = 0x00;
  816afb:	c6 45 e1 00          	movb   $0x0,-0x1f(%rbp)
    mcastaddr.addr[2] = 0x5e;
  816aff:	c6 45 e2 5e          	movb   $0x5e,-0x1e(%rbp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
  816b03:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  816b07:	8b 00                	mov    (%rax),%eax
  816b09:	89 c7                	mov    %eax,%edi
  816b0b:	48 b8 8c 30 81 00 00 	movabs $0x81308c,%rax
  816b12:	00 00 00 
  816b15:	ff d0                	callq  *%rax
  816b17:	c1 e8 10             	shr    $0x10,%eax
  816b1a:	83 e0 7f             	and    $0x7f,%eax
  816b1d:	88 45 e3             	mov    %al,-0x1d(%rbp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
  816b20:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  816b24:	8b 00                	mov    (%rax),%eax
  816b26:	89 c7                	mov    %eax,%edi
  816b28:	48 b8 8c 30 81 00 00 	movabs $0x81308c,%rax
  816b2f:	00 00 00 
  816b32:	ff d0                	callq  *%rax
  816b34:	c1 e8 08             	shr    $0x8,%eax
  816b37:	88 45 e4             	mov    %al,-0x1c(%rbp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
  816b3a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  816b3e:	8b 00                	mov    (%rax),%eax
  816b40:	89 c7                	mov    %eax,%edi
  816b42:	48 b8 8c 30 81 00 00 	movabs $0x81308c,%rax
  816b49:	00 00 00 
  816b4c:	ff d0                	callq  *%rax
  816b4e:	88 45 e5             	mov    %al,-0x1b(%rbp)
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
  816b51:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  816b55:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  816b59:	eb 5c                	jmp    816bb7 <etharp_output+0x162>
  /* unicast destination IP address? */
  } else {
    /* outside local network? */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
  816b5b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  816b5f:	8b 10                	mov    (%rax),%edx
  816b61:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816b65:	8b 40 08             	mov    0x8(%rax),%eax
  816b68:	31 c2                	xor    %eax,%edx
  816b6a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816b6e:	8b 40 0c             	mov    0xc(%rax),%eax
  816b71:	21 d0                	and    %edx,%eax
  816b73:	85 c0                	test   %eax,%eax
  816b75:	74 20                	je     816b97 <etharp_output+0x142>
      /* interface has default gateway? */
      if (netif->gw.addr != 0) {
  816b77:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816b7b:	8b 40 10             	mov    0x10(%rax),%eax
  816b7e:	85 c0                	test   %eax,%eax
  816b80:	74 0e                	je     816b90 <etharp_output+0x13b>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
  816b82:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816b86:	48 83 c0 10          	add    $0x10,%rax
  816b8a:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  816b8e:	eb 07                	jmp    816b97 <etharp_output+0x142>
      /* no default gateway available */
      } else {
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
  816b90:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  816b95:	eb 49                	jmp    816be0 <etharp_output+0x18b>
      }
    }
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
  816b97:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  816b9b:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  816b9f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816ba3:	48 89 ce             	mov    %rcx,%rsi
  816ba6:	48 89 c7             	mov    %rax,%rdi
  816ba9:	48 b8 e7 6b 81 00 00 	movabs $0x816be7,%rax
  816bb0:	00 00 00 
  816bb3:	ff d0                	callq  *%rax
  816bb5:	eb 29                	jmp    816be0 <etharp_output+0x18b>
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
  816bb7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816bbb:	48 8d 78 41          	lea    0x41(%rax),%rdi
  816bbf:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  816bc3:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  816bc7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816bcb:	48 89 d1             	mov    %rdx,%rcx
  816bce:	48 89 fa             	mov    %rdi,%rdx
  816bd1:	48 89 c7             	mov    %rax,%rdi
  816bd4:	48 b8 1d 62 81 00 00 	movabs $0x81621d,%rax
  816bdb:	00 00 00 
  816bde:	ff d0                	callq  *%rax
}
  816be0:	48 83 c4 38          	add    $0x38,%rsp
  816be4:	5b                   	pop    %rbx
  816be5:	5d                   	pop    %rbp
  816be6:	c3                   	retq   

0000000000816be7 <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  816be7:	55                   	push   %rbp
  816be8:	48 89 e5             	mov    %rsp,%rbp
  816beb:	53                   	push   %rbx
  816bec:	48 83 ec 68          	sub    $0x68,%rsp
  816bf0:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  816bf4:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  816bf8:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  816bfc:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  816c00:	48 83 c0 41          	add    $0x41,%rax
  816c04:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  err_t result = ERR_MEM;
  816c08:	c6 45 ef ff          	movb   $0xff,-0x11(%rbp)
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  816c0c:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  816c10:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  816c14:	48 89 d6             	mov    %rdx,%rsi
  816c17:	48 89 c7             	mov    %rax,%rdi
  816c1a:	48 b8 41 0d 81 00 00 	movabs $0x810d41,%rax
  816c21:	00 00 00 
  816c24:	ff d0                	callq  *%rax
  816c26:	84 c0                	test   %al,%al
  816c28:	75 3f                	jne    816c69 <etharp_query+0x82>
      ip_addr_ismulticast(ipaddr) ||
  816c2a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  816c2e:	8b 18                	mov    (%rax),%ebx
  816c30:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  816c35:	48 b8 8c 30 81 00 00 	movabs $0x81308c,%rax
  816c3c:	00 00 00 
  816c3f:	ff d0                	callq  *%rax
  816c41:	21 c3                	and    %eax,%ebx
  816c43:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  816c48:	48 b8 8c 30 81 00 00 	movabs $0x81308c,%rax
  816c4f:	00 00 00 
  816c52:	ff d0                	callq  *%rax
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  816c54:	39 c3                	cmp    %eax,%ebx
  816c56:	74 11                	je     816c69 <etharp_query+0x82>
      ip_addr_ismulticast(ipaddr) ||
  816c58:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  816c5d:	74 0a                	je     816c69 <etharp_query+0x82>
      ip_addr_isany(ipaddr)) {
  816c5f:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  816c63:	8b 00                	mov    (%rax),%eax
  816c65:	85 c0                	test   %eax,%eax
  816c67:	75 0a                	jne    816c73 <etharp_query+0x8c>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  816c69:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  816c6e:	e9 1f 04 00 00       	jmpq   817092 <etharp_query+0x4ab>

  /* find entry in ARP cache, ask to create entry if queueing packet */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_TRY_HARD, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
  816c73:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  816c77:	be 01 00 00 00       	mov    $0x1,%esi
  816c7c:	48 89 c7             	mov    %rax,%rdi
  816c7f:	48 b8 89 5c 81 00 00 	movabs $0x815c89,%rax
  816c86:	00 00 00 
  816c89:	ff d0                	callq  *%rax
  816c8b:	88 45 c7             	mov    %al,-0x39(%rbp)
#endif /* LWIP_NETIF_HWADDRHINT */

  /* could not find or create entry? */
  if (i < 0) {
  816c8e:	80 7d c7 00          	cmpb   $0x0,-0x39(%rbp)
  816c92:	79 09                	jns    816c9d <etharp_query+0xb6>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
    if (q) {
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
      ETHARP_STATS_INC(etharp.memerr);
    }
    return (err_t)i;
  816c94:	0f b6 45 c7          	movzbl -0x39(%rbp),%eax
  816c98:	e9 f5 03 00 00       	jmpq   817092 <etharp_query+0x4ab>
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
  816c9d:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816ca1:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816ca8:	00 00 00 
  816cab:	48 63 d0             	movslq %eax,%rdx
  816cae:	48 89 d0             	mov    %rdx,%rax
  816cb1:	48 c1 e0 02          	shl    $0x2,%rax
  816cb5:	48 01 d0             	add    %rdx,%rax
  816cb8:	48 c1 e0 03          	shl    $0x3,%rax
  816cbc:	48 01 c8             	add    %rcx,%rax
  816cbf:	48 83 c0 10          	add    $0x10,%rax
  816cc3:	8b 40 04             	mov    0x4(%rax),%eax
  816cc6:	85 c0                	test   %eax,%eax
  816cc8:	75 2d                	jne    816cf7 <etharp_query+0x110>
    arp_table[i].state = ETHARP_STATE_PENDING;
  816cca:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816cce:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816cd5:	00 00 00 
  816cd8:	48 63 d0             	movslq %eax,%rdx
  816cdb:	48 89 d0             	mov    %rdx,%rax
  816cde:	48 c1 e0 02          	shl    $0x2,%rax
  816ce2:	48 01 d0             	add    %rdx,%rax
  816ce5:	48 c1 e0 03          	shl    $0x3,%rax
  816ce9:	48 01 c8             	add    %rcx,%rax
  816cec:	48 83 c0 10          	add    $0x10,%rax
  816cf0:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%rax)
  }

  /* { i is either a STABLE or (new or existing) PENDING entry } */
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  816cf7:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816cfb:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816d02:	00 00 00 
  816d05:	48 63 d0             	movslq %eax,%rdx
  816d08:	48 89 d0             	mov    %rdx,%rax
  816d0b:	48 c1 e0 02          	shl    $0x2,%rax
  816d0f:	48 01 d0             	add    %rdx,%rax
  816d12:	48 c1 e0 03          	shl    $0x3,%rax
  816d16:	48 01 c8             	add    %rcx,%rax
  816d19:	48 83 c0 10          	add    $0x10,%rax
  816d1d:	8b 40 04             	mov    0x4(%rax),%eax
  816d20:	83 f8 01             	cmp    $0x1,%eax
  816d23:	74 58                	je     816d7d <etharp_query+0x196>
  816d25:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816d29:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816d30:	00 00 00 
  816d33:	48 63 d0             	movslq %eax,%rdx
  816d36:	48 89 d0             	mov    %rdx,%rax
  816d39:	48 c1 e0 02          	shl    $0x2,%rax
  816d3d:	48 01 d0             	add    %rdx,%rax
  816d40:	48 c1 e0 03          	shl    $0x3,%rax
  816d44:	48 01 c8             	add    %rcx,%rax
  816d47:	48 83 c0 10          	add    $0x10,%rax
  816d4b:	8b 40 04             	mov    0x4(%rax),%eax
  816d4e:	83 f8 02             	cmp    $0x2,%eax
  816d51:	74 2a                	je     816d7d <etharp_query+0x196>
  816d53:	48 ba c0 2b 82 00 00 	movabs $0x822bc0,%rdx
  816d5a:	00 00 00 
  816d5d:	be 93 03 00 00       	mov    $0x393,%esi
  816d62:	48 bf de 2a 82 00 00 	movabs $0x822ade,%rdi
  816d69:	00 00 00 
  816d6c:	b8 00 00 00 00       	mov    $0x0,%eax
  816d71:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  816d78:	00 00 00 
  816d7b:	ff d1                	callq  *%rcx
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
  816d7d:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816d81:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816d88:	00 00 00 
  816d8b:	48 63 d0             	movslq %eax,%rdx
  816d8e:	48 89 d0             	mov    %rdx,%rax
  816d91:	48 c1 e0 02          	shl    $0x2,%rax
  816d95:	48 01 d0             	add    %rdx,%rax
  816d98:	48 c1 e0 03          	shl    $0x3,%rax
  816d9c:	48 01 c8             	add    %rcx,%rax
  816d9f:	48 83 c0 10          	add    $0x10,%rax
  816da3:	8b 40 04             	mov    0x4(%rax),%eax
  816da6:	83 f8 01             	cmp    $0x1,%eax
  816da9:	74 07                	je     816db2 <etharp_query+0x1cb>
  816dab:	48 83 7d 98 00       	cmpq   $0x0,-0x68(%rbp)
  816db0:	75 1d                	jne    816dcf <etharp_query+0x1e8>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  816db2:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  816db6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  816dba:	48 89 d6             	mov    %rdx,%rsi
  816dbd:	48 89 c7             	mov    %rax,%rdi
  816dc0:	48 b8 cf 72 81 00 00 	movabs $0x8172cf,%rax
  816dc7:	00 00 00 
  816dca:	ff d0                	callq  *%rax
  816dcc:	88 45 ef             	mov    %al,-0x11(%rbp)
         etharp_query again could lead to sending the queued packets. */
    }
  }
  
  /* packet given? */
  if (q != NULL) {
  816dcf:	48 83 7d 98 00       	cmpq   $0x0,-0x68(%rbp)
  816dd4:	0f 84 b4 02 00 00    	je     81708e <etharp_query+0x4a7>
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
  816dda:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816dde:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816de5:	00 00 00 
  816de8:	48 63 d0             	movslq %eax,%rdx
  816deb:	48 89 d0             	mov    %rdx,%rax
  816dee:	48 c1 e0 02          	shl    $0x2,%rax
  816df2:	48 01 d0             	add    %rdx,%rax
  816df5:	48 c1 e0 03          	shl    $0x3,%rax
  816df9:	48 01 c8             	add    %rcx,%rax
  816dfc:	48 83 c0 10          	add    $0x10,%rax
  816e00:	8b 40 04             	mov    0x4(%rax),%eax
  816e03:	83 f8 02             	cmp    $0x2,%eax
  816e06:	75 49                	jne    816e51 <etharp_query+0x26a>
      /* we have a valid IP->Ethernet address mapping */
      /* send the packet */
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  816e08:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816e0c:	48 63 d0             	movslq %eax,%rdx
  816e0f:	48 89 d0             	mov    %rdx,%rax
  816e12:	48 c1 e0 02          	shl    $0x2,%rax
  816e16:	48 01 d0             	add    %rdx,%rax
  816e19:	48 c1 e0 03          	shl    $0x3,%rax
  816e1d:	48 ba 80 b6 b4 00 00 	movabs $0xb4b680,%rdx
  816e24:	00 00 00 
  816e27:	48 01 d0             	add    %rdx,%rax
  816e2a:	48 8d 48 0c          	lea    0xc(%rax),%rcx
  816e2e:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  816e32:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
  816e36:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  816e3a:	48 89 c7             	mov    %rax,%rdi
  816e3d:	48 b8 1d 62 81 00 00 	movabs $0x81621d,%rax
  816e44:	00 00 00 
  816e47:	ff d0                	callq  *%rax
  816e49:	88 45 ef             	mov    %al,-0x11(%rbp)
  816e4c:	e9 3d 02 00 00       	jmpq   81708e <etharp_query+0x4a7>
    /* pending entry? (either just created or already pending */
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  816e51:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816e55:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816e5c:	00 00 00 
  816e5f:	48 63 d0             	movslq %eax,%rdx
  816e62:	48 89 d0             	mov    %rdx,%rax
  816e65:	48 c1 e0 02          	shl    $0x2,%rax
  816e69:	48 01 d0             	add    %rdx,%rax
  816e6c:	48 c1 e0 03          	shl    $0x3,%rax
  816e70:	48 01 c8             	add    %rcx,%rax
  816e73:	48 83 c0 10          	add    $0x10,%rax
  816e77:	8b 40 04             	mov    0x4(%rax),%eax
  816e7a:	83 f8 01             	cmp    $0x1,%eax
  816e7d:	0f 85 0b 02 00 00    	jne    81708e <etharp_query+0x4a7>
#if ARP_QUEUEING /* queue the given q packet */
      struct pbuf *p;
      int copy_needed = 0;
  816e83:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
  816e8a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  816e8e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      while (p) {
  816e92:	eb 6b                	jmp    816eff <etharp_query+0x318>
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  816e94:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816e98:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  816e9c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816ea0:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  816ea4:	66 39 c2             	cmp    %ax,%dx
  816ea7:	75 36                	jne    816edf <etharp_query+0x2f8>
  816ea9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816ead:	48 8b 00             	mov    (%rax),%rax
  816eb0:	48 85 c0             	test   %rax,%rax
  816eb3:	74 2a                	je     816edf <etharp_query+0x2f8>
  816eb5:	48 ba e8 2b 82 00 00 	movabs $0x822be8,%rdx
  816ebc:	00 00 00 
  816ebf:	be b2 03 00 00       	mov    $0x3b2,%esi
  816ec4:	48 bf de 2a 82 00 00 	movabs $0x822ade,%rdi
  816ecb:	00 00 00 
  816ece:	b8 00 00 00 00       	mov    $0x0,%eax
  816ed3:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  816eda:	00 00 00 
  816edd:	ff d1                	callq  *%rcx
        if(p->type != PBUF_ROM) {
  816edf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816ee3:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  816ee7:	3c 01                	cmp    $0x1,%al
  816ee9:	74 09                	je     816ef4 <etharp_query+0x30d>
          copy_needed = 1;
  816eeb:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%rbp)
          break;
  816ef2:	eb 12                	jmp    816f06 <etharp_query+0x31f>
        }
        p = p->next;
  816ef4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816ef8:	48 8b 00             	mov    (%rax),%rax
  816efb:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      int copy_needed = 0;
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
  816eff:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  816f04:	75 8e                	jne    816e94 <etharp_query+0x2ad>
          copy_needed = 1;
          break;
        }
        p = p->next;
      }
      if(copy_needed) {
  816f06:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  816f0a:	74 69                	je     816f75 <etharp_query+0x38e>
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  816f0c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816f10:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  816f14:	0f b7 c0             	movzwl %ax,%eax
  816f17:	ba 00 00 00 00       	mov    $0x0,%edx
  816f1c:	89 c6                	mov    %eax,%esi
  816f1e:	bf 03 00 00 00       	mov    $0x3,%edi
  816f23:	48 b8 61 d4 80 00 00 	movabs $0x80d461,%rax
  816f2a:	00 00 00 
  816f2d:	ff d0                	callq  *%rax
  816f2f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        if(p != NULL) {
  816f33:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  816f38:	74 56                	je     816f90 <etharp_query+0x3a9>
          if (pbuf_copy(p, q) != ERR_OK) {
  816f3a:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  816f3e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816f42:	48 89 d6             	mov    %rdx,%rsi
  816f45:	48 89 c7             	mov    %rax,%rdi
  816f48:	48 b8 bf e1 80 00 00 	movabs $0x80e1bf,%rax
  816f4f:	00 00 00 
  816f52:	ff d0                	callq  *%rax
  816f54:	84 c0                	test   %al,%al
  816f56:	74 38                	je     816f90 <etharp_query+0x3a9>
            pbuf_free(p);
  816f58:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816f5c:	48 89 c7             	mov    %rax,%rdi
  816f5f:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  816f66:	00 00 00 
  816f69:	ff d0                	callq  *%rax
            p = NULL;
  816f6b:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  816f72:	00 
  816f73:	eb 1b                	jmp    816f90 <etharp_query+0x3a9>
          }
        }
      } else {
        /* referencing the old pbuf is enough */
        p = q;
  816f75:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  816f79:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        pbuf_ref(p);
  816f7d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816f81:	48 89 c7             	mov    %rax,%rdi
  816f84:	48 b8 23 df 80 00 00 	movabs $0x80df23,%rax
  816f8b:	00 00 00 
  816f8e:	ff d0                	callq  *%rax
      }
      /* packet could be taken over? */
      if (p != NULL) {
  816f90:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  816f95:	0f 84 f3 00 00 00    	je     81708e <etharp_query+0x4a7>
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
  816f9b:	bf 0a 00 00 00       	mov    $0xa,%edi
  816fa0:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  816fa7:	00 00 00 
  816faa:	ff d0                	callq  *%rax
  816fac:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
        if (new_entry != NULL) {
  816fb0:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  816fb5:	0f 84 c0 00 00 00    	je     81707b <etharp_query+0x494>
          new_entry->next = 0;
  816fbb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816fbf:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
          new_entry->p = p;
  816fc6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816fca:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  816fce:	48 89 50 08          	mov    %rdx,0x8(%rax)
          if(arp_table[i].q != NULL) {
  816fd2:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816fd6:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816fdd:	00 00 00 
  816fe0:	48 63 d0             	movslq %eax,%rdx
  816fe3:	48 89 d0             	mov    %rdx,%rax
  816fe6:	48 c1 e0 02          	shl    $0x2,%rax
  816fea:	48 01 d0             	add    %rdx,%rax
  816fed:	48 c1 e0 03          	shl    $0x3,%rax
  816ff1:	48 01 c8             	add    %rcx,%rax
  816ff4:	48 8b 00             	mov    (%rax),%rax
  816ff7:	48 85 c0             	test   %rax,%rax
  816ffa:	74 4f                	je     81704b <etharp_query+0x464>
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
  816ffc:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  817000:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  817007:	00 00 00 
  81700a:	48 63 d0             	movslq %eax,%rdx
  81700d:	48 89 d0             	mov    %rdx,%rax
  817010:	48 c1 e0 02          	shl    $0x2,%rax
  817014:	48 01 d0             	add    %rdx,%rax
  817017:	48 c1 e0 03          	shl    $0x3,%rax
  81701b:	48 01 c8             	add    %rcx,%rax
  81701e:	48 8b 00             	mov    (%rax),%rax
  817021:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
            while (r->next != NULL) {
  817025:	eb 0b                	jmp    817032 <etharp_query+0x44b>
              r = r->next;
  817027:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81702b:	48 8b 00             	mov    (%rax),%rax
  81702e:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
          new_entry->p = p;
          if(arp_table[i].q != NULL) {
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
            while (r->next != NULL) {
  817032:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  817036:	48 8b 00             	mov    (%rax),%rax
  817039:	48 85 c0             	test   %rax,%rax
  81703c:	75 e9                	jne    817027 <etharp_query+0x440>
              r = r->next;
            }
            r->next = new_entry;
  81703e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  817042:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  817046:	48 89 10             	mov    %rdx,(%rax)
  817049:	eb 2a                	jmp    817075 <etharp_query+0x48e>
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
  81704b:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  81704f:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  817056:	00 00 00 
  817059:	48 63 d0             	movslq %eax,%rdx
  81705c:	48 89 d0             	mov    %rdx,%rax
  81705f:	48 c1 e0 02          	shl    $0x2,%rax
  817063:	48 01 d0             	add    %rdx,%rax
  817066:	48 c1 e0 03          	shl    $0x3,%rax
  81706a:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  81706e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  817072:	48 89 02             	mov    %rax,(%rdx)
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
  817075:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  817079:	eb 13                	jmp    81708e <etharp_query+0x4a7>
        } else {
          /* the pool MEMP_ARP_QUEUE is empty */
          pbuf_free(p);
  81707b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81707f:	48 89 c7             	mov    %rax,%rdi
  817082:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  817089:	00 00 00 
  81708c:	ff d0                	callq  *%rax
      /* { result == ERR_MEM } through initialization */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: Ethernet destination address unknown, queueing disabled, packet %p dropped\n", (void *)q));
#endif
    }
  }
  return result;
  81708e:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
}
  817092:	48 83 c4 68          	add    $0x68,%rsp
  817096:	5b                   	pop    %rbx
  817097:	5d                   	pop    %rbp
  817098:	c3                   	retq   

0000000000817099 <etharp_raw>:
etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
           const struct eth_addr *ethdst_addr,
           const struct eth_addr *hwsrc_addr, const struct ip_addr *ipsrc_addr,
           const struct eth_addr *hwdst_addr, const struct ip_addr *ipdst_addr,
           const u16_t opcode)
{
  817099:	55                   	push   %rbp
  81709a:	48 89 e5             	mov    %rsp,%rbp
  81709d:	48 83 ec 60          	sub    $0x60,%rsp
  8170a1:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8170a5:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8170a9:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8170ad:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  8170b1:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
  8170b5:	4c 89 4d b0          	mov    %r9,-0x50(%rbp)
  8170b9:	8b 45 18             	mov    0x18(%rbp),%eax
  8170bc:	66 89 45 ac          	mov    %ax,-0x54(%rbp)
  struct pbuf *p;
  err_t result = ERR_OK;
  8170c0:	c6 45 fe 00          	movb   $0x0,-0x2(%rbp)
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  8170c4:	ba 00 00 00 00       	mov    $0x0,%edx
  8170c9:	be 2a 00 00 00       	mov    $0x2a,%esi
  8170ce:	bf 02 00 00 00       	mov    $0x2,%edi
  8170d3:	48 b8 61 d4 80 00 00 	movabs $0x80d461,%rax
  8170da:	00 00 00 
  8170dd:	ff d0                	callq  *%rax
  8170df:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
  8170e3:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8170e8:	75 0a                	jne    8170f4 <etharp_raw+0x5b>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  8170ea:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8170ef:	e9 d9 01 00 00       	jmpq   8172cd <etharp_raw+0x234>
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  8170f4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8170f8:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8170fc:	66 83 f8 29          	cmp    $0x29,%ax
  817100:	77 2a                	ja     81712c <etharp_raw+0x93>
  817102:	48 ba 08 2c 82 00 00 	movabs $0x822c08,%rdx
  817109:	00 00 00 
  81710c:	be 1d 04 00 00       	mov    $0x41d,%esi
  817111:	48 bf de 2a 82 00 00 	movabs $0x822ade,%rdi
  817118:	00 00 00 
  81711b:	b8 00 00 00 00       	mov    $0x0,%eax
  817120:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  817127:	00 00 00 
  81712a:	ff d1                	callq  *%rcx
              (p->len >= sizeof(struct etharp_hdr)));

  hdr = p->payload;
  81712c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  817130:	48 8b 40 08          	mov    0x8(%rax),%rax
  817134:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
  817138:	0f b7 45 ac          	movzwl -0x54(%rbp),%eax
  81713c:	89 c7                	mov    %eax,%edi
  81713e:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  817145:	00 00 00 
  817148:	ff d0                	callq  *%rax
  81714a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81714e:	66 89 42 14          	mov    %ax,0x14(%rdx)

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  817152:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  817156:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  81715a:	3c 06                	cmp    $0x6,%al
  81715c:	74 2a                	je     817188 <etharp_raw+0xef>
  81715e:	48 ba 40 2b 82 00 00 	movabs $0x822b40,%rdx
  817165:	00 00 00 
  817168:	be 24 04 00 00       	mov    $0x424,%esi
  81716d:	48 bf de 2a 82 00 00 	movabs $0x822ade,%rdi
  817174:	00 00 00 
  817177:	b8 00 00 00 00       	mov    $0x0,%eax
  81717c:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  817183:	00 00 00 
  817186:	ff d1                	callq  *%rcx
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  817188:	c6 45 ff 06          	movb   $0x6,-0x1(%rbp)
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
  81718c:	eb 7d                	jmp    81720b <etharp_raw+0x172>
    k--;
  81718e:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  817192:	83 e8 01             	sub    $0x1,%eax
  817195:	88 45 ff             	mov    %al,-0x1(%rbp)
    /* Write the ARP MAC-Addresses */
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
  817198:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  81719c:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  8171a0:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8171a4:	48 98                	cltq   
  8171a6:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  8171aa:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8171ae:	48 63 c6             	movslq %esi,%rax
  8171b1:	88 4c 02 16          	mov    %cl,0x16(%rdx,%rax,1)
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  8171b5:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  8171b9:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  8171bd:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8171c1:	48 98                	cltq   
  8171c3:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  8171c7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8171cb:	48 63 c6             	movslq %esi,%rax
  8171ce:	88 4c 02 20          	mov    %cl,0x20(%rdx,%rax,1)
    /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
    hdr->ethhdr.dest.addr[k] = ethdst_hwaddr[k];
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
  8171d2:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  8171d6:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  8171da:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8171de:	48 98                	cltq   
  8171e0:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  8171e4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8171e8:	48 63 c6             	movslq %esi,%rax
  8171eb:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  8171ee:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  8171f2:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  8171f6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8171fa:	48 98                	cltq   
  8171fc:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  817200:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  817204:	48 63 c6             	movslq %esi,%rax
  817207:	88 4c 02 06          	mov    %cl,0x6(%rdx,%rax,1)
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
  81720b:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  81720f:	0f 85 79 ff ff ff    	jne    81718e <etharp_raw+0xf5>
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  }
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
  817215:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  817219:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  81721d:	8b 12                	mov    (%rdx),%edx
  81721f:	89 50 1c             	mov    %edx,0x1c(%rax)
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
  817222:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  817226:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  81722a:	8b 12                	mov    (%rdx),%edx
  81722c:	89 50 26             	mov    %edx,0x26(%rax)

  hdr->hwtype = htons(HWTYPE_ETHERNET);
  81722f:	bf 01 00 00 00       	mov    $0x1,%edi
  817234:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  81723b:	00 00 00 
  81723e:	ff d0                	callq  *%rax
  817240:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  817244:	66 89 42 0e          	mov    %ax,0xe(%rdx)
  hdr->proto = htons(ETHTYPE_IP);
  817248:	bf 00 08 00 00       	mov    $0x800,%edi
  81724d:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  817254:	00 00 00 
  817257:	ff d0                	callq  *%rax
  817259:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81725d:	66 89 42 10          	mov    %ax,0x10(%rdx)
  /* set hwlen and protolen together */
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
  817261:	bf 04 06 00 00       	mov    $0x604,%edi
  817266:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  81726d:	00 00 00 
  817270:	ff d0                	callq  *%rax
  817272:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  817276:	66 89 42 12          	mov    %ax,0x12(%rdx)

  hdr->ethhdr.type = htons(ETHTYPE_ARP);
  81727a:	bf 06 08 00 00       	mov    $0x806,%edi
  81727f:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  817286:	00 00 00 
  817289:	ff d0                	callq  *%rax
  81728b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81728f:	66 89 42 0c          	mov    %ax,0xc(%rdx)
  /* send ARP query */
  result = netif->linkoutput(netif, p);
  817293:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  817297:	48 8b 40 28          	mov    0x28(%rax),%rax
  81729b:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  81729f:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8172a3:	48 89 ce             	mov    %rcx,%rsi
  8172a6:	48 89 d7             	mov    %rdx,%rdi
  8172a9:	ff d0                	callq  *%rax
  8172ab:	88 45 fe             	mov    %al,-0x2(%rbp)
  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
  8172ae:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8172b2:	48 89 c7             	mov    %rax,%rdi
  8172b5:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  8172bc:	00 00 00 
  8172bf:	ff d0                	callq  *%rax
  p = NULL;
  8172c1:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8172c8:	00 
  /* could not allocate pbuf for ARP request */

  return result;
  8172c9:	0f b6 45 fe          	movzbl -0x2(%rbp),%eax
}
  8172cd:	c9                   	leaveq 
  8172ce:	c3                   	retq   

00000000008172cf <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  8172cf:	55                   	push   %rbp
  8172d0:	48 89 e5             	mov    %rsp,%rbp
  8172d3:	48 83 ec 20          	sub    $0x20,%rsp
  8172d7:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8172db:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
  8172df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8172e3:	48 8d 78 08          	lea    0x8(%rax),%rdi
  8172e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8172eb:	48 8d 48 41          	lea    0x41(%rax),%rcx
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
  8172ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8172f3:	48 8d 70 41          	lea    0x41(%rax),%rsi
  8172f7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8172fb:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%rsp)
  817302:	00 
  817303:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  817307:	48 89 14 24          	mov    %rdx,(%rsp)
  81730b:	49 b9 ce 2a 82 00 00 	movabs $0x822ace,%r9
  817312:	00 00 00 
  817315:	49 89 f8             	mov    %rdi,%r8
  817318:	48 ba c8 2a 82 00 00 	movabs $0x822ac8,%rdx
  81731f:	00 00 00 
  817322:	48 89 c7             	mov    %rax,%rdi
  817325:	48 b8 99 70 81 00 00 	movabs $0x817099,%rax
  81732c:	00 00 00 
  81732f:	ff d0                	callq  *%rax
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
  817331:	c9                   	leaveq 
  817332:	c3                   	retq   

0000000000817333 <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
  817333:	55                   	push   %rbp
  817334:	48 89 e5             	mov    %rsp,%rbp
  817337:	48 83 ec 20          	sub    $0x20,%rsp
  81733b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81733f:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct eth_hdr* ethhdr;

  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = p->payload;
  817343:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  817347:	48 8b 40 08          	mov    0x8(%rax),%rax
  81734b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  switch (htons(ethhdr->type)) {
  81734f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817353:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  817357:	0f b7 c0             	movzwl %ax,%eax
  81735a:	89 c7                	mov    %eax,%edi
  81735c:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  817363:	00 00 00 
  817366:	ff d0                	callq  *%rax
  817368:	0f b7 c0             	movzwl %ax,%eax
  81736b:	3d 00 08 00 00       	cmp    $0x800,%eax
  817370:	74 10                	je     817382 <ethernet_input+0x4f>
  817372:	3d 06 08 00 00       	cmp    $0x806,%eax
  817377:	0f 84 81 00 00 00    	je     8173fe <ethernet_input+0xcb>
  81737d:	e9 a0 00 00 00       	jmpq   817422 <ethernet_input+0xef>
    /* IP packet? */
    case ETHTYPE_IP:
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
  817382:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  817386:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81738a:	48 89 d6             	mov    %rdx,%rsi
  81738d:	48 89 c7             	mov    %rax,%rdi
  817390:	48 b8 79 66 81 00 00 	movabs $0x816679,%rax
  817397:	00 00 00 
  81739a:	ff d0                	callq  *%rax
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -(s16_t)sizeof(struct eth_hdr))) {
  81739c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8173a0:	be f2 ff ff ff       	mov    $0xfffffff2,%esi
  8173a5:	48 89 c7             	mov    %rax,%rdi
  8173a8:	48 b8 7f db 80 00 00 	movabs $0x80db7f,%rax
  8173af:	00 00 00 
  8173b2:	ff d0                	callq  *%rax
  8173b4:	84 c0                	test   %al,%al
  8173b6:	74 2a                	je     8173e2 <ethernet_input+0xaf>
        LWIP_ASSERT("Can't move over header in packet", 0);
  8173b8:	48 ba 40 2c 82 00 00 	movabs $0x822c40,%rdx
  8173bf:	00 00 00 
  8173c2:	be 7f 04 00 00       	mov    $0x47f,%esi
  8173c7:	48 bf de 2a 82 00 00 	movabs $0x822ade,%rdi
  8173ce:	00 00 00 
  8173d1:	b8 00 00 00 00       	mov    $0x0,%eax
  8173d6:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  8173dd:	00 00 00 
  8173e0:	ff d1                	callq  *%rcx
        pbuf_free(p);
        p = NULL;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
  8173e2:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8173e6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8173ea:	48 89 d6             	mov    %rdx,%rsi
  8173ed:	48 89 c7             	mov    %rax,%rdi
  8173f0:	48 b8 90 0e 81 00 00 	movabs $0x810e90,%rax
  8173f7:	00 00 00 
  8173fa:	ff d0                	callq  *%rax
      }
      break;
  8173fc:	eb 40                	jmp    81743e <ethernet_input+0x10b>
      
    case ETHTYPE_ARP:
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
  8173fe:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  817402:	48 8d 48 41          	lea    0x41(%rax),%rcx
  817406:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81740a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81740e:	48 89 ce             	mov    %rcx,%rsi
  817411:	48 89 c7             	mov    %rax,%rdi
  817414:	48 b8 0f 67 81 00 00 	movabs $0x81670f,%rax
  81741b:	00 00 00 
  81741e:	ff d0                	callq  *%rax
      break;
  817420:	eb 1c                	jmp    81743e <ethernet_input+0x10b>
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      pbuf_free(p);
  817422:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  817426:	48 89 c7             	mov    %rax,%rdi
  817429:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  817430:	00 00 00 
  817433:	ff d0                	callq  *%rax
      p = NULL;
  817435:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  81743c:	00 
      break;
  81743d:	90                   	nop
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
  81743e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  817443:	c9                   	leaveq 
  817444:	c3                   	retq   

0000000000817445 <sys_init>:
enum { thread_hash_size = 257 };
static LIST_HEAD(thread_list, sys_thread) threads[thread_hash_size];

void
sys_init(void)
{
  817445:	55                   	push   %rbp
  817446:	48 89 e5             	mov    %rsp,%rbp
  817449:	53                   	push   %rbx
  81744a:	48 83 ec 10          	sub    $0x10,%rsp
    int i = 0;
  81744e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
    for (i = 0; i < NSEM; i++) {
  817455:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  81745c:	e9 ea 00 00 00       	jmpq   81754b <sys_init+0x106>
	sems[i].freed = 1;
  817461:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817468:	00 00 00 
  81746b:	8b 55 f4             	mov    -0xc(%rbp),%edx
  81746e:	48 63 d2             	movslq %edx,%rdx
  817471:	48 c1 e2 05          	shl    $0x5,%rdx
  817475:	48 01 d0             	add    %rdx,%rax
  817478:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  81747e:	48 b8 20 d8 b4 00 00 	movabs $0xb4d820,%rax
  817485:	00 00 00 
  817488:	48 8b 00             	mov    (%rax),%rax
  81748b:	48 ba 20 b8 b4 00 00 	movabs $0xb4b820,%rdx
  817492:	00 00 00 
  817495:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  817498:	48 63 c9             	movslq %ecx,%rcx
  81749b:	48 c1 e1 05          	shl    $0x5,%rcx
  81749f:	48 01 ca             	add    %rcx,%rdx
  8174a2:	48 83 c2 10          	add    $0x10,%rdx
  8174a6:	48 89 02             	mov    %rax,(%rdx)
  8174a9:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  8174b0:	00 00 00 
  8174b3:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8174b6:	48 63 d2             	movslq %edx,%rdx
  8174b9:	48 c1 e2 05          	shl    $0x5,%rdx
  8174bd:	48 01 d0             	add    %rdx,%rax
  8174c0:	48 83 c0 10          	add    $0x10,%rax
  8174c4:	48 8b 00             	mov    (%rax),%rax
  8174c7:	48 85 c0             	test   %rax,%rax
  8174ca:	74 2c                	je     8174f8 <sys_init+0xb3>
  8174cc:	48 b8 20 d8 b4 00 00 	movabs $0xb4d820,%rax
  8174d3:	00 00 00 
  8174d6:	48 8b 00             	mov    (%rax),%rax
  8174d9:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8174dc:	48 63 d2             	movslq %edx,%rdx
  8174df:	48 c1 e2 05          	shl    $0x5,%rdx
  8174e3:	48 8d 4a 10          	lea    0x10(%rdx),%rcx
  8174e7:	48 ba 20 b8 b4 00 00 	movabs $0xb4b820,%rdx
  8174ee:	00 00 00 
  8174f1:	48 01 ca             	add    %rcx,%rdx
  8174f4:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8174f8:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8174fb:	48 98                	cltq   
  8174fd:	48 c1 e0 05          	shl    $0x5,%rax
  817501:	48 89 c2             	mov    %rax,%rdx
  817504:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  81750b:	00 00 00 
  81750e:	48 01 c2             	add    %rax,%rdx
  817511:	48 b8 20 d8 b4 00 00 	movabs $0xb4d820,%rax
  817518:	00 00 00 
  81751b:	48 89 10             	mov    %rdx,(%rax)
  81751e:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817525:	00 00 00 
  817528:	8b 55 f4             	mov    -0xc(%rbp),%edx
  81752b:	48 63 d2             	movslq %edx,%rdx
  81752e:	48 c1 e2 05          	shl    $0x5,%rdx
  817532:	48 01 d0             	add    %rdx,%rax
  817535:	48 83 c0 10          	add    $0x10,%rax
  817539:	48 bf 20 d8 b4 00 00 	movabs $0xb4d820,%rdi
  817540:	00 00 00 
  817543:	48 89 78 08          	mov    %rdi,0x8(%rax)

void
sys_init(void)
{
    int i = 0;
    for (i = 0; i < NSEM; i++) {
  817547:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  81754b:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%rbp)
  817552:	0f 8e 09 ff ff ff    	jle    817461 <sys_init+0x1c>
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
  817558:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  81755f:	e9 60 01 00 00       	jmpq   8176c4 <sys_init+0x27f>
	mboxes[i].freed = 1;
  817564:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  81756b:	00 00 00 
  81756e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  817571:	48 63 d0             	movslq %eax,%rdx
  817574:	48 89 d0             	mov    %rdx,%rax
  817577:	48 c1 e0 03          	shl    $0x3,%rax
  81757b:	48 01 d0             	add    %rdx,%rax
  81757e:	48 c1 e0 02          	shl    $0x2,%rax
  817582:	48 01 d0             	add    %rdx,%rax
  817585:	48 c1 e0 03          	shl    $0x3,%rax
  817589:	48 01 c8             	add    %rcx,%rax
  81758c:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  817592:	48 b8 40 6c b5 00 00 	movabs $0xb56c40,%rax
  817599:	00 00 00 
  81759c:	48 8b 08             	mov    (%rax),%rcx
  81759f:	48 be 40 d8 b4 00 00 	movabs $0xb4d840,%rsi
  8175a6:	00 00 00 
  8175a9:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8175ac:	48 63 d0             	movslq %eax,%rdx
  8175af:	48 89 d0             	mov    %rdx,%rax
  8175b2:	48 c1 e0 03          	shl    $0x3,%rax
  8175b6:	48 01 d0             	add    %rdx,%rax
  8175b9:	48 c1 e0 02          	shl    $0x2,%rax
  8175bd:	48 01 d0             	add    %rdx,%rax
  8175c0:	48 c1 e0 03          	shl    $0x3,%rax
  8175c4:	48 01 f0             	add    %rsi,%rax
  8175c7:	48 05 10 01 00 00    	add    $0x110,%rax
  8175cd:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8175d1:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  8175d8:	00 00 00 
  8175db:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8175de:	48 63 d0             	movslq %eax,%rdx
  8175e1:	48 89 d0             	mov    %rdx,%rax
  8175e4:	48 c1 e0 03          	shl    $0x3,%rax
  8175e8:	48 01 d0             	add    %rdx,%rax
  8175eb:	48 c1 e0 02          	shl    $0x2,%rax
  8175ef:	48 01 d0             	add    %rdx,%rax
  8175f2:	48 c1 e0 03          	shl    $0x3,%rax
  8175f6:	48 01 c8             	add    %rcx,%rax
  8175f9:	48 05 10 01 00 00    	add    $0x110,%rax
  8175ff:	48 8b 40 08          	mov    0x8(%rax),%rax
  817603:	48 85 c0             	test   %rax,%rax
  817606:	74 47                	je     81764f <sys_init+0x20a>
  817608:	48 b8 40 6c b5 00 00 	movabs $0xb56c40,%rax
  81760f:	00 00 00 
  817612:	48 8b 08             	mov    (%rax),%rcx
  817615:	8b 45 f4             	mov    -0xc(%rbp),%eax
  817618:	48 63 d0             	movslq %eax,%rdx
  81761b:	48 89 d0             	mov    %rdx,%rax
  81761e:	48 c1 e0 03          	shl    $0x3,%rax
  817622:	48 01 d0             	add    %rdx,%rax
  817625:	48 c1 e0 02          	shl    $0x2,%rax
  817629:	48 01 d0             	add    %rdx,%rax
  81762c:	48 c1 e0 03          	shl    $0x3,%rax
  817630:	48 8d 90 10 01 00 00 	lea    0x110(%rax),%rdx
  817637:	48 b8 40 d8 b4 00 00 	movabs $0xb4d840,%rax
  81763e:	00 00 00 
  817641:	48 01 d0             	add    %rdx,%rax
  817644:	48 83 c0 08          	add    $0x8,%rax
  817648:	48 89 81 20 01 00 00 	mov    %rax,0x120(%rcx)
  81764f:	8b 45 f4             	mov    -0xc(%rbp),%eax
  817652:	48 63 d0             	movslq %eax,%rdx
  817655:	48 89 d0             	mov    %rdx,%rax
  817658:	48 c1 e0 03          	shl    $0x3,%rax
  81765c:	48 01 d0             	add    %rdx,%rax
  81765f:	48 c1 e0 02          	shl    $0x2,%rax
  817663:	48 01 d0             	add    %rdx,%rax
  817666:	48 c1 e0 03          	shl    $0x3,%rax
  81766a:	48 ba 40 d8 b4 00 00 	movabs $0xb4d840,%rdx
  817671:	00 00 00 
  817674:	48 01 c2             	add    %rax,%rdx
  817677:	48 b8 40 6c b5 00 00 	movabs $0xb56c40,%rax
  81767e:	00 00 00 
  817681:	48 89 10             	mov    %rdx,(%rax)
  817684:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  81768b:	00 00 00 
  81768e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  817691:	48 63 d0             	movslq %eax,%rdx
  817694:	48 89 d0             	mov    %rdx,%rax
  817697:	48 c1 e0 03          	shl    $0x3,%rax
  81769b:	48 01 d0             	add    %rdx,%rax
  81769e:	48 c1 e0 02          	shl    $0x2,%rax
  8176a2:	48 01 d0             	add    %rdx,%rax
  8176a5:	48 c1 e0 03          	shl    $0x3,%rax
  8176a9:	48 01 c8             	add    %rcx,%rax
  8176ac:	48 05 10 01 00 00    	add    $0x110,%rax
  8176b2:	48 bb 40 6c b5 00 00 	movabs $0xb56c40,%rbx
  8176b9:	00 00 00 
  8176bc:	48 89 58 10          	mov    %rbx,0x10(%rax)
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
  8176c0:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8176c4:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%rbp)
  8176c8:	0f 8e 96 fe ff ff    	jle    817564 <sys_init+0x11f>
	mboxes[i].freed = 1;
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
    }
}
  8176ce:	48 83 c4 10          	add    $0x10,%rsp
  8176d2:	5b                   	pop    %rbx
  8176d3:	5d                   	pop    %rbp
  8176d4:	c3                   	retq   

00000000008176d5 <sys_mbox_new>:

sys_mbox_t
sys_mbox_new(int size)
{
  8176d5:	55                   	push   %rbp
  8176d6:	48 89 e5             	mov    %rsp,%rbp
  8176d9:	48 83 ec 20          	sub    $0x20,%rsp
  8176dd:	89 7d ec             	mov    %edi,-0x14(%rbp)
    assert(size < MBOXSLOTS);
  8176e0:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%rbp)
  8176e4:	7e 35                	jle    81771b <sys_mbox_new+0x46>
  8176e6:	48 b9 68 2c 82 00 00 	movabs $0x822c68,%rcx
  8176ed:	00 00 00 
  8176f0:	48 ba 79 2c 82 00 00 	movabs $0x822c79,%rdx
  8176f7:	00 00 00 
  8176fa:	be 46 00 00 00       	mov    $0x46,%esi
  8176ff:	48 bf 8e 2c 82 00 00 	movabs $0x822c8e,%rdi
  817706:	00 00 00 
  817709:	b8 00 00 00 00       	mov    $0x0,%eax
  81770e:	49 b8 e9 10 80 00 00 	movabs $0x8010e9,%r8
  817715:	00 00 00 
  817718:	41 ff d0             	callq  *%r8
    struct sys_mbox_entry *mbe = LIST_FIRST(&mbox_free);
  81771b:	48 b8 40 6c b5 00 00 	movabs $0xb56c40,%rax
  817722:	00 00 00 
  817725:	48 8b 00             	mov    (%rax),%rax
  817728:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (!mbe) {
  81772c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  817731:	75 25                	jne    817758 <sys_mbox_new+0x83>
	cprintf("lwip: sys_mbox_new: out of mailboxes\n");
  817733:	48 bf b0 2c 82 00 00 	movabs $0x822cb0,%rdi
  81773a:	00 00 00 
  81773d:	b8 00 00 00 00       	mov    $0x0,%eax
  817742:	48 ba 22 13 80 00 00 	movabs $0x801322,%rdx
  817749:	00 00 00 
  81774c:	ff d2                	callq  *%rdx
	return SYS_MBOX_NULL;
  81774e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  817753:	e9 5b 01 00 00       	jmpq   8178b3 <sys_mbox_new+0x1de>
    }
    LIST_REMOVE(mbe, link);
  817758:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81775c:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  817763:	48 85 c0             	test   %rax,%rax
  817766:	74 1d                	je     817785 <sys_mbox_new+0xb0>
  817768:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81776c:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  817773:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  817777:	48 8b 92 20 01 00 00 	mov    0x120(%rdx),%rdx
  81777e:	48 89 90 20 01 00 00 	mov    %rdx,0x120(%rax)
  817785:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817789:	48 8b 80 20 01 00 00 	mov    0x120(%rax),%rax
  817790:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  817794:	48 8b 92 18 01 00 00 	mov    0x118(%rdx),%rdx
  81779b:	48 89 10             	mov    %rdx,(%rax)
    assert(mbe->freed);
  81779e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8177a2:	8b 00                	mov    (%rax),%eax
  8177a4:	85 c0                	test   %eax,%eax
  8177a6:	75 35                	jne    8177dd <sys_mbox_new+0x108>
  8177a8:	48 b9 d6 2c 82 00 00 	movabs $0x822cd6,%rcx
  8177af:	00 00 00 
  8177b2:	48 ba 79 2c 82 00 00 	movabs $0x822c79,%rdx
  8177b9:	00 00 00 
  8177bc:	be 4d 00 00 00       	mov    $0x4d,%esi
  8177c1:	48 bf 8e 2c 82 00 00 	movabs $0x822c8e,%rdi
  8177c8:	00 00 00 
  8177cb:	b8 00 00 00 00       	mov    $0x0,%eax
  8177d0:	49 b8 e9 10 80 00 00 	movabs $0x8010e9,%r8
  8177d7:	00 00 00 
  8177da:	41 ff d0             	callq  *%r8
    mbe->freed = 0;
  8177dd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8177e1:	c7 00 00 00 00 00    	movl   $0x0,(%rax)

    int i = mbe - &mboxes[0];
  8177e7:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8177eb:	48 b8 40 d8 b4 00 00 	movabs $0xb4d840,%rax
  8177f2:	00 00 00 
  8177f5:	48 29 c2             	sub    %rax,%rdx
  8177f8:	48 89 d0             	mov    %rdx,%rax
  8177fb:	48 c1 f8 03          	sar    $0x3,%rax
  8177ff:	48 89 c2             	mov    %rax,%rdx
  817802:	48 b8 ad 1b 4c 91 cf 	movabs $0x14c1bacf914c1bad,%rax
  817809:	ba c1 14 
  81780c:	48 0f af c2          	imul   %rdx,%rax
  817810:	89 45 f4             	mov    %eax,-0xc(%rbp)
    mbe->head = -1;
  817813:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817817:	c7 40 04 ff ff ff ff 	movl   $0xffffffff,0x4(%rax)
    mbe->nextq = 0;
  81781e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817822:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
    mbe->queued_msg = sys_sem_new(0);
  817829:	bf 00 00 00 00       	mov    $0x0,%edi
  81782e:	48 b8 cc 7d 81 00 00 	movabs $0x817dcc,%rax
  817835:	00 00 00 
  817838:	ff d0                	callq  *%rax
  81783a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81783e:	89 82 10 01 00 00    	mov    %eax,0x110(%rdx)
    mbe->free_msg = sys_sem_new(MBOXSLOTS);
  817844:	bf 20 00 00 00       	mov    $0x20,%edi
  817849:	48 b8 cc 7d 81 00 00 	movabs $0x817dcc,%rax
  817850:	00 00 00 
  817853:	ff d0                	callq  *%rax
  817855:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  817859:	89 82 14 01 00 00    	mov    %eax,0x114(%rdx)

    if (mbe->queued_msg == SYS_SEM_NULL ||
  81785f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817863:	8b 80 10 01 00 00    	mov    0x110(%rax),%eax
  817869:	83 f8 ff             	cmp    $0xffffffff,%eax
  81786c:	74 0f                	je     81787d <sys_mbox_new+0x1a8>
	mbe->free_msg == SYS_SEM_NULL)
  81786e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817872:	8b 80 14 01 00 00    	mov    0x114(%rax),%eax
    mbe->head = -1;
    mbe->nextq = 0;
    mbe->queued_msg = sys_sem_new(0);
    mbe->free_msg = sys_sem_new(MBOXSLOTS);

    if (mbe->queued_msg == SYS_SEM_NULL ||
  817878:	83 f8 ff             	cmp    $0xffffffff,%eax
  81787b:	75 33                	jne    8178b0 <sys_mbox_new+0x1db>
	mbe->free_msg == SYS_SEM_NULL)
    {
	sys_mbox_free(i);
  81787d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  817880:	89 c7                	mov    %eax,%edi
  817882:	48 b8 b5 78 81 00 00 	movabs $0x8178b5,%rax
  817889:	00 00 00 
  81788c:	ff d0                	callq  *%rax
	cprintf("lwip: sys_mbox_new: can't get semaphore\n");
  81788e:	48 bf e8 2c 82 00 00 	movabs $0x822ce8,%rdi
  817895:	00 00 00 
  817898:	b8 00 00 00 00       	mov    $0x0,%eax
  81789d:	48 ba 22 13 80 00 00 	movabs $0x801322,%rdx
  8178a4:	00 00 00 
  8178a7:	ff d2                	callq  *%rdx
	return SYS_MBOX_NULL;
  8178a9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8178ae:	eb 03                	jmp    8178b3 <sys_mbox_new+0x1de>
    }
    return i;
  8178b0:	8b 45 f4             	mov    -0xc(%rbp),%eax
}
  8178b3:	c9                   	leaveq 
  8178b4:	c3                   	retq   

00000000008178b5 <sys_mbox_free>:

void
sys_mbox_free(sys_mbox_t mbox)
{
  8178b5:	55                   	push   %rbp
  8178b6:	48 89 e5             	mov    %rsp,%rbp
  8178b9:	53                   	push   %rbx
  8178ba:	48 83 ec 18          	sub    $0x18,%rsp
  8178be:	89 7d ec             	mov    %edi,-0x14(%rbp)
    assert(!mboxes[mbox].freed);
  8178c1:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  8178c8:	00 00 00 
  8178cb:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8178ce:	48 63 d0             	movslq %eax,%rdx
  8178d1:	48 89 d0             	mov    %rdx,%rax
  8178d4:	48 c1 e0 03          	shl    $0x3,%rax
  8178d8:	48 01 d0             	add    %rdx,%rax
  8178db:	48 c1 e0 02          	shl    $0x2,%rax
  8178df:	48 01 d0             	add    %rdx,%rax
  8178e2:	48 c1 e0 03          	shl    $0x3,%rax
  8178e6:	48 01 c8             	add    %rcx,%rax
  8178e9:	8b 00                	mov    (%rax),%eax
  8178eb:	85 c0                	test   %eax,%eax
  8178ed:	74 35                	je     817924 <sys_mbox_free+0x6f>
  8178ef:	48 b9 11 2d 82 00 00 	movabs $0x822d11,%rcx
  8178f6:	00 00 00 
  8178f9:	48 ba 79 2c 82 00 00 	movabs $0x822c79,%rdx
  817900:	00 00 00 
  817903:	be 63 00 00 00       	mov    $0x63,%esi
  817908:	48 bf 8e 2c 82 00 00 	movabs $0x822c8e,%rdi
  81790f:	00 00 00 
  817912:	b8 00 00 00 00       	mov    $0x0,%eax
  817917:	49 b8 e9 10 80 00 00 	movabs $0x8010e9,%r8
  81791e:	00 00 00 
  817921:	41 ff d0             	callq  *%r8
    sys_sem_free(mboxes[mbox].queued_msg);
  817924:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  81792b:	00 00 00 
  81792e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817931:	48 63 d0             	movslq %eax,%rdx
  817934:	48 89 d0             	mov    %rdx,%rax
  817937:	48 c1 e0 03          	shl    $0x3,%rax
  81793b:	48 01 d0             	add    %rdx,%rax
  81793e:	48 c1 e0 02          	shl    $0x2,%rax
  817942:	48 01 d0             	add    %rdx,%rax
  817945:	48 c1 e0 03          	shl    $0x3,%rax
  817949:	48 01 c8             	add    %rcx,%rax
  81794c:	48 05 10 01 00 00    	add    $0x110,%rax
  817952:	8b 00                	mov    (%rax),%eax
  817954:	89 c7                	mov    %eax,%edi
  817956:	48 b8 ca 7e 81 00 00 	movabs $0x817eca,%rax
  81795d:	00 00 00 
  817960:	ff d0                	callq  *%rax
    sys_sem_free(mboxes[mbox].free_msg);
  817962:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817969:	00 00 00 
  81796c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  81796f:	48 63 d0             	movslq %eax,%rdx
  817972:	48 89 d0             	mov    %rdx,%rax
  817975:	48 c1 e0 03          	shl    $0x3,%rax
  817979:	48 01 d0             	add    %rdx,%rax
  81797c:	48 c1 e0 02          	shl    $0x2,%rax
  817980:	48 01 d0             	add    %rdx,%rax
  817983:	48 c1 e0 03          	shl    $0x3,%rax
  817987:	48 01 c8             	add    %rcx,%rax
  81798a:	48 05 10 01 00 00    	add    $0x110,%rax
  817990:	8b 40 04             	mov    0x4(%rax),%eax
  817993:	89 c7                	mov    %eax,%edi
  817995:	48 b8 ca 7e 81 00 00 	movabs $0x817eca,%rax
  81799c:	00 00 00 
  81799f:	ff d0                	callq  *%rax
    LIST_INSERT_HEAD(&mbox_free, &mboxes[mbox], link);
  8179a1:	48 b8 40 6c b5 00 00 	movabs $0xb56c40,%rax
  8179a8:	00 00 00 
  8179ab:	48 8b 08             	mov    (%rax),%rcx
  8179ae:	48 be 40 d8 b4 00 00 	movabs $0xb4d840,%rsi
  8179b5:	00 00 00 
  8179b8:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8179bb:	48 63 d0             	movslq %eax,%rdx
  8179be:	48 89 d0             	mov    %rdx,%rax
  8179c1:	48 c1 e0 03          	shl    $0x3,%rax
  8179c5:	48 01 d0             	add    %rdx,%rax
  8179c8:	48 c1 e0 02          	shl    $0x2,%rax
  8179cc:	48 01 d0             	add    %rdx,%rax
  8179cf:	48 c1 e0 03          	shl    $0x3,%rax
  8179d3:	48 01 f0             	add    %rsi,%rax
  8179d6:	48 05 10 01 00 00    	add    $0x110,%rax
  8179dc:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8179e0:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  8179e7:	00 00 00 
  8179ea:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8179ed:	48 63 d0             	movslq %eax,%rdx
  8179f0:	48 89 d0             	mov    %rdx,%rax
  8179f3:	48 c1 e0 03          	shl    $0x3,%rax
  8179f7:	48 01 d0             	add    %rdx,%rax
  8179fa:	48 c1 e0 02          	shl    $0x2,%rax
  8179fe:	48 01 d0             	add    %rdx,%rax
  817a01:	48 c1 e0 03          	shl    $0x3,%rax
  817a05:	48 01 c8             	add    %rcx,%rax
  817a08:	48 05 10 01 00 00    	add    $0x110,%rax
  817a0e:	48 8b 40 08          	mov    0x8(%rax),%rax
  817a12:	48 85 c0             	test   %rax,%rax
  817a15:	74 47                	je     817a5e <sys_mbox_free+0x1a9>
  817a17:	48 b8 40 6c b5 00 00 	movabs $0xb56c40,%rax
  817a1e:	00 00 00 
  817a21:	48 8b 08             	mov    (%rax),%rcx
  817a24:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817a27:	48 63 d0             	movslq %eax,%rdx
  817a2a:	48 89 d0             	mov    %rdx,%rax
  817a2d:	48 c1 e0 03          	shl    $0x3,%rax
  817a31:	48 01 d0             	add    %rdx,%rax
  817a34:	48 c1 e0 02          	shl    $0x2,%rax
  817a38:	48 01 d0             	add    %rdx,%rax
  817a3b:	48 c1 e0 03          	shl    $0x3,%rax
  817a3f:	48 8d 90 10 01 00 00 	lea    0x110(%rax),%rdx
  817a46:	48 b8 40 d8 b4 00 00 	movabs $0xb4d840,%rax
  817a4d:	00 00 00 
  817a50:	48 01 d0             	add    %rdx,%rax
  817a53:	48 83 c0 08          	add    $0x8,%rax
  817a57:	48 89 81 20 01 00 00 	mov    %rax,0x120(%rcx)
  817a5e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817a61:	48 63 d0             	movslq %eax,%rdx
  817a64:	48 89 d0             	mov    %rdx,%rax
  817a67:	48 c1 e0 03          	shl    $0x3,%rax
  817a6b:	48 01 d0             	add    %rdx,%rax
  817a6e:	48 c1 e0 02          	shl    $0x2,%rax
  817a72:	48 01 d0             	add    %rdx,%rax
  817a75:	48 c1 e0 03          	shl    $0x3,%rax
  817a79:	48 ba 40 d8 b4 00 00 	movabs $0xb4d840,%rdx
  817a80:	00 00 00 
  817a83:	48 01 c2             	add    %rax,%rdx
  817a86:	48 b8 40 6c b5 00 00 	movabs $0xb56c40,%rax
  817a8d:	00 00 00 
  817a90:	48 89 10             	mov    %rdx,(%rax)
  817a93:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817a9a:	00 00 00 
  817a9d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817aa0:	48 63 d0             	movslq %eax,%rdx
  817aa3:	48 89 d0             	mov    %rdx,%rax
  817aa6:	48 c1 e0 03          	shl    $0x3,%rax
  817aaa:	48 01 d0             	add    %rdx,%rax
  817aad:	48 c1 e0 02          	shl    $0x2,%rax
  817ab1:	48 01 d0             	add    %rdx,%rax
  817ab4:	48 c1 e0 03          	shl    $0x3,%rax
  817ab8:	48 01 c8             	add    %rcx,%rax
  817abb:	48 05 10 01 00 00    	add    $0x110,%rax
  817ac1:	48 bb 40 6c b5 00 00 	movabs $0xb56c40,%rbx
  817ac8:	00 00 00 
  817acb:	48 89 58 10          	mov    %rbx,0x10(%rax)
    mboxes[mbox].freed = 1;
  817acf:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817ad6:	00 00 00 
  817ad9:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817adc:	48 63 d0             	movslq %eax,%rdx
  817adf:	48 89 d0             	mov    %rdx,%rax
  817ae2:	48 c1 e0 03          	shl    $0x3,%rax
  817ae6:	48 01 d0             	add    %rdx,%rax
  817ae9:	48 c1 e0 02          	shl    $0x2,%rax
  817aed:	48 01 d0             	add    %rdx,%rax
  817af0:	48 c1 e0 03          	shl    $0x3,%rax
  817af4:	48 01 c8             	add    %rcx,%rax
  817af7:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
}
  817afd:	48 83 c4 18          	add    $0x18,%rsp
  817b01:	5b                   	pop    %rbx
  817b02:	5d                   	pop    %rbp
  817b03:	c3                   	retq   

0000000000817b04 <sys_mbox_post>:

void
sys_mbox_post(sys_mbox_t mbox, void *msg)
{
  817b04:	55                   	push   %rbp
  817b05:	48 89 e5             	mov    %rsp,%rbp
  817b08:	48 83 ec 10          	sub    $0x10,%rsp
  817b0c:	89 7d fc             	mov    %edi,-0x4(%rbp)
  817b0f:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  817b13:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  817b17:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817b1a:	48 89 d6             	mov    %rdx,%rsi
  817b1d:	89 c7                	mov    %eax,%edi
  817b1f:	48 b8 66 7b 81 00 00 	movabs $0x817b66,%rax
  817b26:	00 00 00 
  817b29:	ff d0                	callq  *%rax
  817b2b:	84 c0                	test   %al,%al
  817b2d:	74 35                	je     817b64 <sys_mbox_post+0x60>
  817b2f:	48 b9 28 2d 82 00 00 	movabs $0x822d28,%rcx
  817b36:	00 00 00 
  817b39:	48 ba 79 2c 82 00 00 	movabs $0x822c79,%rdx
  817b40:	00 00 00 
  817b43:	be 6d 00 00 00       	mov    $0x6d,%esi
  817b48:	48 bf 8e 2c 82 00 00 	movabs $0x822c8e,%rdi
  817b4f:	00 00 00 
  817b52:	b8 00 00 00 00       	mov    $0x0,%eax
  817b57:	49 b8 e9 10 80 00 00 	movabs $0x8010e9,%r8
  817b5e:	00 00 00 
  817b61:	41 ff d0             	callq  *%r8
}
  817b64:	c9                   	leaveq 
  817b65:	c3                   	retq   

0000000000817b66 <sys_mbox_trypost>:

err_t 
sys_mbox_trypost(sys_mbox_t mbox, void *msg)
{
  817b66:	55                   	push   %rbp
  817b67:	48 89 e5             	mov    %rsp,%rbp
  817b6a:	48 83 ec 20          	sub    $0x20,%rsp
  817b6e:	89 7d ec             	mov    %edi,-0x14(%rbp)
  817b71:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
    assert(!mboxes[mbox].freed);
  817b75:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817b7c:	00 00 00 
  817b7f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817b82:	48 63 d0             	movslq %eax,%rdx
  817b85:	48 89 d0             	mov    %rdx,%rax
  817b88:	48 c1 e0 03          	shl    $0x3,%rax
  817b8c:	48 01 d0             	add    %rdx,%rax
  817b8f:	48 c1 e0 02          	shl    $0x2,%rax
  817b93:	48 01 d0             	add    %rdx,%rax
  817b96:	48 c1 e0 03          	shl    $0x3,%rax
  817b9a:	48 01 c8             	add    %rcx,%rax
  817b9d:	8b 00                	mov    (%rax),%eax
  817b9f:	85 c0                	test   %eax,%eax
  817ba1:	74 35                	je     817bd8 <sys_mbox_trypost+0x72>
  817ba3:	48 b9 11 2d 82 00 00 	movabs $0x822d11,%rcx
  817baa:	00 00 00 
  817bad:	48 ba 79 2c 82 00 00 	movabs $0x822c79,%rdx
  817bb4:	00 00 00 
  817bb7:	be 73 00 00 00       	mov    $0x73,%esi
  817bbc:	48 bf 8e 2c 82 00 00 	movabs $0x822c8e,%rdi
  817bc3:	00 00 00 
  817bc6:	b8 00 00 00 00       	mov    $0x0,%eax
  817bcb:	49 b8 e9 10 80 00 00 	movabs $0x8010e9,%r8
  817bd2:	00 00 00 
  817bd5:	41 ff d0             	callq  *%r8

    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
  817bd8:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817bdf:	00 00 00 
  817be2:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817be5:	48 63 d0             	movslq %eax,%rdx
  817be8:	48 89 d0             	mov    %rdx,%rax
  817beb:	48 c1 e0 03          	shl    $0x3,%rax
  817bef:	48 01 d0             	add    %rdx,%rax
  817bf2:	48 c1 e0 02          	shl    $0x2,%rax
  817bf6:	48 01 d0             	add    %rdx,%rax
  817bf9:	48 c1 e0 03          	shl    $0x3,%rax
  817bfd:	48 01 c8             	add    %rcx,%rax
  817c00:	48 05 10 01 00 00    	add    $0x110,%rax
  817c06:	8b 40 04             	mov    0x4(%rax),%eax
  817c09:	be 00 00 00 00       	mov    $0x0,%esi
  817c0e:	89 c7                	mov    %eax,%edi
  817c10:	48 b8 4d 81 81 00 00 	movabs $0x81814d,%rax
  817c17:	00 00 00 
  817c1a:	ff d0                	callq  *%rax
    if (mboxes[mbox].nextq == mboxes[mbox].head)
  817c1c:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817c23:	00 00 00 
  817c26:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817c29:	48 63 d0             	movslq %eax,%rdx
  817c2c:	48 89 d0             	mov    %rdx,%rax
  817c2f:	48 c1 e0 03          	shl    $0x3,%rax
  817c33:	48 01 d0             	add    %rdx,%rax
  817c36:	48 c1 e0 02          	shl    $0x2,%rax
  817c3a:	48 01 d0             	add    %rdx,%rax
  817c3d:	48 c1 e0 03          	shl    $0x3,%rax
  817c41:	48 01 c8             	add    %rcx,%rax
  817c44:	8b 48 08             	mov    0x8(%rax),%ecx
  817c47:	48 be 40 d8 b4 00 00 	movabs $0xb4d840,%rsi
  817c4e:	00 00 00 
  817c51:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817c54:	48 63 d0             	movslq %eax,%rdx
  817c57:	48 89 d0             	mov    %rdx,%rax
  817c5a:	48 c1 e0 03          	shl    $0x3,%rax
  817c5e:	48 01 d0             	add    %rdx,%rax
  817c61:	48 c1 e0 02          	shl    $0x2,%rax
  817c65:	48 01 d0             	add    %rdx,%rax
  817c68:	48 c1 e0 03          	shl    $0x3,%rax
  817c6c:	48 01 f0             	add    %rsi,%rax
  817c6f:	8b 40 04             	mov    0x4(%rax),%eax
  817c72:	39 c1                	cmp    %eax,%ecx
  817c74:	75 0a                	jne    817c80 <sys_mbox_trypost+0x11a>
	return ERR_MEM;
  817c76:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  817c7b:	e9 4a 01 00 00       	jmpq   817dca <sys_mbox_trypost+0x264>

    int slot = mboxes[mbox].nextq;
  817c80:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817c87:	00 00 00 
  817c8a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817c8d:	48 63 d0             	movslq %eax,%rdx
  817c90:	48 89 d0             	mov    %rdx,%rax
  817c93:	48 c1 e0 03          	shl    $0x3,%rax
  817c97:	48 01 d0             	add    %rdx,%rax
  817c9a:	48 c1 e0 02          	shl    $0x2,%rax
  817c9e:	48 01 d0             	add    %rdx,%rax
  817ca1:	48 c1 e0 03          	shl    $0x3,%rax
  817ca5:	48 01 c8             	add    %rcx,%rax
  817ca8:	8b 40 08             	mov    0x8(%rax),%eax
  817cab:	89 45 fc             	mov    %eax,-0x4(%rbp)
    mboxes[mbox].nextq = (slot + 1) % MBOXSLOTS;
  817cae:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817cb1:	8d 50 01             	lea    0x1(%rax),%edx
  817cb4:	89 d0                	mov    %edx,%eax
  817cb6:	c1 f8 1f             	sar    $0x1f,%eax
  817cb9:	c1 e8 1b             	shr    $0x1b,%eax
  817cbc:	01 c2                	add    %eax,%edx
  817cbe:	83 e2 1f             	and    $0x1f,%edx
  817cc1:	29 c2                	sub    %eax,%edx
  817cc3:	89 d0                	mov    %edx,%eax
  817cc5:	89 c1                	mov    %eax,%ecx
  817cc7:	48 be 40 d8 b4 00 00 	movabs $0xb4d840,%rsi
  817cce:	00 00 00 
  817cd1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817cd4:	48 63 d0             	movslq %eax,%rdx
  817cd7:	48 89 d0             	mov    %rdx,%rax
  817cda:	48 c1 e0 03          	shl    $0x3,%rax
  817cde:	48 01 d0             	add    %rdx,%rax
  817ce1:	48 c1 e0 02          	shl    $0x2,%rax
  817ce5:	48 01 d0             	add    %rdx,%rax
  817ce8:	48 c1 e0 03          	shl    $0x3,%rax
  817cec:	48 01 f0             	add    %rsi,%rax
  817cef:	89 48 08             	mov    %ecx,0x8(%rax)
    mboxes[mbox].msg[slot] = msg;
  817cf2:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817cf9:	00 00 00 
  817cfc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817cff:	48 63 f0             	movslq %eax,%rsi
  817d02:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817d05:	48 63 d0             	movslq %eax,%rdx
  817d08:	48 89 d0             	mov    %rdx,%rax
  817d0b:	48 c1 e0 03          	shl    $0x3,%rax
  817d0f:	48 01 d0             	add    %rdx,%rax
  817d12:	48 c1 e0 02          	shl    $0x2,%rax
  817d16:	48 01 d0             	add    %rdx,%rax
  817d19:	48 01 f0             	add    %rsi,%rax
  817d1c:	48 8d 50 02          	lea    0x2(%rax),%rdx
  817d20:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  817d24:	48 89 04 d1          	mov    %rax,(%rcx,%rdx,8)

    if (mboxes[mbox].head == -1)
  817d28:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817d2f:	00 00 00 
  817d32:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817d35:	48 63 d0             	movslq %eax,%rdx
  817d38:	48 89 d0             	mov    %rdx,%rax
  817d3b:	48 c1 e0 03          	shl    $0x3,%rax
  817d3f:	48 01 d0             	add    %rdx,%rax
  817d42:	48 c1 e0 02          	shl    $0x2,%rax
  817d46:	48 01 d0             	add    %rdx,%rax
  817d49:	48 c1 e0 03          	shl    $0x3,%rax
  817d4d:	48 01 c8             	add    %rcx,%rax
  817d50:	8b 40 04             	mov    0x4(%rax),%eax
  817d53:	83 f8 ff             	cmp    $0xffffffff,%eax
  817d56:	75 2f                	jne    817d87 <sys_mbox_trypost+0x221>
	mboxes[mbox].head = slot;
  817d58:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817d5f:	00 00 00 
  817d62:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817d65:	48 63 d0             	movslq %eax,%rdx
  817d68:	48 89 d0             	mov    %rdx,%rax
  817d6b:	48 c1 e0 03          	shl    $0x3,%rax
  817d6f:	48 01 d0             	add    %rdx,%rax
  817d72:	48 c1 e0 02          	shl    $0x2,%rax
  817d76:	48 01 d0             	add    %rdx,%rax
  817d79:	48 c1 e0 03          	shl    $0x3,%rax
  817d7d:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  817d81:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817d84:	89 42 04             	mov    %eax,0x4(%rdx)

    sys_sem_signal(mboxes[mbox].queued_msg);
  817d87:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817d8e:	00 00 00 
  817d91:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817d94:	48 63 d0             	movslq %eax,%rdx
  817d97:	48 89 d0             	mov    %rdx,%rax
  817d9a:	48 c1 e0 03          	shl    $0x3,%rax
  817d9e:	48 01 d0             	add    %rdx,%rax
  817da1:	48 c1 e0 02          	shl    $0x2,%rax
  817da5:	48 01 d0             	add    %rdx,%rax
  817da8:	48 c1 e0 03          	shl    $0x3,%rax
  817dac:	48 01 c8             	add    %rcx,%rax
  817daf:	48 05 10 01 00 00    	add    $0x110,%rax
  817db5:	8b 00                	mov    (%rax),%eax
  817db7:	89 c7                	mov    %eax,%edi
  817db9:	48 b8 4c 80 81 00 00 	movabs $0x81804c,%rax
  817dc0:	00 00 00 
  817dc3:	ff d0                	callq  *%rax

    return ERR_OK;
  817dc5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  817dca:	c9                   	leaveq 
  817dcb:	c3                   	retq   

0000000000817dcc <sys_sem_new>:

sys_sem_t
sys_sem_new(u8_t count)
{
  817dcc:	55                   	push   %rbp
  817dcd:	48 89 e5             	mov    %rsp,%rbp
  817dd0:	48 83 ec 20          	sub    $0x20,%rsp
  817dd4:	89 f8                	mov    %edi,%eax
  817dd6:	88 45 ec             	mov    %al,-0x14(%rbp)
    struct sys_sem_entry *se = LIST_FIRST(&sem_free);
  817dd9:	48 b8 20 d8 b4 00 00 	movabs $0xb4d820,%rax
  817de0:	00 00 00 
  817de3:	48 8b 00             	mov    (%rax),%rax
  817de6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (!se) {
  817dea:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  817def:	75 25                	jne    817e16 <sys_sem_new+0x4a>
	cprintf("lwip: sys_sem_new: out of semaphores\n");
  817df1:	48 bf 50 2d 82 00 00 	movabs $0x822d50,%rdi
  817df8:	00 00 00 
  817dfb:	b8 00 00 00 00       	mov    $0x0,%eax
  817e00:	48 ba 22 13 80 00 00 	movabs $0x801322,%rdx
  817e07:	00 00 00 
  817e0a:	ff d2                	callq  *%rdx
	return SYS_SEM_NULL;
  817e0c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  817e11:	e9 b2 00 00 00       	jmpq   817ec8 <sys_sem_new+0xfc>
    }
    LIST_REMOVE(se, link);
  817e16:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817e1a:	48 8b 40 10          	mov    0x10(%rax),%rax
  817e1e:	48 85 c0             	test   %rax,%rax
  817e21:	74 14                	je     817e37 <sys_sem_new+0x6b>
  817e23:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817e27:	48 8b 40 10          	mov    0x10(%rax),%rax
  817e2b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  817e2f:	48 8b 52 18          	mov    0x18(%rdx),%rdx
  817e33:	48 89 50 18          	mov    %rdx,0x18(%rax)
  817e37:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817e3b:	48 8b 40 18          	mov    0x18(%rax),%rax
  817e3f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  817e43:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  817e47:	48 89 10             	mov    %rdx,(%rax)
    assert(se->freed);
  817e4a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817e4e:	8b 00                	mov    (%rax),%eax
  817e50:	85 c0                	test   %eax,%eax
  817e52:	75 35                	jne    817e89 <sys_sem_new+0xbd>
  817e54:	48 b9 76 2d 82 00 00 	movabs $0x822d76,%rcx
  817e5b:	00 00 00 
  817e5e:	48 ba 79 2c 82 00 00 	movabs $0x822c79,%rdx
  817e65:	00 00 00 
  817e68:	be 8e 00 00 00       	mov    $0x8e,%esi
  817e6d:	48 bf 8e 2c 82 00 00 	movabs $0x822c8e,%rdi
  817e74:	00 00 00 
  817e77:	b8 00 00 00 00       	mov    $0x0,%eax
  817e7c:	49 b8 e9 10 80 00 00 	movabs $0x8010e9,%r8
  817e83:	00 00 00 
  817e86:	41 ff d0             	callq  *%r8
    se->freed = 0;
  817e89:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817e8d:	c7 00 00 00 00 00    	movl   $0x0,(%rax)

    se->counter = count;
  817e93:	0f b6 55 ec          	movzbl -0x14(%rbp),%edx
  817e97:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817e9b:	66 89 50 08          	mov    %dx,0x8(%rax)
    se->gen++;
  817e9f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817ea3:	8b 40 04             	mov    0x4(%rax),%eax
  817ea6:	8d 50 01             	lea    0x1(%rax),%edx
  817ea9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817ead:	89 50 04             	mov    %edx,0x4(%rax)
    return se - &sems[0];
  817eb0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  817eb4:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817ebb:	00 00 00 
  817ebe:	48 29 c2             	sub    %rax,%rdx
  817ec1:	48 89 d0             	mov    %rdx,%rax
  817ec4:	48 c1 f8 05          	sar    $0x5,%rax
}
  817ec8:	c9                   	leaveq 
  817ec9:	c3                   	retq   

0000000000817eca <sys_sem_free>:

void
sys_sem_free(sys_sem_t sem)
{
  817eca:	55                   	push   %rbp
  817ecb:	48 89 e5             	mov    %rsp,%rbp
  817ece:	53                   	push   %rbx
  817ecf:	48 83 ec 18          	sub    $0x18,%rsp
  817ed3:	89 7d ec             	mov    %edi,-0x14(%rbp)
    assert(!sems[sem].freed);
  817ed6:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817edd:	00 00 00 
  817ee0:	8b 55 ec             	mov    -0x14(%rbp),%edx
  817ee3:	48 63 d2             	movslq %edx,%rdx
  817ee6:	48 c1 e2 05          	shl    $0x5,%rdx
  817eea:	48 01 d0             	add    %rdx,%rax
  817eed:	8b 00                	mov    (%rax),%eax
  817eef:	85 c0                	test   %eax,%eax
  817ef1:	74 35                	je     817f28 <sys_sem_free+0x5e>
  817ef3:	48 b9 80 2d 82 00 00 	movabs $0x822d80,%rcx
  817efa:	00 00 00 
  817efd:	48 ba 79 2c 82 00 00 	movabs $0x822c79,%rdx
  817f04:	00 00 00 
  817f07:	be 99 00 00 00       	mov    $0x99,%esi
  817f0c:	48 bf 8e 2c 82 00 00 	movabs $0x822c8e,%rdi
  817f13:	00 00 00 
  817f16:	b8 00 00 00 00       	mov    $0x0,%eax
  817f1b:	49 b8 e9 10 80 00 00 	movabs $0x8010e9,%r8
  817f22:	00 00 00 
  817f25:	41 ff d0             	callq  *%r8
    sems[sem].freed = 1;
  817f28:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817f2f:	00 00 00 
  817f32:	8b 55 ec             	mov    -0x14(%rbp),%edx
  817f35:	48 63 d2             	movslq %edx,%rdx
  817f38:	48 c1 e2 05          	shl    $0x5,%rdx
  817f3c:	48 01 d0             	add    %rdx,%rax
  817f3f:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
    sems[sem].gen++;
  817f45:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817f4c:	00 00 00 
  817f4f:	8b 55 ec             	mov    -0x14(%rbp),%edx
  817f52:	48 63 d2             	movslq %edx,%rdx
  817f55:	48 c1 e2 05          	shl    $0x5,%rdx
  817f59:	48 01 d0             	add    %rdx,%rax
  817f5c:	8b 40 04             	mov    0x4(%rax),%eax
  817f5f:	8d 50 01             	lea    0x1(%rax),%edx
  817f62:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817f69:	00 00 00 
  817f6c:	8b 4d ec             	mov    -0x14(%rbp),%ecx
  817f6f:	48 63 c9             	movslq %ecx,%rcx
  817f72:	48 c1 e1 05          	shl    $0x5,%rcx
  817f76:	48 01 c8             	add    %rcx,%rax
  817f79:	89 50 04             	mov    %edx,0x4(%rax)
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
  817f7c:	48 b8 20 d8 b4 00 00 	movabs $0xb4d820,%rax
  817f83:	00 00 00 
  817f86:	48 8b 00             	mov    (%rax),%rax
  817f89:	48 ba 20 b8 b4 00 00 	movabs $0xb4b820,%rdx
  817f90:	00 00 00 
  817f93:	8b 4d ec             	mov    -0x14(%rbp),%ecx
  817f96:	48 63 c9             	movslq %ecx,%rcx
  817f99:	48 c1 e1 05          	shl    $0x5,%rcx
  817f9d:	48 01 ca             	add    %rcx,%rdx
  817fa0:	48 83 c2 10          	add    $0x10,%rdx
  817fa4:	48 89 02             	mov    %rax,(%rdx)
  817fa7:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817fae:	00 00 00 
  817fb1:	8b 55 ec             	mov    -0x14(%rbp),%edx
  817fb4:	48 63 d2             	movslq %edx,%rdx
  817fb7:	48 c1 e2 05          	shl    $0x5,%rdx
  817fbb:	48 01 d0             	add    %rdx,%rax
  817fbe:	48 83 c0 10          	add    $0x10,%rax
  817fc2:	48 8b 00             	mov    (%rax),%rax
  817fc5:	48 85 c0             	test   %rax,%rax
  817fc8:	74 2c                	je     817ff6 <sys_sem_free+0x12c>
  817fca:	48 b8 20 d8 b4 00 00 	movabs $0xb4d820,%rax
  817fd1:	00 00 00 
  817fd4:	48 8b 00             	mov    (%rax),%rax
  817fd7:	8b 55 ec             	mov    -0x14(%rbp),%edx
  817fda:	48 63 d2             	movslq %edx,%rdx
  817fdd:	48 c1 e2 05          	shl    $0x5,%rdx
  817fe1:	48 8d 4a 10          	lea    0x10(%rdx),%rcx
  817fe5:	48 ba 20 b8 b4 00 00 	movabs $0xb4b820,%rdx
  817fec:	00 00 00 
  817fef:	48 01 ca             	add    %rcx,%rdx
  817ff2:	48 89 50 18          	mov    %rdx,0x18(%rax)
  817ff6:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817ff9:	48 98                	cltq   
  817ffb:	48 c1 e0 05          	shl    $0x5,%rax
  817fff:	48 89 c2             	mov    %rax,%rdx
  818002:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  818009:	00 00 00 
  81800c:	48 01 c2             	add    %rax,%rdx
  81800f:	48 b8 20 d8 b4 00 00 	movabs $0xb4d820,%rax
  818016:	00 00 00 
  818019:	48 89 10             	mov    %rdx,(%rax)
  81801c:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  818023:	00 00 00 
  818026:	8b 55 ec             	mov    -0x14(%rbp),%edx
  818029:	48 63 d2             	movslq %edx,%rdx
  81802c:	48 c1 e2 05          	shl    $0x5,%rdx
  818030:	48 01 d0             	add    %rdx,%rax
  818033:	48 83 c0 10          	add    $0x10,%rax
  818037:	48 bb 20 d8 b4 00 00 	movabs $0xb4d820,%rbx
  81803e:	00 00 00 
  818041:	48 89 58 08          	mov    %rbx,0x8(%rax)
}
  818045:	48 83 c4 18          	add    $0x18,%rsp
  818049:	5b                   	pop    %rbx
  81804a:	5d                   	pop    %rbp
  81804b:	c3                   	retq   

000000000081804c <sys_sem_signal>:

void
sys_sem_signal(sys_sem_t sem)
{
  81804c:	55                   	push   %rbp
  81804d:	48 89 e5             	mov    %rsp,%rbp
  818050:	48 83 ec 10          	sub    $0x10,%rsp
  818054:	89 7d fc             	mov    %edi,-0x4(%rbp)
    assert(!sems[sem].freed);
  818057:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  81805e:	00 00 00 
  818061:	8b 55 fc             	mov    -0x4(%rbp),%edx
  818064:	48 63 d2             	movslq %edx,%rdx
  818067:	48 c1 e2 05          	shl    $0x5,%rdx
  81806b:	48 01 d0             	add    %rdx,%rax
  81806e:	8b 00                	mov    (%rax),%eax
  818070:	85 c0                	test   %eax,%eax
  818072:	74 35                	je     8180a9 <sys_sem_signal+0x5d>
  818074:	48 b9 80 2d 82 00 00 	movabs $0x822d80,%rcx
  81807b:	00 00 00 
  81807e:	48 ba 79 2c 82 00 00 	movabs $0x822c79,%rdx
  818085:	00 00 00 
  818088:	be a2 00 00 00       	mov    $0xa2,%esi
  81808d:	48 bf 8e 2c 82 00 00 	movabs $0x822c8e,%rdi
  818094:	00 00 00 
  818097:	b8 00 00 00 00       	mov    $0x0,%eax
  81809c:	49 b8 e9 10 80 00 00 	movabs $0x8010e9,%r8
  8180a3:	00 00 00 
  8180a6:	41 ff d0             	callq  *%r8
    sems[sem].counter++;
  8180a9:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  8180b0:	00 00 00 
  8180b3:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8180b6:	48 63 d2             	movslq %edx,%rdx
  8180b9:	48 c1 e2 05          	shl    $0x5,%rdx
  8180bd:	48 01 d0             	add    %rdx,%rax
  8180c0:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8180c4:	8d 50 01             	lea    0x1(%rax),%edx
  8180c7:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  8180ce:	00 00 00 
  8180d1:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8180d4:	48 63 c9             	movslq %ecx,%rcx
  8180d7:	48 c1 e1 05          	shl    $0x5,%rcx
  8180db:	48 01 c8             	add    %rcx,%rax
  8180de:	66 89 50 08          	mov    %dx,0x8(%rax)
    if (sems[sem].waiters) {
  8180e2:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  8180e9:	00 00 00 
  8180ec:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8180ef:	48 63 d2             	movslq %edx,%rdx
  8180f2:	48 c1 e2 05          	shl    $0x5,%rdx
  8180f6:	48 01 d0             	add    %rdx,%rax
  8180f9:	0f b7 40 0a          	movzwl 0xa(%rax),%eax
  8180fd:	66 85 c0             	test   %ax,%ax
  818100:	74 49                	je     81814b <sys_sem_signal+0xff>
	sems[sem].waiters = 0;
  818102:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  818109:	00 00 00 
  81810c:	8b 55 fc             	mov    -0x4(%rbp),%edx
  81810f:	48 63 d2             	movslq %edx,%rdx
  818112:	48 c1 e2 05          	shl    $0x5,%rdx
  818116:	48 01 d0             	add    %rdx,%rax
  818119:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
	thread_wakeup(&sems[sem].v);
  81811f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  818122:	48 98                	cltq   
  818124:	48 c1 e0 05          	shl    $0x5,%rax
  818128:	48 89 c2             	mov    %rax,%rdx
  81812b:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  818132:	00 00 00 
  818135:	48 01 d0             	add    %rdx,%rax
  818138:	48 83 c0 08          	add    $0x8,%rax
  81813c:	48 89 c7             	mov    %rax,%rdi
  81813f:	48 b8 c6 8b 81 00 00 	movabs $0x818bc6,%rax
  818146:	00 00 00 
  818149:	ff d0                	callq  *%rax
    }
}
  81814b:	c9                   	leaveq 
  81814c:	c3                   	retq   

000000000081814d <sys_arch_sem_wait>:

u32_t
sys_arch_sem_wait(sys_sem_t sem, u32_t tm_msec)
{
  81814d:	55                   	push   %rbp
  81814e:	48 89 e5             	mov    %rsp,%rbp
  818151:	48 83 ec 30          	sub    $0x30,%rsp
  818155:	89 7d dc             	mov    %edi,-0x24(%rbp)
  818158:	89 75 d8             	mov    %esi,-0x28(%rbp)
    assert(!sems[sem].freed);
  81815b:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  818162:	00 00 00 
  818165:	8b 55 dc             	mov    -0x24(%rbp),%edx
  818168:	48 63 d2             	movslq %edx,%rdx
  81816b:	48 c1 e2 05          	shl    $0x5,%rdx
  81816f:	48 01 d0             	add    %rdx,%rax
  818172:	8b 00                	mov    (%rax),%eax
  818174:	85 c0                	test   %eax,%eax
  818176:	74 35                	je     8181ad <sys_arch_sem_wait+0x60>
  818178:	48 b9 80 2d 82 00 00 	movabs $0x822d80,%rcx
  81817f:	00 00 00 
  818182:	48 ba 79 2c 82 00 00 	movabs $0x822c79,%rdx
  818189:	00 00 00 
  81818c:	be ad 00 00 00       	mov    $0xad,%esi
  818191:	48 bf 8e 2c 82 00 00 	movabs $0x822c8e,%rdi
  818198:	00 00 00 
  81819b:	b8 00 00 00 00       	mov    $0x0,%eax
  8181a0:	49 b8 e9 10 80 00 00 	movabs $0x8010e9,%r8
  8181a7:	00 00 00 
  8181aa:	41 ff d0             	callq  *%r8
    u32_t waited = 0;
  8181ad:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)

    int gen = sems[sem].gen;
  8181b4:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  8181bb:	00 00 00 
  8181be:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8181c1:	48 63 d2             	movslq %edx,%rdx
  8181c4:	48 c1 e2 05          	shl    $0x5,%rdx
  8181c8:	48 01 d0             	add    %rdx,%rax
  8181cb:	8b 40 04             	mov    0x4(%rax),%eax
  8181ce:	89 45 f8             	mov    %eax,-0x8(%rbp)

    while (tm_msec == 0 || waited < tm_msec) {
  8181d1:	e9 80 01 00 00       	jmpq   818356 <sys_arch_sem_wait+0x209>
	if (sems[sem].counter > 0) {
  8181d6:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  8181dd:	00 00 00 
  8181e0:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8181e3:	48 63 d2             	movslq %edx,%rdx
  8181e6:	48 c1 e2 05          	shl    $0x5,%rdx
  8181ea:	48 01 d0             	add    %rdx,%rax
  8181ed:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8181f1:	66 85 c0             	test   %ax,%ax
  8181f4:	74 41                	je     818237 <sys_arch_sem_wait+0xea>
	    sems[sem].counter--;
  8181f6:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  8181fd:	00 00 00 
  818200:	8b 55 dc             	mov    -0x24(%rbp),%edx
  818203:	48 63 d2             	movslq %edx,%rdx
  818206:	48 c1 e2 05          	shl    $0x5,%rdx
  81820a:	48 01 d0             	add    %rdx,%rax
  81820d:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  818211:	8d 50 ff             	lea    -0x1(%rax),%edx
  818214:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  81821b:	00 00 00 
  81821e:	8b 4d dc             	mov    -0x24(%rbp),%ecx
  818221:	48 63 c9             	movslq %ecx,%rcx
  818224:	48 c1 e1 05          	shl    $0x5,%rcx
  818228:	48 01 c8             	add    %rcx,%rax
  81822b:	66 89 50 08          	mov    %dx,0x8(%rax)
	    return waited;
  81822f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  818232:	e9 3a 01 00 00       	jmpq   818371 <sys_arch_sem_wait+0x224>
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
  818237:	83 7d d8 fe          	cmpl   $0xfffffffe,-0x28(%rbp)
  81823b:	75 0a                	jne    818247 <sys_arch_sem_wait+0xfa>
	    return SYS_ARCH_TIMEOUT;
  81823d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  818242:	e9 2a 01 00 00       	jmpq   818371 <sys_arch_sem_wait+0x224>
	} else {
	    uint32_t a = sys_time_msec();
  818247:	48 b8 73 2a 80 00 00 	movabs $0x802a73,%rax
  81824e:	00 00 00 
  818251:	ff d0                	callq  *%rax
  818253:	89 45 f4             	mov    %eax,-0xc(%rbp)
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
  818256:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  81825a:	74 0f                	je     81826b <sys_arch_sem_wait+0x11e>
  81825c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81825f:	8b 55 d8             	mov    -0x28(%rbp),%edx
  818262:	29 c2                	sub    %eax,%edx
  818264:	8b 45 f4             	mov    -0xc(%rbp),%eax
  818267:	01 d0                	add    %edx,%eax
  818269:	eb 05                	jmp    818270 <sys_arch_sem_wait+0x123>
  81826b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  818270:	89 45 f0             	mov    %eax,-0x10(%rbp)
	    sems[sem].waiters = 1;
  818273:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  81827a:	00 00 00 
  81827d:	8b 55 dc             	mov    -0x24(%rbp),%edx
  818280:	48 63 d2             	movslq %edx,%rdx
  818283:	48 c1 e2 05          	shl    $0x5,%rdx
  818287:	48 01 d0             	add    %rdx,%rax
  81828a:	66 c7 40 0a 01 00    	movw   $0x1,0xa(%rax)
	    uint32_t cur_v = sems[sem].v;
  818290:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  818297:	00 00 00 
  81829a:	8b 55 dc             	mov    -0x24(%rbp),%edx
  81829d:	48 63 d2             	movslq %edx,%rdx
  8182a0:	48 c1 e2 05          	shl    $0x5,%rdx
  8182a4:	48 01 d0             	add    %rdx,%rax
  8182a7:	8b 40 08             	mov    0x8(%rax),%eax
  8182aa:	89 45 ec             	mov    %eax,-0x14(%rbp)
	    lwip_core_unlock();
  8182ad:	48 b8 a4 8a 81 00 00 	movabs $0x818aa4,%rax
  8182b4:	00 00 00 
  8182b7:	ff d0                	callq  *%rax
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  8182b9:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8182bc:	48 98                	cltq   
  8182be:	48 c1 e0 05          	shl    $0x5,%rax
  8182c2:	48 89 c2             	mov    %rax,%rdx
  8182c5:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  8182cc:	00 00 00 
  8182cf:	48 01 d0             	add    %rdx,%rax
  8182d2:	48 8d 48 08          	lea    0x8(%rax),%rcx
  8182d6:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8182d9:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8182dc:	89 c6                	mov    %eax,%esi
  8182de:	48 89 cf             	mov    %rcx,%rdi
  8182e1:	48 b8 19 8c 81 00 00 	movabs $0x818c19,%rax
  8182e8:	00 00 00 
  8182eb:	ff d0                	callq  *%rax
	    lwip_core_lock();
  8182ed:	48 b8 9e 8a 81 00 00 	movabs $0x818a9e,%rax
  8182f4:	00 00 00 
  8182f7:	ff d0                	callq  *%rax
	    if (gen != sems[sem].gen) {
  8182f9:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  818300:	00 00 00 
  818303:	8b 55 dc             	mov    -0x24(%rbp),%edx
  818306:	48 63 d2             	movslq %edx,%rdx
  818309:	48 c1 e2 05          	shl    $0x5,%rdx
  81830d:	48 01 d0             	add    %rdx,%rax
  818310:	8b 40 04             	mov    0x4(%rax),%eax
  818313:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  818316:	74 22                	je     81833a <sys_arch_sem_wait+0x1ed>
		cprintf("sys_arch_sem_wait: sem freed under waiter!\n");
  818318:	48 bf 98 2d 82 00 00 	movabs $0x822d98,%rdi
  81831f:	00 00 00 
  818322:	b8 00 00 00 00       	mov    $0x0,%eax
  818327:	48 ba 22 13 80 00 00 	movabs $0x801322,%rdx
  81832e:	00 00 00 
  818331:	ff d2                	callq  *%rdx
		return SYS_ARCH_TIMEOUT;
  818333:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  818338:	eb 37                	jmp    818371 <sys_arch_sem_wait+0x224>
	    }
	    uint32_t b = sys_time_msec();
  81833a:	48 b8 73 2a 80 00 00 	movabs $0x802a73,%rax
  818341:	00 00 00 
  818344:	ff d0                	callq  *%rax
  818346:	89 45 e8             	mov    %eax,-0x18(%rbp)
	    waited += (b - a);
  818349:	8b 45 f4             	mov    -0xc(%rbp),%eax
  81834c:	8b 55 e8             	mov    -0x18(%rbp),%edx
  81834f:	29 c2                	sub    %eax,%edx
  818351:	89 d0                	mov    %edx,%eax
  818353:	01 45 fc             	add    %eax,-0x4(%rbp)
    assert(!sems[sem].freed);
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
  818356:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  81835a:	0f 84 76 fe ff ff    	je     8181d6 <sys_arch_sem_wait+0x89>
  818360:	8b 45 fc             	mov    -0x4(%rbp),%eax
  818363:	3b 45 d8             	cmp    -0x28(%rbp),%eax
  818366:	0f 82 6a fe ff ff    	jb     8181d6 <sys_arch_sem_wait+0x89>
	    uint32_t b = sys_time_msec();
	    waited += (b - a);
	}
    }

    return SYS_ARCH_TIMEOUT;
  81836c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  818371:	c9                   	leaveq 
  818372:	c3                   	retq   

0000000000818373 <sys_arch_mbox_fetch>:

u32_t
sys_arch_mbox_fetch(sys_mbox_t mbox, void **msg, u32_t tm_msec)
{
  818373:	55                   	push   %rbp
  818374:	48 89 e5             	mov    %rsp,%rbp
  818377:	48 83 ec 20          	sub    $0x20,%rsp
  81837b:	89 7d ec             	mov    %edi,-0x14(%rbp)
  81837e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  818382:	89 55 e8             	mov    %edx,-0x18(%rbp)
    assert(!mboxes[mbox].freed);
  818385:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  81838c:	00 00 00 
  81838f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  818392:	48 63 d0             	movslq %eax,%rdx
  818395:	48 89 d0             	mov    %rdx,%rax
  818398:	48 c1 e0 03          	shl    $0x3,%rax
  81839c:	48 01 d0             	add    %rdx,%rax
  81839f:	48 c1 e0 02          	shl    $0x2,%rax
  8183a3:	48 01 d0             	add    %rdx,%rax
  8183a6:	48 c1 e0 03          	shl    $0x3,%rax
  8183aa:	48 01 c8             	add    %rcx,%rax
  8183ad:	8b 00                	mov    (%rax),%eax
  8183af:	85 c0                	test   %eax,%eax
  8183b1:	74 35                	je     8183e8 <sys_arch_mbox_fetch+0x75>
  8183b3:	48 b9 11 2d 82 00 00 	movabs $0x822d11,%rcx
  8183ba:	00 00 00 
  8183bd:	48 ba 79 2c 82 00 00 	movabs $0x822c79,%rdx
  8183c4:	00 00 00 
  8183c7:	be cf 00 00 00       	mov    $0xcf,%esi
  8183cc:	48 bf 8e 2c 82 00 00 	movabs $0x822c8e,%rdi
  8183d3:	00 00 00 
  8183d6:	b8 00 00 00 00       	mov    $0x0,%eax
  8183db:	49 b8 e9 10 80 00 00 	movabs $0x8010e9,%r8
  8183e2:	00 00 00 
  8183e5:	41 ff d0             	callq  *%r8

    u32_t waited = sys_arch_sem_wait(mboxes[mbox].queued_msg, tm_msec);
  8183e8:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  8183ef:	00 00 00 
  8183f2:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8183f5:	48 63 d0             	movslq %eax,%rdx
  8183f8:	48 89 d0             	mov    %rdx,%rax
  8183fb:	48 c1 e0 03          	shl    $0x3,%rax
  8183ff:	48 01 d0             	add    %rdx,%rax
  818402:	48 c1 e0 02          	shl    $0x2,%rax
  818406:	48 01 d0             	add    %rdx,%rax
  818409:	48 c1 e0 03          	shl    $0x3,%rax
  81840d:	48 01 c8             	add    %rcx,%rax
  818410:	48 05 10 01 00 00    	add    $0x110,%rax
  818416:	8b 00                	mov    (%rax),%eax
  818418:	8b 55 e8             	mov    -0x18(%rbp),%edx
  81841b:	89 d6                	mov    %edx,%esi
  81841d:	89 c7                	mov    %eax,%edi
  81841f:	48 b8 4d 81 81 00 00 	movabs $0x81814d,%rax
  818426:	00 00 00 
  818429:	ff d0                	callq  *%rax
  81842b:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (waited == SYS_ARCH_TIMEOUT)
  81842e:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  818432:	75 08                	jne    81843c <sys_arch_mbox_fetch+0xc9>
	return waited;
  818434:	8b 45 fc             	mov    -0x4(%rbp),%eax
  818437:	e9 ad 01 00 00       	jmpq   8185e9 <sys_arch_mbox_fetch+0x276>

    int slot = mboxes[mbox].head;
  81843c:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  818443:	00 00 00 
  818446:	8b 45 ec             	mov    -0x14(%rbp),%eax
  818449:	48 63 d0             	movslq %eax,%rdx
  81844c:	48 89 d0             	mov    %rdx,%rax
  81844f:	48 c1 e0 03          	shl    $0x3,%rax
  818453:	48 01 d0             	add    %rdx,%rax
  818456:	48 c1 e0 02          	shl    $0x2,%rax
  81845a:	48 01 d0             	add    %rdx,%rax
  81845d:	48 c1 e0 03          	shl    $0x3,%rax
  818461:	48 01 c8             	add    %rcx,%rax
  818464:	8b 40 04             	mov    0x4(%rax),%eax
  818467:	89 45 f8             	mov    %eax,-0x8(%rbp)
    if (slot == -1)
  81846a:	83 7d f8 ff          	cmpl   $0xffffffff,-0x8(%rbp)
  81846e:	75 2a                	jne    81849a <sys_arch_mbox_fetch+0x127>
	panic("lwip: sys_arch_mbox_fetch: no message");
  818470:	48 ba c8 2d 82 00 00 	movabs $0x822dc8,%rdx
  818477:	00 00 00 
  81847a:	be d7 00 00 00       	mov    $0xd7,%esi
  81847f:	48 bf 8e 2c 82 00 00 	movabs $0x822c8e,%rdi
  818486:	00 00 00 
  818489:	b8 00 00 00 00       	mov    $0x0,%eax
  81848e:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  818495:	00 00 00 
  818498:	ff d1                	callq  *%rcx
    if (msg)
  81849a:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81849f:	74 39                	je     8184da <sys_arch_mbox_fetch+0x167>
	*msg = mboxes[mbox].msg[slot];
  8184a1:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  8184a8:	00 00 00 
  8184ab:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8184ae:	48 63 f0             	movslq %eax,%rsi
  8184b1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8184b4:	48 63 d0             	movslq %eax,%rdx
  8184b7:	48 89 d0             	mov    %rdx,%rax
  8184ba:	48 c1 e0 03          	shl    $0x3,%rax
  8184be:	48 01 d0             	add    %rdx,%rax
  8184c1:	48 c1 e0 02          	shl    $0x2,%rax
  8184c5:	48 01 d0             	add    %rdx,%rax
  8184c8:	48 01 f0             	add    %rsi,%rax
  8184cb:	48 83 c0 02          	add    $0x2,%rax
  8184cf:	48 8b 14 c1          	mov    (%rcx,%rax,8),%rdx
  8184d3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8184d7:	48 89 10             	mov    %rdx,(%rax)

    mboxes[mbox].head = (slot + 1) % MBOXSLOTS;
  8184da:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8184dd:	8d 50 01             	lea    0x1(%rax),%edx
  8184e0:	89 d0                	mov    %edx,%eax
  8184e2:	c1 f8 1f             	sar    $0x1f,%eax
  8184e5:	c1 e8 1b             	shr    $0x1b,%eax
  8184e8:	01 c2                	add    %eax,%edx
  8184ea:	83 e2 1f             	and    $0x1f,%edx
  8184ed:	29 c2                	sub    %eax,%edx
  8184ef:	89 d0                	mov    %edx,%eax
  8184f1:	89 c1                	mov    %eax,%ecx
  8184f3:	48 be 40 d8 b4 00 00 	movabs $0xb4d840,%rsi
  8184fa:	00 00 00 
  8184fd:	8b 45 ec             	mov    -0x14(%rbp),%eax
  818500:	48 63 d0             	movslq %eax,%rdx
  818503:	48 89 d0             	mov    %rdx,%rax
  818506:	48 c1 e0 03          	shl    $0x3,%rax
  81850a:	48 01 d0             	add    %rdx,%rax
  81850d:	48 c1 e0 02          	shl    $0x2,%rax
  818511:	48 01 d0             	add    %rdx,%rax
  818514:	48 c1 e0 03          	shl    $0x3,%rax
  818518:	48 01 f0             	add    %rsi,%rax
  81851b:	89 48 04             	mov    %ecx,0x4(%rax)
    if (mboxes[mbox].head == mboxes[mbox].nextq)
  81851e:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  818525:	00 00 00 
  818528:	8b 45 ec             	mov    -0x14(%rbp),%eax
  81852b:	48 63 d0             	movslq %eax,%rdx
  81852e:	48 89 d0             	mov    %rdx,%rax
  818531:	48 c1 e0 03          	shl    $0x3,%rax
  818535:	48 01 d0             	add    %rdx,%rax
  818538:	48 c1 e0 02          	shl    $0x2,%rax
  81853c:	48 01 d0             	add    %rdx,%rax
  81853f:	48 c1 e0 03          	shl    $0x3,%rax
  818543:	48 01 c8             	add    %rcx,%rax
  818546:	8b 48 04             	mov    0x4(%rax),%ecx
  818549:	48 be 40 d8 b4 00 00 	movabs $0xb4d840,%rsi
  818550:	00 00 00 
  818553:	8b 45 ec             	mov    -0x14(%rbp),%eax
  818556:	48 63 d0             	movslq %eax,%rdx
  818559:	48 89 d0             	mov    %rdx,%rax
  81855c:	48 c1 e0 03          	shl    $0x3,%rax
  818560:	48 01 d0             	add    %rdx,%rax
  818563:	48 c1 e0 02          	shl    $0x2,%rax
  818567:	48 01 d0             	add    %rdx,%rax
  81856a:	48 c1 e0 03          	shl    $0x3,%rax
  81856e:	48 01 f0             	add    %rsi,%rax
  818571:	8b 40 08             	mov    0x8(%rax),%eax
  818574:	39 c1                	cmp    %eax,%ecx
  818576:	75 2f                	jne    8185a7 <sys_arch_mbox_fetch+0x234>
	mboxes[mbox].head = -1;
  818578:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  81857f:	00 00 00 
  818582:	8b 45 ec             	mov    -0x14(%rbp),%eax
  818585:	48 63 d0             	movslq %eax,%rdx
  818588:	48 89 d0             	mov    %rdx,%rax
  81858b:	48 c1 e0 03          	shl    $0x3,%rax
  81858f:	48 01 d0             	add    %rdx,%rax
  818592:	48 c1 e0 02          	shl    $0x2,%rax
  818596:	48 01 d0             	add    %rdx,%rax
  818599:	48 c1 e0 03          	shl    $0x3,%rax
  81859d:	48 01 c8             	add    %rcx,%rax
  8185a0:	c7 40 04 ff ff ff ff 	movl   $0xffffffff,0x4(%rax)

    sys_sem_signal(mboxes[mbox].free_msg);
  8185a7:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  8185ae:	00 00 00 
  8185b1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8185b4:	48 63 d0             	movslq %eax,%rdx
  8185b7:	48 89 d0             	mov    %rdx,%rax
  8185ba:	48 c1 e0 03          	shl    $0x3,%rax
  8185be:	48 01 d0             	add    %rdx,%rax
  8185c1:	48 c1 e0 02          	shl    $0x2,%rax
  8185c5:	48 01 d0             	add    %rdx,%rax
  8185c8:	48 c1 e0 03          	shl    $0x3,%rax
  8185cc:	48 01 c8             	add    %rcx,%rax
  8185cf:	48 05 10 01 00 00    	add    $0x110,%rax
  8185d5:	8b 40 04             	mov    0x4(%rax),%eax
  8185d8:	89 c7                	mov    %eax,%edi
  8185da:	48 b8 4c 80 81 00 00 	movabs $0x81804c,%rax
  8185e1:	00 00 00 
  8185e4:	ff d0                	callq  *%rax
    return waited;
  8185e6:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8185e9:	c9                   	leaveq 
  8185ea:	c3                   	retq   

00000000008185eb <sys_arch_mbox_tryfetch>:

u32_t 
sys_arch_mbox_tryfetch(sys_mbox_t mbox, void **msg)
{
  8185eb:	55                   	push   %rbp
  8185ec:	48 89 e5             	mov    %rsp,%rbp
  8185ef:	48 83 ec 10          	sub    $0x10,%rsp
  8185f3:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8185f6:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    return sys_arch_mbox_fetch(mbox, msg, SYS_ARCH_NOWAIT);
  8185fa:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  8185fe:	8b 45 fc             	mov    -0x4(%rbp),%eax
  818601:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
  818606:	48 89 ce             	mov    %rcx,%rsi
  818609:	89 c7                	mov    %eax,%edi
  81860b:	48 b8 73 83 81 00 00 	movabs $0x818373,%rax
  818612:	00 00 00 
  818615:	ff d0                	callq  *%rax
}
  818617:	c9                   	leaveq 
  818618:	c3                   	retq   

0000000000818619 <lwip_thread_entry>:
    void *arg;
};

static void
lwip_thread_entry(uint64_t arg)
{
  818619:	55                   	push   %rbp
  81861a:	48 89 e5             	mov    %rsp,%rbp
  81861d:	48 83 ec 20          	sub    $0x20,%rsp
  818621:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    struct lwip_thread *lt = (struct lwip_thread *)arg;
  818625:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818629:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    lwip_core_lock();
  81862d:	48 b8 9e 8a 81 00 00 	movabs $0x818a9e,%rax
  818634:	00 00 00 
  818637:	ff d0                	callq  *%rax
    lt->func(lt->arg);
  818639:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81863d:	48 8b 00             	mov    (%rax),%rax
  818640:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  818644:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  818648:	48 89 d7             	mov    %rdx,%rdi
  81864b:	ff d0                	callq  *%rax
    lwip_core_unlock();
  81864d:	48 b8 a4 8a 81 00 00 	movabs $0x818aa4,%rax
  818654:	00 00 00 
  818657:	ff d0                	callq  *%rax
    free(lt);
  818659:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81865d:	48 89 c7             	mov    %rax,%rdi
  818660:	48 b8 8d 51 80 00 00 	movabs $0x80518d,%rax
  818667:	00 00 00 
  81866a:	ff d0                	callq  *%rax
}
  81866c:	c9                   	leaveq 
  81866d:	c3                   	retq   

000000000081866e <sys_thread_new>:

sys_thread_t
sys_thread_new(char *name, void (* thread)(void *arg), void *arg, 
	       int stacksize, int prio)
{
  81866e:	55                   	push   %rbp
  81866f:	48 89 e5             	mov    %rsp,%rbp
  818672:	48 83 ec 30          	sub    $0x30,%rsp
  818676:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81867a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81867e:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  818682:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
  818685:	44 89 45 d0          	mov    %r8d,-0x30(%rbp)
    struct lwip_thread *lt = malloc(sizeof(*lt));
  818689:	bf 10 00 00 00       	mov    $0x10,%edi
  81868e:	48 b8 0f 4e 80 00 00 	movabs $0x804e0f,%rax
  818695:	00 00 00 
  818698:	ff d0                	callq  *%rax
  81869a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (lt == 0)
  81869e:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8186a3:	75 2a                	jne    8186cf <sys_thread_new+0x61>
	panic("sys_thread_new: cannot allocate thread struct");
  8186a5:	48 ba f0 2d 82 00 00 	movabs $0x822df0,%rdx
  8186ac:	00 00 00 
  8186af:	be fe 00 00 00       	mov    $0xfe,%esi
  8186b4:	48 bf 8e 2c 82 00 00 	movabs $0x822c8e,%rdi
  8186bb:	00 00 00 
  8186be:	b8 00 00 00 00       	mov    $0x0,%eax
  8186c3:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  8186ca:	00 00 00 
  8186cd:	ff d1                	callq  *%rcx

    if (stacksize > PGSIZE)
  8186cf:	81 7d d4 00 10 00 00 	cmpl   $0x1000,-0x2c(%rbp)
  8186d6:	7e 30                	jle    818708 <sys_thread_new+0x9a>
	panic("large stack %d", stacksize);
  8186d8:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8186db:	89 c1                	mov    %eax,%ecx
  8186dd:	48 ba 1e 2e 82 00 00 	movabs $0x822e1e,%rdx
  8186e4:	00 00 00 
  8186e7:	be 01 01 00 00       	mov    $0x101,%esi
  8186ec:	48 bf 8e 2c 82 00 00 	movabs $0x822c8e,%rdi
  8186f3:	00 00 00 
  8186f6:	b8 00 00 00 00       	mov    $0x0,%eax
  8186fb:	49 b8 e9 10 80 00 00 	movabs $0x8010e9,%r8
  818702:	00 00 00 
  818705:	41 ff d0             	callq  *%r8

    lt->func = thread;
  818708:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81870c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  818710:	48 89 10             	mov    %rdx,(%rax)
    lt->arg = arg;
  818713:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818717:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81871b:	48 89 50 08          	mov    %rdx,0x8(%rax)

    thread_id_t tid;
    int r = thread_create(&tid, name, lwip_thread_entry, (uint64_t)lt);
  81871f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  818723:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  818727:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  81872b:	48 89 d1             	mov    %rdx,%rcx
  81872e:	48 ba 19 86 81 00 00 	movabs $0x818619,%rdx
  818735:	00 00 00 
  818738:	48 89 c7             	mov    %rax,%rdi
  81873b:	48 b8 8e 8e 81 00 00 	movabs $0x818e8e,%rax
  818742:	00 00 00 
  818745:	ff d0                	callq  *%rax
  818747:	89 45 f4             	mov    %eax,-0xc(%rbp)

    if (r < 0)
  81874a:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  81874e:	79 3f                	jns    81878f <sys_thread_new+0x121>
	panic("lwip: sys_thread_new: cannot create: %s\n", e2s(r));
  818750:	8b 45 f4             	mov    -0xc(%rbp),%eax
  818753:	89 c7                	mov    %eax,%edi
  818755:	48 b8 15 95 81 00 00 	movabs $0x819515,%rax
  81875c:	00 00 00 
  81875f:	ff d0                	callq  *%rax
  818761:	48 89 c1             	mov    %rax,%rcx
  818764:	48 ba 30 2e 82 00 00 	movabs $0x822e30,%rdx
  81876b:	00 00 00 
  81876e:	be 0a 01 00 00       	mov    $0x10a,%esi
  818773:	48 bf 8e 2c 82 00 00 	movabs $0x822c8e,%rdi
  81877a:	00 00 00 
  81877d:	b8 00 00 00 00       	mov    $0x0,%eax
  818782:	49 b8 e9 10 80 00 00 	movabs $0x8010e9,%r8
  818789:	00 00 00 
  81878c:	41 ff d0             	callq  *%r8

    return tid;
  81878f:	8b 45 f0             	mov    -0x10(%rbp),%eax
}
  818792:	c9                   	leaveq 
  818793:	c3                   	retq   

0000000000818794 <timeout_cleanup>:

static void
timeout_cleanup(thread_id_t tid)
{
  818794:	55                   	push   %rbp
  818795:	48 89 e5             	mov    %rsp,%rbp
  818798:	48 83 ec 20          	sub    $0x20,%rsp
  81879c:	89 7d ec             	mov    %edi,-0x14(%rbp)
    lwip_core_lock();
  81879f:	48 b8 9e 8a 81 00 00 	movabs $0x818a9e,%rax
  8187a6:	00 00 00 
  8187a9:	ff d0                	callq  *%rax

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  8187ab:	8b 4d ec             	mov    -0x14(%rbp),%ecx
  8187ae:	89 ca                	mov    %ecx,%edx
  8187b0:	b8 01 ff 00 ff       	mov    $0xff00ff01,%eax
  8187b5:	48 0f af c2          	imul   %rdx,%rax
  8187b9:	48 c1 e8 20          	shr    $0x20,%rax
  8187bd:	89 c2                	mov    %eax,%edx
  8187bf:	c1 ea 08             	shr    $0x8,%edx
  8187c2:	89 d0                	mov    %edx,%eax
  8187c4:	c1 e0 08             	shl    $0x8,%eax
  8187c7:	01 d0                	add    %edx,%eax
  8187c9:	29 c1                	sub    %eax,%ecx
  8187cb:	89 ca                	mov    %ecx,%edx
  8187cd:	48 b8 60 6c b5 00 00 	movabs $0xb56c60,%rax
  8187d4:	00 00 00 
  8187d7:	89 d2                	mov    %edx,%edx
  8187d9:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8187dd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8187e1:	eb 60                	jmp    818843 <timeout_cleanup+0xaf>
	if (t->tid == tid) {
  8187e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8187e7:	8b 00                	mov    (%rax),%eax
  8187e9:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8187ec:	75 49                	jne    818837 <timeout_cleanup+0xa3>
	    LIST_REMOVE(t, link);
  8187ee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8187f2:	48 8b 40 10          	mov    0x10(%rax),%rax
  8187f6:	48 85 c0             	test   %rax,%rax
  8187f9:	74 14                	je     81880f <timeout_cleanup+0x7b>
  8187fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8187ff:	48 8b 40 10          	mov    0x10(%rax),%rax
  818803:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  818807:	48 8b 52 18          	mov    0x18(%rdx),%rdx
  81880b:	48 89 50 18          	mov    %rdx,0x18(%rax)
  81880f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818813:	48 8b 40 18          	mov    0x18(%rax),%rax
  818817:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81881b:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  81881f:	48 89 10             	mov    %rdx,(%rax)
	    free(t);
  818822:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818826:	48 89 c7             	mov    %rax,%rdi
  818829:	48 b8 8d 51 80 00 00 	movabs $0x80518d,%rax
  818830:	00 00 00 
  818833:	ff d0                	callq  *%rax
	    goto done;
  818835:	eb 13                	jmp    81884a <timeout_cleanup+0xb6>
timeout_cleanup(thread_id_t tid)
{
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  818837:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81883b:	48 8b 40 10          	mov    0x10(%rax),%rax
  81883f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  818843:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  818848:	75 99                	jne    8187e3 <timeout_cleanup+0x4f>
	    goto done;
	}

    if (debug) cprintf("timeout_cleanup: bogus tid %ld\n", tid);
 done:
    lwip_core_unlock();
  81884a:	48 b8 a4 8a 81 00 00 	movabs $0x818aa4,%rax
  818851:	00 00 00 
  818854:	ff d0                	callq  *%rax
}
  818856:	c9                   	leaveq 
  818857:	c3                   	retq   

0000000000818858 <sys_arch_timeouts>:

struct sys_timeouts *
sys_arch_timeouts(void)
{
  818858:	55                   	push   %rbp
  818859:	48 89 e5             	mov    %rsp,%rbp
  81885c:	48 83 ec 10          	sub    $0x10,%rsp
    thread_id_t tid = thread_id();
  818860:	48 b8 b1 8b 81 00 00 	movabs $0x818bb1,%rax
  818867:	00 00 00 
  81886a:	ff d0                	callq  *%rax
  81886c:	89 45 f4             	mov    %eax,-0xc(%rbp)

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  81886f:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  818872:	89 ca                	mov    %ecx,%edx
  818874:	b8 01 ff 00 ff       	mov    $0xff00ff01,%eax
  818879:	48 0f af c2          	imul   %rdx,%rax
  81887d:	48 c1 e8 20          	shr    $0x20,%rax
  818881:	89 c2                	mov    %eax,%edx
  818883:	c1 ea 08             	shr    $0x8,%edx
  818886:	89 d0                	mov    %edx,%eax
  818888:	c1 e0 08             	shl    $0x8,%eax
  81888b:	01 d0                	add    %edx,%eax
  81888d:	29 c1                	sub    %eax,%ecx
  81888f:	89 ca                	mov    %ecx,%edx
  818891:	48 b8 60 6c b5 00 00 	movabs $0xb56c60,%rax
  818898:	00 00 00 
  81889b:	89 d2                	mov    %edx,%edx
  81889d:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8188a1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8188a5:	eb 1c                	jmp    8188c3 <sys_arch_timeouts+0x6b>
	if (t->tid == tid)
  8188a7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8188ab:	8b 00                	mov    (%rax),%eax
  8188ad:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  8188b0:	75 05                	jne    8188b7 <sys_arch_timeouts+0x5f>
	    goto out;
  8188b2:	e9 dd 01 00 00       	jmpq   818a94 <sys_arch_timeouts+0x23c>
sys_arch_timeouts(void)
{
    thread_id_t tid = thread_id();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  8188b7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8188bb:	48 8b 40 10          	mov    0x10(%rax),%rax
  8188bf:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8188c3:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8188c8:	75 dd                	jne    8188a7 <sys_arch_timeouts+0x4f>
	if (t->tid == tid)
	    goto out;

    t = malloc(sizeof(*t));
  8188ca:	bf 20 00 00 00       	mov    $0x20,%edi
  8188cf:	48 b8 0f 4e 80 00 00 	movabs $0x804e0f,%rax
  8188d6:	00 00 00 
  8188d9:	ff d0                	callq  *%rax
  8188db:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (t == 0)
  8188df:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8188e4:	75 2a                	jne    818910 <sys_arch_timeouts+0xb8>
	panic("sys_arch_timeouts: cannot malloc");
  8188e6:	48 ba 60 2e 82 00 00 	movabs $0x822e60,%rdx
  8188ed:	00 00 00 
  8188f0:	be 2d 01 00 00       	mov    $0x12d,%esi
  8188f5:	48 bf 8e 2c 82 00 00 	movabs $0x822c8e,%rdi
  8188fc:	00 00 00 
  8188ff:	b8 00 00 00 00       	mov    $0x0,%eax
  818904:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81890b:	00 00 00 
  81890e:	ff d1                	callq  *%rcx

    int r = thread_onhalt(timeout_cleanup);
  818910:	48 bf 94 87 81 00 00 	movabs $0x818794,%rdi
  818917:	00 00 00 
  81891a:	48 b8 47 8d 81 00 00 	movabs $0x818d47,%rax
  818921:	00 00 00 
  818924:	ff d0                	callq  *%rax
  818926:	89 45 f0             	mov    %eax,-0x10(%rbp)
    if (r < 0)
  818929:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  81892d:	79 3f                	jns    81896e <sys_arch_timeouts+0x116>
	panic("thread_onhalt failed: %s", e2s(r));
  81892f:	8b 45 f0             	mov    -0x10(%rbp),%eax
  818932:	89 c7                	mov    %eax,%edi
  818934:	48 b8 15 95 81 00 00 	movabs $0x819515,%rax
  81893b:	00 00 00 
  81893e:	ff d0                	callq  *%rax
  818940:	48 89 c1             	mov    %rax,%rcx
  818943:	48 ba 81 2e 82 00 00 	movabs $0x822e81,%rdx
  81894a:	00 00 00 
  81894d:	be 31 01 00 00       	mov    $0x131,%esi
  818952:	48 bf 8e 2c 82 00 00 	movabs $0x822c8e,%rdi
  818959:	00 00 00 
  81895c:	b8 00 00 00 00       	mov    $0x0,%eax
  818961:	49 b8 e9 10 80 00 00 	movabs $0x8010e9,%r8
  818968:	00 00 00 
  81896b:	41 ff d0             	callq  *%r8

    t->tid = tid;
  81896e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818972:	8b 55 f4             	mov    -0xc(%rbp),%edx
  818975:	89 10                	mov    %edx,(%rax)
    memset(&t->tmo, 0, sizeof(t->tmo));
  818977:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81897b:	48 83 c0 08          	add    $0x8,%rax
  81897f:	ba 08 00 00 00       	mov    $0x8,%edx
  818984:	be 00 00 00 00       	mov    $0x0,%esi
  818989:	48 89 c7             	mov    %rax,%rdi
  81898c:	48 b8 70 21 80 00 00 	movabs $0x802170,%rax
  818993:	00 00 00 
  818996:	ff d0                	callq  *%rax
    LIST_INSERT_HEAD(&threads[tid % thread_hash_size], t, link);
  818998:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  81899b:	89 ca                	mov    %ecx,%edx
  81899d:	b8 01 ff 00 ff       	mov    $0xff00ff01,%eax
  8189a2:	48 0f af c2          	imul   %rdx,%rax
  8189a6:	48 c1 e8 20          	shr    $0x20,%rax
  8189aa:	89 c2                	mov    %eax,%edx
  8189ac:	c1 ea 08             	shr    $0x8,%edx
  8189af:	89 d0                	mov    %edx,%eax
  8189b1:	c1 e0 08             	shl    $0x8,%eax
  8189b4:	01 d0                	add    %edx,%eax
  8189b6:	29 c1                	sub    %eax,%ecx
  8189b8:	89 ca                	mov    %ecx,%edx
  8189ba:	48 b8 60 6c b5 00 00 	movabs $0xb56c60,%rax
  8189c1:	00 00 00 
  8189c4:	89 d2                	mov    %edx,%edx
  8189c6:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  8189ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8189ce:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8189d2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8189d6:	48 8b 40 10          	mov    0x10(%rax),%rax
  8189da:	48 85 c0             	test   %rax,%rax
  8189dd:	74 3e                	je     818a1d <sys_arch_timeouts+0x1c5>
  8189df:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  8189e2:	89 ca                	mov    %ecx,%edx
  8189e4:	b8 01 ff 00 ff       	mov    $0xff00ff01,%eax
  8189e9:	48 0f af c2          	imul   %rdx,%rax
  8189ed:	48 c1 e8 20          	shr    $0x20,%rax
  8189f1:	89 c2                	mov    %eax,%edx
  8189f3:	c1 ea 08             	shr    $0x8,%edx
  8189f6:	89 d0                	mov    %edx,%eax
  8189f8:	c1 e0 08             	shl    $0x8,%eax
  8189fb:	01 d0                	add    %edx,%eax
  8189fd:	29 c1                	sub    %eax,%ecx
  8189ff:	89 ca                	mov    %ecx,%edx
  818a01:	48 b8 60 6c b5 00 00 	movabs $0xb56c60,%rax
  818a08:	00 00 00 
  818a0b:	89 d2                	mov    %edx,%edx
  818a0d:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  818a11:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  818a15:	48 83 c2 10          	add    $0x10,%rdx
  818a19:	48 89 50 18          	mov    %rdx,0x18(%rax)
  818a1d:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  818a20:	89 ca                	mov    %ecx,%edx
  818a22:	b8 01 ff 00 ff       	mov    $0xff00ff01,%eax
  818a27:	48 0f af c2          	imul   %rdx,%rax
  818a2b:	48 c1 e8 20          	shr    $0x20,%rax
  818a2f:	89 c2                	mov    %eax,%edx
  818a31:	c1 ea 08             	shr    $0x8,%edx
  818a34:	89 d0                	mov    %edx,%eax
  818a36:	c1 e0 08             	shl    $0x8,%eax
  818a39:	01 d0                	add    %edx,%eax
  818a3b:	29 c1                	sub    %eax,%ecx
  818a3d:	89 ca                	mov    %ecx,%edx
  818a3f:	48 b8 60 6c b5 00 00 	movabs $0xb56c60,%rax
  818a46:	00 00 00 
  818a49:	89 d2                	mov    %edx,%edx
  818a4b:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  818a4f:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)
  818a53:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  818a56:	89 ca                	mov    %ecx,%edx
  818a58:	b8 01 ff 00 ff       	mov    $0xff00ff01,%eax
  818a5d:	48 0f af c2          	imul   %rdx,%rax
  818a61:	48 c1 e8 20          	shr    $0x20,%rax
  818a65:	89 c2                	mov    %eax,%edx
  818a67:	c1 ea 08             	shr    $0x8,%edx
  818a6a:	89 d0                	mov    %edx,%eax
  818a6c:	c1 e0 08             	shl    $0x8,%eax
  818a6f:	01 d0                	add    %edx,%eax
  818a71:	29 c1                	sub    %eax,%ecx
  818a73:	89 ca                	mov    %ecx,%edx
  818a75:	89 d0                	mov    %edx,%eax
  818a77:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  818a7e:	00 
  818a7f:	48 b8 60 6c b5 00 00 	movabs $0xb56c60,%rax
  818a86:	00 00 00 
  818a89:	48 01 c2             	add    %rax,%rdx
  818a8c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818a90:	48 89 50 18          	mov    %rdx,0x18(%rax)

out:
    return &t->tmo;
  818a94:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818a98:	48 83 c0 08          	add    $0x8,%rax
}
  818a9c:	c9                   	leaveq 
  818a9d:	c3                   	retq   

0000000000818a9e <lwip_core_lock>:

void
lwip_core_lock(void)
{
  818a9e:	55                   	push   %rbp
  818a9f:	48 89 e5             	mov    %rsp,%rbp
}
  818aa2:	5d                   	pop    %rbp
  818aa3:	c3                   	retq   

0000000000818aa4 <lwip_core_unlock>:

void
lwip_core_unlock(void)
{
  818aa4:	55                   	push   %rbp
  818aa5:	48 89 e5             	mov    %rsp,%rbp
}
  818aa8:	5d                   	pop    %rbp
  818aa9:	c3                   	retq   

0000000000818aaa <threadq_init>:
    struct thread_context *tc_queue_link;
};

static inline void 
threadq_init(struct thread_queue *tq)
{
  818aaa:	55                   	push   %rbp
  818aab:	48 89 e5             	mov    %rsp,%rbp
  818aae:	48 83 ec 08          	sub    $0x8,%rsp
  818ab2:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    tq->tq_first = 0;
  818ab6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818aba:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    tq->tq_last = 0;
  818ac1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818ac5:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  818acc:	00 
}
  818acd:	c9                   	leaveq 
  818ace:	c3                   	retq   

0000000000818acf <threadq_push>:

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
  818acf:	55                   	push   %rbp
  818ad0:	48 89 e5             	mov    %rsp,%rbp
  818ad3:	48 83 ec 10          	sub    $0x10,%rsp
  818ad7:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  818adb:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    tc->tc_queue_link = 0;
  818adf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  818ae3:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
  818aea:	00 00 00 00 
    if (!tq->tq_first) {
  818aee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818af2:	48 8b 00             	mov    (%rax),%rax
  818af5:	48 85 c0             	test   %rax,%rax
  818af8:	75 19                	jne    818b13 <threadq_push+0x44>
	tq->tq_first = tc;
  818afa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818afe:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  818b02:	48 89 10             	mov    %rdx,(%rax)
	tq->tq_last = tc;
  818b05:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818b09:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  818b0d:	48 89 50 08          	mov    %rdx,0x8(%rax)
  818b11:	eb 1f                	jmp    818b32 <threadq_push+0x63>
    } else {
	tq->tq_last->tc_queue_link = tc;
  818b13:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818b17:	48 8b 40 08          	mov    0x8(%rax),%rax
  818b1b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  818b1f:	48 89 90 e8 00 00 00 	mov    %rdx,0xe8(%rax)
	tq->tq_last = tc;
  818b26:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818b2a:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  818b2e:	48 89 50 08          	mov    %rdx,0x8(%rax)
    }
}
  818b32:	c9                   	leaveq 
  818b33:	c3                   	retq   

0000000000818b34 <threadq_pop>:

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
  818b34:	55                   	push   %rbp
  818b35:	48 89 e5             	mov    %rsp,%rbp
  818b38:	48 83 ec 18          	sub    $0x18,%rsp
  818b3c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    if (!tq->tq_first)
  818b40:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818b44:	48 8b 00             	mov    (%rax),%rax
  818b47:	48 85 c0             	test   %rax,%rax
  818b4a:	75 07                	jne    818b53 <threadq_pop+0x1f>
	return 0;
  818b4c:	b8 00 00 00 00       	mov    $0x0,%eax
  818b51:	eb 30                	jmp    818b83 <threadq_pop+0x4f>

    struct thread_context *tc = tq->tq_first;
  818b53:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818b57:	48 8b 00             	mov    (%rax),%rax
  818b5a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    tq->tq_first = tc->tc_queue_link;
  818b5e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818b62:	48 8b 90 e8 00 00 00 	mov    0xe8(%rax),%rdx
  818b69:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818b6d:	48 89 10             	mov    %rdx,(%rax)
    tc->tc_queue_link = 0;
  818b70:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818b74:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
  818b7b:	00 00 00 00 
    return tc;
  818b7f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  818b83:	c9                   	leaveq 
  818b84:	c3                   	retq   

0000000000818b85 <thread_init>:

static struct thread_queue thread_queue;
static struct thread_queue kill_queue;

void
thread_init(void) {
  818b85:	55                   	push   %rbp
  818b86:	48 89 e5             	mov    %rsp,%rbp
    threadq_init(&thread_queue);
  818b89:	48 bf 80 74 b5 00 00 	movabs $0xb57480,%rdi
  818b90:	00 00 00 
  818b93:	48 b8 aa 8a 81 00 00 	movabs $0x818aaa,%rax
  818b9a:	00 00 00 
  818b9d:	ff d0                	callq  *%rax
    max_tid = 0;
  818b9f:	48 b8 70 74 b5 00 00 	movabs $0xb57470,%rax
  818ba6:	00 00 00 
  818ba9:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
}
  818baf:	5d                   	pop    %rbp
  818bb0:	c3                   	retq   

0000000000818bb1 <thread_id>:

uint32_t
thread_id(void) {
  818bb1:	55                   	push   %rbp
  818bb2:	48 89 e5             	mov    %rsp,%rbp
    return cur_tc->tc_tid;
  818bb5:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818bbc:	00 00 00 
  818bbf:	48 8b 00             	mov    (%rax),%rax
  818bc2:	8b 00                	mov    (%rax),%eax
}
  818bc4:	5d                   	pop    %rbp
  818bc5:	c3                   	retq   

0000000000818bc6 <thread_wakeup>:

void
thread_wakeup(volatile uint32_t *addr) {
  818bc6:	55                   	push   %rbp
  818bc7:	48 89 e5             	mov    %rsp,%rbp
  818bca:	48 83 ec 18          	sub    $0x18,%rsp
  818bce:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    struct thread_context *tc = thread_queue.tq_first;
  818bd2:	48 b8 80 74 b5 00 00 	movabs $0xb57480,%rax
  818bd9:	00 00 00 
  818bdc:	48 8b 00             	mov    (%rax),%rax
  818bdf:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    while (tc) {
  818be3:	eb 2b                	jmp    818c10 <thread_wakeup+0x4a>
	if (tc->tc_wait_addr == addr)
  818be5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818be9:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  818bf0:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  818bf4:	75 0b                	jne    818c01 <thread_wakeup+0x3b>
	    tc->tc_wakeup = 1;
  818bf6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818bfa:	c6 80 b8 00 00 00 01 	movb   $0x1,0xb8(%rax)
	tc = tc->tc_queue_link;
  818c01:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818c05:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  818c0c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

void
thread_wakeup(volatile uint32_t *addr) {
    struct thread_context *tc = thread_queue.tq_first;
    while (tc) {
  818c10:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  818c15:	75 ce                	jne    818be5 <thread_wakeup+0x1f>
	if (tc->tc_wait_addr == addr)
	    tc->tc_wakeup = 1;
	tc = tc->tc_queue_link;
    }
}
  818c17:	c9                   	leaveq 
  818c18:	c3                   	retq   

0000000000818c19 <thread_wait>:

void
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
  818c19:	55                   	push   %rbp
  818c1a:	48 89 e5             	mov    %rsp,%rbp
  818c1d:	48 83 ec 20          	sub    $0x20,%rsp
  818c21:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  818c25:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  818c28:	89 55 e0             	mov    %edx,-0x20(%rbp)
    uint32_t s = sys_time_msec();
  818c2b:	48 b8 73 2a 80 00 00 	movabs $0x802a73,%rax
  818c32:	00 00 00 
  818c35:	ff d0                	callq  *%rax
  818c37:	89 45 f8             	mov    %eax,-0x8(%rbp)
    uint32_t p = s;
  818c3a:	8b 45 f8             	mov    -0x8(%rbp),%eax
  818c3d:	89 45 fc             	mov    %eax,-0x4(%rbp)

    cur_tc->tc_wait_addr = addr;
  818c40:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818c47:	00 00 00 
  818c4a:	48 8b 00             	mov    (%rax),%rax
  818c4d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  818c51:	48 89 90 b0 00 00 00 	mov    %rdx,0xb0(%rax)
    cur_tc->tc_wakeup = 0;
  818c58:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818c5f:	00 00 00 
  818c62:	48 8b 00             	mov    (%rax),%rax
  818c65:	c6 80 b8 00 00 00 00 	movb   $0x0,0xb8(%rax)

    while (p < msec) {
  818c6c:	eb 53                	jmp    818cc1 <thread_wait+0xa8>
	if (p < s)
  818c6e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  818c71:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  818c74:	73 02                	jae    818c78 <thread_wait+0x5f>
	    break;
  818c76:	eb 51                	jmp    818cc9 <thread_wait+0xb0>
	if (addr && *addr != val)
  818c78:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  818c7d:	74 0d                	je     818c8c <thread_wait+0x73>
  818c7f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818c83:	8b 00                	mov    (%rax),%eax
  818c85:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  818c88:	74 02                	je     818c8c <thread_wait+0x73>
	    break;
  818c8a:	eb 3d                	jmp    818cc9 <thread_wait+0xb0>
	if (cur_tc->tc_wakeup)
  818c8c:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818c93:	00 00 00 
  818c96:	48 8b 00             	mov    (%rax),%rax
  818c99:	0f b6 80 b8 00 00 00 	movzbl 0xb8(%rax),%eax
  818ca0:	84 c0                	test   %al,%al
  818ca2:	74 02                	je     818ca6 <thread_wait+0x8d>
	    break;
  818ca4:	eb 23                	jmp    818cc9 <thread_wait+0xb0>

	thread_yield();
  818ca6:	48 b8 0e 91 81 00 00 	movabs $0x81910e,%rax
  818cad:	00 00 00 
  818cb0:	ff d0                	callq  *%rax
	p = sys_time_msec();
  818cb2:	48 b8 73 2a 80 00 00 	movabs $0x802a73,%rax
  818cb9:	00 00 00 
  818cbc:	ff d0                	callq  *%rax
  818cbe:	89 45 fc             	mov    %eax,-0x4(%rbp)
    uint32_t p = s;

    cur_tc->tc_wait_addr = addr;
    cur_tc->tc_wakeup = 0;

    while (p < msec) {
  818cc1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  818cc4:	3b 45 e0             	cmp    -0x20(%rbp),%eax
  818cc7:	72 a5                	jb     818c6e <thread_wait+0x55>

	thread_yield();
	p = sys_time_msec();
    }

    cur_tc->tc_wait_addr = 0;
  818cc9:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818cd0:	00 00 00 
  818cd3:	48 8b 00             	mov    (%rax),%rax
  818cd6:	48 c7 80 b0 00 00 00 	movq   $0x0,0xb0(%rax)
  818cdd:	00 00 00 00 
    cur_tc->tc_wakeup = 0;
  818ce1:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818ce8:	00 00 00 
  818ceb:	48 8b 00             	mov    (%rax),%rax
  818cee:	c6 80 b8 00 00 00 00 	movb   $0x0,0xb8(%rax)
}
  818cf5:	c9                   	leaveq 
  818cf6:	c3                   	retq   

0000000000818cf7 <thread_wakeups_pending>:

int
thread_wakeups_pending(void)
{
  818cf7:	55                   	push   %rbp
  818cf8:	48 89 e5             	mov    %rsp,%rbp
  818cfb:	48 83 ec 10          	sub    $0x10,%rsp
    struct thread_context *tc = thread_queue.tq_first;
  818cff:	48 b8 80 74 b5 00 00 	movabs $0xb57480,%rax
  818d06:	00 00 00 
  818d09:	48 8b 00             	mov    (%rax),%rax
  818d0c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    int n = 0;
  818d10:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
    while (tc) {
  818d17:	eb 22                	jmp    818d3b <thread_wakeups_pending+0x44>
	if (tc->tc_wakeup)
  818d19:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818d1d:	0f b6 80 b8 00 00 00 	movzbl 0xb8(%rax),%eax
  818d24:	84 c0                	test   %al,%al
  818d26:	74 04                	je     818d2c <thread_wakeups_pending+0x35>
	    ++n;
  818d28:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
	tc = tc->tc_queue_link;
  818d2c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818d30:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  818d37:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
int
thread_wakeups_pending(void)
{
    struct thread_context *tc = thread_queue.tq_first;
    int n = 0;
    while (tc) {
  818d3b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  818d40:	75 d7                	jne    818d19 <thread_wakeups_pending+0x22>
	if (tc->tc_wakeup)
	    ++n;
	tc = tc->tc_queue_link;
    }
    return n;
  818d42:	8b 45 f4             	mov    -0xc(%rbp),%eax
}
  818d45:	c9                   	leaveq 
  818d46:	c3                   	retq   

0000000000818d47 <thread_onhalt>:

int
thread_onhalt(void (*fun)(thread_id_t)) {
  818d47:	55                   	push   %rbp
  818d48:	48 89 e5             	mov    %rsp,%rbp
  818d4b:	48 83 ec 08          	sub    $0x8,%rsp
  818d4f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
  818d53:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818d5a:	00 00 00 
  818d5d:	48 8b 00             	mov    (%rax),%rax
  818d60:	8b 80 e0 00 00 00    	mov    0xe0(%rax),%eax
  818d66:	83 f8 03             	cmp    $0x3,%eax
  818d69:	7e 07                	jle    818d72 <thread_onhalt+0x2b>
	return -E_NO_MEM;
  818d6b:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  818d70:	eb 3d                	jmp    818daf <thread_onhalt+0x68>

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
  818d72:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818d79:	00 00 00 
  818d7c:	48 8b 08             	mov    (%rax),%rcx
  818d7f:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818d86:	00 00 00 
  818d89:	48 8b 00             	mov    (%rax),%rax
  818d8c:	8b 90 e0 00 00 00    	mov    0xe0(%rax),%edx
  818d92:	8d 72 01             	lea    0x1(%rdx),%esi
  818d95:	89 b0 e0 00 00 00    	mov    %esi,0xe0(%rax)
  818d9b:	48 63 c2             	movslq %edx,%rax
  818d9e:	48 8d 50 18          	lea    0x18(%rax),%rdx
  818da2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818da6:	48 89 04 d1          	mov    %rax,(%rcx,%rdx,8)
    return 0;
  818daa:	b8 00 00 00 00       	mov    $0x0,%eax
}
  818daf:	c9                   	leaveq 
  818db0:	c3                   	retq   

0000000000818db1 <alloc_tid>:

static thread_id_t
alloc_tid(void) {
  818db1:	55                   	push   %rbp
  818db2:	48 89 e5             	mov    %rsp,%rbp
  818db5:	48 83 ec 10          	sub    $0x10,%rsp
    int tid = max_tid++;
  818db9:	48 b8 70 74 b5 00 00 	movabs $0xb57470,%rax
  818dc0:	00 00 00 
  818dc3:	8b 00                	mov    (%rax),%eax
  818dc5:	8d 48 01             	lea    0x1(%rax),%ecx
  818dc8:	48 ba 70 74 b5 00 00 	movabs $0xb57470,%rdx
  818dcf:	00 00 00 
  818dd2:	89 0a                	mov    %ecx,(%rdx)
  818dd4:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (max_tid == (uint32_t)~0)
  818dd7:	48 b8 70 74 b5 00 00 	movabs $0xb57470,%rax
  818dde:	00 00 00 
  818de1:	8b 00                	mov    (%rax),%eax
  818de3:	83 f8 ff             	cmp    $0xffffffff,%eax
  818de6:	75 2a                	jne    818e12 <alloc_tid+0x61>
	panic("alloc_tid: no more thread ids");
  818de8:	48 ba 9a 2e 82 00 00 	movabs $0x822e9a,%rdx
  818def:	00 00 00 
  818df2:	be 55 00 00 00       	mov    $0x55,%esi
  818df7:	48 bf b8 2e 82 00 00 	movabs $0x822eb8,%rdi
  818dfe:	00 00 00 
  818e01:	b8 00 00 00 00       	mov    $0x0,%eax
  818e06:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  818e0d:	00 00 00 
  818e10:	ff d1                	callq  *%rcx
    return tid;
  818e12:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  818e15:	c9                   	leaveq 
  818e16:	c3                   	retq   

0000000000818e17 <thread_set_name>:

static void
thread_set_name(struct thread_context *tc, const char *name)
{
  818e17:	55                   	push   %rbp
  818e18:	48 89 e5             	mov    %rsp,%rbp
  818e1b:	48 83 ec 10          	sub    $0x10,%rsp
  818e1f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  818e23:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    strncpy(tc->tc_name, name, name_size - 1);
  818e27:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818e2b:	48 8d 48 10          	lea    0x10(%rax),%rcx
  818e2f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  818e33:	ba 1f 00 00 00       	mov    $0x1f,%edx
  818e38:	48 89 c6             	mov    %rax,%rsi
  818e3b:	48 89 cf             	mov    %rcx,%rdi
  818e3e:	48 b8 69 1f 80 00 00 	movabs $0x801f69,%rax
  818e45:	00 00 00 
  818e48:	ff d0                	callq  *%rax
    tc->tc_name[name_size - 1] = 0;
  818e4a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818e4e:	c6 40 2f 00          	movb   $0x0,0x2f(%rax)
}
  818e52:	c9                   	leaveq 
  818e53:	c3                   	retq   

0000000000818e54 <thread_entry>:

static void
thread_entry(void) {
  818e54:	55                   	push   %rbp
  818e55:	48 89 e5             	mov    %rsp,%rbp
    cur_tc->tc_entry(cur_tc->tc_arg);
  818e58:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818e5f:	00 00 00 
  818e62:	48 8b 00             	mov    (%rax),%rax
  818e65:	48 8b 40 30          	mov    0x30(%rax),%rax
  818e69:	48 ba 78 74 b5 00 00 	movabs $0xb57478,%rdx
  818e70:	00 00 00 
  818e73:	48 8b 12             	mov    (%rdx),%rdx
  818e76:	8b 52 38             	mov    0x38(%rdx),%edx
  818e79:	89 d2                	mov    %edx,%edx
  818e7b:	48 89 d7             	mov    %rdx,%rdi
  818e7e:	ff d0                	callq  *%rax
    thread_halt();
  818e80:	48 b8 94 90 81 00 00 	movabs $0x819094,%rax
  818e87:	00 00 00 
  818e8a:	ff d0                	callq  *%rax
}
  818e8c:	5d                   	pop    %rbp
  818e8d:	c3                   	retq   

0000000000818e8e <thread_create>:

int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint64_t), uint64_t arg) {
  818e8e:	55                   	push   %rbp
  818e8f:	48 89 e5             	mov    %rsp,%rbp
  818e92:	48 83 ec 30          	sub    $0x30,%rsp
  818e96:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  818e9a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  818e9e:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  818ea2:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
    struct thread_context *tc = malloc(sizeof(struct thread_context));
  818ea6:	bf f0 00 00 00       	mov    $0xf0,%edi
  818eab:	48 b8 0f 4e 80 00 00 	movabs $0x804e0f,%rax
  818eb2:	00 00 00 
  818eb5:	ff d0                	callq  *%rax
  818eb7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (!tc)
  818ebb:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  818ec0:	75 0a                	jne    818ecc <thread_create+0x3e>
	return -E_NO_MEM;
  818ec2:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  818ec7:	e9 4d 01 00 00       	jmpq   819019 <thread_create+0x18b>

    memset(tc, 0, sizeof(struct thread_context));
  818ecc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818ed0:	ba f0 00 00 00       	mov    $0xf0,%edx
  818ed5:	be 00 00 00 00       	mov    $0x0,%esi
  818eda:	48 89 c7             	mov    %rax,%rdi
  818edd:	48 b8 70 21 80 00 00 	movabs $0x802170,%rax
  818ee4:	00 00 00 
  818ee7:	ff d0                	callq  *%rax
    
    thread_set_name(tc, name);
  818ee9:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  818eed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818ef1:	48 89 d6             	mov    %rdx,%rsi
  818ef4:	48 89 c7             	mov    %rax,%rdi
  818ef7:	48 b8 17 8e 81 00 00 	movabs $0x818e17,%rax
  818efe:	00 00 00 
  818f01:	ff d0                	callq  *%rax
    tc->tc_tid = alloc_tid();
  818f03:	48 b8 b1 8d 81 00 00 	movabs $0x818db1,%rax
  818f0a:	00 00 00 
  818f0d:	ff d0                	callq  *%rax
  818f0f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  818f13:	89 02                	mov    %eax,(%rdx)

    tc->tc_stack_bottom = malloc(stack_size);
  818f15:	bf 00 10 00 00       	mov    $0x1000,%edi
  818f1a:	48 b8 0f 4e 80 00 00 	movabs $0x804e0f,%rax
  818f21:	00 00 00 
  818f24:	ff d0                	callq  *%rax
  818f26:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  818f2a:	48 89 42 08          	mov    %rax,0x8(%rdx)
    if (!tc->tc_stack_bottom) {
  818f2e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818f32:	48 8b 40 08          	mov    0x8(%rax),%rax
  818f36:	48 85 c0             	test   %rax,%rax
  818f39:	75 1d                	jne    818f58 <thread_create+0xca>
	free(tc);
  818f3b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818f3f:	48 89 c7             	mov    %rax,%rdi
  818f42:	48 b8 8d 51 80 00 00 	movabs $0x80518d,%rax
  818f49:	00 00 00 
  818f4c:	ff d0                	callq  *%rax
	return -E_NO_MEM;
  818f4e:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  818f53:	e9 c1 00 00 00       	jmpq   819019 <thread_create+0x18b>
    }

    void *stacktop = tc->tc_stack_bottom + stack_size;
  818f58:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818f5c:	48 8b 40 08          	mov    0x8(%rax),%rax
  818f60:	48 05 00 10 00 00    	add    $0x1000,%rax
  818f66:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    // Terminate stack unwinding
    stacktop = stacktop - 8;
  818f6a:	48 83 6d f0 08       	subq   $0x8,-0x10(%rbp)
    memset(stacktop, 0, 8);
  818f6f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  818f73:	ba 08 00 00 00       	mov    $0x8,%edx
  818f78:	be 00 00 00 00       	mov    $0x0,%esi
  818f7d:	48 89 c7             	mov    %rax,%rdi
  818f80:	48 b8 70 21 80 00 00 	movabs $0x802170,%rax
  818f87:	00 00 00 
  818f8a:	ff d0                	callq  *%rax
    
    memset(&tc->tc_jb, 0, sizeof(tc->tc_jb));
  818f8c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818f90:	48 83 c0 40          	add    $0x40,%rax
  818f94:	ba 70 00 00 00       	mov    $0x70,%edx
  818f99:	be 00 00 00 00       	mov    $0x0,%esi
  818f9e:	48 89 c7             	mov    %rax,%rdi
  818fa1:	48 b8 70 21 80 00 00 	movabs $0x802170,%rax
  818fa8:	00 00 00 
  818fab:	ff d0                	callq  *%rax
    tc->tc_jb.jb_rsp = (uint64_t)stacktop;
  818fad:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  818fb1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818fb5:	48 89 50 48          	mov    %rdx,0x48(%rax)
    tc->tc_jb.jb_rip = (uint64_t)&thread_entry;
  818fb9:	48 ba 54 8e 81 00 00 	movabs $0x818e54,%rdx
  818fc0:	00 00 00 
  818fc3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818fc7:	48 89 50 40          	mov    %rdx,0x40(%rax)
    tc->tc_entry = entry;
  818fcb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818fcf:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  818fd3:	48 89 50 30          	mov    %rdx,0x30(%rax)
    tc->tc_arg = arg;
  818fd7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  818fdb:	89 c2                	mov    %eax,%edx
  818fdd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818fe1:	89 50 38             	mov    %edx,0x38(%rax)

    threadq_push(&thread_queue, tc);
  818fe4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818fe8:	48 89 c6             	mov    %rax,%rsi
  818feb:	48 bf 80 74 b5 00 00 	movabs $0xb57480,%rdi
  818ff2:	00 00 00 
  818ff5:	48 b8 cf 8a 81 00 00 	movabs $0x818acf,%rax
  818ffc:	00 00 00 
  818fff:	ff d0                	callq  *%rax

    if (tid)
  819001:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  819006:	74 0c                	je     819014 <thread_create+0x186>
	*tid = tc->tc_tid;
  819008:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81900c:	8b 10                	mov    (%rax),%edx
  81900e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819012:	89 10                	mov    %edx,(%rax)
    return 0;
  819014:	b8 00 00 00 00       	mov    $0x0,%eax
}
  819019:	c9                   	leaveq 
  81901a:	c3                   	retq   

000000000081901b <thread_clean>:

static void
thread_clean(struct thread_context *tc) {
  81901b:	55                   	push   %rbp
  81901c:	48 89 e5             	mov    %rsp,%rbp
  81901f:	48 83 ec 20          	sub    $0x20,%rsp
  819023:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    if (!tc) return;
  819027:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81902c:	75 02                	jne    819030 <thread_clean+0x15>
  81902e:	eb 62                	jmp    819092 <thread_clean+0x77>

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
  819030:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  819037:	eb 20                	jmp    819059 <thread_clean+0x3e>
	tc->tc_onhalt[i](tc->tc_tid);
  819039:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81903d:	8b 55 fc             	mov    -0x4(%rbp),%edx
  819040:	48 63 d2             	movslq %edx,%rdx
  819043:	48 83 c2 18          	add    $0x18,%rdx
  819047:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  81904b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81904f:	8b 12                	mov    (%rdx),%edx
  819051:	89 d7                	mov    %edx,%edi
  819053:	ff d0                	callq  *%rax
static void
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
  819055:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  819059:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81905d:	8b 80 e0 00 00 00    	mov    0xe0(%rax),%eax
  819063:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  819066:	7f d1                	jg     819039 <thread_clean+0x1e>
	tc->tc_onhalt[i](tc->tc_tid);
    free(tc->tc_stack_bottom);
  819068:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81906c:	48 8b 40 08          	mov    0x8(%rax),%rax
  819070:	48 89 c7             	mov    %rax,%rdi
  819073:	48 b8 8d 51 80 00 00 	movabs $0x80518d,%rax
  81907a:	00 00 00 
  81907d:	ff d0                	callq  *%rax
    free(tc);
  81907f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819083:	48 89 c7             	mov    %rax,%rdi
  819086:	48 b8 8d 51 80 00 00 	movabs $0x80518d,%rax
  81908d:	00 00 00 
  819090:	ff d0                	callq  *%rax
}
  819092:	c9                   	leaveq 
  819093:	c3                   	retq   

0000000000819094 <thread_halt>:

void
thread_halt() {
  819094:	55                   	push   %rbp
  819095:	48 89 e5             	mov    %rsp,%rbp
    // right now the kill_queue will never be more than one
    // clean up a thread if one is on the queue
    thread_clean(threadq_pop(&kill_queue));
  819098:	48 bf 90 74 b5 00 00 	movabs $0xb57490,%rdi
  81909f:	00 00 00 
  8190a2:	48 b8 34 8b 81 00 00 	movabs $0x818b34,%rax
  8190a9:	00 00 00 
  8190ac:	ff d0                	callq  *%rax
  8190ae:	48 89 c7             	mov    %rax,%rdi
  8190b1:	48 b8 1b 90 81 00 00 	movabs $0x81901b,%rax
  8190b8:	00 00 00 
  8190bb:	ff d0                	callq  *%rax

    threadq_push(&kill_queue, cur_tc);
  8190bd:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  8190c4:	00 00 00 
  8190c7:	48 8b 00             	mov    (%rax),%rax
  8190ca:	48 89 c6             	mov    %rax,%rsi
  8190cd:	48 bf 90 74 b5 00 00 	movabs $0xb57490,%rdi
  8190d4:	00 00 00 
  8190d7:	48 b8 cf 8a 81 00 00 	movabs $0x818acf,%rax
  8190de:	00 00 00 
  8190e1:	ff d0                	callq  *%rax
    cur_tc = NULL;
  8190e3:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  8190ea:	00 00 00 
  8190ed:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    thread_yield();
  8190f4:	48 b8 0e 91 81 00 00 	movabs $0x81910e,%rax
  8190fb:	00 00 00 
  8190fe:	ff d0                	callq  *%rax
    // WHAT IF THERE ARE NO MORE THREADS? HOW DO WE STOP?
    // when yield has no thread to run, it will return here!
    exit();
  819100:	48 b8 c6 10 80 00 00 	movabs $0x8010c6,%rax
  819107:	00 00 00 
  81910a:	ff d0                	callq  *%rax
}
  81910c:	5d                   	pop    %rbp
  81910d:	c3                   	retq   

000000000081910e <thread_yield>:

void
thread_yield(void) {
  81910e:	55                   	push   %rbp
  81910f:	48 89 e5             	mov    %rsp,%rbp
  819112:	48 83 ec 10          	sub    $0x10,%rsp
    struct thread_context *next_tc = threadq_pop(&thread_queue);
  819116:	48 bf 80 74 b5 00 00 	movabs $0xb57480,%rdi
  81911d:	00 00 00 
  819120:	48 b8 34 8b 81 00 00 	movabs $0x818b34,%rax
  819127:	00 00 00 
  81912a:	ff d0                	callq  *%rax
  81912c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

    if (!next_tc)
  819130:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  819135:	75 05                	jne    81913c <thread_yield+0x2e>
	return;
  819137:	e9 94 00 00 00       	jmpq   8191d0 <thread_yield+0xc2>

    if (cur_tc) {
  81913c:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  819143:	00 00 00 
  819146:	48 8b 00             	mov    (%rax),%rax
  819149:	48 85 c0             	test   %rax,%rax
  81914c:	74 4c                	je     81919a <thread_yield+0x8c>
	if (jos_setjmp(&cur_tc->tc_jb) != 0)
  81914e:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  819155:	00 00 00 
  819158:	48 8b 00             	mov    (%rax),%rax
  81915b:	48 83 c0 40          	add    $0x40,%rax
  81915f:	48 89 c7             	mov    %rax,%rdi
  819162:	48 b8 30 94 81 00 00 	movabs $0x819430,%rax
  819169:	00 00 00 
  81916c:	ff d0                	callq  *%rax
  81916e:	85 c0                	test   %eax,%eax
  819170:	74 02                	je     819174 <thread_yield+0x66>
	    return;
  819172:	eb 5c                	jmp    8191d0 <thread_yield+0xc2>
	threadq_push(&thread_queue, cur_tc);
  819174:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  81917b:	00 00 00 
  81917e:	48 8b 00             	mov    (%rax),%rax
  819181:	48 89 c6             	mov    %rax,%rsi
  819184:	48 bf 80 74 b5 00 00 	movabs $0xb57480,%rdi
  81918b:	00 00 00 
  81918e:	48 b8 cf 8a 81 00 00 	movabs $0x818acf,%rax
  819195:	00 00 00 
  819198:	ff d0                	callq  *%rax
    }

    cur_tc = next_tc;
  81919a:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  8191a1:	00 00 00 
  8191a4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8191a8:	48 89 10             	mov    %rdx,(%rax)
    jos_longjmp(&cur_tc->tc_jb, 1);
  8191ab:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  8191b2:	00 00 00 
  8191b5:	48 8b 00             	mov    (%rax),%rax
  8191b8:	48 83 c0 40          	add    $0x40,%rax
  8191bc:	be 01 00 00 00       	mov    $0x1,%esi
  8191c1:	48 89 c7             	mov    %rax,%rdi
  8191c4:	48 b8 80 94 81 00 00 	movabs $0x819480,%rax
  8191cb:	00 00 00 
  8191ce:	ff d0                	callq  *%rax
}
  8191d0:	c9                   	leaveq 
  8191d1:	c3                   	retq   

00000000008191d2 <print_jb>:

static void
print_jb(struct thread_context *tc) {
  8191d2:	55                   	push   %rbp
  8191d3:	48 89 e5             	mov    %rsp,%rbp
  8191d6:	48 83 ec 10          	sub    $0x10,%rsp
  8191da:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    cprintf("jump buffer for thread %s:\n", tc->tc_name);
  8191de:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8191e2:	48 83 c0 10          	add    $0x10,%rax
  8191e6:	48 89 c6             	mov    %rax,%rsi
  8191e9:	48 bf d3 2e 82 00 00 	movabs $0x822ed3,%rdi
  8191f0:	00 00 00 
  8191f3:	b8 00 00 00 00       	mov    $0x0,%eax
  8191f8:	48 ba 22 13 80 00 00 	movabs $0x801322,%rdx
  8191ff:	00 00 00 
  819202:	ff d2                	callq  *%rdx
    cprintf("\trip: %x\n", tc->tc_jb.jb_rip);
  819204:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819208:	48 8b 40 40          	mov    0x40(%rax),%rax
  81920c:	48 89 c6             	mov    %rax,%rsi
  81920f:	48 bf ef 2e 82 00 00 	movabs $0x822eef,%rdi
  819216:	00 00 00 
  819219:	b8 00 00 00 00       	mov    $0x0,%eax
  81921e:	48 ba 22 13 80 00 00 	movabs $0x801322,%rdx
  819225:	00 00 00 
  819228:	ff d2                	callq  *%rdx
    cprintf("\trsp: %x\n", tc->tc_jb.jb_rsp);
  81922a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81922e:	48 8b 40 48          	mov    0x48(%rax),%rax
  819232:	48 89 c6             	mov    %rax,%rsi
  819235:	48 bf f9 2e 82 00 00 	movabs $0x822ef9,%rdi
  81923c:	00 00 00 
  81923f:	b8 00 00 00 00       	mov    $0x0,%eax
  819244:	48 ba 22 13 80 00 00 	movabs $0x801322,%rdx
  81924b:	00 00 00 
  81924e:	ff d2                	callq  *%rdx
    cprintf("\trbp: %x\n", tc->tc_jb.jb_rbp);
  819250:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819254:	48 8b 40 50          	mov    0x50(%rax),%rax
  819258:	48 89 c6             	mov    %rax,%rsi
  81925b:	48 bf 03 2f 82 00 00 	movabs $0x822f03,%rdi
  819262:	00 00 00 
  819265:	b8 00 00 00 00       	mov    $0x0,%eax
  81926a:	48 ba 22 13 80 00 00 	movabs $0x801322,%rdx
  819271:	00 00 00 
  819274:	ff d2                	callq  *%rdx
    cprintf("\trbx: %x\n", tc->tc_jb.jb_rbx);
  819276:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81927a:	48 8b 40 58          	mov    0x58(%rax),%rax
  81927e:	48 89 c6             	mov    %rax,%rsi
  819281:	48 bf 0d 2f 82 00 00 	movabs $0x822f0d,%rdi
  819288:	00 00 00 
  81928b:	b8 00 00 00 00       	mov    $0x0,%eax
  819290:	48 ba 22 13 80 00 00 	movabs $0x801322,%rdx
  819297:	00 00 00 
  81929a:	ff d2                	callq  *%rdx
    cprintf("\trsi: %x\n", tc->tc_jb.jb_rsi);
  81929c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8192a0:	48 8b 40 60          	mov    0x60(%rax),%rax
  8192a4:	48 89 c6             	mov    %rax,%rsi
  8192a7:	48 bf 17 2f 82 00 00 	movabs $0x822f17,%rdi
  8192ae:	00 00 00 
  8192b1:	b8 00 00 00 00       	mov    $0x0,%eax
  8192b6:	48 ba 22 13 80 00 00 	movabs $0x801322,%rdx
  8192bd:	00 00 00 
  8192c0:	ff d2                	callq  *%rdx
    cprintf("\trdi: %x\n", tc->tc_jb.jb_rdi);
  8192c2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8192c6:	48 8b 40 68          	mov    0x68(%rax),%rax
  8192ca:	48 89 c6             	mov    %rax,%rsi
  8192cd:	48 bf 21 2f 82 00 00 	movabs $0x822f21,%rdi
  8192d4:	00 00 00 
  8192d7:	b8 00 00 00 00       	mov    $0x0,%eax
  8192dc:	48 ba 22 13 80 00 00 	movabs $0x801322,%rdx
  8192e3:	00 00 00 
  8192e6:	ff d2                	callq  *%rdx
    cprintf("\tr15: %x\n", tc->tc_jb.jb_r15);
  8192e8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8192ec:	48 8b 40 70          	mov    0x70(%rax),%rax
  8192f0:	48 89 c6             	mov    %rax,%rsi
  8192f3:	48 bf 2b 2f 82 00 00 	movabs $0x822f2b,%rdi
  8192fa:	00 00 00 
  8192fd:	b8 00 00 00 00       	mov    $0x0,%eax
  819302:	48 ba 22 13 80 00 00 	movabs $0x801322,%rdx
  819309:	00 00 00 
  81930c:	ff d2                	callq  *%rdx
    cprintf("\tr14: %x\n", tc->tc_jb.jb_r14);
  81930e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819312:	48 8b 40 78          	mov    0x78(%rax),%rax
  819316:	48 89 c6             	mov    %rax,%rsi
  819319:	48 bf 35 2f 82 00 00 	movabs $0x822f35,%rdi
  819320:	00 00 00 
  819323:	b8 00 00 00 00       	mov    $0x0,%eax
  819328:	48 ba 22 13 80 00 00 	movabs $0x801322,%rdx
  81932f:	00 00 00 
  819332:	ff d2                	callq  *%rdx
    cprintf("\tr13: %x\n", tc->tc_jb.jb_r13);
  819334:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819338:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81933f:	48 89 c6             	mov    %rax,%rsi
  819342:	48 bf 3f 2f 82 00 00 	movabs $0x822f3f,%rdi
  819349:	00 00 00 
  81934c:	b8 00 00 00 00       	mov    $0x0,%eax
  819351:	48 ba 22 13 80 00 00 	movabs $0x801322,%rdx
  819358:	00 00 00 
  81935b:	ff d2                	callq  *%rdx
    cprintf("\tr12: %x\n", tc->tc_jb.jb_r12);
  81935d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819361:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  819368:	48 89 c6             	mov    %rax,%rsi
  81936b:	48 bf 49 2f 82 00 00 	movabs $0x822f49,%rdi
  819372:	00 00 00 
  819375:	b8 00 00 00 00       	mov    $0x0,%eax
  81937a:	48 ba 22 13 80 00 00 	movabs $0x801322,%rdx
  819381:	00 00 00 
  819384:	ff d2                	callq  *%rdx
    cprintf("\tr11: %x\n", tc->tc_jb.jb_r11);
  819386:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81938a:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  819391:	48 89 c6             	mov    %rax,%rsi
  819394:	48 bf 53 2f 82 00 00 	movabs $0x822f53,%rdi
  81939b:	00 00 00 
  81939e:	b8 00 00 00 00       	mov    $0x0,%eax
  8193a3:	48 ba 22 13 80 00 00 	movabs $0x801322,%rdx
  8193aa:	00 00 00 
  8193ad:	ff d2                	callq  *%rdx
    cprintf("\tr10: %x\n", tc->tc_jb.jb_r10);
  8193af:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8193b3:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  8193ba:	48 89 c6             	mov    %rax,%rsi
  8193bd:	48 bf 5d 2f 82 00 00 	movabs $0x822f5d,%rdi
  8193c4:	00 00 00 
  8193c7:	b8 00 00 00 00       	mov    $0x0,%eax
  8193cc:	48 ba 22 13 80 00 00 	movabs $0x801322,%rdx
  8193d3:	00 00 00 
  8193d6:	ff d2                	callq  *%rdx
    cprintf("\tr9: %x\n", tc->tc_jb.jb_r9);
  8193d8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8193dc:	48 8b 80 a0 00 00 00 	mov    0xa0(%rax),%rax
  8193e3:	48 89 c6             	mov    %rax,%rsi
  8193e6:	48 bf 67 2f 82 00 00 	movabs $0x822f67,%rdi
  8193ed:	00 00 00 
  8193f0:	b8 00 00 00 00       	mov    $0x0,%eax
  8193f5:	48 ba 22 13 80 00 00 	movabs $0x801322,%rdx
  8193fc:	00 00 00 
  8193ff:	ff d2                	callq  *%rdx
    cprintf("\tr8: %x\n", tc->tc_jb.jb_r8);
  819401:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819405:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81940c:	48 89 c6             	mov    %rax,%rsi
  81940f:	48 bf 70 2f 82 00 00 	movabs $0x822f70,%rdi
  819416:	00 00 00 
  819419:	b8 00 00 00 00       	mov    $0x0,%eax
  81941e:	48 ba 22 13 80 00 00 	movabs $0x801322,%rdx
  819425:	00 00 00 
  819428:	ff d2                	callq  *%rdx
}
  81942a:	c9                   	leaveq 
  81942b:	c3                   	retq   
  81942c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000819430 <jos_setjmp>:


ENTRY(jos_setjmp)
	//movq	4(%esp), %ecx	// jos_jmp_buf

	movq	%rdi, %rcx	// jos_jmp_buf
  819430:	48 89 f9             	mov    %rdi,%rcx
	movq	0(%rsp), %rdx	// %rip as pushed by call
  819433:	48 8b 14 24          	mov    (%rsp),%rdx
	movq	%rdx,  0(%rcx)
  819437:	48 89 11             	mov    %rdx,(%rcx)

	leaq	8(%rsp), %rdx	// where %esp will point when we return
  81943a:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx
	movq	%rdx,  8(%rcx)
  81943f:	48 89 51 08          	mov    %rdx,0x8(%rcx)

	movq	%rbp,  16(%rcx)
  819443:	48 89 69 10          	mov    %rbp,0x10(%rcx)
	movq	%rbx, 24(%rcx)
  819447:	48 89 59 18          	mov    %rbx,0x18(%rcx)
	movq	%rsi, 32(%rcx)
  81944b:	48 89 71 20          	mov    %rsi,0x20(%rcx)
	movq	%rdi, 40(%rcx)
  81944f:	48 89 79 28          	mov    %rdi,0x28(%rcx)
	movq	%r15, 48(%rcx)
  819453:	4c 89 79 30          	mov    %r15,0x30(%rcx)
	movq	%r14, 56(%rcx)
  819457:	4c 89 71 38          	mov    %r14,0x38(%rcx)
	movq	%r13, 64(%rcx)
  81945b:	4c 89 69 40          	mov    %r13,0x40(%rcx)
	movq	%r12, 72(%rcx)
  81945f:	4c 89 61 48          	mov    %r12,0x48(%rcx)
	movq	%r11, 80(%rcx)
  819463:	4c 89 59 50          	mov    %r11,0x50(%rcx)
	movq	%r10, 88(%rcx)
  819467:	4c 89 51 58          	mov    %r10,0x58(%rcx)
	movq	%r9, 96(%rcx)
  81946b:	4c 89 49 60          	mov    %r9,0x60(%rcx)
	movq	%r8, 104(%rcx)
  81946f:	4c 89 41 68          	mov    %r8,0x68(%rcx)

	movq	$0, %rax
  819473:	48 c7 c0 00 00 00 00 	mov    $0x0,%rax
	ret
  81947a:	c3                   	retq   
  81947b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000819480 <jos_longjmp>:

ENTRY(jos_longjmp)
	// %eax is the jos_jmp_buf*
	// %edx is the return value
	movq     %rdi, %rax
  819480:	48 89 f8             	mov    %rdi,%rax
	movq	 %rsi, %rdx
  819483:	48 89 f2             	mov    %rsi,%rdx
	movq	 0(%rax), %rcx	// %rip
  819486:	48 8b 08             	mov    (%rax),%rcx
	movq	 8(%rax), %rsp
  819489:	48 8b 60 08          	mov    0x8(%rax),%rsp
	movq	 16(%rax), %rbp
  81948d:	48 8b 68 10          	mov    0x10(%rax),%rbp
	movq	24(%rax), %rbx
  819491:	48 8b 58 18          	mov    0x18(%rax),%rbx
	movq	32(%rax), %rsi
  819495:	48 8b 70 20          	mov    0x20(%rax),%rsi
	movq	40(%rax), %rdi
  819499:	48 8b 78 28          	mov    0x28(%rax),%rdi
	movq	48(%rax), %r15
  81949d:	4c 8b 78 30          	mov    0x30(%rax),%r15
	movq	56(%rax), %r14
  8194a1:	4c 8b 70 38          	mov    0x38(%rax),%r14
	movq	64(%rax), %r13
  8194a5:	4c 8b 68 40          	mov    0x40(%rax),%r13
	movq	72(%rax), %r12
  8194a9:	4c 8b 60 48          	mov    0x48(%rax),%r12
	movq	80(%rax), %r11
  8194ad:	4c 8b 58 50          	mov    0x50(%rax),%r11
	movq	88(%rax), %r10
  8194b1:	4c 8b 50 58          	mov    0x58(%rax),%r10
	movq	96(%rax), %r9
  8194b5:	4c 8b 48 60          	mov    0x60(%rax),%r9
	movq	104(%rax), %r8
  8194b9:	4c 8b 40 68          	mov    0x68(%rax),%r8

	movq	%rdx, %rax
  8194bd:	48 89 d0             	mov    %rdx,%rax
	jmp	*%rcx
  8194c0:	ff e1                	jmpq   *%rcx

00000000008194c2 <perror>:
  [ENSRQUERYDOMAINTOOLONG] = "ENSRQUERYDOMAINTOOLONG",  /* Domain name is too long */
  [ENSRCNAMELOOP] = "ENSRCNAMELOOP" /* Domain name is too long */
};

void
perror(const char *s) {
  8194c2:	55                   	push   %rbp
  8194c3:	48 89 e5             	mov    %rsp,%rbp
  8194c6:	48 83 ec 20          	sub    $0x20,%rsp
  8194ca:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int err = errno;
  8194ce:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8194d5:	00 00 00 
  8194d8:	8b 00                	mov    (%rax),%eax
  8194da:	89 45 fc             	mov    %eax,-0x4(%rbp)
	cprintf("%s: %s\n", s, e2s(err));
  8194dd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8194e0:	89 c7                	mov    %eax,%edi
  8194e2:	48 b8 15 95 81 00 00 	movabs $0x819515,%rax
  8194e9:	00 00 00 
  8194ec:	ff d0                	callq  *%rax
  8194ee:	48 89 c2             	mov    %rax,%rdx
  8194f1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8194f5:	48 89 c6             	mov    %rax,%rsi
  8194f8:	48 bf 5d 34 82 00 00 	movabs $0x82345d,%rdi
  8194ff:	00 00 00 
  819502:	b8 00 00 00 00       	mov    $0x0,%eax
  819507:	48 b9 22 13 80 00 00 	movabs $0x801322,%rcx
  81950e:	00 00 00 
  819511:	ff d1                	callq  *%rcx
}
  819513:	c9                   	leaveq 
  819514:	c3                   	retq   

0000000000819515 <e2s>:

const char *
e2s(int err) {
  819515:	55                   	push   %rbp
  819516:	48 89 e5             	mov    %rsp,%rbp
  819519:	48 83 ec 04          	sub    $0x4,%rsp
  81951d:	89 7d fc             	mov    %edi,-0x4(%rbp)
	return sys_errlist[err];
  819520:	48 b8 00 82 82 00 00 	movabs $0x828200,%rax
  819527:	00 00 00 
  81952a:	8b 55 fc             	mov    -0x4(%rbp),%edx
  81952d:	48 63 d2             	movslq %edx,%rdx
  819530:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
}
  819534:	c9                   	leaveq 
  819535:	c3                   	retq   

0000000000819536 <low_level_init>:
    envid_t envid;
};

static void
low_level_init(struct netif *netif)
{
  819536:	55                   	push   %rbp
  819537:	48 89 e5             	mov    %rsp,%rbp
  81953a:	48 83 ec 08          	sub    $0x8,%rsp
  81953e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    int r;

    netif->hwaddr_len = 6;
  819542:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819546:	c6 40 40 06          	movb   $0x6,0x40(%rax)
    netif->mtu = 1500;
  81954a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81954e:	66 c7 40 48 dc 05    	movw   $0x5dc,0x48(%rax)
    netif->flags = NETIF_FLAG_BROADCAST;
  819554:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819558:	c6 40 4a 02          	movb   $0x2,0x4a(%rax)

    // MAC address is hardcoded to eliminate a system call
    netif->hwaddr[0] = 0x52;
  81955c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819560:	c6 40 41 52          	movb   $0x52,0x41(%rax)
    netif->hwaddr[1] = 0x54;
  819564:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819568:	c6 40 42 54          	movb   $0x54,0x42(%rax)
    netif->hwaddr[2] = 0x00;
  81956c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819570:	c6 40 43 00          	movb   $0x0,0x43(%rax)
    netif->hwaddr[3] = 0x12;
  819574:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819578:	c6 40 44 12          	movb   $0x12,0x44(%rax)
    netif->hwaddr[4] = 0x34;
  81957c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819580:	c6 40 45 34          	movb   $0x34,0x45(%rax)
    netif->hwaddr[5] = 0x56;
  819584:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819588:	c6 40 46 56          	movb   $0x56,0x46(%rax)
}
  81958c:	c9                   	leaveq 
  81958d:	c3                   	retq   

000000000081958e <low_level_output>:
 * might be chained.
 *
 */
static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
  81958e:	55                   	push   %rbp
  81958f:	48 89 e5             	mov    %rsp,%rbp
  819592:	48 83 ec 40          	sub    $0x40,%rsp
  819596:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  81959a:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
    int r = sys_page_alloc(0, (void *)PKTMAP, PTE_U|PTE_W|PTE_P);
  81959e:	ba 07 00 00 00       	mov    $0x7,%edx
  8195a3:	be 00 00 00 10       	mov    $0x10000000,%esi
  8195a8:	bf 00 00 00 00       	mov    $0x0,%edi
  8195ad:	48 b8 06 28 80 00 00 	movabs $0x802806,%rax
  8195b4:	00 00 00 
  8195b7:	ff d0                	callq  *%rax
  8195b9:	89 45 ec             	mov    %eax,-0x14(%rbp)
    if (r < 0)
  8195bc:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  8195c0:	79 2a                	jns    8195ec <low_level_output+0x5e>
	panic("jif: could not allocate page of memory");
  8195c2:	48 ba 68 34 82 00 00 	movabs $0x823468,%rdx
  8195c9:	00 00 00 
  8195cc:	be 56 00 00 00       	mov    $0x56,%esi
  8195d1:	48 bf 8f 34 82 00 00 	movabs $0x82348f,%rdi
  8195d8:	00 00 00 
  8195db:	b8 00 00 00 00       	mov    $0x0,%eax
  8195e0:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  8195e7:	00 00 00 
  8195ea:	ff d1                	callq  *%rcx
    struct jif_pkt *pkt = (struct jif_pkt *)PKTMAP;
  8195ec:	48 c7 45 e0 00 00 00 	movq   $0x10000000,-0x20(%rbp)
  8195f3:	10 

    struct jif *jif;
    jif = netif->state;
  8195f4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8195f8:	48 8b 40 30          	mov    0x30(%rax),%rax
  8195fc:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

    char *txbuf = pkt->jp_data;
  819600:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  819604:	48 83 c0 04          	add    $0x4,%rax
  819608:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    int txsize = 0;
  81960c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  819613:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  819617:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  81961b:	e9 a0 00 00 00       	jmpq   8196c0 <low_level_output+0x132>
	/* Send the data from the pbuf to the interface, one pbuf at a
	   time. The size of the data in each pbuf is kept in the ->len
	   variable. */

	if (txsize + q->len > 2000)
  819620:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819624:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  819628:	0f b7 d0             	movzwl %ax,%edx
  81962b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81962e:	01 d0                	add    %edx,%eax
  819630:	3d d0 07 00 00       	cmp    $0x7d0,%eax
  819635:	7e 3e                	jle    819675 <low_level_output+0xe7>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
  819637:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81963b:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81963f:	0f b7 c0             	movzwl %ax,%eax
  819642:	8b 55 fc             	mov    -0x4(%rbp),%edx
  819645:	41 89 d0             	mov    %edx,%r8d
  819648:	89 c1                	mov    %eax,%ecx
  81964a:	48 ba a8 34 82 00 00 	movabs $0x8234a8,%rdx
  819651:	00 00 00 
  819654:	be 65 00 00 00       	mov    $0x65,%esi
  819659:	48 bf 8f 34 82 00 00 	movabs $0x82348f,%rdi
  819660:	00 00 00 
  819663:	b8 00 00 00 00       	mov    $0x0,%eax
  819668:	49 b9 e9 10 80 00 00 	movabs $0x8010e9,%r9
  81966f:	00 00 00 
  819672:	41 ff d1             	callq  *%r9
	memcpy(&txbuf[txsize], q->payload, q->len);
  819675:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819679:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81967d:	0f b7 d0             	movzwl %ax,%edx
  819680:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819684:	48 8b 40 08          	mov    0x8(%rax),%rax
  819688:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  81968b:	48 63 f1             	movslq %ecx,%rsi
  81968e:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  819692:	48 01 f1             	add    %rsi,%rcx
  819695:	48 89 c6             	mov    %rax,%rsi
  819698:	48 89 cf             	mov    %rcx,%rdi
  81969b:	48 b8 12 23 80 00 00 	movabs $0x802312,%rax
  8196a2:	00 00 00 
  8196a5:	ff d0                	callq  *%rax
	txsize += q->len;
  8196a7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8196ab:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8196af:	0f b7 c0             	movzwl %ax,%eax
  8196b2:	01 45 fc             	add    %eax,-0x4(%rbp)
    jif = netif->state;

    char *txbuf = pkt->jp_data;
    int txsize = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  8196b5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8196b9:	48 8b 00             	mov    (%rax),%rax
  8196bc:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8196c0:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8196c5:	0f 85 55 ff ff ff    	jne    819620 <low_level_output+0x92>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
	memcpy(&txbuf[txsize], q->payload, q->len);
	txsize += q->len;
    }

    pkt->jp_len = txsize;
  8196cb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8196cf:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8196d2:	89 10                	mov    %edx,(%rax)

    ipc_send(jif->envid, NSREQ_OUTPUT, (void *)pkt, PTE_P|PTE_W|PTE_U);
  8196d4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8196d8:	8b 40 08             	mov    0x8(%rax),%eax
  8196db:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8196df:	b9 07 00 00 00       	mov    $0x7,%ecx
  8196e4:	be 0b 00 00 00       	mov    $0xb,%esi
  8196e9:	89 c7                	mov    %eax,%edi
  8196eb:	48 b8 bc 32 80 00 00 	movabs $0x8032bc,%rax
  8196f2:	00 00 00 
  8196f5:	ff d0                	callq  *%rax
    sys_page_unmap(0, (void *)pkt);
  8196f7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8196fb:	48 89 c6             	mov    %rax,%rsi
  8196fe:	bf 00 00 00 00       	mov    $0x0,%edi
  819703:	48 b8 b1 28 80 00 00 	movabs $0x8028b1,%rax
  81970a:	00 00 00 
  81970d:	ff d0                	callq  *%rax

    return ERR_OK;
  81970f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  819714:	c9                   	leaveq 
  819715:	c3                   	retq   

0000000000819716 <low_level_input>:
 * packet from the interface into the pbuf.
 *
 */
static struct pbuf *
low_level_input(void *va)
{
  819716:	55                   	push   %rbp
  819717:	48 89 e5             	mov    %rsp,%rbp
  81971a:	48 83 ec 50          	sub    $0x50,%rsp
  81971e:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
    struct jif_pkt *pkt = (struct jif_pkt *)va;
  819722:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819726:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    s16_t len = pkt->jp_len;
  81972a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81972e:	8b 00                	mov    (%rax),%eax
  819730:	66 89 45 de          	mov    %ax,-0x22(%rbp)

    struct pbuf *p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
  819734:	0f b7 45 de          	movzwl -0x22(%rbp),%eax
  819738:	0f b7 c0             	movzwl %ax,%eax
  81973b:	ba 03 00 00 00       	mov    $0x3,%edx
  819740:	89 c6                	mov    %eax,%esi
  819742:	bf 03 00 00 00       	mov    $0x3,%edi
  819747:	48 b8 61 d4 80 00 00 	movabs $0x80d461,%rax
  81974e:	00 00 00 
  819751:	ff d0                	callq  *%rax
  819753:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    if (p == 0)
  819757:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  81975c:	75 0a                	jne    819768 <low_level_input+0x52>
	return 0;
  81975e:	b8 00 00 00 00       	mov    $0x0,%eax
  819763:	e9 8a 00 00 00       	jmpq   8197f2 <low_level_input+0xdc>

    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
  819768:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81976c:	48 83 c0 04          	add    $0x4,%rax
  819770:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    int copied = 0;
  819774:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  81977b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81977f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  819783:	eb 62                	jmp    8197e7 <low_level_input+0xd1>
	/* Read enough bytes to fill this pbuf in the chain. The
	 * available data in the pbuf is given by the q->len
	 * variable. */
	int bytes = q->len;
  819785:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819789:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81978d:	0f b7 c0             	movzwl %ax,%eax
  819790:	89 45 ec             	mov    %eax,-0x14(%rbp)
	if (bytes > (len - copied))
  819793:	0f bf 45 de          	movswl -0x22(%rbp),%eax
  819797:	2b 45 fc             	sub    -0x4(%rbp),%eax
  81979a:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  81979d:	7d 0a                	jge    8197a9 <low_level_input+0x93>
	    bytes = len - copied;
  81979f:	0f bf 45 de          	movswl -0x22(%rbp),%eax
  8197a3:	2b 45 fc             	sub    -0x4(%rbp),%eax
  8197a6:	89 45 ec             	mov    %eax,-0x14(%rbp)
	memcpy(q->payload, rxbuf + copied, bytes);
  8197a9:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8197ac:	48 63 d0             	movslq %eax,%rdx
  8197af:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8197b2:	48 63 c8             	movslq %eax,%rcx
  8197b5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8197b9:	48 01 c1             	add    %rax,%rcx
  8197bc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8197c0:	48 8b 40 08          	mov    0x8(%rax),%rax
  8197c4:	48 89 ce             	mov    %rcx,%rsi
  8197c7:	48 89 c7             	mov    %rax,%rdi
  8197ca:	48 b8 12 23 80 00 00 	movabs $0x802312,%rax
  8197d1:	00 00 00 
  8197d4:	ff d0                	callq  *%rax
	copied += bytes;
  8197d6:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8197d9:	01 45 fc             	add    %eax,-0x4(%rbp)
    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
    int copied = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  8197dc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8197e0:	48 8b 00             	mov    (%rax),%rax
  8197e3:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8197e7:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8197ec:	75 97                	jne    819785 <low_level_input+0x6f>
	    bytes = len - copied;
	memcpy(q->payload, rxbuf + copied, bytes);
	copied += bytes;
    }

    return p;
  8197ee:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
}
  8197f2:	c9                   	leaveq 
  8197f3:	c3                   	retq   

00000000008197f4 <jif_output>:
 */

static err_t
jif_output(struct netif *netif, struct pbuf *p,
      struct ip_addr *ipaddr)
{
  8197f4:	55                   	push   %rbp
  8197f5:	48 89 e5             	mov    %rsp,%rbp
  8197f8:	48 83 ec 20          	sub    $0x20,%rsp
  8197fc:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  819800:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  819804:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
    /* resolve hardware address, then send (or queue) packet */
    return etharp_output(netif, p, ipaddr);
  819808:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81980c:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  819810:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819814:	48 89 ce             	mov    %rcx,%rsi
  819817:	48 89 c7             	mov    %rax,%rdi
  81981a:	48 b8 55 6a 81 00 00 	movabs $0x816a55,%rax
  819821:	00 00 00 
  819824:	ff d0                	callq  *%rax
}
  819826:	c9                   	leaveq 
  819827:	c3                   	retq   

0000000000819828 <jif_input>:
 *
 */

void
jif_input(struct netif *netif, void *va)
{
  819828:	55                   	push   %rbp
  819829:	48 89 e5             	mov    %rsp,%rbp
  81982c:	48 83 ec 30          	sub    $0x30,%rsp
  819830:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  819834:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
    struct jif *jif;
    struct eth_hdr *ethhdr;
    struct pbuf *p;

    jif = netif->state;
  819838:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81983c:	48 8b 40 30          	mov    0x30(%rax),%rax
  819840:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  
    /* move received packet into a new pbuf */
    p = low_level_input(va);
  819844:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  819848:	48 89 c7             	mov    %rax,%rdi
  81984b:	48 b8 16 97 81 00 00 	movabs $0x819716,%rax
  819852:	00 00 00 
  819855:	ff d0                	callq  *%rax
  819857:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

    /* no packet could be read, silently ignore this */
    if (p == NULL) return;
  81985b:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  819860:	75 05                	jne    819867 <jif_input+0x3f>
  819862:	e9 ba 00 00 00       	jmpq   819921 <jif_input+0xf9>
    /* points to packet payload, which starts with an Ethernet header */
    ethhdr = p->payload;
  819867:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81986b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81986f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

    switch (htons(ethhdr->type)) {
  819873:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819877:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81987b:	0f b7 c0             	movzwl %ax,%eax
  81987e:	89 c7                	mov    %eax,%edi
  819880:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  819887:	00 00 00 
  81988a:	ff d0                	callq  *%rax
  81988c:	0f b7 c0             	movzwl %ax,%eax
  81988f:	3d 00 08 00 00       	cmp    $0x800,%eax
  819894:	74 09                	je     81989f <jif_input+0x77>
  819896:	3d 06 08 00 00       	cmp    $0x806,%eax
  81989b:	74 4e                	je     8198eb <jif_input+0xc3>
  81989d:	eb 6f                	jmp    81990e <jif_input+0xe6>
    case ETHTYPE_IP:
	/* update ARP table */
	etharp_ip_input(netif, p);
  81989f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8198a3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8198a7:	48 89 d6             	mov    %rdx,%rsi
  8198aa:	48 89 c7             	mov    %rax,%rdi
  8198ad:	48 b8 79 66 81 00 00 	movabs $0x816679,%rax
  8198b4:	00 00 00 
  8198b7:	ff d0                	callq  *%rax
	/* skip Ethernet header */
	pbuf_header(p, -(int)sizeof(struct eth_hdr));
  8198b9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8198bd:	be f2 ff ff ff       	mov    $0xfffffff2,%esi
  8198c2:	48 89 c7             	mov    %rax,%rdi
  8198c5:	48 b8 7f db 80 00 00 	movabs $0x80db7f,%rax
  8198cc:	00 00 00 
  8198cf:	ff d0                	callq  *%rax
	/* pass to network layer */
	netif->input(p, netif);
  8198d1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8198d5:	48 8b 40 18          	mov    0x18(%rax),%rax
  8198d9:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8198dd:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8198e1:	48 89 ce             	mov    %rcx,%rsi
  8198e4:	48 89 d7             	mov    %rdx,%rdi
  8198e7:	ff d0                	callq  *%rax
	break;
  8198e9:	eb 36                	jmp    819921 <jif_input+0xf9>
      
    case ETHTYPE_ARP:
	/* pass p to ARP module  */
	etharp_arp_input(netif, jif->ethaddr, p);
  8198eb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8198ef:	48 8b 08             	mov    (%rax),%rcx
  8198f2:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8198f6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8198fa:	48 89 ce             	mov    %rcx,%rsi
  8198fd:	48 89 c7             	mov    %rax,%rdi
  819900:	48 b8 0f 67 81 00 00 	movabs $0x81670f,%rax
  819907:	00 00 00 
  81990a:	ff d0                	callq  *%rax
	break;
  81990c:	eb 13                	jmp    819921 <jif_input+0xf9>

    default:
	pbuf_free(p);
  81990e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819912:	48 89 c7             	mov    %rax,%rdi
  819915:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  81991c:	00 00 00 
  81991f:	ff d0                	callq  *%rax
    }
}
  819921:	c9                   	leaveq 
  819922:	c3                   	retq   

0000000000819923 <jif_init>:
 *
 */

err_t
jif_init(struct netif *netif)
{
  819923:	55                   	push   %rbp
  819924:	48 89 e5             	mov    %rsp,%rbp
  819927:	53                   	push   %rbx
  819928:	48 83 ec 38          	sub    $0x38,%rsp
  81992c:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
    struct jif *jif;
    envid_t *output_envid; 

    jif = mem_malloc(sizeof(struct jif));
  819930:	bf 10 00 00 00       	mov    $0x10,%edi
  819935:	48 b8 96 c9 80 00 00 	movabs $0x80c996,%rax
  81993c:	00 00 00 
  81993f:	ff d0                	callq  *%rax
  819941:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

    if (jif == NULL) {
  819945:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81994a:	75 0a                	jne    819956 <jif_init+0x33>
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
  81994c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  819951:	e9 ce 00 00 00       	jmpq   819a24 <jif_init+0x101>
    }

    output_envid = (envid_t *)netif->state;
  819956:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81995a:	48 8b 40 30          	mov    0x30(%rax),%rax
  81995e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

    netif->state = jif;
  819962:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819966:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81996a:	48 89 50 30          	mov    %rdx,0x30(%rax)
    netif->output = jif_output;
  81996e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819972:	48 bb f4 97 81 00 00 	movabs $0x8197f4,%rbx
  819979:	00 00 00 
  81997c:	48 89 58 20          	mov    %rbx,0x20(%rax)
    netif->linkoutput = low_level_output;
  819980:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819984:	48 b9 8e 95 81 00 00 	movabs $0x81958e,%rcx
  81998b:	00 00 00 
  81998e:	48 89 48 28          	mov    %rcx,0x28(%rax)
    memcpy(&netif->name[0], "en", 2);
  819992:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819996:	48 83 c0 4b          	add    $0x4b,%rax
  81999a:	ba 02 00 00 00       	mov    $0x2,%edx
  81999f:	48 be d1 34 82 00 00 	movabs $0x8234d1,%rsi
  8199a6:	00 00 00 
  8199a9:	48 89 c7             	mov    %rax,%rdi
  8199ac:	48 b8 12 23 80 00 00 	movabs $0x802312,%rax
  8199b3:	00 00 00 
  8199b6:	ff d0                	callq  *%rax

    jif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  8199b8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8199bc:	48 8d 50 41          	lea    0x41(%rax),%rdx
  8199c0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8199c4:	48 89 10             	mov    %rdx,(%rax)
    jif->envid = *output_envid; 
  8199c7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8199cb:	8b 10                	mov    (%rax),%edx
  8199cd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8199d1:	89 50 08             	mov    %edx,0x8(%rax)

    low_level_init(netif);
  8199d4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8199d8:	48 89 c7             	mov    %rax,%rdi
  8199db:	48 b8 36 95 81 00 00 	movabs $0x819536,%rax
  8199e2:	00 00 00 
  8199e5:	ff d0                	callq  *%rax
    etharp_init();

    // qemu user-net is dumb; if the host OS does not send and ARP request
    // first, the qemu will send packets destined for the host using the mac
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
  8199e7:	48 bf d4 34 82 00 00 	movabs $0x8234d4,%rdi
  8199ee:	00 00 00 
  8199f1:	48 b8 00 2c 81 00 00 	movabs $0x812c00,%rax
  8199f8:	00 00 00 
  8199fb:	ff d0                	callq  *%rax
  8199fd:	89 45 dc             	mov    %eax,-0x24(%rbp)
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);
  819a00:	48 8d 4d dc          	lea    -0x24(%rbp),%rcx
  819a04:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819a08:	ba 00 00 00 00       	mov    $0x0,%edx
  819a0d:	48 89 ce             	mov    %rcx,%rsi
  819a10:	48 89 c7             	mov    %rax,%rdi
  819a13:	48 b8 e7 6b 81 00 00 	movabs $0x816be7,%rax
  819a1a:	00 00 00 
  819a1d:	ff d0                	callq  *%rax

    return ERR_OK;
  819a1f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  819a24:	48 83 c4 38          	add    $0x38,%rsp
  819a28:	5b                   	pop    %rbx
  819a29:	5d                   	pop    %rbp
  819a2a:	c3                   	retq   

0000000000819a2b <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
  819a2b:	55                   	push   %rbp
  819a2c:	48 89 e5             	mov    %rsp,%rbp
  819a2f:	48 83 ec 40          	sub    $0x40,%rsp
  819a33:	89 7d cc             	mov    %edi,-0x34(%rbp)
  819a36:	89 f0                	mov    %esi,%eax
  819a38:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  819a3c:	88 45 c8             	mov    %al,-0x38(%rbp)
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
  819a3f:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  819a43:	8b 45 cc             	mov    -0x34(%rbp),%eax
  819a46:	48 89 d6             	mov    %rdx,%rsi
  819a49:	89 c7                	mov    %eax,%edi
  819a4b:	48 b8 ad b0 81 00 00 	movabs $0x81b0ad,%rax
  819a52:	00 00 00 
  819a55:	ff d0                	callq  *%rax
  819a57:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  
  if (conn != NULL ) {
  819a5b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  819a60:	0f 84 62 01 00 00    	je     819bc8 <netconn_new_with_proto_and_callback+0x19d>
    msg.function = do_newconn;
  819a66:	48 b8 64 b0 81 00 00 	movabs $0x81b064,%rax
  819a6d:	00 00 00 
  819a70:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    msg.msg.msg.n.proto = proto;
  819a74:	0f b6 45 c8          	movzbl -0x38(%rbp),%eax
  819a78:	88 45 e0             	mov    %al,-0x20(%rbp)
    msg.msg.conn = conn;
  819a7b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819a7f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    TCPIP_APIMSG(&msg);
  819a83:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819a87:	48 89 c7             	mov    %rax,%rdi
  819a8a:	48 b8 d2 8c 80 00 00 	movabs $0x808cd2,%rax
  819a91:	00 00 00 
  819a94:	ff d0                	callq  *%rax

    if (conn->err != ERR_OK) {
  819a96:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819a9a:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  819a9e:	84 c0                	test   %al,%al
  819aa0:	0f 84 22 01 00 00    	je     819bc8 <netconn_new_with_proto_and_callback+0x19d>
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  819aa6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819aaa:	48 8b 40 08          	mov    0x8(%rax),%rax
  819aae:	48 85 c0             	test   %rax,%rax
  819ab1:	74 2a                	je     819add <netconn_new_with_proto_and_callback+0xb2>
  819ab3:	48 ba e0 34 82 00 00 	movabs $0x8234e0,%rdx
  819aba:	00 00 00 
  819abd:	be 53 00 00 00       	mov    $0x53,%esi
  819ac2:	48 bf 01 35 82 00 00 	movabs $0x823501,%rdi
  819ac9:	00 00 00 
  819acc:	b8 00 00 00 00       	mov    $0x0,%eax
  819ad1:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  819ad8:	00 00 00 
  819adb:	ff d1                	callq  *%rcx
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  819add:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819ae1:	8b 40 14             	mov    0x14(%rax),%eax
  819ae4:	83 f8 ff             	cmp    $0xffffffff,%eax
  819ae7:	75 2a                	jne    819b13 <netconn_new_with_proto_and_callback+0xe8>
  819ae9:	48 ba 18 35 82 00 00 	movabs $0x823518,%rdx
  819af0:	00 00 00 
  819af3:	be 54 00 00 00       	mov    $0x54,%esi
  819af8:	48 bf 01 35 82 00 00 	movabs $0x823501,%rdi
  819aff:	00 00 00 
  819b02:	b8 00 00 00 00       	mov    $0x0,%eax
  819b07:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  819b0e:	00 00 00 
  819b11:	ff d1                	callq  *%rcx
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  819b13:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819b17:	8b 40 18             	mov    0x18(%rax),%eax
  819b1a:	83 f8 ff             	cmp    $0xffffffff,%eax
  819b1d:	75 2a                	jne    819b49 <netconn_new_with_proto_and_callback+0x11e>
  819b1f:	48 ba 31 35 82 00 00 	movabs $0x823531,%rdx
  819b26:	00 00 00 
  819b29:	be 55 00 00 00       	mov    $0x55,%esi
  819b2e:	48 bf 01 35 82 00 00 	movabs $0x823501,%rdi
  819b35:	00 00 00 
  819b38:	b8 00 00 00 00       	mov    $0x0,%eax
  819b3d:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  819b44:	00 00 00 
  819b47:	ff d1                	callq  *%rcx
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  819b49:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819b4d:	8b 40 1c             	mov    0x1c(%rax),%eax
  819b50:	83 f8 ff             	cmp    $0xffffffff,%eax
  819b53:	74 2a                	je     819b7f <netconn_new_with_proto_and_callback+0x154>
  819b55:	48 ba 48 35 82 00 00 	movabs $0x823548,%rdx
  819b5c:	00 00 00 
  819b5f:	be 56 00 00 00       	mov    $0x56,%esi
  819b64:	48 bf 01 35 82 00 00 	movabs $0x823501,%rdi
  819b6b:	00 00 00 
  819b6e:	b8 00 00 00 00       	mov    $0x0,%eax
  819b73:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  819b7a:	00 00 00 
  819b7d:	ff d1                	callq  *%rcx
      sys_sem_free(conn->op_completed);
  819b7f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819b83:	8b 40 14             	mov    0x14(%rax),%eax
  819b86:	89 c7                	mov    %eax,%edi
  819b88:	48 b8 ca 7e 81 00 00 	movabs $0x817eca,%rax
  819b8f:	00 00 00 
  819b92:	ff d0                	callq  *%rax
      sys_mbox_free(conn->recvmbox);
  819b94:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819b98:	8b 40 18             	mov    0x18(%rax),%eax
  819b9b:	89 c7                	mov    %eax,%edi
  819b9d:	48 b8 b5 78 81 00 00 	movabs $0x8178b5,%rax
  819ba4:	00 00 00 
  819ba7:	ff d0                	callq  *%rax
      memp_free(MEMP_NETCONN, conn);
  819ba9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819bad:	48 89 c6             	mov    %rax,%rsi
  819bb0:	bf 07 00 00 00       	mov    $0x7,%edi
  819bb5:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  819bbc:	00 00 00 
  819bbf:	ff d0                	callq  *%rax
      return NULL;
  819bc1:	b8 00 00 00 00       	mov    $0x0,%eax
  819bc6:	eb 04                	jmp    819bcc <netconn_new_with_proto_and_callback+0x1a1>
    }
  }
  return conn;
  819bc8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  819bcc:	c9                   	leaveq 
  819bcd:	c3                   	retq   

0000000000819bce <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
  819bce:	55                   	push   %rbp
  819bcf:	48 89 e5             	mov    %rsp,%rbp
  819bd2:	48 83 ec 40          	sub    $0x40,%rsp
  819bd6:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
  819bda:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819bdf:	75 07                	jne    819be8 <netconn_delete+0x1a>
    return ERR_OK;
  819be1:	b8 00 00 00 00       	mov    $0x0,%eax
  819be6:	eb 4d                	jmp    819c35 <netconn_delete+0x67>
  }

  msg.function = do_delconn;
  819be8:	48 b8 77 b6 81 00 00 	movabs $0x81b677,%rax
  819bef:	00 00 00 
  819bf2:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  819bf6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819bfa:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  tcpip_apimsg(&msg);
  819bfe:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819c02:	48 89 c7             	mov    %rax,%rdi
  819c05:	48 b8 d2 8c 80 00 00 	movabs $0x808cd2,%rax
  819c0c:	00 00 00 
  819c0f:	ff d0                	callq  *%rax

  conn->pcb.tcp = NULL;
  819c11:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819c15:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  819c1c:	00 
  netconn_free(conn);
  819c1d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819c21:	48 89 c7             	mov    %rax,%rdi
  819c24:	48 b8 e1 b1 81 00 00 	movabs $0x81b1e1,%rax
  819c2b:	00 00 00 
  819c2e:	ff d0                	callq  *%rax

  return ERR_OK;
  819c30:	b8 00 00 00 00       	mov    $0x0,%eax
}
  819c35:	c9                   	leaveq 
  819c36:	c3                   	retq   

0000000000819c37 <netconn_type>:
 * @param conn the netconn of which to get the type
 * @return the netconn_type of conn
 */
enum netconn_type
netconn_type(struct netconn *conn)
{
  819c37:	55                   	push   %rbp
  819c38:	48 89 e5             	mov    %rsp,%rbp
  819c3b:	48 83 ec 10          	sub    $0x10,%rsp
  819c3f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  819c43:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  819c48:	75 2a                	jne    819c74 <netconn_type+0x3d>
  819c4a:	48 ba 69 35 82 00 00 	movabs $0x823569,%rdx
  819c51:	00 00 00 
  819c54:	be 85 00 00 00       	mov    $0x85,%esi
  819c59:	48 bf 01 35 82 00 00 	movabs $0x823501,%rdi
  819c60:	00 00 00 
  819c63:	b8 00 00 00 00       	mov    $0x0,%eax
  819c68:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  819c6f:	00 00 00 
  819c72:	ff d1                	callq  *%rcx
  return conn->type;
  819c74:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819c78:	8b 00                	mov    (%rax),%eax
}
  819c7a:	c9                   	leaveq 
  819c7b:	c3                   	retq   

0000000000819c7c <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, struct ip_addr *addr, u16_t *port, u8_t local)
{
  819c7c:	55                   	push   %rbp
  819c7d:	48 89 e5             	mov    %rsp,%rbp
  819c80:	48 83 ec 50          	sub    $0x50,%rsp
  819c84:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  819c88:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  819c8c:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  819c90:	89 c8                	mov    %ecx,%eax
  819c92:	88 45 b4             	mov    %al,-0x4c(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  819c95:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819c9a:	75 2a                	jne    819cc6 <netconn_getaddr+0x4a>
  819c9c:	48 ba 84 35 82 00 00 	movabs $0x823584,%rdx
  819ca3:	00 00 00 
  819ca6:	be 99 00 00 00       	mov    $0x99,%esi
  819cab:	48 bf 01 35 82 00 00 	movabs $0x823501,%rdi
  819cb2:	00 00 00 
  819cb5:	b8 00 00 00 00       	mov    $0x0,%eax
  819cba:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  819cc1:	00 00 00 
  819cc4:	ff d1                	callq  *%rcx
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  819cc6:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  819ccb:	75 2a                	jne    819cf7 <netconn_getaddr+0x7b>
  819ccd:	48 ba a2 35 82 00 00 	movabs $0x8235a2,%rdx
  819cd4:	00 00 00 
  819cd7:	be 9a 00 00 00       	mov    $0x9a,%esi
  819cdc:	48 bf 01 35 82 00 00 	movabs $0x823501,%rdi
  819ce3:	00 00 00 
  819ce6:	b8 00 00 00 00       	mov    $0x0,%eax
  819ceb:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  819cf2:	00 00 00 
  819cf5:	ff d1                	callq  *%rcx
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  819cf7:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  819cfc:	75 2a                	jne    819d28 <netconn_getaddr+0xac>
  819cfe:	48 ba c0 35 82 00 00 	movabs $0x8235c0,%rdx
  819d05:	00 00 00 
  819d08:	be 9b 00 00 00       	mov    $0x9b,%esi
  819d0d:	48 bf 01 35 82 00 00 	movabs $0x823501,%rdi
  819d14:	00 00 00 
  819d17:	b8 00 00 00 00       	mov    $0x0,%eax
  819d1c:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  819d23:	00 00 00 
  819d26:	ff d1                	callq  *%rcx

  msg.function = do_getaddr;
  819d28:	48 b8 1f c2 81 00 00 	movabs $0x81c21f,%rax
  819d2f:	00 00 00 
  819d32:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  819d36:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819d3a:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  msg.msg.msg.ad.ipaddr = addr;
  819d3e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  819d42:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  msg.msg.msg.ad.port = port;
  819d46:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819d4a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  msg.msg.msg.ad.local = local;
  819d4e:	0f b6 45 b4          	movzbl -0x4c(%rbp),%eax
  819d52:	88 45 f0             	mov    %al,-0x10(%rbp)
  TCPIP_APIMSG(&msg);
  819d55:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819d59:	48 89 c7             	mov    %rax,%rdi
  819d5c:	48 b8 d2 8c 80 00 00 	movabs $0x808cd2,%rax
  819d63:	00 00 00 
  819d66:	ff d0                	callq  *%rax

  return conn->err;
  819d68:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819d6c:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  819d70:	c9                   	leaveq 
  819d71:	c3                   	retq   

0000000000819d72 <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  819d72:	55                   	push   %rbp
  819d73:	48 89 e5             	mov    %rsp,%rbp
  819d76:	48 83 ec 50          	sub    $0x50,%rsp
  819d7a:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  819d7e:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  819d82:	89 d0                	mov    %edx,%eax
  819d84:	66 89 45 bc          	mov    %ax,-0x44(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  819d88:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819d8d:	75 2a                	jne    819db9 <netconn_bind+0x47>
  819d8f:	48 ba de 35 82 00 00 	movabs $0x8235de,%rdx
  819d96:	00 00 00 
  819d99:	be b6 00 00 00       	mov    $0xb6,%esi
  819d9e:	48 bf 01 35 82 00 00 	movabs $0x823501,%rdi
  819da5:	00 00 00 
  819da8:	b8 00 00 00 00       	mov    $0x0,%eax
  819dad:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  819db4:	00 00 00 
  819db7:	ff d1                	callq  *%rcx

  msg.function = do_bind;
  819db9:	48 b8 b5 b7 81 00 00 	movabs $0x81b7b5,%rax
  819dc0:	00 00 00 
  819dc3:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  819dc7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819dcb:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  msg.msg.msg.bc.ipaddr = addr;
  819dcf:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  819dd3:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  msg.msg.msg.bc.port = port;
  819dd7:	0f b7 45 bc          	movzwl -0x44(%rbp),%eax
  819ddb:	66 89 45 e8          	mov    %ax,-0x18(%rbp)
  TCPIP_APIMSG(&msg);
  819ddf:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819de3:	48 89 c7             	mov    %rax,%rdi
  819de6:	48 b8 d2 8c 80 00 00 	movabs $0x808cd2,%rax
  819ded:	00 00 00 
  819df0:	ff d0                	callq  *%rax
  return conn->err;
  819df2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819df6:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  819dfa:	c9                   	leaveq 
  819dfb:	c3                   	retq   

0000000000819dfc <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  819dfc:	55                   	push   %rbp
  819dfd:	48 89 e5             	mov    %rsp,%rbp
  819e00:	48 83 ec 50          	sub    $0x50,%rsp
  819e04:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  819e08:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  819e0c:	89 d0                	mov    %edx,%eax
  819e0e:	66 89 45 bc          	mov    %ax,-0x44(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  819e12:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819e17:	75 2a                	jne    819e43 <netconn_connect+0x47>
  819e19:	48 ba f9 35 82 00 00 	movabs $0x8235f9,%rdx
  819e20:	00 00 00 
  819e23:	be cd 00 00 00       	mov    $0xcd,%esi
  819e28:	48 bf 01 35 82 00 00 	movabs $0x823501,%rdi
  819e2f:	00 00 00 
  819e32:	b8 00 00 00 00       	mov    $0x0,%eax
  819e37:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  819e3e:	00 00 00 
  819e41:	ff d1                	callq  *%rcx

  msg.function = do_connect;
  819e43:	48 b8 60 b9 81 00 00 	movabs $0x81b960,%rax
  819e4a:	00 00 00 
  819e4d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  819e51:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819e55:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  msg.msg.msg.bc.ipaddr = addr;
  819e59:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  819e5d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  msg.msg.msg.bc.port = port;
  819e61:	0f b7 45 bc          	movzwl -0x44(%rbp),%eax
  819e65:	66 89 45 e8          	mov    %ax,-0x18(%rbp)
  /* This is the only function which need to not block tcpip_thread */
  tcpip_apimsg(&msg);
  819e69:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819e6d:	48 89 c7             	mov    %rax,%rdi
  819e70:	48 b8 d2 8c 80 00 00 	movabs $0x808cd2,%rax
  819e77:	00 00 00 
  819e7a:	ff d0                	callq  *%rax
  return conn->err;
  819e7c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819e80:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  819e84:	c9                   	leaveq 
  819e85:	c3                   	retq   

0000000000819e86 <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
  819e86:	55                   	push   %rbp
  819e87:	48 89 e5             	mov    %rsp,%rbp
  819e8a:	48 83 ec 40          	sub    $0x40,%rsp
  819e8e:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  819e92:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819e97:	75 2a                	jne    819ec3 <netconn_disconnect+0x3d>
  819e99:	48 ba 18 36 82 00 00 	movabs $0x823618,%rdx
  819ea0:	00 00 00 
  819ea3:	be e3 00 00 00       	mov    $0xe3,%esi
  819ea8:	48 bf 01 35 82 00 00 	movabs $0x823501,%rdi
  819eaf:	00 00 00 
  819eb2:	b8 00 00 00 00       	mov    $0x0,%eax
  819eb7:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  819ebe:	00 00 00 
  819ec1:	ff d1                	callq  *%rcx

  msg.function = do_disconnect;
  819ec3:	48 b8 cd ba 81 00 00 	movabs $0x81bacd,%rax
  819eca:	00 00 00 
  819ecd:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  819ed1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819ed5:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  TCPIP_APIMSG(&msg);
  819ed9:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819edd:	48 89 c7             	mov    %rax,%rdi
  819ee0:	48 b8 d2 8c 80 00 00 	movabs $0x808cd2,%rax
  819ee7:	00 00 00 
  819eea:	ff d0                	callq  *%rax
  return conn->err;
  819eec:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819ef0:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  819ef4:	c9                   	leaveq 
  819ef5:	c3                   	retq   

0000000000819ef6 <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
  819ef6:	55                   	push   %rbp
  819ef7:	48 89 e5             	mov    %rsp,%rbp
  819efa:	48 83 ec 40          	sub    $0x40,%rsp
  819efe:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  819f02:	89 f0                	mov    %esi,%eax
  819f04:	88 45 c4             	mov    %al,-0x3c(%rbp)
  struct api_msg msg;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  819f07:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819f0c:	75 2a                	jne    819f38 <netconn_listen_with_backlog+0x42>
  819f0e:	48 ba 39 36 82 00 00 	movabs $0x823639,%rdx
  819f15:	00 00 00 
  819f18:	be fb 00 00 00       	mov    $0xfb,%esi
  819f1d:	48 bf 01 35 82 00 00 	movabs $0x823501,%rdi
  819f24:	00 00 00 
  819f27:	b8 00 00 00 00       	mov    $0x0,%eax
  819f2c:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  819f33:	00 00 00 
  819f36:	ff d1                	callq  *%rcx

  msg.function = do_listen;
  819f38:	48 b8 20 bb 81 00 00 	movabs $0x81bb20,%rax
  819f3f:	00 00 00 
  819f42:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  819f46:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819f4a:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  TCPIP_APIMSG(&msg);
  819f4e:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819f52:	48 89 c7             	mov    %rax,%rdi
  819f55:	48 b8 d2 8c 80 00 00 	movabs $0x808cd2,%rax
  819f5c:	00 00 00 
  819f5f:	ff d0                	callq  *%rax
  return conn->err;
  819f61:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819f65:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  819f69:	c9                   	leaveq 
  819f6a:	c3                   	retq   

0000000000819f6b <netconn_accept>:
 * @param conn the TCP listen netconn
 * @return the newly accepted netconn or NULL on timeout
 */
struct netconn *
netconn_accept(struct netconn *conn)
{
  819f6b:	55                   	push   %rbp
  819f6c:	48 89 e5             	mov    %rsp,%rbp
  819f6f:	48 83 ec 20          	sub    $0x20,%rsp
  819f73:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct netconn *newconn;

  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  819f77:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  819f7c:	75 2a                	jne    819fa8 <netconn_accept+0x3d>
  819f7e:	48 ba 56 36 82 00 00 	movabs $0x823656,%rdx
  819f85:	00 00 00 
  819f88:	be 11 01 00 00       	mov    $0x111,%esi
  819f8d:	48 bf 01 35 82 00 00 	movabs $0x823501,%rdi
  819f94:	00 00 00 
  819f97:	b8 00 00 00 00       	mov    $0x0,%eax
  819f9c:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  819fa3:	00 00 00 
  819fa6:	ff d1                	callq  *%rcx
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  819fa8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819fac:	8b 40 1c             	mov    0x1c(%rax),%eax
  819faf:	83 f8 ff             	cmp    $0xffffffff,%eax
  819fb2:	75 2a                	jne    819fde <netconn_accept+0x73>
  819fb4:	48 ba 78 36 82 00 00 	movabs $0x823678,%rdx
  819fbb:	00 00 00 
  819fbe:	be 12 01 00 00       	mov    $0x112,%esi
  819fc3:	48 bf 01 35 82 00 00 	movabs $0x823501,%rdi
  819fca:	00 00 00 
  819fcd:	b8 00 00 00 00       	mov    $0x0,%eax
  819fd2:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  819fd9:	00 00 00 
  819fdc:	ff d1                	callq  *%rcx
#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    newconn = NULL;
  } else
#else
  sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, 0);
  819fde:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819fe2:	8b 40 1c             	mov    0x1c(%rax),%eax
  819fe5:	48 8d 4d f8          	lea    -0x8(%rbp),%rcx
  819fe9:	ba 00 00 00 00       	mov    $0x0,%edx
  819fee:	48 89 ce             	mov    %rcx,%rsi
  819ff1:	89 c7                	mov    %eax,%edi
  819ff3:	48 b8 73 83 81 00 00 	movabs $0x818373,%rax
  819ffa:	00 00 00 
  819ffd:	ff d0                	callq  *%rax
#endif /* LWIP_SO_RCVTIMEO*/
  {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
  819fff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a003:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a007:	48 85 c0             	test   %rax,%rax
  81a00a:	74 1b                	je     81a027 <netconn_accept+0xbc>
  81a00c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a010:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a014:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  81a018:	ba 00 00 00 00       	mov    $0x0,%edx
  81a01d:	be 01 00 00 00       	mov    $0x1,%esi
  81a022:	48 89 cf             	mov    %rcx,%rdi
  81a025:	ff d0                	callq  *%rax
      TCPIP_APIMSG(&msg);
    }
#endif /* TCP_LISTEN_BACKLOG */
  }

  return newconn;
  81a027:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  81a02b:	c9                   	leaveq 
  81a02c:	c3                   	retq   

000000000081a02d <netconn_recv>:
 * @param conn the netconn from which to receive data
 * @return a new netbuf containing received data or NULL on memory error or timeout
 */
struct netbuf *
netconn_recv(struct netconn *conn)
{
  81a02d:	55                   	push   %rbp
  81a02e:	48 89 e5             	mov    %rsp,%rbp
  81a031:	48 83 ec 50          	sub    $0x50,%rsp
  81a035:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  struct api_msg msg;
  struct netbuf *buf = NULL;
  81a039:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  81a040:	00 
  struct pbuf *p;
  u16_t len;

  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  81a041:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  81a046:	75 2a                	jne    81a072 <netconn_recv+0x45>
  81a048:	48 ba 9b 36 82 00 00 	movabs $0x82369b,%rdx
  81a04f:	00 00 00 
  81a052:	be 3b 01 00 00       	mov    $0x13b,%esi
  81a057:	48 bf 01 35 82 00 00 	movabs $0x823501,%rdi
  81a05e:	00 00 00 
  81a061:	b8 00 00 00 00       	mov    $0x0,%eax
  81a066:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81a06d:	00 00 00 
  81a070:	ff d1                	callq  *%rcx

  if (conn->recvmbox == SYS_MBOX_NULL) {
  81a072:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a076:	8b 40 18             	mov    0x18(%rax),%eax
  81a079:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a07c:	75 12                	jne    81a090 <netconn_recv+0x63>
    /* @todo: should calling netconn_recv on a TCP listen conn be fatal (ERR_CONN)?? */
    /* TCP listen conns don't have a recvmbox! */
    conn->err = ERR_CONN;
  81a07e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a082:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
    return NULL;
  81a086:	b8 00 00 00 00       	mov    $0x0,%eax
  81a08b:	e9 21 02 00 00       	jmpq   81a2b1 <netconn_recv+0x284>
  }

  if (ERR_IS_FATAL(conn->err)) {
  81a090:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a094:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81a098:	3c fc                	cmp    $0xfc,%al
  81a09a:	7d 0a                	jge    81a0a6 <netconn_recv+0x79>
    return NULL;
  81a09c:	b8 00 00 00 00       	mov    $0x0,%eax
  81a0a1:	e9 0b 02 00 00       	jmpq   81a2b1 <netconn_recv+0x284>
  }

  if (conn->type == NETCONN_TCP) {
  81a0a6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a0aa:	8b 00                	mov    (%rax),%eax
  81a0ac:	83 f8 10             	cmp    $0x10,%eax
  81a0af:	0f 85 80 01 00 00    	jne    81a235 <netconn_recv+0x208>
#if LWIP_TCP
    if (conn->state == NETCONN_LISTEN) {
  81a0b5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a0b9:	8b 40 04             	mov    0x4(%rax),%eax
  81a0bc:	83 f8 02             	cmp    $0x2,%eax
  81a0bf:	75 12                	jne    81a0d3 <netconn_recv+0xa6>
      /* @todo: should calling netconn_recv on a TCP listen conn be fatal?? */
      conn->err = ERR_CONN;
  81a0c1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a0c5:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
      return NULL;
  81a0c9:	b8 00 00 00 00       	mov    $0x0,%eax
  81a0ce:	e9 de 01 00 00       	jmpq   81a2b1 <netconn_recv+0x284>
    }

    buf = memp_malloc(MEMP_NETBUF);
  81a0d3:	bf 06 00 00 00       	mov    $0x6,%edi
  81a0d8:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  81a0df:	00 00 00 
  81a0e2:	ff d0                	callq  *%rax
  81a0e4:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

    if (buf == NULL) {
  81a0e8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a0ec:	48 85 c0             	test   %rax,%rax
  81a0ef:	75 12                	jne    81a103 <netconn_recv+0xd6>
      conn->err = ERR_MEM;
  81a0f1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a0f5:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
      return NULL;
  81a0f9:	b8 00 00 00 00       	mov    $0x0,%eax
  81a0fe:	e9 ae 01 00 00       	jmpq   81a2b1 <netconn_recv+0x284>
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      conn->err = ERR_TIMEOUT;
      p = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, 0);
  81a103:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a107:	8b 40 18             	mov    0x18(%rax),%eax
  81a10a:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  81a10e:	ba 00 00 00 00       	mov    $0x0,%edx
  81a113:	48 89 ce             	mov    %rcx,%rsi
  81a116:	89 c7                	mov    %eax,%edi
  81a118:	48 b8 73 83 81 00 00 	movabs $0x818373,%rax
  81a11f:	00 00 00 
  81a122:	ff d0                	callq  *%rax
#endif /* LWIP_SO_RCVTIMEO*/

    if (p != NULL) {
  81a124:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81a128:	48 85 c0             	test   %rax,%rax
  81a12b:	74 24                	je     81a151 <netconn_recv+0x124>
      len = p->tot_len;
  81a12d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81a131:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81a135:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
      SYS_ARCH_DEC(conn->recv_avail, len);
  81a139:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a13d:	0f b7 40 24          	movzwl 0x24(%rax),%eax
  81a141:	66 2b 45 fe          	sub    -0x2(%rbp),%ax
  81a145:	89 c2                	mov    %eax,%edx
  81a147:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a14b:	66 89 50 24          	mov    %dx,0x24(%rax)
  81a14f:	eb 06                	jmp    81a157 <netconn_recv+0x12a>
    } else {
      len = 0;
  81a151:	66 c7 45 fe 00 00    	movw   $0x0,-0x2(%rbp)
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  81a157:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a15b:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a15f:	48 85 c0             	test   %rax,%rax
  81a162:	74 1a                	je     81a17e <netconn_recv+0x151>
  81a164:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a168:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a16c:	0f b7 55 fe          	movzwl -0x2(%rbp),%edx
  81a170:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  81a174:	be 01 00 00 00       	mov    $0x1,%esi
  81a179:	48 89 cf             	mov    %rcx,%rdi
  81a17c:	ff d0                	callq  *%rax

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
  81a17e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81a182:	48 85 c0             	test   %rax,%rax
  81a185:	75 36                	jne    81a1bd <netconn_recv+0x190>
      memp_free(MEMP_NETBUF, buf);
  81a187:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a18b:	48 89 c6             	mov    %rax,%rsi
  81a18e:	bf 06 00 00 00       	mov    $0x6,%edi
  81a193:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  81a19a:	00 00 00 
  81a19d:	ff d0                	callq  *%rax
      /* Avoid to lose any previous error code */
      if (conn->err == ERR_OK) {
  81a19f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a1a3:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81a1a7:	84 c0                	test   %al,%al
  81a1a9:	75 08                	jne    81a1b3 <netconn_recv+0x186>
        conn->err = ERR_CLSD;
  81a1ab:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a1af:	c6 40 10 f9          	movb   $0xf9,0x10(%rax)
      }
      return NULL;
  81a1b3:	b8 00 00 00 00       	mov    $0x0,%eax
  81a1b8:	e9 f4 00 00 00       	jmpq   81a2b1 <netconn_recv+0x284>
    }

    buf->p = p;
  81a1bd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a1c1:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  81a1c5:	48 89 10             	mov    %rdx,(%rax)
    buf->ptr = p;
  81a1c8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a1cc:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  81a1d0:	48 89 50 08          	mov    %rdx,0x8(%rax)
    buf->port = 0;
  81a1d4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a1d8:	66 c7 40 18 00 00    	movw   $0x0,0x18(%rax)
    buf->addr = NULL;
  81a1de:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a1e2:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  81a1e9:	00 

    /* Let the stack know that we have taken the data. */
    msg.function = do_recv;
  81a1ea:	48 b8 59 be 81 00 00 	movabs $0x81be59,%rax
  81a1f1:	00 00 00 
  81a1f4:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    msg.msg.conn = conn;
  81a1f8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a1fc:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    if (buf != NULL) {
  81a200:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a204:	48 85 c0             	test   %rax,%rax
  81a207:	74 11                	je     81a21a <netconn_recv+0x1ed>
      msg.msg.msg.r.len = buf->p->tot_len;
  81a209:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a20d:	48 8b 00             	mov    (%rax),%rax
  81a210:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81a214:	66 89 45 e0          	mov    %ax,-0x20(%rbp)
  81a218:	eb 06                	jmp    81a220 <netconn_recv+0x1f3>
    } else {
      msg.msg.msg.r.len = 1;
  81a21a:	66 c7 45 e0 01 00    	movw   $0x1,-0x20(%rbp)
    }
    TCPIP_APIMSG(&msg);
  81a220:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  81a224:	48 89 c7             	mov    %rax,%rdi
  81a227:	48 b8 d2 8c 80 00 00 	movabs $0x808cd2,%rax
  81a22e:	00 00 00 
  81a231:	ff d0                	callq  *%rax
  81a233:	eb 78                	jmp    81a2ad <netconn_recv+0x280>
#if LWIP_SO_RCVTIMEO
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      buf = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, 0);
  81a235:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a239:	8b 40 18             	mov    0x18(%rax),%eax
  81a23c:	48 8d 4d c8          	lea    -0x38(%rbp),%rcx
  81a240:	ba 00 00 00 00       	mov    $0x0,%edx
  81a245:	48 89 ce             	mov    %rcx,%rsi
  81a248:	89 c7                	mov    %eax,%edi
  81a24a:	48 b8 73 83 81 00 00 	movabs $0x818373,%rax
  81a251:	00 00 00 
  81a254:	ff d0                	callq  *%rax
#endif /* LWIP_SO_RCVTIMEO*/
    if (buf!=NULL) {
  81a256:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a25a:	48 85 c0             	test   %rax,%rax
  81a25d:	74 4e                	je     81a2ad <netconn_recv+0x280>
      SYS_ARCH_DEC(conn->recv_avail, buf->p->tot_len);
  81a25f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a263:	0f b7 50 24          	movzwl 0x24(%rax),%edx
  81a267:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a26b:	48 8b 00             	mov    (%rax),%rax
  81a26e:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81a272:	29 c2                	sub    %eax,%edx
  81a274:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a278:	66 89 50 24          	mov    %dx,0x24(%rax)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, buf->p->tot_len);
  81a27c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a280:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a284:	48 85 c0             	test   %rax,%rax
  81a287:	74 24                	je     81a2ad <netconn_recv+0x280>
  81a289:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a28d:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a291:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81a295:	48 8b 12             	mov    (%rdx),%rdx
  81a298:	0f b7 52 10          	movzwl 0x10(%rdx),%edx
  81a29c:	0f b7 d2             	movzwl %dx,%edx
  81a29f:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  81a2a3:	be 01 00 00 00       	mov    $0x1,%esi
  81a2a8:	48 89 cf             	mov    %rcx,%rdi
  81a2ab:	ff d0                	callq  *%rax
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
  81a2ad:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
}
  81a2b1:	c9                   	leaveq 
  81a2b2:	c3                   	retq   

000000000081a2b3 <netconn_sendto>:
 * @param port the remote port to which to send the data
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_sendto(struct netconn *conn, struct netbuf *buf, struct ip_addr *addr, u16_t port)
{
  81a2b3:	55                   	push   %rbp
  81a2b4:	48 89 e5             	mov    %rsp,%rbp
  81a2b7:	48 83 ec 20          	sub    $0x20,%rsp
  81a2bb:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81a2bf:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  81a2c3:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  81a2c7:	89 c8                	mov    %ecx,%eax
  81a2c9:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
  if (buf != NULL) {
  81a2cd:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81a2d2:	74 34                	je     81a308 <netconn_sendto+0x55>
    buf->addr = addr;
  81a2d4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a2d8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81a2dc:	48 89 50 10          	mov    %rdx,0x10(%rax)
    buf->port = port;
  81a2e0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a2e4:	0f b7 55 e4          	movzwl -0x1c(%rbp),%edx
  81a2e8:	66 89 50 18          	mov    %dx,0x18(%rax)
    return netconn_send(conn, buf);
  81a2ec:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81a2f0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a2f4:	48 89 d6             	mov    %rdx,%rsi
  81a2f7:	48 89 c7             	mov    %rax,%rdi
  81a2fa:	48 b8 0f a3 81 00 00 	movabs $0x81a30f,%rax
  81a301:	00 00 00 
  81a304:	ff d0                	callq  *%rax
  81a306:	eb 05                	jmp    81a30d <netconn_sendto+0x5a>
  }
  return ERR_VAL;
  81a308:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  81a30d:	c9                   	leaveq 
  81a30e:	c3                   	retq   

000000000081a30f <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
  81a30f:	55                   	push   %rbp
  81a310:	48 89 e5             	mov    %rsp,%rbp
  81a313:	48 83 ec 40          	sub    $0x40,%rsp
  81a317:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  81a31b:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  81a31f:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  81a324:	75 2a                	jne    81a350 <netconn_send+0x41>
  81a326:	48 ba b6 36 82 00 00 	movabs $0x8236b6,%rdx
  81a32d:	00 00 00 
  81a330:	be ba 01 00 00       	mov    $0x1ba,%esi
  81a335:	48 bf 01 35 82 00 00 	movabs $0x823501,%rdi
  81a33c:	00 00 00 
  81a33f:	b8 00 00 00 00       	mov    $0x0,%eax
  81a344:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81a34b:	00 00 00 
  81a34e:	ff d1                	callq  *%rcx

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %d bytes\n", buf->p->tot_len));
  msg.function = do_send;
  81a350:	48 b8 ca bc 81 00 00 	movabs $0x81bcca,%rax
  81a357:	00 00 00 
  81a35a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  81a35e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a362:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  msg.msg.msg.b = buf;
  81a366:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81a36a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  TCPIP_APIMSG(&msg);
  81a36e:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  81a372:	48 89 c7             	mov    %rax,%rdi
  81a375:	48 b8 d2 8c 80 00 00 	movabs $0x808cd2,%rax
  81a37c:	00 00 00 
  81a37f:	ff d0                	callq  *%rax
  return conn->err;
  81a381:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a385:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  81a389:	c9                   	leaveq 
  81a38a:	c3                   	retq   

000000000081a38b <netconn_write>:
 * - NETCONN_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write(struct netconn *conn, const void *dataptr, int size, u8_t apiflags)
{
  81a38b:	55                   	push   %rbp
  81a38c:	48 89 e5             	mov    %rsp,%rbp
  81a38f:	48 83 ec 50          	sub    $0x50,%rsp
  81a393:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  81a397:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  81a39b:	89 55 bc             	mov    %edx,-0x44(%rbp)
  81a39e:	89 c8                	mov    %ecx,%eax
  81a3a0:	88 45 b8             	mov    %al,-0x48(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  81a3a3:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  81a3a8:	75 2a                	jne    81a3d4 <netconn_write+0x49>
  81a3aa:	48 ba d1 36 82 00 00 	movabs $0x8236d1,%rdx
  81a3b1:	00 00 00 
  81a3b4:	be d4 01 00 00       	mov    $0x1d4,%esi
  81a3b9:	48 bf 01 35 82 00 00 	movabs $0x823501,%rdi
  81a3c0:	00 00 00 
  81a3c3:	b8 00 00 00 00       	mov    $0x0,%eax
  81a3c8:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81a3cf:	00 00 00 
  81a3d2:	ff d1                	callq  *%rcx
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  81a3d4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a3d8:	8b 00                	mov    (%rax),%eax
  81a3da:	83 f8 10             	cmp    $0x10,%eax
  81a3dd:	74 2a                	je     81a409 <netconn_write+0x7e>
  81a3df:	48 ba f0 36 82 00 00 	movabs $0x8236f0,%rdx
  81a3e6:	00 00 00 
  81a3e9:	be d5 01 00 00       	mov    $0x1d5,%esi
  81a3ee:	48 bf 01 35 82 00 00 	movabs $0x823501,%rdi
  81a3f5:	00 00 00 
  81a3f8:	b8 00 00 00 00       	mov    $0x0,%eax
  81a3fd:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81a404:	00 00 00 
  81a407:	ff d1                	callq  *%rcx

  msg.function = do_write;
  81a409:	48 b8 7e c1 81 00 00 	movabs $0x81c17e,%rax
  81a410:	00 00 00 
  81a413:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  81a417:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a41b:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  msg.msg.msg.w.dataptr = dataptr;
  81a41f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81a423:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  msg.msg.msg.w.apiflags = apiflags;
  81a427:	0f b6 45 b8          	movzbl -0x48(%rbp),%eax
  81a42b:	88 45 ec             	mov    %al,-0x14(%rbp)
  msg.msg.msg.w.len = size;
  81a42e:	8b 45 bc             	mov    -0x44(%rbp),%eax
  81a431:	89 45 e8             	mov    %eax,-0x18(%rbp)
  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  TCPIP_APIMSG(&msg);
  81a434:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  81a438:	48 89 c7             	mov    %rax,%rdi
  81a43b:	48 b8 d2 8c 80 00 00 	movabs $0x808cd2,%rax
  81a442:	00 00 00 
  81a445:	ff d0                	callq  *%rax
  return conn->err;
  81a447:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a44b:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  81a44f:	c9                   	leaveq 
  81a450:	c3                   	retq   

000000000081a451 <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
  81a451:	55                   	push   %rbp
  81a452:	48 89 e5             	mov    %rsp,%rbp
  81a455:	48 83 ec 40          	sub    $0x40,%rsp
  81a459:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  81a45d:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  81a462:	75 2a                	jne    81a48e <netconn_close+0x3d>
  81a464:	48 ba 12 37 82 00 00 	movabs $0x823712,%rdx
  81a46b:	00 00 00 
  81a46e:	be ee 01 00 00       	mov    $0x1ee,%esi
  81a473:	48 bf 01 35 82 00 00 	movabs $0x823501,%rdi
  81a47a:	00 00 00 
  81a47d:	b8 00 00 00 00       	mov    $0x0,%eax
  81a482:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81a489:	00 00 00 
  81a48c:	ff d1                	callq  *%rcx

  msg.function = do_close;
  81a48e:	48 b8 a3 c3 81 00 00 	movabs $0x81c3a3,%rax
  81a495:	00 00 00 
  81a498:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  81a49c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a4a0:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  tcpip_apimsg(&msg);
  81a4a4:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  81a4a8:	48 89 c7             	mov    %rax,%rdi
  81a4ab:	48 b8 d2 8c 80 00 00 	movabs $0x808cd2,%rax
  81a4b2:	00 00 00 
  81a4b5:	ff d0                	callq  *%rax
  return conn->err;
  81a4b7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a4bb:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  81a4bf:	c9                   	leaveq 
  81a4c0:	c3                   	retq   

000000000081a4c1 <recv_raw>:
 * @see raw.h (struct raw_pcb.recv) for parameters and return value
 */
static u8_t
recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
    struct ip_addr *addr)
{
  81a4c1:	55                   	push   %rbp
  81a4c2:	48 89 e5             	mov    %rsp,%rbp
  81a4c5:	48 83 ec 40          	sub    $0x40,%rsp
  81a4c9:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  81a4cd:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  81a4d1:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  81a4d5:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(addr);
  conn = arg;
  81a4d9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81a4dd:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL) &&
      ((recv_avail + (int)(p->tot_len)) <= conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL)) {
  81a4e1:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81a4e6:	0f 84 74 01 00 00    	je     81a660 <recv_raw+0x19f>
  81a4ec:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a4f0:	8b 40 18             	mov    0x18(%rax),%eax
  81a4f3:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a4f6:	0f 84 64 01 00 00    	je     81a660 <recv_raw+0x19f>
#endif /* LWIP_SO_RCVBUF */
    /* copy the whole packet into new pbufs */
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  81a4fc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a500:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81a504:	0f b7 c0             	movzwl %ax,%eax
  81a507:	ba 00 00 00 00       	mov    $0x0,%edx
  81a50c:	89 c6                	mov    %eax,%esi
  81a50e:	bf 03 00 00 00       	mov    $0x3,%edi
  81a513:	48 b8 61 d4 80 00 00 	movabs $0x80d461,%rax
  81a51a:	00 00 00 
  81a51d:	ff d0                	callq  *%rax
  81a51f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if(q != NULL) {
  81a523:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81a528:	74 39                	je     81a563 <recv_raw+0xa2>
      if (pbuf_copy(q, p) != ERR_OK) {
  81a52a:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81a52e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a532:	48 89 d6             	mov    %rdx,%rsi
  81a535:	48 89 c7             	mov    %rax,%rdi
  81a538:	48 b8 bf e1 80 00 00 	movabs $0x80e1bf,%rax
  81a53f:	00 00 00 
  81a542:	ff d0                	callq  *%rax
  81a544:	84 c0                	test   %al,%al
  81a546:	74 1b                	je     81a563 <recv_raw+0xa2>
        pbuf_free(q);
  81a548:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a54c:	48 89 c7             	mov    %rax,%rdi
  81a54f:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  81a556:	00 00 00 
  81a559:	ff d0                	callq  *%rax
        q = NULL;
  81a55b:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  81a562:	00 
      }
    }

    if(q != NULL) {
  81a563:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81a568:	0f 84 f2 00 00 00    	je     81a660 <recv_raw+0x19f>
      buf = memp_malloc(MEMP_NETBUF);
  81a56e:	bf 06 00 00 00       	mov    $0x6,%edi
  81a573:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  81a57a:	00 00 00 
  81a57d:	ff d0                	callq  *%rax
  81a57f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      if (buf == NULL) {
  81a583:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81a588:	75 1d                	jne    81a5a7 <recv_raw+0xe6>
        pbuf_free(q);
  81a58a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a58e:	48 89 c7             	mov    %rax,%rdi
  81a591:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  81a598:	00 00 00 
  81a59b:	ff d0                	callq  *%rax
        return 0;
  81a59d:	b8 00 00 00 00       	mov    $0x0,%eax
  81a5a2:	e9 be 00 00 00       	jmpq   81a665 <recv_raw+0x1a4>
      }

      buf->p = q;
  81a5a7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a5ab:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81a5af:	48 89 10             	mov    %rdx,(%rax)
      buf->ptr = q;
  81a5b2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a5b6:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81a5ba:	48 89 50 08          	mov    %rdx,0x8(%rax)
      buf->addr = &(((struct ip_hdr*)(q->payload))->src);
  81a5be:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a5c2:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a5c6:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  81a5ca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a5ce:	48 89 50 10          	mov    %rdx,0x10(%rax)
      buf->port = pcb->protocol;
  81a5d2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81a5d6:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81a5da:	0f b6 d0             	movzbl %al,%edx
  81a5dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a5e1:	66 89 50 18          	mov    %dx,0x18(%rax)

      SYS_ARCH_INC(conn->recv_avail, q->tot_len);
  81a5e5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a5e9:	0f b7 50 24          	movzwl 0x24(%rax),%edx
  81a5ed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a5f1:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81a5f5:	01 c2                	add    %eax,%edx
  81a5f7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a5fb:	66 89 50 24          	mov    %dx,0x24(%rax)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, q->tot_len);
  81a5ff:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a603:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a607:	48 85 c0             	test   %rax,%rax
  81a60a:	74 21                	je     81a62d <recv_raw+0x16c>
  81a60c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a610:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a614:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81a618:	0f b7 52 10          	movzwl 0x10(%rdx),%edx
  81a61c:	0f b7 d2             	movzwl %dx,%edx
  81a61f:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  81a623:	be 00 00 00 00       	mov    $0x0,%esi
  81a628:	48 89 cf             	mov    %rcx,%rdi
  81a62b:	ff d0                	callq  *%rax
      if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  81a62d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a631:	8b 40 18             	mov    0x18(%rax),%eax
  81a634:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81a638:	48 89 d6             	mov    %rdx,%rsi
  81a63b:	89 c7                	mov    %eax,%edi
  81a63d:	48 b8 66 7b 81 00 00 	movabs $0x817b66,%rax
  81a644:	00 00 00 
  81a647:	ff d0                	callq  *%rax
  81a649:	84 c0                	test   %al,%al
  81a64b:	74 13                	je     81a660 <recv_raw+0x19f>
        netbuf_delete(buf);
  81a64d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a651:	48 89 c7             	mov    %rax,%rdi
  81a654:	48 b8 b5 8e 80 00 00 	movabs $0x808eb5,%rax
  81a65b:	00 00 00 
  81a65e:	ff d0                	callq  *%rax
      }
    }
  }

  return 0; /* do not eat the packet */
  81a660:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81a665:	c9                   	leaveq 
  81a666:	c3                   	retq   

000000000081a667 <recv_udp>:
 * @see udp.h (struct udp_pcb.recv) for parameters
 */
static void
recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
   struct ip_addr *addr, u16_t port)
{
  81a667:	55                   	push   %rbp
  81a668:	48 89 e5             	mov    %rsp,%rbp
  81a66b:	48 83 ec 40          	sub    $0x40,%rsp
  81a66f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81a673:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81a677:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  81a67b:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  81a67f:	44 89 c0             	mov    %r8d,%eax
  81a682:	66 89 45 cc          	mov    %ax,-0x34(%rbp)
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  81a686:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81a68b:	75 2a                	jne    81a6b7 <recv_udp+0x50>
  81a68d:	48 ba 30 37 82 00 00 	movabs $0x823730,%rdx
  81a694:	00 00 00 
  81a697:	be 8f 00 00 00       	mov    $0x8f,%esi
  81a69c:	48 bf 52 37 82 00 00 	movabs $0x823752,%rdi
  81a6a3:	00 00 00 
  81a6a6:	b8 00 00 00 00       	mov    $0x0,%eax
  81a6ab:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81a6b2:	00 00 00 
  81a6b5:	ff d1                	callq  *%rcx
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  81a6b7:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81a6bc:	75 2a                	jne    81a6e8 <recv_udp+0x81>
  81a6be:	48 ba 70 37 82 00 00 	movabs $0x823770,%rdx
  81a6c5:	00 00 00 
  81a6c8:	be 90 00 00 00       	mov    $0x90,%esi
  81a6cd:	48 bf 52 37 82 00 00 	movabs $0x823752,%rdi
  81a6d4:	00 00 00 
  81a6d7:	b8 00 00 00 00       	mov    $0x0,%eax
  81a6dc:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81a6e3:	00 00 00 
  81a6e6:	ff d1                	callq  *%rcx
  conn = arg;
  81a6e8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a6ec:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  81a6f0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a6f4:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a6f8:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  81a6fc:	74 2a                	je     81a728 <recv_udp+0xc1>
  81a6fe:	48 ba 8f 37 82 00 00 	movabs $0x82378f,%rdx
  81a705:	00 00 00 
  81a708:	be 92 00 00 00       	mov    $0x92,%esi
  81a70d:	48 bf 52 37 82 00 00 	movabs $0x823752,%rdi
  81a714:	00 00 00 
  81a717:	b8 00 00 00 00       	mov    $0x0,%eax
  81a71c:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81a723:	00 00 00 
  81a726:	ff d1                	callq  *%rcx
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL) ||
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  81a728:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81a72d:	74 0c                	je     81a73b <recv_udp+0xd4>
  81a72f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a733:	8b 40 18             	mov    0x18(%rax),%eax
  81a736:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a739:	75 18                	jne    81a753 <recv_udp+0xec>
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
  81a73b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81a73f:	48 89 c7             	mov    %rax,%rdi
  81a742:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  81a749:	00 00 00 
  81a74c:	ff d0                	callq  *%rax
    return;
  81a74e:	e9 df 00 00 00       	jmpq   81a832 <recv_udp+0x1cb>
  }

  buf = memp_malloc(MEMP_NETBUF);
  81a753:	bf 06 00 00 00       	mov    $0x6,%edi
  81a758:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  81a75f:	00 00 00 
  81a762:	ff d0                	callq  *%rax
  81a764:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (buf == NULL) {
  81a768:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81a76d:	75 18                	jne    81a787 <recv_udp+0x120>
    pbuf_free(p);
  81a76f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81a773:	48 89 c7             	mov    %rax,%rdi
  81a776:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  81a77d:	00 00 00 
  81a780:	ff d0                	callq  *%rax
    return;
  81a782:	e9 ab 00 00 00       	jmpq   81a832 <recv_udp+0x1cb>
  } else {
    buf->p = p;
  81a787:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a78b:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81a78f:	48 89 10             	mov    %rdx,(%rax)
    buf->ptr = p;
  81a792:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a796:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81a79a:	48 89 50 08          	mov    %rdx,0x8(%rax)
    buf->addr = addr;
  81a79e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a7a2:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  81a7a6:	48 89 50 10          	mov    %rdx,0x10(%rax)
    buf->port = port;
  81a7aa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a7ae:	0f b7 55 cc          	movzwl -0x34(%rbp),%edx
  81a7b2:	66 89 50 18          	mov    %dx,0x18(%rax)
  }

  SYS_ARCH_INC(conn->recv_avail, p->tot_len);
  81a7b6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a7ba:	0f b7 50 24          	movzwl 0x24(%rax),%edx
  81a7be:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81a7c2:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81a7c6:	01 c2                	add    %eax,%edx
  81a7c8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a7cc:	66 89 50 24          	mov    %dx,0x24(%rax)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
  81a7d0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a7d4:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a7d8:	48 85 c0             	test   %rax,%rax
  81a7db:	74 21                	je     81a7fe <recv_udp+0x197>
  81a7dd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a7e1:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a7e5:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81a7e9:	0f b7 52 10          	movzwl 0x10(%rdx),%edx
  81a7ed:	0f b7 d2             	movzwl %dx,%edx
  81a7f0:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  81a7f4:	be 00 00 00 00       	mov    $0x0,%esi
  81a7f9:	48 89 cf             	mov    %rcx,%rdi
  81a7fc:	ff d0                	callq  *%rax
  if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  81a7fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a802:	8b 40 18             	mov    0x18(%rax),%eax
  81a805:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81a809:	48 89 d6             	mov    %rdx,%rsi
  81a80c:	89 c7                	mov    %eax,%edi
  81a80e:	48 b8 66 7b 81 00 00 	movabs $0x817b66,%rax
  81a815:	00 00 00 
  81a818:	ff d0                	callq  *%rax
  81a81a:	84 c0                	test   %al,%al
  81a81c:	74 14                	je     81a832 <recv_udp+0x1cb>
    netbuf_delete(buf);
  81a81e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a822:	48 89 c7             	mov    %rax,%rdi
  81a825:	48 b8 b5 8e 80 00 00 	movabs $0x808eb5,%rax
  81a82c:	00 00 00 
  81a82f:	ff d0                	callq  *%rax
    return;
  81a831:	90                   	nop
  }
}
  81a832:	c9                   	leaveq 
  81a833:	c3                   	retq   

000000000081a834 <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  81a834:	55                   	push   %rbp
  81a835:	48 89 e5             	mov    %rsp,%rbp
  81a838:	48 83 ec 30          	sub    $0x30,%rsp
  81a83c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81a840:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81a844:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  81a848:	89 c8                	mov    %ecx,%eax
  81a84a:	88 45 d4             	mov    %al,-0x2c(%rbp)
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  81a84d:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81a852:	75 2a                	jne    81a87e <recv_tcp+0x4a>
  81a854:	48 ba b0 37 82 00 00 	movabs $0x8237b0,%rdx
  81a85b:	00 00 00 
  81a85e:	be c2 00 00 00       	mov    $0xc2,%esi
  81a863:	48 bf 52 37 82 00 00 	movabs $0x823752,%rdi
  81a86a:	00 00 00 
  81a86d:	b8 00 00 00 00       	mov    $0x0,%eax
  81a872:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81a879:	00 00 00 
  81a87c:	ff d1                	callq  *%rcx
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  81a87e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81a883:	75 2a                	jne    81a8af <recv_tcp+0x7b>
  81a885:	48 ba d8 37 82 00 00 	movabs $0x8237d8,%rdx
  81a88c:	00 00 00 
  81a88f:	be c3 00 00 00       	mov    $0xc3,%esi
  81a894:	48 bf 52 37 82 00 00 	movabs $0x823752,%rdi
  81a89b:	00 00 00 
  81a89e:	b8 00 00 00 00       	mov    $0x0,%eax
  81a8a3:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81a8aa:	00 00 00 
  81a8ad:	ff d1                	callq  *%rcx
  conn = arg;
  81a8af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a8b3:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  81a8b7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a8bb:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a8bf:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  81a8c3:	74 2a                	je     81a8ef <recv_tcp+0xbb>
  81a8c5:	48 ba f7 37 82 00 00 	movabs $0x8237f7,%rdx
  81a8cc:	00 00 00 
  81a8cf:	be c5 00 00 00       	mov    $0xc5,%esi
  81a8d4:	48 bf 52 37 82 00 00 	movabs $0x823752,%rdi
  81a8db:	00 00 00 
  81a8de:	b8 00 00 00 00       	mov    $0x0,%eax
  81a8e3:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81a8ea:	00 00 00 
  81a8ed:	ff d1                	callq  *%rcx

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  81a8ef:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81a8f4:	74 0c                	je     81a902 <recv_tcp+0xce>
  81a8f6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a8fa:	8b 40 18             	mov    0x18(%rax),%eax
  81a8fd:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a900:	75 0a                	jne    81a90c <recv_tcp+0xd8>
    return ERR_VAL;
  81a902:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  81a907:	e9 8f 00 00 00       	jmpq   81a99b <recv_tcp+0x167>
  }

  conn->err = err;
  81a90c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a910:	0f b6 55 d4          	movzbl -0x2c(%rbp),%edx
  81a914:	88 50 10             	mov    %dl,0x10(%rax)
  if (p != NULL) {
  81a917:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  81a91c:	74 24                	je     81a942 <recv_tcp+0x10e>
    len = p->tot_len;
  81a91e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81a922:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81a926:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
    SYS_ARCH_INC(conn->recv_avail, len);
  81a92a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a92e:	0f b7 50 24          	movzwl 0x24(%rax),%edx
  81a932:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  81a936:	01 c2                	add    %eax,%edx
  81a938:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a93c:	66 89 50 24          	mov    %dx,0x24(%rax)
  81a940:	eb 06                	jmp    81a948 <recv_tcp+0x114>
  } else {
    len = 0;
  81a942:	66 c7 45 fe 00 00    	movw   $0x0,-0x2(%rbp)
  }
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  81a948:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a94c:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a950:	48 85 c0             	test   %rax,%rax
  81a953:	74 1a                	je     81a96f <recv_tcp+0x13b>
  81a955:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a959:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a95d:	0f b7 55 fe          	movzwl -0x2(%rbp),%edx
  81a961:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  81a965:	be 00 00 00 00       	mov    $0x0,%esi
  81a96a:	48 89 cf             	mov    %rcx,%rdi
  81a96d:	ff d0                	callq  *%rax
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
  81a96f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a973:	8b 40 18             	mov    0x18(%rax),%eax
  81a976:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81a97a:	48 89 d6             	mov    %rdx,%rsi
  81a97d:	89 c7                	mov    %eax,%edi
  81a97f:	48 b8 66 7b 81 00 00 	movabs $0x817b66,%rax
  81a986:	00 00 00 
  81a989:	ff d0                	callq  *%rax
  81a98b:	84 c0                	test   %al,%al
  81a98d:	74 07                	je     81a996 <recv_tcp+0x162>
    return ERR_MEM;
  81a98f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81a994:	eb 05                	jmp    81a99b <recv_tcp+0x167>
  }

  return ERR_OK;
  81a996:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81a99b:	c9                   	leaveq 
  81a99c:	c3                   	retq   

000000000081a99d <poll_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.poll) for parameters and return value
 */
static err_t
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
  81a99d:	55                   	push   %rbp
  81a99e:	48 89 e5             	mov    %rsp,%rbp
  81a9a1:	48 83 ec 20          	sub    $0x20,%rsp
  81a9a5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81a9a9:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct netconn *conn = arg;
  81a9ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a9b1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  81a9b5:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81a9ba:	75 2a                	jne    81a9e6 <poll_tcp+0x49>
  81a9bc:	48 ba 15 38 82 00 00 	movabs $0x823815,%rdx
  81a9c3:	00 00 00 
  81a9c6:	be ec 00 00 00       	mov    $0xec,%esi
  81a9cb:	48 bf 52 37 82 00 00 	movabs $0x823752,%rdi
  81a9d2:	00 00 00 
  81a9d5:	b8 00 00 00 00       	mov    $0x0,%eax
  81a9da:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81a9e1:	00 00 00 
  81a9e4:	ff d1                	callq  *%rcx

  if (conn->state == NETCONN_WRITE) {
  81a9e6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a9ea:	8b 40 04             	mov    0x4(%rax),%eax
  81a9ed:	83 f8 01             	cmp    $0x1,%eax
  81a9f0:	75 15                	jne    81aa07 <poll_tcp+0x6a>
    do_writemore(conn);
  81a9f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a9f6:	48 89 c7             	mov    %rax,%rdi
  81a9f9:	48 b8 d3 be 81 00 00 	movabs $0x81bed3,%rax
  81aa00:	00 00 00 
  81aa03:	ff d0                	callq  *%rax
  81aa05:	eb 1f                	jmp    81aa26 <poll_tcp+0x89>
  } else if (conn->state == NETCONN_CLOSE) {
  81aa07:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aa0b:	8b 40 04             	mov    0x4(%rax),%eax
  81aa0e:	83 f8 04             	cmp    $0x4,%eax
  81aa11:	75 13                	jne    81aa26 <poll_tcp+0x89>
    do_close_internal(conn);
  81aa13:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aa17:	48 89 c7             	mov    %rax,%rdi
  81aa1a:	48 b8 4b b3 81 00 00 	movabs $0x81b34b,%rax
  81aa21:	00 00 00 
  81aa24:	ff d0                	callq  *%rax
  }

  return ERR_OK;
  81aa26:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81aa2b:	c9                   	leaveq 
  81aa2c:	c3                   	retq   

000000000081aa2d <sent_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.sent) for parameters and return value
 */
static err_t
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
  81aa2d:	55                   	push   %rbp
  81aa2e:	48 89 e5             	mov    %rsp,%rbp
  81aa31:	48 83 ec 30          	sub    $0x30,%rsp
  81aa35:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81aa39:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81aa3d:	89 d0                	mov    %edx,%eax
  81aa3f:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
  struct netconn *conn = arg;
  81aa43:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aa47:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  81aa4b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81aa50:	75 2a                	jne    81aa7c <sent_tcp+0x4f>
  81aa52:	48 ba 15 38 82 00 00 	movabs $0x823815,%rdx
  81aa59:	00 00 00 
  81aa5c:	be 04 01 00 00       	mov    $0x104,%esi
  81aa61:	48 bf 52 37 82 00 00 	movabs $0x823752,%rdi
  81aa68:	00 00 00 
  81aa6b:	b8 00 00 00 00       	mov    $0x0,%eax
  81aa70:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81aa77:	00 00 00 
  81aa7a:	ff d1                	callq  *%rcx

  if (conn->state == NETCONN_WRITE) {
  81aa7c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aa80:	8b 40 04             	mov    0x4(%rax),%eax
  81aa83:	83 f8 01             	cmp    $0x1,%eax
  81aa86:	75 4c                	jne    81aad4 <sent_tcp+0xa7>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  81aa88:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aa8c:	48 8b 40 08          	mov    0x8(%rax),%rax
  81aa90:	48 85 c0             	test   %rax,%rax
  81aa93:	75 2a                	jne    81aabf <sent_tcp+0x92>
  81aa95:	48 ba 22 38 82 00 00 	movabs $0x823822,%rdx
  81aa9c:	00 00 00 
  81aa9f:	be 07 01 00 00       	mov    $0x107,%esi
  81aaa4:	48 bf 52 37 82 00 00 	movabs $0x823752,%rdi
  81aaab:	00 00 00 
  81aaae:	b8 00 00 00 00       	mov    $0x0,%eax
  81aab3:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81aaba:	00 00 00 
  81aabd:	ff d1                	callq  *%rcx
    do_writemore(conn);
  81aabf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aac3:	48 89 c7             	mov    %rax,%rdi
  81aac6:	48 b8 d3 be 81 00 00 	movabs $0x81bed3,%rax
  81aacd:	00 00 00 
  81aad0:	ff d0                	callq  *%rax
  81aad2:	eb 1f                	jmp    81aaf3 <sent_tcp+0xc6>
  } else if (conn->state == NETCONN_CLOSE) {
  81aad4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aad8:	8b 40 04             	mov    0x4(%rax),%eax
  81aadb:	83 f8 04             	cmp    $0x4,%eax
  81aade:	75 13                	jne    81aaf3 <sent_tcp+0xc6>
    do_close_internal(conn);
  81aae0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aae4:	48 89 c7             	mov    %rax,%rdi
  81aae7:	48 b8 4b b3 81 00 00 	movabs $0x81b34b,%rax
  81aaee:	00 00 00 
  81aaf1:	ff d0                	callq  *%rax
  }

  if (conn) {
  81aaf3:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81aaf8:	74 46                	je     81ab40 <sent_tcp+0x113>
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  81aafa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aafe:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ab02:	48 85 c0             	test   %rax,%rax
  81ab05:	74 39                	je     81ab40 <sent_tcp+0x113>
  81ab07:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ab0b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ab0f:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  81ab13:	66 3d a0 2d          	cmp    $0x2da0,%ax
  81ab17:	76 27                	jbe    81ab40 <sent_tcp+0x113>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
  81ab19:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ab1d:	48 8b 40 38          	mov    0x38(%rax),%rax
  81ab21:	48 85 c0             	test   %rax,%rax
  81ab24:	74 1a                	je     81ab40 <sent_tcp+0x113>
  81ab26:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ab2a:	48 8b 40 38          	mov    0x38(%rax),%rax
  81ab2e:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  81ab32:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  81ab36:	be 02 00 00 00       	mov    $0x2,%esi
  81ab3b:	48 89 cf             	mov    %rcx,%rdi
  81ab3e:	ff d0                	callq  *%rax
    }
  }
  
  return ERR_OK;
  81ab40:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81ab45:	c9                   	leaveq 
  81ab46:	c3                   	retq   

000000000081ab47 <err_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.err) for parameters
 */
static void
err_tcp(void *arg, err_t err)
{
  81ab47:	55                   	push   %rbp
  81ab48:	48 89 e5             	mov    %rsp,%rbp
  81ab4b:	48 83 ec 20          	sub    $0x20,%rsp
  81ab4f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81ab53:	89 f0                	mov    %esi,%eax
  81ab55:	88 45 e4             	mov    %al,-0x1c(%rbp)
  struct netconn *conn;

  conn = arg;
  81ab58:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ab5c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  81ab60:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81ab65:	75 2a                	jne    81ab91 <err_tcp+0x4a>
  81ab67:	48 ba 15 38 82 00 00 	movabs $0x823815,%rdx
  81ab6e:	00 00 00 
  81ab71:	be 23 01 00 00       	mov    $0x123,%esi
  81ab76:	48 bf 52 37 82 00 00 	movabs $0x823752,%rdi
  81ab7d:	00 00 00 
  81ab80:	b8 00 00 00 00       	mov    $0x0,%eax
  81ab85:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81ab8c:	00 00 00 
  81ab8f:	ff d1                	callq  *%rcx

  conn->pcb.tcp = NULL;
  81ab91:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ab95:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81ab9c:	00 

  conn->err = err;
  81ab9d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aba1:	0f b6 55 e4          	movzbl -0x1c(%rbp),%edx
  81aba5:	88 50 10             	mov    %dl,0x10(%rax)
  if (conn->recvmbox != SYS_MBOX_NULL) {
  81aba8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81abac:	8b 40 18             	mov    0x18(%rax),%eax
  81abaf:	83 f8 ff             	cmp    $0xffffffff,%eax
  81abb2:	74 42                	je     81abf6 <err_tcp+0xaf>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  81abb4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81abb8:	48 8b 40 38          	mov    0x38(%rax),%rax
  81abbc:	48 85 c0             	test   %rax,%rax
  81abbf:	74 1b                	je     81abdc <err_tcp+0x95>
  81abc1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81abc5:	48 8b 40 38          	mov    0x38(%rax),%rax
  81abc9:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  81abcd:	ba 00 00 00 00       	mov    $0x0,%edx
  81abd2:	be 00 00 00 00       	mov    $0x0,%esi
  81abd7:	48 89 cf             	mov    %rcx,%rdi
  81abda:	ff d0                	callq  *%rax
    sys_mbox_post(conn->recvmbox, NULL);
  81abdc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81abe0:	8b 40 18             	mov    0x18(%rax),%eax
  81abe3:	be 00 00 00 00       	mov    $0x0,%esi
  81abe8:	89 c7                	mov    %eax,%edi
  81abea:	48 b8 04 7b 81 00 00 	movabs $0x817b04,%rax
  81abf1:	00 00 00 
  81abf4:	ff d0                	callq  *%rax
  }
  if (conn->op_completed != SYS_SEM_NULL && conn->state == NETCONN_CONNECT) {
  81abf6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81abfa:	8b 40 14             	mov    0x14(%rax),%eax
  81abfd:	83 f8 ff             	cmp    $0xffffffff,%eax
  81ac00:	74 2c                	je     81ac2e <err_tcp+0xe7>
  81ac02:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ac06:	8b 40 04             	mov    0x4(%rax),%eax
  81ac09:	83 f8 03             	cmp    $0x3,%eax
  81ac0c:	75 20                	jne    81ac2e <err_tcp+0xe7>
    conn->state = NETCONN_NONE;
  81ac0e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ac12:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    sys_sem_signal(conn->op_completed);
  81ac19:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ac1d:	8b 40 14             	mov    0x14(%rax),%eax
  81ac20:	89 c7                	mov    %eax,%edi
  81ac22:	48 b8 4c 80 81 00 00 	movabs $0x81804c,%rax
  81ac29:	00 00 00 
  81ac2c:	ff d0                	callq  *%rax
  }
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  81ac2e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ac32:	8b 40 1c             	mov    0x1c(%rax),%eax
  81ac35:	83 f8 ff             	cmp    $0xffffffff,%eax
  81ac38:	74 42                	je     81ac7c <err_tcp+0x135>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  81ac3a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ac3e:	48 8b 40 38          	mov    0x38(%rax),%rax
  81ac42:	48 85 c0             	test   %rax,%rax
  81ac45:	74 1b                	je     81ac62 <err_tcp+0x11b>
  81ac47:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ac4b:	48 8b 40 38          	mov    0x38(%rax),%rax
  81ac4f:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  81ac53:	ba 00 00 00 00       	mov    $0x0,%edx
  81ac58:	be 00 00 00 00       	mov    $0x0,%esi
  81ac5d:	48 89 cf             	mov    %rcx,%rdi
  81ac60:	ff d0                	callq  *%rax
    sys_mbox_post(conn->acceptmbox, NULL);
  81ac62:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ac66:	8b 40 1c             	mov    0x1c(%rax),%eax
  81ac69:	be 00 00 00 00       	mov    $0x0,%esi
  81ac6e:	89 c7                	mov    %eax,%edi
  81ac70:	48 b8 04 7b 81 00 00 	movabs $0x817b04,%rax
  81ac77:	00 00 00 
  81ac7a:	ff d0                	callq  *%rax
  }
  if ((conn->state == NETCONN_WRITE) || (conn->state == NETCONN_CLOSE)) {
  81ac7c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ac80:	8b 40 04             	mov    0x4(%rax),%eax
  81ac83:	83 f8 01             	cmp    $0x1,%eax
  81ac86:	74 0c                	je     81ac94 <err_tcp+0x14d>
  81ac88:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ac8c:	8b 40 04             	mov    0x4(%rax),%eax
  81ac8f:	83 f8 04             	cmp    $0x4,%eax
  81ac92:	75 20                	jne    81acb4 <err_tcp+0x16d>
    /* calling do_writemore/do_close_internal is not necessary
       since the pcb has already been deleted! */
    conn->state = NETCONN_NONE;
  81ac94:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ac98:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    /* wake up the waiting task */
    sys_sem_signal(conn->op_completed);
  81ac9f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aca3:	8b 40 14             	mov    0x14(%rax),%eax
  81aca6:	89 c7                	mov    %eax,%edi
  81aca8:	48 b8 4c 80 81 00 00 	movabs $0x81804c,%rax
  81acaf:	00 00 00 
  81acb2:	ff d0                	callq  *%rax
  }
}
  81acb4:	c9                   	leaveq 
  81acb5:	c3                   	retq   

000000000081acb6 <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
  81acb6:	55                   	push   %rbp
  81acb7:	48 89 e5             	mov    %rsp,%rbp
  81acba:	48 83 ec 20          	sub    $0x20,%rsp
  81acbe:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
  81acc2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81acc6:	48 8b 40 08          	mov    0x8(%rax),%rax
  81acca:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  tcp_arg(pcb, conn);
  81acce:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81acd2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81acd6:	48 89 d6             	mov    %rdx,%rsi
  81acd9:	48 89 c7             	mov    %rax,%rdi
  81acdc:	48 b8 d7 08 81 00 00 	movabs $0x8108d7,%rax
  81ace3:	00 00 00 
  81ace6:	ff d0                	callq  *%rax
  tcp_recv(pcb, recv_tcp);
  81ace8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81acec:	48 be 34 a8 81 00 00 	movabs $0x81a834,%rsi
  81acf3:	00 00 00 
  81acf6:	48 89 c7             	mov    %rax,%rdi
  81acf9:	48 b8 f5 08 81 00 00 	movabs $0x8108f5,%rax
  81ad00:	00 00 00 
  81ad03:	ff d0                	callq  *%rax
  tcp_sent(pcb, sent_tcp);
  81ad05:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ad09:	48 be 2d aa 81 00 00 	movabs $0x81aa2d,%rsi
  81ad10:	00 00 00 
  81ad13:	48 89 c7             	mov    %rax,%rdi
  81ad16:	48 b8 16 09 81 00 00 	movabs $0x810916,%rax
  81ad1d:	00 00 00 
  81ad20:	ff d0                	callq  *%rax
  tcp_poll(pcb, poll_tcp, 4);
  81ad22:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ad26:	ba 04 00 00 00       	mov    $0x4,%edx
  81ad2b:	48 be 9d a9 81 00 00 	movabs $0x81a99d,%rsi
  81ad32:	00 00 00 
  81ad35:	48 89 c7             	mov    %rax,%rdi
  81ad38:	48 b8 76 09 81 00 00 	movabs $0x810976,%rax
  81ad3f:	00 00 00 
  81ad42:	ff d0                	callq  *%rax
  tcp_err(pcb, err_tcp);
  81ad44:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ad48:	48 be 47 ab 81 00 00 	movabs $0x81ab47,%rsi
  81ad4f:	00 00 00 
  81ad52:	48 89 c7             	mov    %rax,%rdi
  81ad55:	48 b8 37 09 81 00 00 	movabs $0x810937,%rax
  81ad5c:	00 00 00 
  81ad5f:	ff d0                	callq  *%rax
}
  81ad61:	c9                   	leaveq 
  81ad62:	c3                   	retq   

000000000081ad63 <accept_function>:
 *
 * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
 */
static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
  81ad63:	55                   	push   %rbp
  81ad64:	48 89 e5             	mov    %rsp,%rbp
  81ad67:	48 83 ec 30          	sub    $0x30,%rsp
  81ad6b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81ad6f:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81ad73:	89 d0                	mov    %edx,%eax
  81ad75:	88 45 dc             	mov    %al,-0x24(%rbp)
#if API_MSG_DEBUG
#if TCP_DEBUG
  tcp_debug_print_state(newpcb->state);
#endif /* TCP_DEBUG */
#endif /* API_MSG_DEBUG */
  conn = (struct netconn *)arg;
  81ad78:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ad7c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  81ad80:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ad84:	8b 40 1c             	mov    0x1c(%rax),%eax
  81ad87:	83 f8 ff             	cmp    $0xffffffff,%eax
  81ad8a:	75 2a                	jne    81adb6 <accept_function+0x53>
  81ad8c:	48 ba 38 38 82 00 00 	movabs $0x823838,%rdx
  81ad93:	00 00 00 
  81ad96:	be 66 01 00 00       	mov    $0x166,%esi
  81ad9b:	48 bf 52 37 82 00 00 	movabs $0x823752,%rdi
  81ada2:	00 00 00 
  81ada5:	b8 00 00 00 00       	mov    $0x0,%eax
  81adaa:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81adb1:	00 00 00 
  81adb4:	ff d1                	callq  *%rcx
             conn->acceptmbox != SYS_MBOX_NULL, return ERR_VAL;);

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
  81adb6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81adba:	48 8b 50 38          	mov    0x38(%rax),%rdx
  81adbe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81adc2:	8b 00                	mov    (%rax),%eax
  81adc4:	48 89 d6             	mov    %rdx,%rsi
  81adc7:	89 c7                	mov    %eax,%edi
  81adc9:	48 b8 ad b0 81 00 00 	movabs $0x81b0ad,%rax
  81add0:	00 00 00 
  81add3:	ff d0                	callq  *%rax
  81add5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (newconn == NULL) {
  81add9:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81adde:	75 0a                	jne    81adea <accept_function+0x87>
    return ERR_MEM;
  81ade0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81ade5:	e9 9d 00 00 00       	jmpq   81ae87 <accept_function+0x124>
  }
  newconn->pcb.tcp = newpcb;
  81adea:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81adee:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81adf2:	48 89 50 08          	mov    %rdx,0x8(%rax)
  setup_tcp(newconn);
  81adf6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81adfa:	48 89 c7             	mov    %rax,%rdi
  81adfd:	48 b8 b6 ac 81 00 00 	movabs $0x81acb6,%rax
  81ae04:	00 00 00 
  81ae07:	ff d0                	callq  *%rax
  newconn->err = err;
  81ae09:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81ae0d:	0f b6 55 dc          	movzbl -0x24(%rbp),%edx
  81ae11:	88 50 10             	mov    %dl,0x10(%rax)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  81ae14:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ae18:	48 8b 40 38          	mov    0x38(%rax),%rax
  81ae1c:	48 85 c0             	test   %rax,%rax
  81ae1f:	74 1b                	je     81ae3c <accept_function+0xd9>
  81ae21:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ae25:	48 8b 40 38          	mov    0x38(%rax),%rax
  81ae29:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  81ae2d:	ba 00 00 00 00       	mov    $0x0,%edx
  81ae32:	be 00 00 00 00       	mov    $0x0,%esi
  81ae37:	48 89 cf             	mov    %rcx,%rdi
  81ae3a:	ff d0                	callq  *%rax

  if (sys_mbox_trypost(conn->acceptmbox, newconn) != ERR_OK) {
  81ae3c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ae40:	8b 40 1c             	mov    0x1c(%rax),%eax
  81ae43:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81ae47:	48 89 d6             	mov    %rdx,%rsi
  81ae4a:	89 c7                	mov    %eax,%edi
  81ae4c:	48 b8 66 7b 81 00 00 	movabs $0x817b66,%rax
  81ae53:	00 00 00 
  81ae56:	ff d0                	callq  *%rax
  81ae58:	84 c0                	test   %al,%al
  81ae5a:	74 26                	je     81ae82 <accept_function+0x11f>
    /* When returning != ERR_OK, the connection is aborted in tcp_process(),
       so do nothing here! */
    newconn->pcb.tcp = NULL;
  81ae5c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81ae60:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81ae67:	00 
    netconn_free(newconn);
  81ae68:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81ae6c:	48 89 c7             	mov    %rax,%rdi
  81ae6f:	48 b8 e1 b1 81 00 00 	movabs $0x81b1e1,%rax
  81ae76:	00 00 00 
  81ae79:	ff d0                	callq  *%rax
    return ERR_MEM;
  81ae7b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81ae80:	eb 05                	jmp    81ae87 <accept_function+0x124>
  }
  return ERR_OK;
  81ae82:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81ae87:	c9                   	leaveq 
  81ae88:	c3                   	retq   

000000000081ae89 <pcb_new>:
 * @param msg the api_msg_msg describing the connection type
 * @return msg->conn->err, but the return value is currently ignored
 */
static err_t
pcb_new(struct api_msg_msg *msg)
{
  81ae89:	55                   	push   %rbp
  81ae8a:	48 89 e5             	mov    %rsp,%rbp
  81ae8d:	53                   	push   %rbx
  81ae8e:	48 83 ec 18          	sub    $0x18,%rsp
  81ae92:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
   msg->conn->err = ERR_OK;
  81ae96:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ae9a:	48 8b 00             	mov    (%rax),%rax
  81ae9d:	c6 40 10 00          	movb   $0x0,0x10(%rax)

   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  81aea1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aea5:	48 8b 00             	mov    (%rax),%rax
  81aea8:	48 8b 40 08          	mov    0x8(%rax),%rax
  81aeac:	48 85 c0             	test   %rax,%rax
  81aeaf:	74 2a                	je     81aedb <pcb_new+0x52>
  81aeb1:	48 ba 68 38 82 00 00 	movabs $0x823868,%rdx
  81aeb8:	00 00 00 
  81aebb:	be 8b 01 00 00       	mov    $0x18b,%esi
  81aec0:	48 bf 52 37 82 00 00 	movabs $0x823752,%rdi
  81aec7:	00 00 00 
  81aeca:	b8 00 00 00 00       	mov    $0x0,%eax
  81aecf:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81aed6:	00 00 00 
  81aed9:	ff d1                	callq  *%rcx

   /* Allocate a PCB for this connection */
   switch(NETCONNTYPE_GROUP(msg->conn->type)) {
  81aedb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aedf:	48 8b 00             	mov    (%rax),%rax
  81aee2:	8b 00                	mov    (%rax),%eax
  81aee4:	25 f0 00 00 00       	and    $0xf0,%eax
  81aee9:	83 f8 20             	cmp    $0x20,%eax
  81aeec:	0f 84 87 00 00 00    	je     81af79 <pcb_new+0xf0>
  81aef2:	83 f8 40             	cmp    $0x40,%eax
  81aef5:	74 0e                	je     81af05 <pcb_new+0x7c>
  81aef7:	83 f8 10             	cmp    $0x10,%eax
  81aefa:	0f 84 fa 00 00 00    	je     81affa <pcb_new+0x171>
  81af00:	e9 41 01 00 00       	jmpq   81b046 <pcb_new+0x1bd>
#if LWIP_RAW
   case NETCONN_RAW:
     msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
  81af05:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81af09:	48 8b 18             	mov    (%rax),%rbx
  81af0c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81af10:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  81af14:	0f b6 c0             	movzbl %al,%eax
  81af17:	89 c7                	mov    %eax,%edi
  81af19:	48 b8 5f 01 82 00 00 	movabs $0x82015f,%rax
  81af20:	00 00 00 
  81af23:	ff d0                	callq  *%rax
  81af25:	48 89 43 08          	mov    %rax,0x8(%rbx)
     if(msg->conn->pcb.raw == NULL) {
  81af29:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81af2d:	48 8b 00             	mov    (%rax),%rax
  81af30:	48 8b 40 08          	mov    0x8(%rax),%rax
  81af34:	48 85 c0             	test   %rax,%rax
  81af37:	75 10                	jne    81af49 <pcb_new+0xc0>
       msg->conn->err = ERR_MEM;
  81af39:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81af3d:	48 8b 00             	mov    (%rax),%rax
  81af40:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
       break;
  81af44:	e9 09 01 00 00       	jmpq   81b052 <pcb_new+0x1c9>
     }
     raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  81af49:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81af4d:	48 8b 10             	mov    (%rax),%rdx
  81af50:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81af54:	48 8b 00             	mov    (%rax),%rax
  81af57:	48 8b 40 08          	mov    0x8(%rax),%rax
  81af5b:	48 be c1 a4 81 00 00 	movabs $0x81a4c1,%rsi
  81af62:	00 00 00 
  81af65:	48 89 c7             	mov    %rax,%rdi
  81af68:	48 b8 af fe 81 00 00 	movabs $0x81feaf,%rax
  81af6f:	00 00 00 
  81af72:	ff d0                	callq  *%rax
     break;
  81af74:	e9 d9 00 00 00       	jmpq   81b052 <pcb_new+0x1c9>
#endif /* LWIP_RAW */
#if LWIP_UDP
   case NETCONN_UDP:
     msg->conn->pcb.udp = udp_new();
  81af79:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81af7d:	48 8b 18             	mov    (%rax),%rbx
  81af80:	48 b8 46 59 81 00 00 	movabs $0x815946,%rax
  81af87:	00 00 00 
  81af8a:	ff d0                	callq  *%rax
  81af8c:	48 89 43 08          	mov    %rax,0x8(%rbx)
     if(msg->conn->pcb.udp == NULL) {
  81af90:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81af94:	48 8b 00             	mov    (%rax),%rax
  81af97:	48 8b 40 08          	mov    0x8(%rax),%rax
  81af9b:	48 85 c0             	test   %rax,%rax
  81af9e:	75 10                	jne    81afb0 <pcb_new+0x127>
       msg->conn->err = ERR_MEM;
  81afa0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81afa4:	48 8b 00             	mov    (%rax),%rax
  81afa7:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
       break;
  81afab:	e9 a2 00 00 00       	jmpq   81b052 <pcb_new+0x1c9>
#if LWIP_UDPLITE
     if (msg->conn->type==NETCONN_UDPLITE) {
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
     }
#endif /* LWIP_UDPLITE */
     if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
  81afb0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81afb4:	48 8b 00             	mov    (%rax),%rax
  81afb7:	8b 00                	mov    (%rax),%eax
  81afb9:	83 f8 22             	cmp    $0x22,%eax
  81afbc:	75 0f                	jne    81afcd <pcb_new+0x144>
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  81afbe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81afc2:	48 8b 00             	mov    (%rax),%rax
  81afc5:	48 8b 40 08          	mov    0x8(%rax),%rax
  81afc9:	c6 40 18 01          	movb   $0x1,0x18(%rax)
     }
     udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  81afcd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81afd1:	48 8b 10             	mov    (%rax),%rdx
  81afd4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81afd8:	48 8b 00             	mov    (%rax),%rax
  81afdb:	48 8b 40 08          	mov    0x8(%rax),%rax
  81afdf:	48 be 67 a6 81 00 00 	movabs $0x81a667,%rsi
  81afe6:	00 00 00 
  81afe9:	48 89 c7             	mov    %rax,%rdi
  81afec:	48 b8 6e 58 81 00 00 	movabs $0x81586e,%rax
  81aff3:	00 00 00 
  81aff6:	ff d0                	callq  *%rax
     break;
  81aff8:	eb 58                	jmp    81b052 <pcb_new+0x1c9>
#endif /* LWIP_UDP */
#if LWIP_TCP
   case NETCONN_TCP:
     msg->conn->pcb.tcp = tcp_new();
  81affa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81affe:	48 8b 18             	mov    (%rax),%rbx
  81b001:	48 b8 c0 08 81 00 00 	movabs $0x8108c0,%rax
  81b008:	00 00 00 
  81b00b:	ff d0                	callq  *%rax
  81b00d:	48 89 43 08          	mov    %rax,0x8(%rbx)
     if(msg->conn->pcb.tcp == NULL) {
  81b011:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b015:	48 8b 00             	mov    (%rax),%rax
  81b018:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b01c:	48 85 c0             	test   %rax,%rax
  81b01f:	75 0d                	jne    81b02e <pcb_new+0x1a5>
       msg->conn->err = ERR_MEM;
  81b021:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b025:	48 8b 00             	mov    (%rax),%rax
  81b028:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
       break;
  81b02c:	eb 24                	jmp    81b052 <pcb_new+0x1c9>
     }
     setup_tcp(msg->conn);
  81b02e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b032:	48 8b 00             	mov    (%rax),%rax
  81b035:	48 89 c7             	mov    %rax,%rdi
  81b038:	48 b8 b6 ac 81 00 00 	movabs $0x81acb6,%rax
  81b03f:	00 00 00 
  81b042:	ff d0                	callq  *%rax
     break;
  81b044:	eb 0c                	jmp    81b052 <pcb_new+0x1c9>
#endif /* LWIP_TCP */
   default:
     /* Unsupported netconn type, e.g. protocol disabled */
     msg->conn->err = ERR_VAL;
  81b046:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b04a:	48 8b 00             	mov    (%rax),%rax
  81b04d:	c6 40 10 f7          	movb   $0xf7,0x10(%rax)
     break;
  81b051:	90                   	nop
   }

  return msg->conn->err;
  81b052:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b056:	48 8b 00             	mov    (%rax),%rax
  81b059:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  81b05d:	48 83 c4 18          	add    $0x18,%rsp
  81b061:	5b                   	pop    %rbx
  81b062:	5d                   	pop    %rbp
  81b063:	c3                   	retq   

000000000081b064 <do_newconn>:
 *
 * @param msg the api_msg_msg describing the connection type
 */
void
do_newconn(struct api_msg_msg *msg)
{
  81b064:	55                   	push   %rbp
  81b065:	48 89 e5             	mov    %rsp,%rbp
  81b068:	48 83 ec 10          	sub    $0x10,%rsp
  81b06c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   if(msg->conn->pcb.tcp == NULL) {
  81b070:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b074:	48 8b 00             	mov    (%rax),%rax
  81b077:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b07b:	48 85 c0             	test   %rax,%rax
  81b07e:	75 13                	jne    81b093 <do_newconn+0x2f>
     pcb_new(msg);
  81b080:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b084:	48 89 c7             	mov    %rax,%rdi
  81b087:	48 b8 89 ae 81 00 00 	movabs $0x81ae89,%rax
  81b08e:	00 00 00 
  81b091:	ff d0                	callq  *%rax
   }
   /* Else? This "new" connection already has a PCB allocated. */
   /* Is this an error condition? Should it be deleted? */
   /* We currently just are happy and return. */

   TCPIP_APIMSG_ACK(msg);
  81b093:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b097:	48 8b 00             	mov    (%rax),%rax
  81b09a:	8b 40 14             	mov    0x14(%rax),%eax
  81b09d:	89 c7                	mov    %eax,%edi
  81b09f:	48 b8 4c 80 81 00 00 	movabs $0x81804c,%rax
  81b0a6:	00 00 00 
  81b0a9:	ff d0                	callq  *%rax
}
  81b0ab:	c9                   	leaveq 
  81b0ac:	c3                   	retq   

000000000081b0ad <netconn_alloc>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_alloc(enum netconn_type t, netconn_callback callback)
{
  81b0ad:	55                   	push   %rbp
  81b0ae:	48 89 e5             	mov    %rsp,%rbp
  81b0b1:	48 83 ec 20          	sub    $0x20,%rsp
  81b0b5:	89 7d ec             	mov    %edi,-0x14(%rbp)
  81b0b8:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct netconn *conn;
  int size;

  conn = memp_malloc(MEMP_NETCONN);
  81b0bc:	bf 07 00 00 00       	mov    $0x7,%edi
  81b0c1:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  81b0c8:	00 00 00 
  81b0cb:	ff d0                	callq  *%rax
  81b0cd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (conn == NULL) {
  81b0d1:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81b0d6:	75 0a                	jne    81b0e2 <netconn_alloc+0x35>
    return NULL;
  81b0d8:	b8 00 00 00 00       	mov    $0x0,%eax
  81b0dd:	e9 fd 00 00 00       	jmpq   81b1df <netconn_alloc+0x132>
  }

  conn->err = ERR_OK;
  81b0e2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b0e6:	c6 40 10 00          	movb   $0x0,0x10(%rax)
  conn->type = t;
  81b0ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b0ee:	8b 55 ec             	mov    -0x14(%rbp),%edx
  81b0f1:	89 10                	mov    %edx,(%rax)
  conn->pcb.tcp = NULL;
  81b0f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b0f7:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81b0fe:	00 

#if (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_UDP_RECVMBOX_SIZE) && \
    (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_TCP_RECVMBOX_SIZE)
  size = DEFAULT_RAW_RECVMBOX_SIZE;
  81b0ff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
    LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
    break;
  }
#endif

  if ((conn->op_completed = sys_sem_new(0)) == SYS_SEM_NULL) {
  81b106:	bf 00 00 00 00       	mov    $0x0,%edi
  81b10b:	48 b8 cc 7d 81 00 00 	movabs $0x817dcc,%rax
  81b112:	00 00 00 
  81b115:	ff d0                	callq  *%rax
  81b117:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81b11b:	89 42 14             	mov    %eax,0x14(%rdx)
  81b11e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b122:	8b 40 14             	mov    0x14(%rax),%eax
  81b125:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b128:	75 22                	jne    81b14c <netconn_alloc+0x9f>
    memp_free(MEMP_NETCONN, conn);
  81b12a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b12e:	48 89 c6             	mov    %rax,%rsi
  81b131:	bf 07 00 00 00       	mov    $0x7,%edi
  81b136:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  81b13d:	00 00 00 
  81b140:	ff d0                	callq  *%rax
    return NULL;
  81b142:	b8 00 00 00 00       	mov    $0x0,%eax
  81b147:	e9 93 00 00 00       	jmpq   81b1df <netconn_alloc+0x132>
  }
  if ((conn->recvmbox = sys_mbox_new(size)) == SYS_MBOX_NULL) {
  81b14c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  81b14f:	89 c7                	mov    %eax,%edi
  81b151:	48 b8 d5 76 81 00 00 	movabs $0x8176d5,%rax
  81b158:	00 00 00 
  81b15b:	ff d0                	callq  *%rax
  81b15d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81b161:	89 42 18             	mov    %eax,0x18(%rdx)
  81b164:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b168:	8b 40 18             	mov    0x18(%rax),%eax
  81b16b:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b16e:	75 34                	jne    81b1a4 <netconn_alloc+0xf7>
    sys_sem_free(conn->op_completed);
  81b170:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b174:	8b 40 14             	mov    0x14(%rax),%eax
  81b177:	89 c7                	mov    %eax,%edi
  81b179:	48 b8 ca 7e 81 00 00 	movabs $0x817eca,%rax
  81b180:	00 00 00 
  81b183:	ff d0                	callq  *%rax
    memp_free(MEMP_NETCONN, conn);
  81b185:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b189:	48 89 c6             	mov    %rax,%rsi
  81b18c:	bf 07 00 00 00       	mov    $0x7,%edi
  81b191:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  81b198:	00 00 00 
  81b19b:	ff d0                	callq  *%rax
    return NULL;
  81b19d:	b8 00 00 00 00       	mov    $0x0,%eax
  81b1a2:	eb 3b                	jmp    81b1df <netconn_alloc+0x132>
  }

  conn->acceptmbox   = SYS_MBOX_NULL;
  81b1a4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b1a8:	c7 40 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%rax)
  conn->state        = NETCONN_NONE;
  81b1af:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b1b3:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
  /* initialize socket to -1 since 0 is a valid socket */
  conn->socket       = -1;
  81b1ba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b1be:	c7 40 20 ff ff ff ff 	movl   $0xffffffff,0x20(%rax)
  conn->callback     = callback;
  81b1c5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b1c9:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81b1cd:	48 89 50 38          	mov    %rdx,0x38(%rax)
  conn->recv_avail   = 0;
  81b1d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b1d5:	66 c7 40 24 00 00    	movw   $0x0,0x24(%rax)
  conn->recv_timeout = 0;
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = INT_MAX;
#endif /* LWIP_SO_RCVBUF */
  return conn;
  81b1db:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  81b1df:	c9                   	leaveq 
  81b1e0:	c3                   	retq   

000000000081b1e1 <netconn_free>:
 *
 * @param conn the netconn to free
 */
void
netconn_free(struct netconn *conn)
{
  81b1e1:	55                   	push   %rbp
  81b1e2:	48 89 e5             	mov    %rsp,%rbp
  81b1e5:	48 83 ec 20          	sub    $0x20,%rsp
  81b1e9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  81b1ed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b1f1:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b1f5:	48 85 c0             	test   %rax,%rax
  81b1f8:	74 2a                	je     81b224 <netconn_free+0x43>
  81b1fa:	48 ba 88 38 82 00 00 	movabs $0x823888,%rdx
  81b201:	00 00 00 
  81b204:	be 27 02 00 00       	mov    $0x227,%esi
  81b209:	48 bf 52 37 82 00 00 	movabs $0x823752,%rdi
  81b210:	00 00 00 
  81b213:	b8 00 00 00 00       	mov    $0x0,%eax
  81b218:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81b21f:	00 00 00 
  81b222:	ff d1                	callq  *%rcx

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
  81b224:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b228:	8b 40 18             	mov    0x18(%rax),%eax
  81b22b:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b22e:	74 7f                	je     81b2af <netconn_free+0xce>
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  81b230:	eb 3c                	jmp    81b26e <netconn_free+0x8d>
      if (conn->type == NETCONN_TCP) {
  81b232:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b236:	8b 00                	mov    (%rax),%eax
  81b238:	83 f8 10             	cmp    $0x10,%eax
  81b23b:	75 1e                	jne    81b25b <netconn_free+0x7a>
        if(mem != NULL) {
  81b23d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b241:	48 85 c0             	test   %rax,%rax
  81b244:	74 28                	je     81b26e <netconn_free+0x8d>
          pbuf_free((struct pbuf *)mem);
  81b246:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b24a:	48 89 c7             	mov    %rax,%rdi
  81b24d:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  81b254:	00 00 00 
  81b257:	ff d0                	callq  *%rax
  81b259:	eb 13                	jmp    81b26e <netconn_free+0x8d>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
  81b25b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b25f:	48 89 c7             	mov    %rax,%rdi
  81b262:	48 b8 b5 8e 80 00 00 	movabs $0x808eb5,%rax
  81b269:	00 00 00 
  81b26c:	ff d0                	callq  *%rax
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  81b26e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b272:	8b 40 18             	mov    0x18(%rax),%eax
  81b275:	48 8d 55 f8          	lea    -0x8(%rbp),%rdx
  81b279:	48 89 d6             	mov    %rdx,%rsi
  81b27c:	89 c7                	mov    %eax,%edi
  81b27e:	48 b8 eb 85 81 00 00 	movabs $0x8185eb,%rax
  81b285:	00 00 00 
  81b288:	ff d0                	callq  *%rax
  81b28a:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b28d:	75 a3                	jne    81b232 <netconn_free+0x51>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
      }
    }
    sys_mbox_free(conn->recvmbox);
  81b28f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b293:	8b 40 18             	mov    0x18(%rax),%eax
  81b296:	89 c7                	mov    %eax,%edi
  81b298:	48 b8 b5 78 81 00 00 	movabs $0x8178b5,%rax
  81b29f:	00 00 00 
  81b2a2:	ff d0                	callq  *%rax
    conn->recvmbox = SYS_MBOX_NULL;
  81b2a4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b2a8:	c7 40 18 ff ff ff ff 	movl   $0xffffffff,0x18(%rax)
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  81b2af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b2b3:	8b 40 1c             	mov    0x1c(%rax),%eax
  81b2b6:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b2b9:	74 56                	je     81b311 <netconn_free+0x130>
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  81b2bb:	eb 13                	jmp    81b2d0 <netconn_free+0xef>
      netconn_delete((struct netconn *)mem);
  81b2bd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b2c1:	48 89 c7             	mov    %rax,%rdi
  81b2c4:	48 b8 ce 9b 81 00 00 	movabs $0x819bce,%rax
  81b2cb:	00 00 00 
  81b2ce:	ff d0                	callq  *%rax
    conn->recvmbox = SYS_MBOX_NULL;
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  81b2d0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b2d4:	8b 40 1c             	mov    0x1c(%rax),%eax
  81b2d7:	48 8d 55 f8          	lea    -0x8(%rbp),%rdx
  81b2db:	48 89 d6             	mov    %rdx,%rsi
  81b2de:	89 c7                	mov    %eax,%edi
  81b2e0:	48 b8 eb 85 81 00 00 	movabs $0x8185eb,%rax
  81b2e7:	00 00 00 
  81b2ea:	ff d0                	callq  *%rax
  81b2ec:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b2ef:	75 cc                	jne    81b2bd <netconn_free+0xdc>
      netconn_delete((struct netconn *)mem);
    }
    sys_mbox_free(conn->acceptmbox);
  81b2f1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b2f5:	8b 40 1c             	mov    0x1c(%rax),%eax
  81b2f8:	89 c7                	mov    %eax,%edi
  81b2fa:	48 b8 b5 78 81 00 00 	movabs $0x8178b5,%rax
  81b301:	00 00 00 
  81b304:	ff d0                	callq  *%rax
    conn->acceptmbox = SYS_MBOX_NULL;
  81b306:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b30a:	c7 40 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%rax)
  }

  sys_sem_free(conn->op_completed);
  81b311:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b315:	8b 40 14             	mov    0x14(%rax),%eax
  81b318:	89 c7                	mov    %eax,%edi
  81b31a:	48 b8 ca 7e 81 00 00 	movabs $0x817eca,%rax
  81b321:	00 00 00 
  81b324:	ff d0                	callq  *%rax
  conn->op_completed = SYS_SEM_NULL;
  81b326:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b32a:	c7 40 14 ff ff ff ff 	movl   $0xffffffff,0x14(%rax)

  memp_free(MEMP_NETCONN, conn);
  81b331:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b335:	48 89 c6             	mov    %rax,%rsi
  81b338:	bf 07 00 00 00       	mov    $0x7,%edi
  81b33d:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  81b344:	00 00 00 
  81b347:	ff d0                	callq  *%rax
}
  81b349:	c9                   	leaveq 
  81b34a:	c3                   	retq   

000000000081b34b <do_close_internal>:
 *
 * @param conn the TCP netconn to close
 */
static void
do_close_internal(struct netconn *conn)
{
  81b34b:	55                   	push   %rbp
  81b34c:	48 89 e5             	mov    %rsp,%rbp
  81b34f:	48 83 ec 20          	sub    $0x20,%rsp
  81b353:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  err_t err;

  LWIP_ASSERT("invalid conn", (conn != NULL));
  81b357:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81b35c:	75 2a                	jne    81b388 <do_close_internal+0x3d>
  81b35e:	48 ba b6 38 82 00 00 	movabs $0x8238b6,%rdx
  81b365:	00 00 00 
  81b368:	be 54 02 00 00       	mov    $0x254,%esi
  81b36d:	48 bf 52 37 82 00 00 	movabs $0x823752,%rdi
  81b374:	00 00 00 
  81b377:	b8 00 00 00 00       	mov    $0x0,%eax
  81b37c:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81b383:	00 00 00 
  81b386:	ff d1                	callq  *%rcx
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  81b388:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b38c:	8b 00                	mov    (%rax),%eax
  81b38e:	83 f8 10             	cmp    $0x10,%eax
  81b391:	74 2a                	je     81b3bd <do_close_internal+0x72>
  81b393:	48 ba c3 38 82 00 00 	movabs $0x8238c3,%rdx
  81b39a:	00 00 00 
  81b39d:	be 55 02 00 00       	mov    $0x255,%esi
  81b3a2:	48 bf 52 37 82 00 00 	movabs $0x823752,%rdi
  81b3a9:	00 00 00 
  81b3ac:	b8 00 00 00 00       	mov    $0x0,%eax
  81b3b1:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81b3b8:	00 00 00 
  81b3bb:	ff d1                	callq  *%rcx
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  81b3bd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b3c1:	8b 40 04             	mov    0x4(%rax),%eax
  81b3c4:	83 f8 04             	cmp    $0x4,%eax
  81b3c7:	74 2a                	je     81b3f3 <do_close_internal+0xa8>
  81b3c9:	48 ba e8 38 82 00 00 	movabs $0x8238e8,%rdx
  81b3d0:	00 00 00 
  81b3d3:	be 56 02 00 00       	mov    $0x256,%esi
  81b3d8:	48 bf 52 37 82 00 00 	movabs $0x823752,%rdi
  81b3df:	00 00 00 
  81b3e2:	b8 00 00 00 00       	mov    $0x0,%eax
  81b3e7:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81b3ee:	00 00 00 
  81b3f1:	ff d1                	callq  *%rcx
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  81b3f3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b3f7:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b3fb:	48 85 c0             	test   %rax,%rax
  81b3fe:	75 2a                	jne    81b42a <do_close_internal+0xdf>
  81b400:	48 ba 0c 39 82 00 00 	movabs $0x82390c,%rdx
  81b407:	00 00 00 
  81b40a:	be 57 02 00 00       	mov    $0x257,%esi
  81b40f:	48 bf 52 37 82 00 00 	movabs $0x823752,%rdi
  81b416:	00 00 00 
  81b419:	b8 00 00 00 00       	mov    $0x0,%eax
  81b41e:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81b425:	00 00 00 
  81b428:	ff d1                	callq  *%rcx

  /* Set back some callback pointers */
  tcp_arg(conn->pcb.tcp, NULL);
  81b42a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b42e:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b432:	be 00 00 00 00       	mov    $0x0,%esi
  81b437:	48 89 c7             	mov    %rax,%rdi
  81b43a:	48 b8 d7 08 81 00 00 	movabs $0x8108d7,%rax
  81b441:	00 00 00 
  81b444:	ff d0                	callq  *%rax
  if (conn->pcb.tcp->state == LISTEN) {
  81b446:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b44a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b44e:	8b 40 18             	mov    0x18(%rax),%eax
  81b451:	83 f8 01             	cmp    $0x1,%eax
  81b454:	75 21                	jne    81b477 <do_close_internal+0x12c>
    tcp_accept(conn->pcb.tcp, NULL);
  81b456:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b45a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b45e:	be 00 00 00 00       	mov    $0x0,%esi
  81b463:	48 89 c7             	mov    %rax,%rdi
  81b466:	48 b8 58 09 81 00 00 	movabs $0x810958,%rax
  81b46d:	00 00 00 
  81b470:	ff d0                	callq  *%rax
  81b472:	e9 91 00 00 00       	jmpq   81b508 <do_close_internal+0x1bd>
  } else {
    tcp_recv(conn->pcb.tcp, NULL);
  81b477:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b47b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b47f:	be 00 00 00 00       	mov    $0x0,%esi
  81b484:	48 89 c7             	mov    %rax,%rdi
  81b487:	48 b8 f5 08 81 00 00 	movabs $0x8108f5,%rax
  81b48e:	00 00 00 
  81b491:	ff d0                	callq  *%rax
    tcp_accept(conn->pcb.tcp, NULL);
  81b493:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b497:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b49b:	be 00 00 00 00       	mov    $0x0,%esi
  81b4a0:	48 89 c7             	mov    %rax,%rdi
  81b4a3:	48 b8 58 09 81 00 00 	movabs $0x810958,%rax
  81b4aa:	00 00 00 
  81b4ad:	ff d0                	callq  *%rax
    /* some callbacks have to be reset if tcp_close is not successful */
    tcp_sent(conn->pcb.tcp, NULL);
  81b4af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b4b3:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b4b7:	be 00 00 00 00       	mov    $0x0,%esi
  81b4bc:	48 89 c7             	mov    %rax,%rdi
  81b4bf:	48 b8 16 09 81 00 00 	movabs $0x810916,%rax
  81b4c6:	00 00 00 
  81b4c9:	ff d0                	callq  *%rax
    tcp_poll(conn->pcb.tcp, NULL, 4);
  81b4cb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b4cf:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b4d3:	ba 04 00 00 00       	mov    $0x4,%edx
  81b4d8:	be 00 00 00 00       	mov    $0x0,%esi
  81b4dd:	48 89 c7             	mov    %rax,%rdi
  81b4e0:	48 b8 76 09 81 00 00 	movabs $0x810976,%rax
  81b4e7:	00 00 00 
  81b4ea:	ff d0                	callq  *%rax
    tcp_err(conn->pcb.tcp, NULL);
  81b4ec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b4f0:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b4f4:	be 00 00 00 00       	mov    $0x0,%esi
  81b4f9:	48 89 c7             	mov    %rax,%rdi
  81b4fc:	48 b8 37 09 81 00 00 	movabs $0x810937,%rax
  81b503:	00 00 00 
  81b506:	ff d0                	callq  *%rax
  }
  /* Try to close the connection */
  err = tcp_close(conn->pcb.tcp);
  81b508:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b50c:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b510:	48 89 c7             	mov    %rax,%rdi
  81b513:	48 b8 79 ec 80 00 00 	movabs $0x80ec79,%rax
  81b51a:	00 00 00 
  81b51d:	ff d0                	callq  *%rax
  81b51f:	88 45 ff             	mov    %al,-0x1(%rbp)
  if (err == ERR_OK) {
  81b522:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  81b526:	0f 85 89 00 00 00    	jne    81b5b5 <do_close_internal+0x26a>
    /* Closing succeeded */
    conn->state = NETCONN_NONE;
  81b52c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b530:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    /* Set back some callback pointers as conn is going away */
    conn->pcb.tcp = NULL;
  81b537:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b53b:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81b542:	00 
    conn->err = ERR_OK;
  81b543:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b547:	c6 40 10 00          	movb   $0x0,0x10(%rax)
    /* Trigger select() in socket layer. This send should something else so the
       errorfd is set, not the read and write fd! */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  81b54b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b54f:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b553:	48 85 c0             	test   %rax,%rax
  81b556:	74 1b                	je     81b573 <do_close_internal+0x228>
  81b558:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b55c:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b560:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  81b564:	ba 00 00 00 00       	mov    $0x0,%edx
  81b569:	be 00 00 00 00       	mov    $0x0,%esi
  81b56e:	48 89 cf             	mov    %rcx,%rdi
  81b571:	ff d0                	callq  *%rax
    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
  81b573:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b577:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b57b:	48 85 c0             	test   %rax,%rax
  81b57e:	74 1b                	je     81b59b <do_close_internal+0x250>
  81b580:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b584:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b588:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  81b58c:	ba 00 00 00 00       	mov    $0x0,%edx
  81b591:	be 02 00 00 00       	mov    $0x2,%esi
  81b596:	48 89 cf             	mov    %rcx,%rdi
  81b599:	ff d0                	callq  *%rax
    /* wake up the application task */
    sys_sem_signal(conn->op_completed);
  81b59b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b59f:	8b 40 14             	mov    0x14(%rax),%eax
  81b5a2:	89 c7                	mov    %eax,%edi
  81b5a4:	48 b8 4c 80 81 00 00 	movabs $0x81804c,%rax
  81b5ab:	00 00 00 
  81b5ae:	ff d0                	callq  *%rax
  81b5b0:	e9 c0 00 00 00       	jmpq   81b675 <do_close_internal+0x32a>
  } else {
    /* Closing failed, restore some of the callbacks */
    /* Closing of listen pcb will never fail! */
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  81b5b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b5b9:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b5bd:	8b 40 18             	mov    0x18(%rax),%eax
  81b5c0:	83 f8 01             	cmp    $0x1,%eax
  81b5c3:	75 2a                	jne    81b5ef <do_close_internal+0x2a4>
  81b5c5:	48 ba 20 39 82 00 00 	movabs $0x823920,%rdx
  81b5cc:	00 00 00 
  81b5cf:	be 76 02 00 00       	mov    $0x276,%esi
  81b5d4:	48 bf 52 37 82 00 00 	movabs $0x823752,%rdi
  81b5db:	00 00 00 
  81b5de:	b8 00 00 00 00       	mov    $0x0,%eax
  81b5e3:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81b5ea:	00 00 00 
  81b5ed:	ff d1                	callq  *%rcx
    tcp_sent(conn->pcb.tcp, sent_tcp);
  81b5ef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b5f3:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b5f7:	48 be 2d aa 81 00 00 	movabs $0x81aa2d,%rsi
  81b5fe:	00 00 00 
  81b601:	48 89 c7             	mov    %rax,%rdi
  81b604:	48 b8 16 09 81 00 00 	movabs $0x810916,%rax
  81b60b:	00 00 00 
  81b60e:	ff d0                	callq  *%rax
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
  81b610:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b614:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b618:	ba 04 00 00 00       	mov    $0x4,%edx
  81b61d:	48 be 9d a9 81 00 00 	movabs $0x81a99d,%rsi
  81b624:	00 00 00 
  81b627:	48 89 c7             	mov    %rax,%rdi
  81b62a:	48 b8 76 09 81 00 00 	movabs $0x810976,%rax
  81b631:	00 00 00 
  81b634:	ff d0                	callq  *%rax
    tcp_err(conn->pcb.tcp, err_tcp);
  81b636:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b63a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b63e:	48 be 47 ab 81 00 00 	movabs $0x81ab47,%rsi
  81b645:	00 00 00 
  81b648:	48 89 c7             	mov    %rax,%rdi
  81b64b:	48 b8 37 09 81 00 00 	movabs $0x810937,%rax
  81b652:	00 00 00 
  81b655:	ff d0                	callq  *%rax
    tcp_arg(conn->pcb.tcp, conn);
  81b657:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b65b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b65f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81b663:	48 89 d6             	mov    %rdx,%rsi
  81b666:	48 89 c7             	mov    %rax,%rdi
  81b669:	48 b8 d7 08 81 00 00 	movabs $0x8108d7,%rax
  81b670:	00 00 00 
  81b673:	ff d0                	callq  *%rax
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
}
  81b675:	c9                   	leaveq 
  81b676:	c3                   	retq   

000000000081b677 <do_delconn>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_delconn(struct api_msg_msg *msg)
{
  81b677:	55                   	push   %rbp
  81b678:	48 89 e5             	mov    %rsp,%rbp
  81b67b:	48 83 ec 10          	sub    $0x10,%rsp
  81b67f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (msg->conn->pcb.tcp != NULL) {
  81b683:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b687:	48 8b 00             	mov    (%rax),%rax
  81b68a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b68e:	48 85 c0             	test   %rax,%rax
  81b691:	0f 84 93 00 00 00    	je     81b72a <do_delconn+0xb3>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  81b697:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b69b:	48 8b 00             	mov    (%rax),%rax
  81b69e:	8b 00                	mov    (%rax),%eax
  81b6a0:	25 f0 00 00 00       	and    $0xf0,%eax
  81b6a5:	83 f8 20             	cmp    $0x20,%eax
  81b6a8:	74 28                	je     81b6d2 <do_delconn+0x5b>
  81b6aa:	83 f8 40             	cmp    $0x40,%eax
  81b6ad:	74 07                	je     81b6b6 <do_delconn+0x3f>
  81b6af:	83 f8 10             	cmp    $0x10,%eax
  81b6b2:	74 4d                	je     81b701 <do_delconn+0x8a>
      /* API_EVENT is called inside do_close_internal, before releasing
         the application thread, so we can return at this point! */
      return;
#endif /* LWIP_TCP */
    default:
      break;
  81b6b4:	eb 74                	jmp    81b72a <do_delconn+0xb3>
{
  if (msg->conn->pcb.tcp != NULL) {
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
    case NETCONN_RAW:
      raw_remove(msg->conn->pcb.raw);
  81b6b6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b6ba:	48 8b 00             	mov    (%rax),%rax
  81b6bd:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b6c1:	48 89 c7             	mov    %rax,%rdi
  81b6c4:	48 b8 b5 00 82 00 00 	movabs $0x8200b5,%rax
  81b6cb:	00 00 00 
  81b6ce:	ff d0                	callq  *%rax
      break;
  81b6d0:	eb 58                	jmp    81b72a <do_delconn+0xb3>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      msg->conn->pcb.udp->recv_arg = NULL;
  81b6d2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b6d6:	48 8b 00             	mov    (%rax),%rax
  81b6d9:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b6dd:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  81b6e4:	00 
      udp_remove(msg->conn->pcb.udp);
  81b6e5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b6e9:	48 8b 00             	mov    (%rax),%rax
  81b6ec:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b6f0:	48 89 c7             	mov    %rax,%rdi
  81b6f3:	48 b8 9c 58 81 00 00 	movabs $0x81589c,%rax
  81b6fa:	00 00 00 
  81b6fd:	ff d0                	callq  *%rax
      break;
  81b6ff:	eb 29                	jmp    81b72a <do_delconn+0xb3>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      msg->conn->state = NETCONN_CLOSE;
  81b701:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b705:	48 8b 00             	mov    (%rax),%rax
  81b708:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%rax)
      do_close_internal(msg->conn);
  81b70f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b713:	48 8b 00             	mov    (%rax),%rax
  81b716:	48 89 c7             	mov    %rax,%rdi
  81b719:	48 b8 4b b3 81 00 00 	movabs $0x81b34b,%rax
  81b720:	00 00 00 
  81b723:	ff d0                	callq  *%rax
      /* API_EVENT is called inside do_close_internal, before releasing
         the application thread, so we can return at this point! */
      return;
  81b725:	e9 89 00 00 00       	jmpq   81b7b3 <do_delconn+0x13c>
  }
  /* tcp netconns don't come here! */

  /* Trigger select() in socket layer. This send should something else so the
     errorfd is set, not the read and write fd! */
  API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
  81b72a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b72e:	48 8b 00             	mov    (%rax),%rax
  81b731:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b735:	48 85 c0             	test   %rax,%rax
  81b738:	74 21                	je     81b75b <do_delconn+0xe4>
  81b73a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b73e:	48 8b 00             	mov    (%rax),%rax
  81b741:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b745:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81b749:	48 8b 0a             	mov    (%rdx),%rcx
  81b74c:	ba 00 00 00 00       	mov    $0x0,%edx
  81b751:	be 00 00 00 00       	mov    $0x0,%esi
  81b756:	48 89 cf             	mov    %rcx,%rdi
  81b759:	ff d0                	callq  *%rax
  API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  81b75b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b75f:	48 8b 00             	mov    (%rax),%rax
  81b762:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b766:	48 85 c0             	test   %rax,%rax
  81b769:	74 21                	je     81b78c <do_delconn+0x115>
  81b76b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b76f:	48 8b 00             	mov    (%rax),%rax
  81b772:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b776:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81b77a:	48 8b 0a             	mov    (%rdx),%rcx
  81b77d:	ba 00 00 00 00       	mov    $0x0,%edx
  81b782:	be 02 00 00 00       	mov    $0x2,%esi
  81b787:	48 89 cf             	mov    %rcx,%rdi
  81b78a:	ff d0                	callq  *%rax

  if (msg->conn->op_completed != SYS_SEM_NULL) {
  81b78c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b790:	48 8b 00             	mov    (%rax),%rax
  81b793:	8b 40 14             	mov    0x14(%rax),%eax
  81b796:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b799:	74 18                	je     81b7b3 <do_delconn+0x13c>
    sys_sem_signal(msg->conn->op_completed);
  81b79b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b79f:	48 8b 00             	mov    (%rax),%rax
  81b7a2:	8b 40 14             	mov    0x14(%rax),%eax
  81b7a5:	89 c7                	mov    %eax,%edi
  81b7a7:	48 b8 4c 80 81 00 00 	movabs $0x81804c,%rax
  81b7ae:	00 00 00 
  81b7b1:	ff d0                	callq  *%rax
  }
}
  81b7b3:	c9                   	leaveq 
  81b7b4:	c3                   	retq   

000000000081b7b5 <do_bind>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to bind to
 */
void
do_bind(struct api_msg_msg *msg)
{
  81b7b5:	55                   	push   %rbp
  81b7b6:	48 89 e5             	mov    %rsp,%rbp
  81b7b9:	53                   	push   %rbx
  81b7ba:	48 83 ec 18          	sub    $0x18,%rsp
  81b7be:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  if (!ERR_IS_FATAL(msg->conn->err)) {
  81b7c2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b7c6:	48 8b 00             	mov    (%rax),%rax
  81b7c9:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81b7cd:	3c fc                	cmp    $0xfc,%al
  81b7cf:	0f 8c eb 00 00 00    	jl     81b8c0 <do_bind+0x10b>
    if (msg->conn->pcb.tcp != NULL) {
  81b7d5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b7d9:	48 8b 00             	mov    (%rax),%rax
  81b7dc:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b7e0:	48 85 c0             	test   %rax,%rax
  81b7e3:	0f 84 cc 00 00 00    	je     81b8b5 <do_bind+0x100>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  81b7e9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b7ed:	48 8b 00             	mov    (%rax),%rax
  81b7f0:	8b 00                	mov    (%rax),%eax
  81b7f2:	25 f0 00 00 00       	and    $0xf0,%eax
  81b7f7:	83 f8 20             	cmp    $0x20,%eax
  81b7fa:	74 40                	je     81b83c <do_bind+0x87>
  81b7fc:	83 f8 40             	cmp    $0x40,%eax
  81b7ff:	74 0a                	je     81b80b <do_bind+0x56>
  81b801:	83 f8 10             	cmp    $0x10,%eax
  81b804:	74 72                	je     81b878 <do_bind+0xc3>
      case NETCONN_TCP:
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
        break;
#endif /* LWIP_TCP */
      default:
        break;
  81b806:	e9 a8 00 00 00       	jmpq   81b8b3 <do_bind+0xfe>
  if (!ERR_IS_FATAL(msg->conn->err)) {
    if (msg->conn->pcb.tcp != NULL) {
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
      case NETCONN_RAW:
        msg->conn->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  81b80b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b80f:	48 8b 18             	mov    (%rax),%rbx
  81b812:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b816:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81b81a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b81e:	48 8b 00             	mov    (%rax),%rax
  81b821:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b825:	48 89 d6             	mov    %rdx,%rsi
  81b828:	48 89 c7             	mov    %rax,%rdi
  81b82b:	48 b8 4c fe 81 00 00 	movabs $0x81fe4c,%rax
  81b832:	00 00 00 
  81b835:	ff d0                	callq  *%rax
  81b837:	88 43 10             	mov    %al,0x10(%rbx)
        break;
  81b83a:	eb 77                	jmp    81b8b3 <do_bind+0xfe>
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  81b83c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b840:	48 8b 18             	mov    (%rax),%rbx
  81b843:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b847:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81b84b:	0f b7 d0             	movzwl %ax,%edx
  81b84e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b852:	48 8b 48 08          	mov    0x8(%rax),%rcx
  81b856:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b85a:	48 8b 00             	mov    (%rax),%rax
  81b85d:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b861:	48 89 ce             	mov    %rcx,%rsi
  81b864:	48 89 c7             	mov    %rax,%rdi
  81b867:	48 b8 ea 55 81 00 00 	movabs $0x8155ea,%rax
  81b86e:	00 00 00 
  81b871:	ff d0                	callq  *%rax
  81b873:	88 43 10             	mov    %al,0x10(%rbx)
        break;
  81b876:	eb 3b                	jmp    81b8b3 <do_bind+0xfe>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  81b878:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b87c:	48 8b 18             	mov    (%rax),%rbx
  81b87f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b883:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81b887:	0f b7 d0             	movzwl %ax,%edx
  81b88a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b88e:	48 8b 48 08          	mov    0x8(%rax),%rcx
  81b892:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b896:	48 8b 00             	mov    (%rax),%rax
  81b899:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b89d:	48 89 ce             	mov    %rcx,%rsi
  81b8a0:	48 89 c7             	mov    %rax,%rdi
  81b8a3:	48 b8 c8 f0 80 00 00 	movabs $0x80f0c8,%rax
  81b8aa:	00 00 00 
  81b8ad:	ff d0                	callq  *%rax
  81b8af:	88 43 10             	mov    %al,0x10(%rbx)
        break;
  81b8b2:	90                   	nop
  81b8b3:	eb 0b                	jmp    81b8c0 <do_bind+0x10b>
      default:
        break;
      }
    } else {
      /* msg->conn->pcb is NULL */
      msg->conn->err = ERR_VAL;
  81b8b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b8b9:	48 8b 00             	mov    (%rax),%rax
  81b8bc:	c6 40 10 f7          	movb   $0xf7,0x10(%rax)
    }
  }
  TCPIP_APIMSG_ACK(msg);
  81b8c0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b8c4:	48 8b 00             	mov    (%rax),%rax
  81b8c7:	8b 40 14             	mov    0x14(%rax),%eax
  81b8ca:	89 c7                	mov    %eax,%edi
  81b8cc:	48 b8 4c 80 81 00 00 	movabs $0x81804c,%rax
  81b8d3:	00 00 00 
  81b8d6:	ff d0                	callq  *%rax
}
  81b8d8:	48 83 c4 18          	add    $0x18,%rsp
  81b8dc:	5b                   	pop    %rbx
  81b8dd:	5d                   	pop    %rbp
  81b8de:	c3                   	retq   

000000000081b8df <do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
  81b8df:	55                   	push   %rbp
  81b8e0:	48 89 e5             	mov    %rsp,%rbp
  81b8e3:	48 83 ec 30          	sub    $0x30,%rsp
  81b8e7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81b8eb:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81b8ef:	89 d0                	mov    %edx,%eax
  81b8f1:	88 45 dc             	mov    %al,-0x24(%rbp)
  struct netconn *conn;

  LWIP_UNUSED_ARG(pcb);

  conn = arg;
  81b8f4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b8f8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  if (conn == NULL) {
  81b8fc:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81b901:	75 07                	jne    81b90a <do_connected+0x2b>
    return ERR_VAL;
  81b903:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  81b908:	eb 54                	jmp    81b95e <do_connected+0x7f>
  }

  conn->err = err;
  81b90a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b90e:	0f b6 55 dc          	movzbl -0x24(%rbp),%edx
  81b912:	88 50 10             	mov    %dl,0x10(%rax)
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
  81b915:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b919:	8b 00                	mov    (%rax),%eax
  81b91b:	83 f8 10             	cmp    $0x10,%eax
  81b91e:	75 19                	jne    81b939 <do_connected+0x5a>
  81b920:	80 7d dc 00          	cmpb   $0x0,-0x24(%rbp)
  81b924:	75 13                	jne    81b939 <do_connected+0x5a>
    setup_tcp(conn);
  81b926:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b92a:	48 89 c7             	mov    %rax,%rdi
  81b92d:	48 b8 b6 ac 81 00 00 	movabs $0x81acb6,%rax
  81b934:	00 00 00 
  81b937:	ff d0                	callq  *%rax
  }
  conn->state = NETCONN_NONE;
  81b939:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b93d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
  sys_sem_signal(conn->op_completed);
  81b944:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b948:	8b 40 14             	mov    0x14(%rax),%eax
  81b94b:	89 c7                	mov    %eax,%edi
  81b94d:	48 b8 4c 80 81 00 00 	movabs $0x81804c,%rax
  81b954:	00 00 00 
  81b957:	ff d0                	callq  *%rax
  return ERR_OK;
  81b959:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81b95e:	c9                   	leaveq 
  81b95f:	c3                   	retq   

000000000081b960 <do_connect>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to connect to
 */
void
do_connect(struct api_msg_msg *msg)
{
  81b960:	55                   	push   %rbp
  81b961:	48 89 e5             	mov    %rsp,%rbp
  81b964:	53                   	push   %rbx
  81b965:	48 83 ec 18          	sub    $0x18,%rsp
  81b969:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  if (msg->conn->pcb.tcp == NULL) {
  81b96d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b971:	48 8b 00             	mov    (%rax),%rax
  81b974:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b978:	48 85 c0             	test   %rax,%rax
  81b97b:	75 1d                	jne    81b99a <do_connect+0x3a>
    sys_sem_signal(msg->conn->op_completed);
  81b97d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b981:	48 8b 00             	mov    (%rax),%rax
  81b984:	8b 40 14             	mov    0x14(%rax),%eax
  81b987:	89 c7                	mov    %eax,%edi
  81b989:	48 b8 4c 80 81 00 00 	movabs $0x81804c,%rax
  81b990:	00 00 00 
  81b993:	ff d0                	callq  *%rax
    return;
  81b995:	e9 2c 01 00 00       	jmpq   81bac6 <do_connect+0x166>
  }

  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  81b99a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b99e:	48 8b 00             	mov    (%rax),%rax
  81b9a1:	8b 00                	mov    (%rax),%eax
  81b9a3:	25 f0 00 00 00       	and    $0xf0,%eax
  81b9a8:	83 f8 20             	cmp    $0x20,%eax
  81b9ab:	74 5f                	je     81ba0c <do_connect+0xac>
  81b9ad:	83 f8 40             	cmp    $0x40,%eax
  81b9b0:	74 0e                	je     81b9c0 <do_connect+0x60>
  81b9b2:	83 f8 10             	cmp    $0x10,%eax
  81b9b5:	0f 84 a5 00 00 00    	je     81ba60 <do_connect+0x100>
    /* sys_sem_signal() is called from do_connected (or err_tcp()),
     * when the connection is established! */
    break;
#endif /* LWIP_TCP */
  default:
    break;
  81b9bb:	e9 06 01 00 00       	jmpq   81bac6 <do_connect+0x166>
  }

  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
  case NETCONN_RAW:
    msg->conn->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  81b9c0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b9c4:	48 8b 18             	mov    (%rax),%rbx
  81b9c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b9cb:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81b9cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b9d3:	48 8b 00             	mov    (%rax),%rax
  81b9d6:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b9da:	48 89 d6             	mov    %rdx,%rsi
  81b9dd:	48 89 c7             	mov    %rax,%rdi
  81b9e0:	48 b8 7d fe 81 00 00 	movabs $0x81fe7d,%rax
  81b9e7:	00 00 00 
  81b9ea:	ff d0                	callq  *%rax
  81b9ec:	88 43 10             	mov    %al,0x10(%rbx)
    sys_sem_signal(msg->conn->op_completed);
  81b9ef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b9f3:	48 8b 00             	mov    (%rax),%rax
  81b9f6:	8b 40 14             	mov    0x14(%rax),%eax
  81b9f9:	89 c7                	mov    %eax,%edi
  81b9fb:	48 b8 4c 80 81 00 00 	movabs $0x81804c,%rax
  81ba02:	00 00 00 
  81ba05:	ff d0                	callq  *%rax
    break;
  81ba07:	e9 ba 00 00 00       	jmpq   81bac6 <do_connect+0x166>
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    msg->conn->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  81ba0c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ba10:	48 8b 18             	mov    (%rax),%rbx
  81ba13:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ba17:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81ba1b:	0f b7 d0             	movzwl %ax,%edx
  81ba1e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ba22:	48 8b 48 08          	mov    0x8(%rax),%rcx
  81ba26:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ba2a:	48 8b 00             	mov    (%rax),%rax
  81ba2d:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ba31:	48 89 ce             	mov    %rcx,%rsi
  81ba34:	48 89 c7             	mov    %rax,%rdi
  81ba37:	48 b8 36 57 81 00 00 	movabs $0x815736,%rax
  81ba3e:	00 00 00 
  81ba41:	ff d0                	callq  *%rax
  81ba43:	88 43 10             	mov    %al,0x10(%rbx)
    sys_sem_signal(msg->conn->op_completed);
  81ba46:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ba4a:	48 8b 00             	mov    (%rax),%rax
  81ba4d:	8b 40 14             	mov    0x14(%rax),%eax
  81ba50:	89 c7                	mov    %eax,%edi
  81ba52:	48 b8 4c 80 81 00 00 	movabs $0x81804c,%rax
  81ba59:	00 00 00 
  81ba5c:	ff d0                	callq  *%rax
    break;
  81ba5e:	eb 66                	jmp    81bac6 <do_connect+0x166>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    msg->conn->state = NETCONN_CONNECT;
  81ba60:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ba64:	48 8b 00             	mov    (%rax),%rax
  81ba67:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%rax)
    setup_tcp(msg->conn);
  81ba6e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ba72:	48 8b 00             	mov    (%rax),%rax
  81ba75:	48 89 c7             	mov    %rax,%rdi
  81ba78:	48 b8 b6 ac 81 00 00 	movabs $0x81acb6,%rax
  81ba7f:	00 00 00 
  81ba82:	ff d0                	callq  *%rax
    msg->conn->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port,
  81ba84:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ba88:	48 8b 18             	mov    (%rax),%rbx
  81ba8b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ba8f:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81ba93:	0f b7 d0             	movzwl %ax,%edx
  81ba96:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ba9a:	48 8b 70 08          	mov    0x8(%rax),%rsi
  81ba9e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81baa2:	48 8b 00             	mov    (%rax),%rax
  81baa5:	48 8b 40 08          	mov    0x8(%rax),%rax
  81baa9:	48 b9 df b8 81 00 00 	movabs $0x81b8df,%rcx
  81bab0:	00 00 00 
  81bab3:	48 89 c7             	mov    %rax,%rdi
  81bab6:	48 b8 02 f8 80 00 00 	movabs $0x80f802,%rax
  81babd:	00 00 00 
  81bac0:	ff d0                	callq  *%rax
  81bac2:	88 43 10             	mov    %al,0x10(%rbx)
                                 do_connected);
    /* sys_sem_signal() is called from do_connected (or err_tcp()),
     * when the connection is established! */
    break;
  81bac5:	90                   	nop
#endif /* LWIP_TCP */
  default:
    break;
  }
}
  81bac6:	48 83 c4 18          	add    $0x18,%rsp
  81baca:	5b                   	pop    %rbx
  81bacb:	5d                   	pop    %rbp
  81bacc:	c3                   	retq   

000000000081bacd <do_disconnect>:
 *
 * @param msg the api_msg_msg pointing to the connection to disconnect
 */
void
do_disconnect(struct api_msg_msg *msg)
{
  81bacd:	55                   	push   %rbp
  81bace:	48 89 e5             	mov    %rsp,%rbp
  81bad1:	48 83 ec 10          	sub    $0x10,%rsp
  81bad5:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
#if LWIP_UDP
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
  81bad9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81badd:	48 8b 00             	mov    (%rax),%rax
  81bae0:	8b 00                	mov    (%rax),%eax
  81bae2:	25 f0 00 00 00       	and    $0xf0,%eax
  81bae7:	83 f8 20             	cmp    $0x20,%eax
  81baea:	75 1a                	jne    81bb06 <do_disconnect+0x39>
    udp_disconnect(msg->conn->pcb.udp);
  81baec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81baf0:	48 8b 00             	mov    (%rax),%rax
  81baf3:	48 8b 40 08          	mov    0x8(%rax),%rax
  81baf7:	48 89 c7             	mov    %rax,%rdi
  81bafa:	48 b8 2f 58 81 00 00 	movabs $0x81582f,%rax
  81bb01:	00 00 00 
  81bb04:	ff d0                	callq  *%rax
  }
#endif /* LWIP_UDP */
  TCPIP_APIMSG_ACK(msg);
  81bb06:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bb0a:	48 8b 00             	mov    (%rax),%rax
  81bb0d:	8b 40 14             	mov    0x14(%rax),%eax
  81bb10:	89 c7                	mov    %eax,%edi
  81bb12:	48 b8 4c 80 81 00 00 	movabs $0x81804c,%rax
  81bb19:	00 00 00 
  81bb1c:	ff d0                	callq  *%rax
}
  81bb1e:	c9                   	leaveq 
  81bb1f:	c3                   	retq   

000000000081bb20 <do_listen>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_listen(struct api_msg_msg *msg)
{
  81bb20:	55                   	push   %rbp
  81bb21:	48 89 e5             	mov    %rsp,%rbp
  81bb24:	53                   	push   %rbx
  81bb25:	48 83 ec 28          	sub    $0x28,%rsp
  81bb29:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  81bb2d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bb31:	48 8b 00             	mov    (%rax),%rax
  81bb34:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81bb38:	3c fc                	cmp    $0xfc,%al
  81bb3a:	0f 8c 6b 01 00 00    	jl     81bcab <do_listen+0x18b>
    if (msg->conn->pcb.tcp != NULL) {
  81bb40:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bb44:	48 8b 00             	mov    (%rax),%rax
  81bb47:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bb4b:	48 85 c0             	test   %rax,%rax
  81bb4e:	0f 84 57 01 00 00    	je     81bcab <do_listen+0x18b>
      if (msg->conn->type == NETCONN_TCP) {
  81bb54:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bb58:	48 8b 00             	mov    (%rax),%rax
  81bb5b:	8b 00                	mov    (%rax),%eax
  81bb5d:	83 f8 10             	cmp    $0x10,%eax
  81bb60:	0f 85 45 01 00 00    	jne    81bcab <do_listen+0x18b>
        if (msg->conn->pcb.tcp->state == CLOSED) {
  81bb66:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bb6a:	48 8b 00             	mov    (%rax),%rax
  81bb6d:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bb71:	8b 40 18             	mov    0x18(%rax),%eax
  81bb74:	85 c0                	test   %eax,%eax
  81bb76:	0f 85 24 01 00 00    	jne    81bca0 <do_listen+0x180>
#if TCP_LISTEN_BACKLOG
          struct tcp_pcb* lpcb = tcp_listen_with_backlog(msg->conn->pcb.tcp, msg->msg.lb.backlog);
#else  /* TCP_LISTEN_BACKLOG */
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
  81bb7c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bb80:	48 8b 00             	mov    (%rax),%rax
  81bb83:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bb87:	be ff 00 00 00       	mov    $0xff,%esi
  81bb8c:	48 89 c7             	mov    %rax,%rdi
  81bb8f:	48 b8 49 f3 80 00 00 	movabs $0x80f349,%rax
  81bb96:	00 00 00 
  81bb99:	ff d0                	callq  *%rax
  81bb9b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
#endif /* TCP_LISTEN_BACKLOG */
          if (lpcb == NULL) {
  81bb9f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81bba4:	75 10                	jne    81bbb6 <do_listen+0x96>
            msg->conn->err = ERR_MEM;
  81bba6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bbaa:	48 8b 00             	mov    (%rax),%rax
  81bbad:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
  81bbb1:	e9 e8 00 00 00       	jmpq   81bc9e <do_listen+0x17e>
          } else {
            /* delete the recvmbox and allocate the acceptmbox */
            if (msg->conn->recvmbox != SYS_MBOX_NULL) {
  81bbb6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bbba:	48 8b 00             	mov    (%rax),%rax
  81bbbd:	8b 40 18             	mov    0x18(%rax),%eax
  81bbc0:	83 f8 ff             	cmp    $0xffffffff,%eax
  81bbc3:	74 26                	je     81bbeb <do_listen+0xcb>
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(msg->conn->recvmbox);
  81bbc5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bbc9:	48 8b 00             	mov    (%rax),%rax
  81bbcc:	8b 40 18             	mov    0x18(%rax),%eax
  81bbcf:	89 c7                	mov    %eax,%edi
  81bbd1:	48 b8 b5 78 81 00 00 	movabs $0x8178b5,%rax
  81bbd8:	00 00 00 
  81bbdb:	ff d0                	callq  *%rax
              msg->conn->recvmbox = SYS_MBOX_NULL;
  81bbdd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bbe1:	48 8b 00             	mov    (%rax),%rax
  81bbe4:	c7 40 18 ff ff ff ff 	movl   $0xffffffff,0x18(%rax)
            }
            if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
  81bbeb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bbef:	48 8b 00             	mov    (%rax),%rax
  81bbf2:	8b 40 1c             	mov    0x1c(%rax),%eax
  81bbf5:	83 f8 ff             	cmp    $0xffffffff,%eax
  81bbf8:	75 2e                	jne    81bc28 <do_listen+0x108>
              if ((msg->conn->acceptmbox = sys_mbox_new(DEFAULT_ACCEPTMBOX_SIZE)) == SYS_MBOX_NULL) {
  81bbfa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bbfe:	48 8b 18             	mov    (%rax),%rbx
  81bc01:	bf 00 00 00 00       	mov    $0x0,%edi
  81bc06:	48 b8 d5 76 81 00 00 	movabs $0x8176d5,%rax
  81bc0d:	00 00 00 
  81bc10:	ff d0                	callq  *%rax
  81bc12:	89 43 1c             	mov    %eax,0x1c(%rbx)
  81bc15:	8b 43 1c             	mov    0x1c(%rbx),%eax
  81bc18:	83 f8 ff             	cmp    $0xffffffff,%eax
  81bc1b:	75 0b                	jne    81bc28 <do_listen+0x108>
                msg->conn->err = ERR_MEM;
  81bc1d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bc21:	48 8b 00             	mov    (%rax),%rax
  81bc24:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
              }
            }
            if (msg->conn->err == ERR_OK) {
  81bc28:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bc2c:	48 8b 00             	mov    (%rax),%rax
  81bc2f:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81bc33:	84 c0                	test   %al,%al
  81bc35:	75 67                	jne    81bc9e <do_listen+0x17e>
              msg->conn->state = NETCONN_LISTEN;
  81bc37:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bc3b:	48 8b 00             	mov    (%rax),%rax
  81bc3e:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%rax)
              msg->conn->pcb.tcp = lpcb;
  81bc45:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bc49:	48 8b 00             	mov    (%rax),%rax
  81bc4c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81bc50:	48 89 50 08          	mov    %rdx,0x8(%rax)
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
  81bc54:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bc58:	48 8b 10             	mov    (%rax),%rdx
  81bc5b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bc5f:	48 8b 00             	mov    (%rax),%rax
  81bc62:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bc66:	48 89 d6             	mov    %rdx,%rsi
  81bc69:	48 89 c7             	mov    %rax,%rdi
  81bc6c:	48 b8 d7 08 81 00 00 	movabs $0x8108d7,%rax
  81bc73:	00 00 00 
  81bc76:	ff d0                	callq  *%rax
              tcp_accept(msg->conn->pcb.tcp, accept_function);
  81bc78:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bc7c:	48 8b 00             	mov    (%rax),%rax
  81bc7f:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bc83:	48 be 63 ad 81 00 00 	movabs $0x81ad63,%rsi
  81bc8a:	00 00 00 
  81bc8d:	48 89 c7             	mov    %rax,%rdi
  81bc90:	48 b8 58 09 81 00 00 	movabs $0x810958,%rax
  81bc97:	00 00 00 
  81bc9a:	ff d0                	callq  *%rax
  81bc9c:	eb 0d                	jmp    81bcab <do_listen+0x18b>
  81bc9e:	eb 0b                	jmp    81bcab <do_listen+0x18b>
            }
          }
        } else {
          msg->conn->err = ERR_CONN;
  81bca0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bca4:	48 8b 00             	mov    (%rax),%rax
  81bca7:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  81bcab:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bcaf:	48 8b 00             	mov    (%rax),%rax
  81bcb2:	8b 40 14             	mov    0x14(%rax),%eax
  81bcb5:	89 c7                	mov    %eax,%edi
  81bcb7:	48 b8 4c 80 81 00 00 	movabs $0x81804c,%rax
  81bcbe:	00 00 00 
  81bcc1:	ff d0                	callq  *%rax
}
  81bcc3:	48 83 c4 28          	add    $0x28,%rsp
  81bcc7:	5b                   	pop    %rbx
  81bcc8:	5d                   	pop    %rbp
  81bcc9:	c3                   	retq   

000000000081bcca <do_send>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_send(struct api_msg_msg *msg)
{
  81bcca:	55                   	push   %rbp
  81bccb:	48 89 e5             	mov    %rsp,%rbp
  81bcce:	53                   	push   %rbx
  81bccf:	48 83 ec 18          	sub    $0x18,%rsp
  81bcd3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  if (!ERR_IS_FATAL(msg->conn->err)) {
  81bcd7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bcdb:	48 8b 00             	mov    (%rax),%rax
  81bcde:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81bce2:	3c fc                	cmp    $0xfc,%al
  81bce4:	0f 8c 50 01 00 00    	jl     81be3a <do_send+0x170>
    if (msg->conn->pcb.tcp != NULL) {
  81bcea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bcee:	48 8b 00             	mov    (%rax),%rax
  81bcf1:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bcf5:	48 85 c0             	test   %rax,%rax
  81bcf8:	0f 84 3c 01 00 00    	je     81be3a <do_send+0x170>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  81bcfe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bd02:	48 8b 00             	mov    (%rax),%rax
  81bd05:	8b 00                	mov    (%rax),%eax
  81bd07:	25 f0 00 00 00       	and    $0xf0,%eax
  81bd0c:	83 f8 20             	cmp    $0x20,%eax
  81bd0f:	0f 84 95 00 00 00    	je     81bdaa <do_send+0xe0>
  81bd15:	83 f8 40             	cmp    $0x40,%eax
  81bd18:	74 05                	je     81bd1f <do_send+0x55>
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
        }
        break;
#endif /* LWIP_UDP */
      default:
        break;
  81bd1a:	e9 1b 01 00 00       	jmpq   81be3a <do_send+0x170>
  if (!ERR_IS_FATAL(msg->conn->err)) {
    if (msg->conn->pcb.tcp != NULL) {
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
      case NETCONN_RAW:
        if (msg->msg.b->addr == NULL) {
  81bd1f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bd23:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bd27:	48 8b 40 10          	mov    0x10(%rax),%rax
  81bd2b:	48 85 c0             	test   %rax,%rax
  81bd2e:	75 37                	jne    81bd67 <do_send+0x9d>
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
  81bd30:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bd34:	48 8b 18             	mov    (%rax),%rbx
  81bd37:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bd3b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bd3f:	48 8b 10             	mov    (%rax),%rdx
  81bd42:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bd46:	48 8b 00             	mov    (%rax),%rax
  81bd49:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bd4d:	48 89 d6             	mov    %rdx,%rsi
  81bd50:	48 89 c7             	mov    %rax,%rdi
  81bd53:	48 b8 81 00 82 00 00 	movabs $0x820081,%rax
  81bd5a:	00 00 00 
  81bd5d:	ff d0                	callq  *%rax
  81bd5f:	88 43 10             	mov    %al,0x10(%rbx)
        } else {
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
        }
        break;
  81bd62:	e9 d3 00 00 00       	jmpq   81be3a <do_send+0x170>
#if LWIP_RAW
      case NETCONN_RAW:
        if (msg->msg.b->addr == NULL) {
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
        } else {
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
  81bd67:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bd6b:	48 8b 18             	mov    (%rax),%rbx
  81bd6e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bd72:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bd76:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81bd7a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bd7e:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bd82:	48 8b 08             	mov    (%rax),%rcx
  81bd85:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bd89:	48 8b 00             	mov    (%rax),%rax
  81bd8c:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bd90:	48 89 ce             	mov    %rcx,%rsi
  81bd93:	48 89 c7             	mov    %rax,%rdi
  81bd96:	48 b8 dd fe 81 00 00 	movabs $0x81fedd,%rax
  81bd9d:	00 00 00 
  81bda0:	ff d0                	callq  *%rax
  81bda2:	88 43 10             	mov    %al,0x10(%rbx)
        }
        break;
  81bda5:	e9 90 00 00 00       	jmpq   81be3a <do_send+0x170>
#endif
#if LWIP_UDP
      case NETCONN_UDP:
        if (msg->msg.b->addr == NULL) {
  81bdaa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bdae:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bdb2:	48 8b 40 10          	mov    0x10(%rax),%rax
  81bdb6:	48 85 c0             	test   %rax,%rax
  81bdb9:	75 34                	jne    81bdef <do_send+0x125>
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
  81bdbb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bdbf:	48 8b 18             	mov    (%rax),%rbx
  81bdc2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bdc6:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bdca:	48 8b 10             	mov    (%rax),%rdx
  81bdcd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bdd1:	48 8b 00             	mov    (%rax),%rax
  81bdd4:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bdd8:	48 89 d6             	mov    %rdx,%rsi
  81bddb:	48 89 c7             	mov    %rax,%rdi
  81bdde:	48 b8 91 52 81 00 00 	movabs $0x815291,%rax
  81bde5:	00 00 00 
  81bde8:	ff d0                	callq  *%rax
  81bdea:	88 43 10             	mov    %al,0x10(%rbx)
        } else {
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
        }
        break;
  81bded:	eb 4a                	jmp    81be39 <do_send+0x16f>
#if LWIP_UDP
      case NETCONN_UDP:
        if (msg->msg.b->addr == NULL) {
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
        } else {
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
  81bdef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bdf3:	48 8b 18             	mov    (%rax),%rbx
  81bdf6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bdfa:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bdfe:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81be02:	0f b7 c8             	movzwl %ax,%ecx
  81be05:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81be09:	48 8b 40 08          	mov    0x8(%rax),%rax
  81be0d:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81be11:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81be15:	48 8b 40 08          	mov    0x8(%rax),%rax
  81be19:	48 8b 30             	mov    (%rax),%rsi
  81be1c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81be20:	48 8b 00             	mov    (%rax),%rax
  81be23:	48 8b 40 08          	mov    0x8(%rax),%rax
  81be27:	48 89 c7             	mov    %rax,%rdi
  81be2a:	48 b8 d2 52 81 00 00 	movabs $0x8152d2,%rax
  81be31:	00 00 00 
  81be34:	ff d0                	callq  *%rax
  81be36:	88 43 10             	mov    %al,0x10(%rbx)
        }
        break;
  81be39:	90                   	nop
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
  81be3a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81be3e:	48 8b 00             	mov    (%rax),%rax
  81be41:	8b 40 14             	mov    0x14(%rax),%eax
  81be44:	89 c7                	mov    %eax,%edi
  81be46:	48 b8 4c 80 81 00 00 	movabs $0x81804c,%rax
  81be4d:	00 00 00 
  81be50:	ff d0                	callq  *%rax
}
  81be52:	48 83 c4 18          	add    $0x18,%rsp
  81be56:	5b                   	pop    %rbx
  81be57:	5d                   	pop    %rbp
  81be58:	c3                   	retq   

000000000081be59 <do_recv>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_recv(struct api_msg_msg *msg)
{
  81be59:	55                   	push   %rbp
  81be5a:	48 89 e5             	mov    %rsp,%rbp
  81be5d:	48 83 ec 10          	sub    $0x10,%rsp
  81be61:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  81be65:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81be69:	48 8b 00             	mov    (%rax),%rax
  81be6c:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81be70:	3c fc                	cmp    $0xfc,%al
  81be72:	7c 45                	jl     81beb9 <do_recv+0x60>
    if (msg->conn->pcb.tcp != NULL) {
  81be74:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81be78:	48 8b 00             	mov    (%rax),%rax
  81be7b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81be7f:	48 85 c0             	test   %rax,%rax
  81be82:	74 35                	je     81beb9 <do_recv+0x60>
      if (msg->conn->type == NETCONN_TCP) {
  81be84:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81be88:	48 8b 00             	mov    (%rax),%rax
  81be8b:	8b 00                	mov    (%rax),%eax
  81be8d:	83 f8 10             	cmp    $0x10,%eax
  81be90:	75 27                	jne    81beb9 <do_recv+0x60>
        if (msg->conn->pcb.tcp->state == LISTEN) {
          tcp_accepted(msg->conn->pcb.tcp);
        } else
#endif /* TCP_LISTEN_BACKLOG */
        {
          tcp_recved(msg->conn->pcb.tcp, msg->msg.r.len);
  81be92:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81be96:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  81be9a:	0f b7 d0             	movzwl %ax,%edx
  81be9d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bea1:	48 8b 00             	mov    (%rax),%rax
  81bea4:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bea8:	89 d6                	mov    %edx,%esi
  81beaa:	48 89 c7             	mov    %rax,%rdi
  81bead:	48 b8 92 f5 80 00 00 	movabs $0x80f592,%rax
  81beb4:	00 00 00 
  81beb7:	ff d0                	callq  *%rax
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  81beb9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bebd:	48 8b 00             	mov    (%rax),%rax
  81bec0:	8b 40 14             	mov    0x14(%rax),%eax
  81bec3:	89 c7                	mov    %eax,%edi
  81bec5:	48 b8 4c 80 81 00 00 	movabs $0x81804c,%rax
  81becc:	00 00 00 
  81becf:	ff d0                	callq  *%rax
}
  81bed1:	c9                   	leaveq 
  81bed2:	c3                   	retq   

000000000081bed3 <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
  81bed3:	55                   	push   %rbp
  81bed4:	48 89 e5             	mov    %rsp,%rbp
  81bed7:	48 83 ec 30          	sub    $0x30,%rsp
  81bedb:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;
  81bedf:	c6 45 fd 00          	movb   $0x0,-0x3(%rbp)

  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  81bee3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bee7:	8b 40 04             	mov    0x4(%rax),%eax
  81beea:	83 f8 01             	cmp    $0x1,%eax
  81beed:	74 2a                	je     81bf19 <do_writemore+0x46>
  81beef:	48 ba 43 39 82 00 00 	movabs $0x823943,%rdx
  81bef6:	00 00 00 
  81bef9:	be b9 03 00 00       	mov    $0x3b9,%esi
  81befe:	48 bf 52 37 82 00 00 	movabs $0x823752,%rdi
  81bf05:	00 00 00 
  81bf08:	b8 00 00 00 00       	mov    $0x0,%eax
  81bf0d:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81bf14:	00 00 00 
  81bf17:	ff d1                	callq  *%rcx

  dataptr = (u8_t*)conn->write_msg->msg.w.dataptr + conn->write_offset;
  81bf19:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bf1d:	48 8b 40 28          	mov    0x28(%rax),%rax
  81bf21:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81bf25:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bf29:	8b 40 30             	mov    0x30(%rax),%eax
  81bf2c:	48 98                	cltq   
  81bf2e:	48 01 d0             	add    %rdx,%rax
  81bf31:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if ((conn->write_msg->msg.w.len - conn->write_offset > 0xffff)) { /* max_u16_t */
  81bf35:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bf39:	48 8b 40 28          	mov    0x28(%rax),%rax
  81bf3d:	8b 50 10             	mov    0x10(%rax),%edx
  81bf40:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bf44:	8b 40 30             	mov    0x30(%rax),%eax
  81bf47:	29 c2                	sub    %eax,%edx
  81bf49:	89 d0                	mov    %edx,%eax
  81bf4b:	3d ff ff 00 00       	cmp    $0xffff,%eax
  81bf50:	7e 08                	jle    81bf5a <do_writemore+0x87>
    len = 0xffff;
  81bf52:	66 c7 45 fe ff ff    	movw   $0xffff,-0x2(%rbp)
  81bf58:	eb 1c                	jmp    81bf76 <do_writemore+0xa3>
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  } else {
    len = conn->write_msg->msg.w.len - conn->write_offset;
  81bf5a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bf5e:	48 8b 40 28          	mov    0x28(%rax),%rax
  81bf62:	8b 40 10             	mov    0x10(%rax),%eax
  81bf65:	89 c2                	mov    %eax,%edx
  81bf67:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bf6b:	8b 40 30             	mov    0x30(%rax),%eax
  81bf6e:	29 c2                	sub    %eax,%edx
  81bf70:	89 d0                	mov    %edx,%eax
  81bf72:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
  }
  available = tcp_sndbuf(conn->pcb.tcp);
  81bf76:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bf7a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bf7e:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  81bf82:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
  if (available < len) {
  81bf86:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  81bf8a:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  81bf8e:	73 08                	jae    81bf98 <do_writemore+0xc5>
    /* don't try to write more than sendbuf */
    len = available;
  81bf90:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  81bf94:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  }

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  81bf98:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bf9c:	48 8b 40 28          	mov    0x28(%rax),%rax
  81bfa0:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  81bfa4:	0f b6 c8             	movzbl %al,%ecx
  81bfa7:	0f b7 55 fe          	movzwl -0x2(%rbp),%edx
  81bfab:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bfaf:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bfb3:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  81bfb7:	48 89 c7             	mov    %rax,%rdi
  81bfba:	48 b8 f3 30 81 00 00 	movabs $0x8130f3,%rax
  81bfc1:	00 00 00 
  81bfc4:	ff d0                	callq  *%rax
  81bfc6:	88 45 ed             	mov    %al,-0x13(%rbp)
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  81bfc9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bfcd:	8b 50 30             	mov    0x30(%rax),%edx
  81bfd0:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  81bfd4:	01 c2                	add    %eax,%edx
  81bfd6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bfda:	48 8b 40 28          	mov    0x28(%rax),%rax
  81bfde:	8b 40 10             	mov    0x10(%rax),%eax
  81bfe1:	39 c2                	cmp    %eax,%edx
  81bfe3:	7e 2a                	jle    81c00f <do_writemore+0x13c>
  81bfe5:	48 ba 60 39 82 00 00 	movabs $0x823960,%rdx
  81bfec:	00 00 00 
  81bfef:	be ce 03 00 00       	mov    $0x3ce,%esi
  81bff4:	48 bf 52 37 82 00 00 	movabs $0x823752,%rdi
  81bffb:	00 00 00 
  81bffe:	b8 00 00 00 00       	mov    $0x0,%eax
  81c003:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81c00a:	00 00 00 
  81c00d:	ff d1                	callq  *%rcx
  if (err == ERR_OK) {
  81c00f:	80 7d ed 00          	cmpb   $0x0,-0x13(%rbp)
  81c013:	0f 85 07 01 00 00    	jne    81c120 <do_writemore+0x24d>
    conn->write_offset += len;
  81c019:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c01d:	8b 50 30             	mov    0x30(%rax),%edx
  81c020:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  81c024:	01 c2                	add    %eax,%edx
  81c026:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c02a:	89 50 30             	mov    %edx,0x30(%rax)
    if (conn->write_offset == conn->write_msg->msg.w.len) {
  81c02d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c031:	8b 50 30             	mov    0x30(%rax),%edx
  81c034:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c038:	48 8b 40 28          	mov    0x28(%rax),%rax
  81c03c:	8b 40 10             	mov    0x10(%rax),%eax
  81c03f:	39 c2                	cmp    %eax,%edx
  81c041:	75 1b                	jne    81c05e <do_writemore+0x18b>
      /* everything was written */
      write_finished = 1;
  81c043:	c6 45 fd 01          	movb   $0x1,-0x3(%rbp)
      conn->write_msg = NULL;
  81c047:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c04b:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  81c052:	00 
      conn->write_offset = 0;
  81c053:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c057:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%rax)
    }
    err = tcp_output_nagle(conn->pcb.tcp);
  81c05e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c062:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c066:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81c06d:	48 85 c0             	test   %rax,%rax
  81c070:	74 41                	je     81c0b3 <do_writemore+0x1e0>
  81c072:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c076:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c07a:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81c07e:	0f b6 c0             	movzbl %al,%eax
  81c081:	83 e0 40             	and    $0x40,%eax
  81c084:	85 c0                	test   %eax,%eax
  81c086:	75 2b                	jne    81c0b3 <do_writemore+0x1e0>
  81c088:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c08c:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c090:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81c097:	48 85 c0             	test   %rax,%rax
  81c09a:	74 30                	je     81c0cc <do_writemore+0x1f9>
  81c09c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c0a0:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c0a4:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81c0ab:	48 8b 00             	mov    (%rax),%rax
  81c0ae:	48 85 c0             	test   %rax,%rax
  81c0b1:	74 19                	je     81c0cc <do_writemore+0x1f9>
  81c0b3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c0b7:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c0bb:	48 89 c7             	mov    %rax,%rdi
  81c0be:	48 b8 3d 3c 81 00 00 	movabs $0x813c3d,%rax
  81c0c5:	00 00 00 
  81c0c8:	ff d0                	callq  *%rax
  81c0ca:	eb 05                	jmp    81c0d1 <do_writemore+0x1fe>
  81c0cc:	b8 00 00 00 00       	mov    $0x0,%eax
  81c0d1:	88 45 ed             	mov    %al,-0x13(%rbp)
    conn->err = err;
  81c0d4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c0d8:	0f b6 55 ed          	movzbl -0x13(%rbp),%edx
  81c0dc:	88 50 10             	mov    %dl,0x10(%rax)
    if ((err == ERR_OK) && (tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)) {
  81c0df:	80 7d ed 00          	cmpb   $0x0,-0x13(%rbp)
  81c0e3:	75 6c                	jne    81c151 <do_writemore+0x27e>
  81c0e5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c0e9:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c0ed:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  81c0f1:	66 3d a0 2d          	cmp    $0x2da0,%ax
  81c0f5:	77 5a                	ja     81c151 <do_writemore+0x27e>
      API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
  81c0f7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c0fb:	48 8b 40 38          	mov    0x38(%rax),%rax
  81c0ff:	48 85 c0             	test   %rax,%rax
  81c102:	74 4d                	je     81c151 <do_writemore+0x27e>
  81c104:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c108:	48 8b 40 38          	mov    0x38(%rax),%rax
  81c10c:	0f b7 55 fe          	movzwl -0x2(%rbp),%edx
  81c110:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  81c114:	be 03 00 00 00       	mov    $0x3,%esi
  81c119:	48 89 cf             	mov    %rcx,%rdi
  81c11c:	ff d0                	callq  *%rax
  81c11e:	eb 31                	jmp    81c151 <do_writemore+0x27e>
    }
  } else if (err == ERR_MEM) {
  81c120:	80 7d ed ff          	cmpb   $0xff,-0x13(%rbp)
  81c124:	75 1c                	jne    81c142 <do_writemore+0x26f>
    /* If ERR_MEM, we wait for sent_tcp or poll_tcp to be called
       we do NOT return to the application thread, since ERR_MEM is
       only a temporary error! */

    /* tcp_enqueue returned ERR_MEM, try tcp_output anyway */
    err = tcp_output(conn->pcb.tcp);
  81c126:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c12a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c12e:	48 89 c7             	mov    %rax,%rdi
  81c131:	48 b8 3d 3c 81 00 00 	movabs $0x813c3d,%rax
  81c138:	00 00 00 
  81c13b:	ff d0                	callq  *%rax
  81c13d:	88 45 ed             	mov    %al,-0x13(%rbp)
  81c140:	eb 0f                	jmp    81c151 <do_writemore+0x27e>
    conn->write_delayed = 1;
#endif
  } else {
    /* On errors != ERR_MEM, we don't try writing any more but return
       the error to the application thread. */
    conn->err = err;
  81c142:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c146:	0f b6 55 ed          	movzbl -0x13(%rbp),%edx
  81c14a:	88 50 10             	mov    %dl,0x10(%rax)
    write_finished = 1;
  81c14d:	c6 45 fd 01          	movb   $0x1,-0x3(%rbp)
  }

  if (write_finished) {
  81c151:	80 7d fd 00          	cmpb   $0x0,-0x3(%rbp)
  81c155:	74 20                	je     81c177 <do_writemore+0x2a4>
    /* everything was written: set back connection state
       and back to application task */
    conn->state = NETCONN_NONE;
  81c157:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c15b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
#if LWIP_TCPIP_CORE_LOCKING
    if (conn->write_delayed != 0)
#endif
    {
      sys_sem_signal(conn->op_completed);
  81c162:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c166:	8b 40 14             	mov    0x14(%rax),%eax
  81c169:	89 c7                	mov    %eax,%edi
  81c16b:	48 b8 4c 80 81 00 00 	movabs $0x81804c,%rax
  81c172:	00 00 00 
  81c175:	ff d0                	callq  *%rax
  }
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
  81c177:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81c17c:	c9                   	leaveq 
  81c17d:	c3                   	retq   

000000000081c17e <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
  81c17e:	55                   	push   %rbp
  81c17f:	48 89 e5             	mov    %rsp,%rbp
  81c182:	48 83 ec 10          	sub    $0x10,%rsp
  81c186:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (!ERR_IS_FATAL(msg->conn->err)) {
  81c18a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c18e:	48 8b 00             	mov    (%rax),%rax
  81c191:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81c195:	3c fc                	cmp    $0xfc,%al
  81c197:	7c 6c                	jl     81c205 <do_write+0x87>
    if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  81c199:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c19d:	48 8b 00             	mov    (%rax),%rax
  81c1a0:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c1a4:	48 85 c0             	test   %rax,%rax
  81c1a7:	74 51                	je     81c1fa <do_write+0x7c>
  81c1a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c1ad:	48 8b 00             	mov    (%rax),%rax
  81c1b0:	8b 00                	mov    (%rax),%eax
  81c1b2:	83 f8 10             	cmp    $0x10,%eax
  81c1b5:	75 43                	jne    81c1fa <do_write+0x7c>
#if LWIP_TCP
      msg->conn->state = NETCONN_WRITE;
  81c1b7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c1bb:	48 8b 00             	mov    (%rax),%rax
  81c1be:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%rax)
      /* set all the variables used by do_writemore */
      msg->conn->write_msg = msg;
  81c1c5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c1c9:	48 8b 00             	mov    (%rax),%rax
  81c1cc:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81c1d0:	48 89 50 28          	mov    %rdx,0x28(%rax)
      msg->conn->write_offset = 0;
  81c1d4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c1d8:	48 8b 00             	mov    (%rax),%rax
  81c1db:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%rax)
        sys_arch_sem_wait(msg->conn->op_completed, 0);
        LOCK_TCPIP_CORE();
        LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
      }
#else
      do_writemore(msg->conn);
  81c1e2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c1e6:	48 8b 00             	mov    (%rax),%rax
  81c1e9:	48 89 c7             	mov    %rax,%rdi
  81c1ec:	48 b8 d3 be 81 00 00 	movabs $0x81bed3,%rax
  81c1f3:	00 00 00 
  81c1f6:	ff d0                	callq  *%rax
#endif
      /* for both cases: if do_writemore was called, don't ACK the APIMSG! */
      return;
  81c1f8:	eb 23                	jmp    81c21d <do_write+0x9f>
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->conn->err = ERR_VAL;
  81c1fa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c1fe:	48 8b 00             	mov    (%rax),%rax
  81c201:	c6 40 10 f7          	movb   $0xf7,0x10(%rax)
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
  81c205:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c209:	48 8b 00             	mov    (%rax),%rax
  81c20c:	8b 40 14             	mov    0x14(%rax),%eax
  81c20f:	89 c7                	mov    %eax,%edi
  81c211:	48 b8 4c 80 81 00 00 	movabs $0x81804c,%rax
  81c218:	00 00 00 
  81c21b:	ff d0                	callq  *%rax
}
  81c21d:	c9                   	leaveq 
  81c21e:	c3                   	retq   

000000000081c21f <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  81c21f:	55                   	push   %rbp
  81c220:	48 89 e5             	mov    %rsp,%rbp
  81c223:	48 83 ec 10          	sub    $0x10,%rsp
  81c227:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (msg->conn->pcb.ip != NULL) {
  81c22b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c22f:	48 8b 00             	mov    (%rax),%rax
  81c232:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c236:	48 85 c0             	test   %rax,%rax
  81c239:	0f 84 3f 01 00 00    	je     81c37e <do_getaddr+0x15f>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  81c23f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c243:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c247:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81c24b:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
  81c24f:	84 d2                	test   %dl,%dl
  81c251:	74 11                	je     81c264 <do_getaddr+0x45>
  81c253:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81c257:	48 8b 12             	mov    (%rdx),%rdx
  81c25a:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81c25e:	8b 12                	mov    (%rdx),%edx
  81c260:	89 10                	mov    %edx,(%rax)
  81c262:	eb 10                	jmp    81c274 <do_getaddr+0x55>
  81c264:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81c268:	48 8b 12             	mov    (%rdx),%rdx
  81c26b:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81c26f:	8b 52 04             	mov    0x4(%rdx),%edx
  81c272:	89 10                	mov    %edx,(%rax)
    
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  81c274:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c278:	48 8b 00             	mov    (%rax),%rax
  81c27b:	8b 00                	mov    (%rax),%eax
  81c27d:	25 f0 00 00 00       	and    $0xf0,%eax
  81c282:	83 f8 20             	cmp    $0x20,%eax
  81c285:	74 51                	je     81c2d8 <do_getaddr+0xb9>
  81c287:	83 f8 40             	cmp    $0x40,%eax
  81c28a:	74 0e                	je     81c29a <do_getaddr+0x7b>
  81c28c:	83 f8 10             	cmp    $0x10,%eax
  81c28f:	0f 84 af 00 00 00    	je     81c344 <do_getaddr+0x125>
  81c295:	e9 ef 00 00 00       	jmpq   81c389 <do_getaddr+0x16a>
#if LWIP_RAW
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
  81c29a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c29e:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81c2a2:	84 c0                	test   %al,%al
  81c2a4:	74 22                	je     81c2c8 <do_getaddr+0xa9>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
  81c2a6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c2aa:	48 8b 40 10          	mov    0x10(%rax),%rax
  81c2ae:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81c2b2:	48 8b 12             	mov    (%rdx),%rdx
  81c2b5:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81c2b9:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
  81c2bd:	0f b6 d2             	movzbl %dl,%edx
  81c2c0:	66 89 10             	mov    %dx,(%rax)
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->conn->err = ERR_CONN;
      }
      break;
  81c2c3:	e9 b4 00 00 00       	jmpq   81c37c <do_getaddr+0x15d>
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->conn->err = ERR_CONN;
  81c2c8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c2cc:	48 8b 00             	mov    (%rax),%rax
  81c2cf:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
      }
      break;
  81c2d3:	e9 a4 00 00 00       	jmpq   81c37c <do_getaddr+0x15d>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
  81c2d8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c2dc:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81c2e0:	84 c0                	test   %al,%al
  81c2e2:	74 1c                	je     81c300 <do_getaddr+0xe1>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
  81c2e4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c2e8:	48 8b 40 10          	mov    0x10(%rax),%rax
  81c2ec:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81c2f0:	48 8b 12             	mov    (%rdx),%rdx
  81c2f3:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81c2f7:	0f b7 52 1a          	movzwl 0x1a(%rdx),%edx
  81c2fb:	66 89 10             	mov    %dx,(%rax)
  81c2fe:	eb 42                	jmp    81c342 <do_getaddr+0x123>
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
  81c300:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c304:	48 8b 00             	mov    (%rax),%rax
  81c307:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c30b:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81c30f:	0f b6 c0             	movzbl %al,%eax
  81c312:	83 e0 04             	and    $0x4,%eax
  81c315:	85 c0                	test   %eax,%eax
  81c317:	75 0d                	jne    81c326 <do_getaddr+0x107>
          msg->conn->err = ERR_CONN;
  81c319:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c31d:	48 8b 00             	mov    (%rax),%rax
  81c320:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
  81c324:	eb 1c                	jmp    81c342 <do_getaddr+0x123>
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
  81c326:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c32a:	48 8b 40 10          	mov    0x10(%rax),%rax
  81c32e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81c332:	48 8b 12             	mov    (%rdx),%rdx
  81c335:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81c339:	0f b7 52 1c          	movzwl 0x1c(%rdx),%edx
  81c33d:	66 89 10             	mov    %dx,(%rax)
        }
      }
      break;
  81c340:	eb 3a                	jmp    81c37c <do_getaddr+0x15d>
  81c342:	eb 38                	jmp    81c37c <do_getaddr+0x15d>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  81c344:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c348:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81c34c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c350:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81c354:	84 c0                	test   %al,%al
  81c356:	74 11                	je     81c369 <do_getaddr+0x14a>
  81c358:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c35c:	48 8b 00             	mov    (%rax),%rax
  81c35f:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c363:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  81c367:	eb 0f                	jmp    81c378 <do_getaddr+0x159>
  81c369:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c36d:	48 8b 00             	mov    (%rax),%rax
  81c370:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c374:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  81c378:	66 89 02             	mov    %ax,(%rdx)
      break;
  81c37b:	90                   	nop
  81c37c:	eb 0b                	jmp    81c389 <do_getaddr+0x16a>
#endif /* LWIP_TCP */
    }
  } else {
    msg->conn->err = ERR_CONN;
  81c37e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c382:	48 8b 00             	mov    (%rax),%rax
  81c385:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
  }
  TCPIP_APIMSG_ACK(msg);
  81c389:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c38d:	48 8b 00             	mov    (%rax),%rax
  81c390:	8b 40 14             	mov    0x14(%rax),%eax
  81c393:	89 c7                	mov    %eax,%edi
  81c395:	48 b8 4c 80 81 00 00 	movabs $0x81804c,%rax
  81c39c:	00 00 00 
  81c39f:	ff d0                	callq  *%rax
}
  81c3a1:	c9                   	leaveq 
  81c3a2:	c3                   	retq   

000000000081c3a3 <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
  81c3a3:	55                   	push   %rbp
  81c3a4:	48 89 e5             	mov    %rsp,%rbp
  81c3a7:	48 83 ec 10          	sub    $0x10,%rsp
  81c3ab:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  81c3af:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c3b3:	48 8b 00             	mov    (%rax),%rax
  81c3b6:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c3ba:	48 85 c0             	test   %rax,%rax
  81c3bd:	74 34                	je     81c3f3 <do_close+0x50>
  81c3bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c3c3:	48 8b 00             	mov    (%rax),%rax
  81c3c6:	8b 00                	mov    (%rax),%eax
  81c3c8:	83 f8 10             	cmp    $0x10,%eax
  81c3cb:	75 26                	jne    81c3f3 <do_close+0x50>
      msg->conn->state = NETCONN_CLOSE;
  81c3cd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c3d1:	48 8b 00             	mov    (%rax),%rax
  81c3d4:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%rax)
      do_close_internal(msg->conn);
  81c3db:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c3df:	48 8b 00             	mov    (%rax),%rax
  81c3e2:	48 89 c7             	mov    %rax,%rdi
  81c3e5:	48 b8 4b b3 81 00 00 	movabs $0x81b34b,%rax
  81c3ec:	00 00 00 
  81c3ef:	ff d0                	callq  *%rax
  81c3f1:	eb 23                	jmp    81c416 <do_close+0x73>
      /* for tcp netconns, do_close_internal ACKs the message */
  } else
#endif /* LWIP_TCP */
  {
    msg->conn->err = ERR_VAL;
  81c3f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c3f7:	48 8b 00             	mov    (%rax),%rax
  81c3fa:	c6 40 10 f7          	movb   $0xf7,0x10(%rax)
    TCPIP_APIMSG_ACK(msg);
  81c3fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c402:	48 8b 00             	mov    (%rax),%rax
  81c405:	8b 40 14             	mov    0x14(%rax),%eax
  81c408:	89 c7                	mov    %eax,%edi
  81c40a:	48 b8 4c 80 81 00 00 	movabs $0x81804c,%rax
  81c411:	00 00 00 
  81c414:	ff d0                	callq  *%rax
  }
}
  81c416:	c9                   	leaveq 
  81c417:	c3                   	retq   

000000000081c418 <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
  81c418:	55                   	push   %rbp
  81c419:	48 89 e5             	mov    %rsp,%rbp
  81c41c:	53                   	push   %rbx
  81c41d:	48 83 ec 38          	sub    $0x38,%rsp
  81c421:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  81c425:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  PERF_START;

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = p->payload;
  81c429:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c42d:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81c431:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c438:	00 00 00 
  81c43b:	48 89 10             	mov    %rdx,(%rax)
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  81c43e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c442:	48 8b 58 08          	mov    0x8(%rax),%rbx
  81c446:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c44d:	00 00 00 
  81c450:	48 8b 00             	mov    (%rax),%rax
  81c453:	0f b7 00             	movzwl (%rax),%eax
  81c456:	0f b7 c0             	movzwl %ax,%eax
  81c459:	89 c7                	mov    %eax,%edi
  81c45b:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  81c462:	00 00 00 
  81c465:	ff d0                	callq  *%rax
  81c467:	66 c1 e8 08          	shr    $0x8,%ax
  81c46b:	0f b7 c0             	movzwl %ax,%eax
  81c46e:	83 e0 0f             	and    $0xf,%eax
  81c471:	c1 e0 02             	shl    $0x2,%eax
  81c474:	48 98                	cltq   
  81c476:	48 8d 14 03          	lea    (%rbx,%rax,1),%rdx
  81c47a:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c481:	00 00 00 
  81c484:	48 89 10             	mov    %rdx,(%rax)
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
  81c487:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c48e:	00 00 00 
  81c491:	48 8b 00             	mov    (%rax),%rax
  81c494:	0f b7 00             	movzwl (%rax),%eax
  81c497:	0f b7 c0             	movzwl %ax,%eax
  81c49a:	89 c7                	mov    %eax,%edi
  81c49c:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  81c4a3:	00 00 00 
  81c4a6:	ff d0                	callq  *%rax
  81c4a8:	66 c1 e8 08          	shr    $0x8,%ax
  81c4ac:	83 e0 0f             	and    $0xf,%eax
  81c4af:	c1 e0 02             	shl    $0x2,%eax
  81c4b2:	f7 d8                	neg    %eax
  81c4b4:	0f bf d0             	movswl %ax,%edx
  81c4b7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c4bb:	89 d6                	mov    %edx,%esi
  81c4bd:	48 89 c7             	mov    %rax,%rdi
  81c4c0:	48 b8 7f db 80 00 00 	movabs $0x80db7f,%rax
  81c4c7:	00 00 00 
  81c4ca:	ff d0                	callq  *%rax
  81c4cc:	84 c0                	test   %al,%al
  81c4ce:	75 0e                	jne    81c4de <tcp_input+0xc6>
  81c4d0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c4d4:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81c4d8:	66 83 f8 13          	cmp    $0x13,%ax
  81c4dc:	77 18                	ja     81c4f6 <tcp_input+0xde>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  81c4de:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c4e2:	48 89 c7             	mov    %rax,%rdi
  81c4e5:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  81c4ec:	00 00 00 
  81c4ef:	ff d0                	callq  *%rax
    return;
  81c4f1:	e9 eb 0b 00 00       	jmpq   81d0e1 <tcp_input+0xcc9>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  81c4f6:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c4fd:	00 00 00 
  81c500:	48 8b 00             	mov    (%rax),%rax
  81c503:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81c507:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81c50b:	48 89 c6             	mov    %rax,%rsi
  81c50e:	48 89 d7             	mov    %rdx,%rdi
  81c511:	48 b8 41 0d 81 00 00 	movabs $0x810d41,%rax
  81c518:	00 00 00 
  81c51b:	ff d0                	callq  *%rax
  81c51d:	84 c0                	test   %al,%al
  81c51f:	75 38                	jne    81c559 <tcp_input+0x141>
      ip_addr_ismulticast(&(iphdr->dest))) {
  81c521:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c528:	00 00 00 
  81c52b:	48 8b 00             	mov    (%rax),%rax
  81c52e:	8b 58 10             	mov    0x10(%rax),%ebx
  81c531:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  81c536:	48 b8 8c 30 81 00 00 	movabs $0x81308c,%rax
  81c53d:	00 00 00 
  81c540:	ff d0                	callq  *%rax
  81c542:	21 c3                	and    %eax,%ebx
  81c544:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  81c549:	48 b8 8c 30 81 00 00 	movabs $0x81308c,%rax
  81c550:	00 00 00 
  81c553:	ff d0                	callq  *%rax
    pbuf_free(p);
    return;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  81c555:	39 c3                	cmp    %eax,%ebx
  81c557:	75 18                	jne    81c571 <tcp_input+0x159>
      ip_addr_ismulticast(&(iphdr->dest))) {
    TCP_STATS_INC(tcp.proterr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  81c559:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c55d:	48 89 c7             	mov    %rax,%rdi
  81c560:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  81c567:	00 00 00 
  81c56a:	ff d0                	callq  *%rax
    return;
  81c56c:	e9 70 0b 00 00       	jmpq   81d0e1 <tcp_input+0xcc9>

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
      (struct ip_addr *)&(iphdr->dest),
      IP_PROTO_TCP, p->tot_len) != 0) {
  81c571:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c575:	0f b7 40 10          	movzwl 0x10(%rax),%eax
    return;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  81c579:	0f b7 c8             	movzwl %ax,%ecx
      (struct ip_addr *)&(iphdr->dest),
  81c57c:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c583:	00 00 00 
  81c586:	48 8b 00             	mov    (%rax),%rax
    return;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  81c589:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81c58d:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c594:	00 00 00 
  81c597:	48 8b 00             	mov    (%rax),%rax
  81c59a:	48 8d 70 0c          	lea    0xc(%rax),%rsi
  81c59e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c5a2:	41 89 c8             	mov    %ecx,%r8d
  81c5a5:	b9 06 00 00 00       	mov    $0x6,%ecx
  81c5aa:	48 89 c7             	mov    %rax,%rdi
  81c5ad:	48 b8 cb 27 81 00 00 	movabs $0x8127cb,%rax
  81c5b4:	00 00 00 
  81c5b7:	ff d0                	callq  *%rax
  81c5b9:	66 85 c0             	test   %ax,%ax
  81c5bc:	74 18                	je     81c5d6 <tcp_input+0x1be>
    tcp_debug_print(tcphdr);
#endif /* TCP_DEBUG */
    TCP_STATS_INC(tcp.chkerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  81c5be:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c5c2:	48 89 c7             	mov    %rax,%rdi
  81c5c5:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  81c5cc:	00 00 00 
  81c5cf:	ff d0                	callq  *%rax
    return;
  81c5d1:	e9 0b 0b 00 00       	jmpq   81d0e1 <tcp_input+0xcc9>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
  81c5d6:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c5dd:	00 00 00 
  81c5e0:	48 8b 00             	mov    (%rax),%rax
  81c5e3:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81c5e7:	0f b7 c0             	movzwl %ax,%eax
  81c5ea:	89 c7                	mov    %eax,%edi
  81c5ec:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  81c5f3:	00 00 00 
  81c5f6:	ff d0                	callq  *%rax
  81c5f8:	66 c1 e8 0c          	shr    $0xc,%ax
  81c5fc:	88 45 d6             	mov    %al,-0x2a(%rbp)
  if(pbuf_header(p, -(hdrlen * 4))){
  81c5ff:	0f b6 55 d6          	movzbl -0x2a(%rbp),%edx
  81c603:	b8 00 00 00 00       	mov    $0x0,%eax
  81c608:	29 d0                	sub    %edx,%eax
  81c60a:	c1 e0 02             	shl    $0x2,%eax
  81c60d:	0f bf d0             	movswl %ax,%edx
  81c610:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c614:	89 d6                	mov    %edx,%esi
  81c616:	48 89 c7             	mov    %rax,%rdi
  81c619:	48 b8 7f db 80 00 00 	movabs $0x80db7f,%rax
  81c620:	00 00 00 
  81c623:	ff d0                	callq  *%rax
  81c625:	84 c0                	test   %al,%al
  81c627:	74 18                	je     81c641 <tcp_input+0x229>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  81c629:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c62d:	48 89 c7             	mov    %rax,%rdi
  81c630:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  81c637:	00 00 00 
  81c63a:	ff d0                	callq  *%rax
    return;
  81c63c:	e9 a0 0a 00 00       	jmpq   81d0e1 <tcp_input+0xcc9>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  81c641:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c648:	00 00 00 
  81c64b:	48 8b 18             	mov    (%rax),%rbx
  81c64e:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c655:	00 00 00 
  81c658:	48 8b 00             	mov    (%rax),%rax
  81c65b:	0f b7 00             	movzwl (%rax),%eax
  81c65e:	0f b7 c0             	movzwl %ax,%eax
  81c661:	89 c7                	mov    %eax,%edi
  81c663:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  81c66a:	00 00 00 
  81c66d:	ff d0                	callq  *%rax
  81c66f:	66 89 03             	mov    %ax,(%rbx)
  tcphdr->dest = ntohs(tcphdr->dest);
  81c672:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c679:	00 00 00 
  81c67c:	48 8b 18             	mov    (%rax),%rbx
  81c67f:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c686:	00 00 00 
  81c689:	48 8b 00             	mov    (%rax),%rax
  81c68c:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  81c690:	0f b7 c0             	movzwl %ax,%eax
  81c693:	89 c7                	mov    %eax,%edi
  81c695:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  81c69c:	00 00 00 
  81c69f:	ff d0                	callq  *%rax
  81c6a1:	66 89 43 02          	mov    %ax,0x2(%rbx)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  81c6a5:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c6ac:	00 00 00 
  81c6af:	48 8b 18             	mov    (%rax),%rbx
  81c6b2:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c6b9:	00 00 00 
  81c6bc:	48 8b 00             	mov    (%rax),%rax
  81c6bf:	8b 40 04             	mov    0x4(%rax),%eax
  81c6c2:	89 c7                	mov    %eax,%edi
  81c6c4:	48 b8 8c 30 81 00 00 	movabs $0x81308c,%rax
  81c6cb:	00 00 00 
  81c6ce:	ff d0                	callq  *%rax
  81c6d0:	89 43 04             	mov    %eax,0x4(%rbx)
  81c6d3:	8b 53 04             	mov    0x4(%rbx),%edx
  81c6d6:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81c6dd:	00 00 00 
  81c6e0:	89 10                	mov    %edx,(%rax)
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  81c6e2:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c6e9:	00 00 00 
  81c6ec:	48 8b 18             	mov    (%rax),%rbx
  81c6ef:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c6f6:	00 00 00 
  81c6f9:	48 8b 00             	mov    (%rax),%rax
  81c6fc:	8b 40 08             	mov    0x8(%rax),%eax
  81c6ff:	89 c7                	mov    %eax,%edi
  81c701:	48 b8 8c 30 81 00 00 	movabs $0x81308c,%rax
  81c708:	00 00 00 
  81c70b:	ff d0                	callq  *%rax
  81c70d:	89 43 08             	mov    %eax,0x8(%rbx)
  81c710:	8b 53 08             	mov    0x8(%rbx),%edx
  81c713:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81c71a:	00 00 00 
  81c71d:	89 10                	mov    %edx,(%rax)
  tcphdr->wnd = ntohs(tcphdr->wnd);
  81c71f:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c726:	00 00 00 
  81c729:	48 8b 18             	mov    (%rax),%rbx
  81c72c:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c733:	00 00 00 
  81c736:	48 8b 00             	mov    (%rax),%rax
  81c739:	0f b7 40 0e          	movzwl 0xe(%rax),%eax
  81c73d:	0f b7 c0             	movzwl %ax,%eax
  81c740:	89 c7                	mov    %eax,%edi
  81c742:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  81c749:	00 00 00 
  81c74c:	ff d0                	callq  *%rax
  81c74e:	66 89 43 0e          	mov    %ax,0xe(%rbx)

  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  81c752:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c759:	00 00 00 
  81c75c:	48 8b 00             	mov    (%rax),%rax
  81c75f:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81c763:	0f b7 c0             	movzwl %ax,%eax
  81c766:	89 c7                	mov    %eax,%edi
  81c768:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  81c76f:	00 00 00 
  81c772:	ff d0                	callq  *%rax
  81c774:	83 e0 3f             	and    $0x3f,%eax
  81c777:	89 c2                	mov    %eax,%edx
  81c779:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81c780:	00 00 00 
  81c783:	88 10                	mov    %dl,(%rax)
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);
  81c785:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c789:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  81c78d:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81c794:	00 00 00 
  81c797:	0f b6 00             	movzbl (%rax),%eax
  81c79a:	0f b6 c0             	movzbl %al,%eax
  81c79d:	83 e0 01             	and    $0x1,%eax
  81c7a0:	85 c0                	test   %eax,%eax
  81c7a2:	75 17                	jne    81c7bb <tcp_input+0x3a3>
  81c7a4:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81c7ab:	00 00 00 
  81c7ae:	0f b6 00             	movzbl (%rax),%eax
  81c7b1:	0f b6 c0             	movzbl %al,%eax
  81c7b4:	83 e0 02             	and    $0x2,%eax
  81c7b7:	85 c0                	test   %eax,%eax
  81c7b9:	74 07                	je     81c7c2 <tcp_input+0x3aa>
  81c7bb:	b8 01 00 00 00       	mov    $0x1,%eax
  81c7c0:	eb 05                	jmp    81c7c7 <tcp_input+0x3af>
  81c7c2:	b8 00 00 00 00       	mov    $0x0,%eax
  81c7c7:	01 c2                	add    %eax,%edx
  81c7c9:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81c7d0:	00 00 00 
  81c7d3:	66 89 10             	mov    %dx,(%rax)

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
  81c7d6:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  81c7dd:	00 

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  81c7de:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81c7e5:	00 00 00 
  81c7e8:	48 8b 00             	mov    (%rax),%rax
  81c7eb:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81c7ef:	e9 e4 01 00 00       	jmpq   81c9d8 <tcp_input+0x5c0>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  81c7f4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c7f8:	8b 40 18             	mov    0x18(%rax),%eax
  81c7fb:	85 c0                	test   %eax,%eax
  81c7fd:	75 2a                	jne    81c829 <tcp_input+0x411>
  81c7ff:	48 ba 80 39 82 00 00 	movabs $0x823980,%rdx
  81c806:	00 00 00 
  81c809:	be b6 00 00 00       	mov    $0xb6,%esi
  81c80e:	48 bf a7 39 82 00 00 	movabs $0x8239a7,%rdi
  81c815:	00 00 00 
  81c818:	b8 00 00 00 00       	mov    $0x0,%eax
  81c81d:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81c824:	00 00 00 
  81c827:	ff d1                	callq  *%rcx
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  81c829:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c82d:	8b 40 18             	mov    0x18(%rax),%eax
  81c830:	83 f8 0a             	cmp    $0xa,%eax
  81c833:	75 2a                	jne    81c85f <tcp_input+0x447>
  81c835:	48 ba c0 39 82 00 00 	movabs $0x8239c0,%rdx
  81c83c:	00 00 00 
  81c83f:	be b7 00 00 00       	mov    $0xb7,%esi
  81c844:	48 bf a7 39 82 00 00 	movabs $0x8239a7,%rdi
  81c84b:	00 00 00 
  81c84e:	b8 00 00 00 00       	mov    $0x0,%eax
  81c853:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81c85a:	00 00 00 
  81c85d:	ff d1                	callq  *%rcx
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  81c85f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c863:	8b 40 18             	mov    0x18(%rax),%eax
  81c866:	83 f8 01             	cmp    $0x1,%eax
  81c869:	75 2a                	jne    81c895 <tcp_input+0x47d>
  81c86b:	48 ba f0 39 82 00 00 	movabs $0x8239f0,%rdx
  81c872:	00 00 00 
  81c875:	be b8 00 00 00       	mov    $0xb8,%esi
  81c87a:	48 bf a7 39 82 00 00 	movabs $0x8239a7,%rdi
  81c881:	00 00 00 
  81c884:	b8 00 00 00 00       	mov    $0x0,%eax
  81c889:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81c890:	00 00 00 
  81c893:	ff d1                	callq  *%rcx
    if (pcb->remote_port == tcphdr->src &&
  81c895:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c899:	0f b7 50 2a          	movzwl 0x2a(%rax),%edx
  81c89d:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c8a4:	00 00 00 
  81c8a7:	48 8b 00             	mov    (%rax),%rax
  81c8aa:	0f b7 00             	movzwl (%rax),%eax
  81c8ad:	66 39 c2             	cmp    %ax,%dx
  81c8b0:	0f 85 0e 01 00 00    	jne    81c9c4 <tcp_input+0x5ac>
       pcb->local_port == tcphdr->dest &&
  81c8b6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c8ba:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  81c8be:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c8c5:	00 00 00 
  81c8c8:	48 8b 00             	mov    (%rax),%rax
  81c8cb:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
  81c8cf:	66 39 c2             	cmp    %ax,%dx
  81c8d2:	0f 85 ec 00 00 00    	jne    81c9c4 <tcp_input+0x5ac>
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  81c8d8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c8dc:	8b 50 04             	mov    0x4(%rax),%edx
  81c8df:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c8e6:	00 00 00 
  81c8e9:	48 8b 00             	mov    (%rax),%rax
  81c8ec:	8b 40 0c             	mov    0xc(%rax),%eax
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
       pcb->local_port == tcphdr->dest &&
  81c8ef:	39 c2                	cmp    %eax,%edx
  81c8f1:	0f 85 cd 00 00 00    	jne    81c9c4 <tcp_input+0x5ac>
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
  81c8f7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c8fb:	8b 10                	mov    (%rax),%edx
  81c8fd:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c904:	00 00 00 
  81c907:	48 8b 00             	mov    (%rax),%rax
  81c90a:	8b 40 10             	mov    0x10(%rax),%eax
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  81c90d:	39 c2                	cmp    %eax,%edx
  81c90f:	0f 85 af 00 00 00    	jne    81c9c4 <tcp_input+0x5ac>
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  81c915:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c919:	48 8b 40 10          	mov    0x10(%rax),%rax
  81c91d:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81c921:	75 2a                	jne    81c94d <tcp_input+0x535>
  81c923:	48 ba 18 3a 82 00 00 	movabs $0x823a18,%rdx
  81c92a:	00 00 00 
  81c92d:	be c1 00 00 00       	mov    $0xc1,%esi
  81c932:	48 bf a7 39 82 00 00 	movabs $0x8239a7,%rdi
  81c939:	00 00 00 
  81c93c:	b8 00 00 00 00       	mov    $0x0,%eax
  81c941:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81c948:	00 00 00 
  81c94b:	ff d1                	callq  *%rcx
      if (prev != NULL) {
  81c94d:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81c952:	74 36                	je     81c98a <tcp_input+0x572>
        prev->next = pcb->next;
  81c954:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c958:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81c95c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81c960:	48 89 50 10          	mov    %rdx,0x10(%rax)
        pcb->next = tcp_active_pcbs;
  81c964:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81c96b:	00 00 00 
  81c96e:	48 8b 10             	mov    (%rax),%rdx
  81c971:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c975:	48 89 50 10          	mov    %rdx,0x10(%rax)
        tcp_active_pcbs = pcb;
  81c979:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81c980:	00 00 00 
  81c983:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81c987:	48 89 10             	mov    %rdx,(%rax)
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  81c98a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c98e:	48 8b 40 10          	mov    0x10(%rax),%rax
  81c992:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81c996:	75 2a                	jne    81c9c2 <tcp_input+0x5aa>
  81c998:	48 ba 48 3a 82 00 00 	movabs $0x823a48,%rdx
  81c99f:	00 00 00 
  81c9a2:	be c7 00 00 00       	mov    $0xc7,%esi
  81c9a7:	48 bf a7 39 82 00 00 	movabs $0x8239a7,%rdi
  81c9ae:	00 00 00 
  81c9b1:	b8 00 00 00 00       	mov    $0x0,%eax
  81c9b6:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81c9bd:	00 00 00 
  81c9c0:	ff d1                	callq  *%rcx
      break;
  81c9c2:	eb 1f                	jmp    81c9e3 <tcp_input+0x5cb>
    }
    prev = pcb;
  81c9c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c9c8:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  81c9cc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c9d0:	48 8b 40 10          	mov    0x10(%rax),%rax
  81c9d4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81c9d8:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81c9dd:	0f 85 11 fe ff ff    	jne    81c7f4 <tcp_input+0x3dc>
      break;
    }
    prev = pcb;
  }

  if (pcb == NULL) {
  81c9e3:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81c9e8:	0f 85 f2 01 00 00    	jne    81cbe0 <tcp_input+0x7c8>
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  81c9ee:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81c9f5:	00 00 00 
  81c9f8:	48 8b 00             	mov    (%rax),%rax
  81c9fb:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81c9ff:	e9 dd 00 00 00       	jmpq   81cae1 <tcp_input+0x6c9>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  81ca04:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ca08:	8b 40 18             	mov    0x18(%rax),%eax
  81ca0b:	83 f8 0a             	cmp    $0xa,%eax
  81ca0e:	74 2a                	je     81ca3a <tcp_input+0x622>
  81ca10:	48 ba 78 3a 82 00 00 	movabs $0x823a78,%rdx
  81ca17:	00 00 00 
  81ca1a:	be d1 00 00 00       	mov    $0xd1,%esi
  81ca1f:	48 bf a7 39 82 00 00 	movabs $0x8239a7,%rdi
  81ca26:	00 00 00 
  81ca29:	b8 00 00 00 00       	mov    $0x0,%eax
  81ca2e:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81ca35:	00 00 00 
  81ca38:	ff d1                	callq  *%rcx
      if (pcb->remote_port == tcphdr->src &&
  81ca3a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ca3e:	0f b7 50 2a          	movzwl 0x2a(%rax),%edx
  81ca42:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81ca49:	00 00 00 
  81ca4c:	48 8b 00             	mov    (%rax),%rax
  81ca4f:	0f b7 00             	movzwl (%rax),%eax
  81ca52:	66 39 c2             	cmp    %ax,%dx
  81ca55:	75 7e                	jne    81cad5 <tcp_input+0x6bd>
         pcb->local_port == tcphdr->dest &&
  81ca57:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ca5b:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  81ca5f:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81ca66:	00 00 00 
  81ca69:	48 8b 00             	mov    (%rax),%rax
  81ca6c:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
  81ca70:	66 39 c2             	cmp    %ax,%dx
  81ca73:	75 60                	jne    81cad5 <tcp_input+0x6bd>
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  81ca75:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ca79:	8b 50 04             	mov    0x4(%rax),%edx
  81ca7c:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81ca83:	00 00 00 
  81ca86:	48 8b 00             	mov    (%rax),%rax
  81ca89:	8b 40 0c             	mov    0xc(%rax),%eax
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
         pcb->local_port == tcphdr->dest &&
  81ca8c:	39 c2                	cmp    %eax,%edx
  81ca8e:	75 45                	jne    81cad5 <tcp_input+0x6bd>
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
         ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
  81ca90:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ca94:	8b 10                	mov    (%rax),%edx
  81ca96:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81ca9d:	00 00 00 
  81caa0:	48 8b 00             	mov    (%rax),%rax
  81caa3:	8b 40 10             	mov    0x10(%rax),%eax
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  81caa6:	39 c2                	cmp    %eax,%edx
  81caa8:	75 2b                	jne    81cad5 <tcp_input+0x6bd>
         ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
  81caaa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81caae:	48 89 c7             	mov    %rax,%rdi
  81cab1:	48 b8 e7 d3 81 00 00 	movabs $0x81d3e7,%rax
  81cab8:	00 00 00 
  81cabb:	ff d0                	callq  *%rax
        pbuf_free(p);
  81cabd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81cac1:	48 89 c7             	mov    %rax,%rdi
  81cac4:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  81cacb:	00 00 00 
  81cace:	ff d0                	callq  *%rax
        return;
  81cad0:	e9 0c 06 00 00       	jmpq   81d0e1 <tcp_input+0xcc9>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  81cad5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cad9:	48 8b 40 10          	mov    0x10(%rax),%rax
  81cadd:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81cae1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81cae6:	0f 85 18 ff ff ff    	jne    81ca04 <tcp_input+0x5ec>
      }
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
  81caec:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  81caf3:	00 
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  81caf4:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  81cafb:	00 00 00 
  81cafe:	48 8b 00             	mov    (%rax),%rax
  81cb01:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  81cb05:	e9 cb 00 00 00       	jmpq   81cbd5 <tcp_input+0x7bd>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  81cb0a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81cb0e:	48 85 c0             	test   %rax,%rax
  81cb11:	74 28                	je     81cb3b <tcp_input+0x723>
  81cb13:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81cb17:	8b 00                	mov    (%rax),%eax
  81cb19:	85 c0                	test   %eax,%eax
  81cb1b:	74 1e                	je     81cb3b <tcp_input+0x723>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  81cb1d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81cb21:	8b 10                	mov    (%rax),%edx
  81cb23:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81cb2a:	00 00 00 
  81cb2d:	48 8b 00             	mov    (%rax),%rax
  81cb30:	8b 40 10             	mov    0x10(%rax),%eax

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  81cb33:	39 c2                	cmp    %eax,%edx
  81cb35:	0f 85 86 00 00 00    	jne    81cbc1 <tcp_input+0x7a9>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
        lpcb->local_port == tcphdr->dest) {
  81cb3b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81cb3f:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  81cb43:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81cb4a:	00 00 00 
  81cb4d:	48 8b 00             	mov    (%rax),%rax
  81cb50:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  81cb54:	66 39 c2             	cmp    %ax,%dx
  81cb57:	75 68                	jne    81cbc1 <tcp_input+0x7a9>
        lpcb->local_port == tcphdr->dest) {
        /* Move this PCB to the front of the list so that subsequent
           lookups will be faster (we exploit locality in TCP segment
           arrivals). */
        if (prev != NULL) {
  81cb59:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81cb5e:	74 36                	je     81cb96 <tcp_input+0x77e>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
  81cb60:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81cb64:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81cb68:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81cb6c:	48 89 50 10          	mov    %rdx,0x10(%rax)
                /* our successor is the remainder of the listening list */
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
  81cb70:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  81cb77:	00 00 00 
  81cb7a:	48 8b 10             	mov    (%rax),%rdx
  81cb7d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81cb81:	48 89 50 10          	mov    %rdx,0x10(%rax)
                /* put this listening pcb at the head of the listening list */
          tcp_listen_pcbs.listen_pcbs = lpcb;
  81cb85:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  81cb8c:	00 00 00 
  81cb8f:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81cb93:	48 89 10             	mov    %rdx,(%rax)
        }
      
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
        tcp_listen_input(lpcb);
  81cb96:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81cb9a:	48 89 c7             	mov    %rax,%rdi
  81cb9d:	48 b8 e8 d0 81 00 00 	movabs $0x81d0e8,%rax
  81cba4:	00 00 00 
  81cba7:	ff d0                	callq  *%rax
        pbuf_free(p);
  81cba9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81cbad:	48 89 c7             	mov    %rax,%rdi
  81cbb0:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  81cbb7:	00 00 00 
  81cbba:	ff d0                	callq  *%rax
        return;
  81cbbc:	e9 20 05 00 00       	jmpq   81d0e1 <tcp_input+0xcc9>
      }
      prev = (struct tcp_pcb *)lpcb;
  81cbc1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81cbc5:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  81cbc9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81cbcd:	48 8b 40 10          	mov    0x10(%rax),%rax
  81cbd1:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  81cbd5:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  81cbda:	0f 85 2a ff ff ff    	jne    81cb0a <tcp_input+0x6f2>
  tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
#endif /* TCP_INPUT_DEBUG */


  if (pcb != NULL) {
  81cbe0:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81cbe5:	0f 84 2b 04 00 00    	je     81d016 <tcp_input+0xbfe>
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
  81cbeb:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81cbf2:	00 00 00 
  81cbf5:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    inseg.len = p->tot_len;
  81cbfc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81cc00:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  81cc04:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81cc0b:	00 00 00 
  81cc0e:	66 89 50 18          	mov    %dx,0x18(%rax)
    inseg.dataptr = p->payload;
  81cc12:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81cc16:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81cc1a:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81cc21:	00 00 00 
  81cc24:	48 89 50 10          	mov    %rdx,0x10(%rax)
    inseg.p = p;
  81cc28:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81cc2f:	00 00 00 
  81cc32:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81cc36:	48 89 50 08          	mov    %rdx,0x8(%rax)
    inseg.tcphdr = tcphdr;
  81cc3a:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81cc41:	00 00 00 
  81cc44:	48 8b 10             	mov    (%rax),%rdx
  81cc47:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81cc4e:	00 00 00 
  81cc51:	48 89 50 20          	mov    %rdx,0x20(%rax)

    recv_data = NULL;
  81cc55:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81cc5c:	00 00 00 
  81cc5f:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    recv_flags = 0;
  81cc66:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81cc6d:	00 00 00 
  81cc70:	c6 00 00             	movb   $0x0,(%rax)

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  81cc73:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cc77:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  81cc7e:	48 85 c0             	test   %rax,%rax
  81cc81:	0f 84 9b 00 00 00    	je     81cd22 <tcp_input+0x90a>
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  81cc87:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cc8b:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81cc92:	48 85 c0             	test   %rax,%rax
  81cc95:	74 2e                	je     81ccc5 <tcp_input+0x8ad>
  81cc97:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cc9b:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81cca2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81cca6:	48 8b 92 98 00 00 00 	mov    0x98(%rdx),%rdx
  81ccad:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  81ccb1:	48 8b 79 20          	mov    0x20(%rcx),%rdi
  81ccb5:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  81ccb9:	b9 00 00 00 00       	mov    $0x0,%ecx
  81ccbe:	ff d0                	callq  *%rax
  81ccc0:	88 45 d7             	mov    %al,-0x29(%rbp)
  81ccc3:	eb 2e                	jmp    81ccf3 <tcp_input+0x8db>
  81ccc5:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
  81ccc9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cccd:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  81ccd4:	48 85 c0             	test   %rax,%rax
  81ccd7:	74 1a                	je     81ccf3 <tcp_input+0x8db>
  81ccd9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ccdd:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  81cce4:	48 89 c7             	mov    %rax,%rdi
  81cce7:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  81ccee:	00 00 00 
  81ccf1:	ff d0                	callq  *%rax
      if (err == ERR_OK) {
  81ccf3:	80 7d d7 00          	cmpb   $0x0,-0x29(%rbp)
  81ccf7:	75 11                	jne    81cd0a <tcp_input+0x8f2>
        pcb->refused_data = NULL;
  81ccf9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ccfd:	48 c7 80 98 00 00 00 	movq   $0x0,0x98(%rax)
  81cd04:	00 00 00 00 
  81cd08:	eb 18                	jmp    81cd22 <tcp_input+0x90a>
      } else {
        /* drop incoming packets, because pcb is "full" */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
        TCP_STATS_INC(tcp.drop);
        snmp_inc_tcpinerrs();
        pbuf_free(p);
  81cd0a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81cd0e:	48 89 c7             	mov    %rax,%rdi
  81cd11:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  81cd18:	00 00 00 
  81cd1b:	ff d0                	callq  *%rax
        return;
  81cd1d:	e9 bf 03 00 00       	jmpq   81d0e1 <tcp_input+0xcc9>
      }
    }

    tcp_input_pcb = pcb;
  81cd22:	48 b8 50 b0 b5 00 00 	movabs $0xb5b050,%rax
  81cd29:	00 00 00 
  81cd2c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81cd30:	48 89 10             	mov    %rdx,(%rax)
    err = tcp_process(pcb);
  81cd33:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cd37:	48 89 c7             	mov    %rax,%rdi
  81cd3a:	48 b8 93 d4 81 00 00 	movabs $0x81d493,%rax
  81cd41:	00 00 00 
  81cd44:	ff d0                	callq  *%rax
  81cd46:	88 45 d7             	mov    %al,-0x29(%rbp)
    tcp_input_pcb = NULL;
  81cd49:	48 b8 50 b0 b5 00 00 	movabs $0xb5b050,%rax
  81cd50:	00 00 00 
  81cd53:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
  81cd5a:	80 7d d7 fb          	cmpb   $0xfb,-0x29(%rbp)
  81cd5e:	0f 84 67 02 00 00    	je     81cfcb <tcp_input+0xbb3>
      if (recv_flags & TF_RESET) {
  81cd64:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81cd6b:	00 00 00 
  81cd6e:	0f b6 00             	movzbl (%rax),%eax
  81cd71:	0f b6 c0             	movzbl %al,%eax
  81cd74:	83 e0 08             	and    $0x8,%eax
  81cd77:	85 c0                	test   %eax,%eax
  81cd79:	74 67                	je     81cde2 <tcp_input+0x9ca>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
  81cd7b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cd7f:	48 8b 80 c8 00 00 00 	mov    0xc8(%rax),%rax
  81cd86:	48 85 c0             	test   %rax,%rax
  81cd89:	74 1d                	je     81cda8 <tcp_input+0x990>
  81cd8b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cd8f:	48 8b 80 c8 00 00 00 	mov    0xc8(%rax),%rax
  81cd96:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81cd9a:	48 8b 52 20          	mov    0x20(%rdx),%rdx
  81cd9e:	be fa ff ff ff       	mov    $0xfffffffa,%esi
  81cda3:	48 89 d7             	mov    %rdx,%rdi
  81cda6:	ff d0                	callq  *%rax
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  81cda8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cdac:	48 89 c6             	mov    %rax,%rsi
  81cdaf:	48 bf 18 b0 b5 00 00 	movabs $0xb5b018,%rdi
  81cdb6:	00 00 00 
  81cdb9:	48 b8 a9 0a 81 00 00 	movabs $0x810aa9,%rax
  81cdc0:	00 00 00 
  81cdc3:	ff d0                	callq  *%rax
        memp_free(MEMP_TCP_PCB, pcb);
  81cdc5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cdc9:	48 89 c6             	mov    %rax,%rsi
  81cdcc:	bf 02 00 00 00       	mov    $0x2,%edi
  81cdd1:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  81cdd8:	00 00 00 
  81cddb:	ff d0                	callq  *%rax
  81cddd:	e9 e9 01 00 00       	jmpq   81cfcb <tcp_input+0xbb3>
      } else if (recv_flags & TF_CLOSED) {
  81cde2:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81cde9:	00 00 00 
  81cdec:	0f b6 00             	movzbl (%rax),%eax
  81cdef:	0f b6 c0             	movzbl %al,%eax
  81cdf2:	83 e0 10             	and    $0x10,%eax
  81cdf5:	85 c0                	test   %eax,%eax
  81cdf7:	74 3a                	je     81ce33 <tcp_input+0xa1b>
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  81cdf9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cdfd:	48 89 c6             	mov    %rax,%rsi
  81ce00:	48 bf 18 b0 b5 00 00 	movabs $0xb5b018,%rdi
  81ce07:	00 00 00 
  81ce0a:	48 b8 a9 0a 81 00 00 	movabs $0x810aa9,%rax
  81ce11:	00 00 00 
  81ce14:	ff d0                	callq  *%rax
        memp_free(MEMP_TCP_PCB, pcb);
  81ce16:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ce1a:	48 89 c6             	mov    %rax,%rsi
  81ce1d:	bf 02 00 00 00       	mov    $0x2,%edi
  81ce22:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  81ce29:	00 00 00 
  81ce2c:	ff d0                	callq  *%rax
  81ce2e:	e9 98 01 00 00       	jmpq   81cfcb <tcp_input+0xbb3>
      } else {
        err = ERR_OK;
  81ce33:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
  81ce37:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ce3b:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  81ce3f:	66 85 c0             	test   %ax,%ax
  81ce42:	74 3a                	je     81ce7e <tcp_input+0xa66>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
  81ce44:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ce48:	48 8b 80 a0 00 00 00 	mov    0xa0(%rax),%rax
  81ce4f:	48 85 c0             	test   %rax,%rax
  81ce52:	74 2a                	je     81ce7e <tcp_input+0xa66>
  81ce54:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ce58:	48 8b 80 a0 00 00 00 	mov    0xa0(%rax),%rax
  81ce5f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81ce63:	0f b7 52 78          	movzwl 0x78(%rdx),%edx
  81ce67:	0f b7 d2             	movzwl %dx,%edx
  81ce6a:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  81ce6e:	48 8b 49 20          	mov    0x20(%rcx),%rcx
  81ce72:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  81ce76:	48 89 cf             	mov    %rcx,%rdi
  81ce79:	ff d0                	callq  *%rax
  81ce7b:	88 45 d7             	mov    %al,-0x29(%rbp)
        }
      
        if (recv_data != NULL) {
  81ce7e:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81ce85:	00 00 00 
  81ce88:	48 8b 00             	mov    (%rax),%rax
  81ce8b:	48 85 c0             	test   %rax,%rax
  81ce8e:	0f 84 cb 00 00 00    	je     81cf5f <tcp_input+0xb47>
          if(flags & TCP_PSH) {
  81ce94:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81ce9b:	00 00 00 
  81ce9e:	0f b6 00             	movzbl (%rax),%eax
  81cea1:	0f b6 c0             	movzbl %al,%eax
  81cea4:	83 e0 08             	and    $0x8,%eax
  81cea7:	85 c0                	test   %eax,%eax
  81cea9:	74 24                	je     81cecf <tcp_input+0xab7>
            recv_data->flags |= PBUF_FLAG_PUSH;
  81ceab:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81ceb2:	00 00 00 
  81ceb5:	48 8b 00             	mov    (%rax),%rax
  81ceb8:	48 ba e8 74 b5 00 00 	movabs $0xb574e8,%rdx
  81cebf:	00 00 00 
  81cec2:	48 8b 12             	mov    (%rdx),%rdx
  81cec5:	0f b6 52 15          	movzbl 0x15(%rdx),%edx
  81cec9:	83 ca 01             	or     $0x1,%edx
  81cecc:	88 50 15             	mov    %dl,0x15(%rax)
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  81cecf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ced3:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81ceda:	48 85 c0             	test   %rax,%rax
  81cedd:	74 30                	je     81cf0f <tcp_input+0xaf7>
  81cedf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cee3:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81ceea:	48 ba e8 74 b5 00 00 	movabs $0xb574e8,%rdx
  81cef1:	00 00 00 
  81cef4:	48 8b 12             	mov    (%rdx),%rdx
  81cef7:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  81cefb:	48 8b 79 20          	mov    0x20(%rcx),%rdi
  81ceff:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  81cf03:	b9 00 00 00 00       	mov    $0x0,%ecx
  81cf08:	ff d0                	callq  *%rax
  81cf0a:	88 45 d7             	mov    %al,-0x29(%rbp)
  81cf0d:	eb 32                	jmp    81cf41 <tcp_input+0xb29>
  81cf0f:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
  81cf13:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81cf1a:	00 00 00 
  81cf1d:	48 8b 00             	mov    (%rax),%rax
  81cf20:	48 85 c0             	test   %rax,%rax
  81cf23:	74 1c                	je     81cf41 <tcp_input+0xb29>
  81cf25:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81cf2c:	00 00 00 
  81cf2f:	48 8b 00             	mov    (%rax),%rax
  81cf32:	48 89 c7             	mov    %rax,%rdi
  81cf35:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  81cf3c:	00 00 00 
  81cf3f:	ff d0                	callq  *%rax

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
  81cf41:	80 7d d7 00          	cmpb   $0x0,-0x29(%rbp)
  81cf45:	74 18                	je     81cf5f <tcp_input+0xb47>
            pcb->refused_data = recv_data;
  81cf47:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81cf4e:	00 00 00 
  81cf51:	48 8b 10             	mov    (%rax),%rdx
  81cf54:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cf58:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
  81cf5f:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81cf66:	00 00 00 
  81cf69:	0f b6 00             	movzbl (%rax),%eax
  81cf6c:	0f b6 c0             	movzbl %al,%eax
  81cf6f:	83 e0 20             	and    $0x20,%eax
  81cf72:	85 c0                	test   %eax,%eax
  81cf74:	74 3c                	je     81cfb2 <tcp_input+0xb9a>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
  81cf76:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cf7a:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81cf81:	48 85 c0             	test   %rax,%rax
  81cf84:	74 28                	je     81cfae <tcp_input+0xb96>
  81cf86:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cf8a:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81cf91:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81cf95:	48 8b 7a 20          	mov    0x20(%rdx),%rdi
  81cf99:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  81cf9d:	b9 00 00 00 00       	mov    $0x0,%ecx
  81cfa2:	ba 00 00 00 00       	mov    $0x0,%edx
  81cfa7:	ff d0                	callq  *%rax
  81cfa9:	88 45 d7             	mov    %al,-0x29(%rbp)
  81cfac:	eb 04                	jmp    81cfb2 <tcp_input+0xb9a>
  81cfae:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
        }

        /* If there were no errors, we try to send something out. */
        if (err == ERR_OK) {
  81cfb2:	80 7d d7 00          	cmpb   $0x0,-0x29(%rbp)
  81cfb6:	75 13                	jne    81cfcb <tcp_input+0xbb3>
          tcp_output(pcb);
  81cfb8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cfbc:	48 89 c7             	mov    %rax,%rdi
  81cfbf:	48 b8 3d 3c 81 00 00 	movabs $0x813c3d,%rax
  81cfc6:	00 00 00 
  81cfc9:	ff d0                	callq  *%rax
      }
    }


    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
  81cfcb:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81cfd2:	00 00 00 
  81cfd5:	48 8b 40 08          	mov    0x8(%rax),%rax
  81cfd9:	48 85 c0             	test   %rax,%rax
  81cfdc:	0f 84 ff 00 00 00    	je     81d0e1 <tcp_input+0xcc9>
    {
      pbuf_free(inseg.p);
  81cfe2:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81cfe9:	00 00 00 
  81cfec:	48 8b 40 08          	mov    0x8(%rax),%rax
  81cff0:	48 89 c7             	mov    %rax,%rdi
  81cff3:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  81cffa:	00 00 00 
  81cffd:	ff d0                	callq  *%rax
      inseg.p = NULL;
  81cfff:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81d006:	00 00 00 
  81d009:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81d010:	00 
  81d011:	e9 cb 00 00 00       	jmpq   81d0e1 <tcp_input+0xcc9>
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
  81d016:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d01d:	00 00 00 
  81d020:	48 8b 00             	mov    (%rax),%rax
  81d023:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81d027:	0f b7 c0             	movzwl %ax,%eax
  81d02a:	89 c7                	mov    %eax,%edi
  81d02c:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  81d033:	00 00 00 
  81d036:	ff d0                	callq  *%rax
  81d038:	0f b7 c0             	movzwl %ax,%eax
  81d03b:	83 e0 04             	and    $0x4,%eax
  81d03e:	85 c0                	test   %eax,%eax
  81d040:	0f 85 88 00 00 00    	jne    81d0ce <tcp_input+0xcb6>
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  81d046:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d04d:	00 00 00 
  81d050:	48 8b 00             	mov    (%rax),%rax
  81d053:	0f b7 00             	movzwl (%rax),%eax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  81d056:	44 0f b7 c0          	movzwl %ax,%r8d
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  81d05a:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d061:	00 00 00 
  81d064:	48 8b 00             	mov    (%rax),%rax
  81d067:	0f b7 40 02          	movzwl 0x2(%rax),%eax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  81d06b:	0f b7 f8             	movzwl %ax,%edi
        &(iphdr->dest), &(iphdr->src),
  81d06e:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d075:	00 00 00 
  81d078:	48 8b 00             	mov    (%rax),%rax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  81d07b:	48 8d 48 0c          	lea    0xc(%rax),%rcx
        &(iphdr->dest), &(iphdr->src),
  81d07f:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d086:	00 00 00 
  81d089:	48 8b 00             	mov    (%rax),%rax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  81d08c:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81d090:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81d097:	00 00 00 
  81d09a:	0f b7 00             	movzwl (%rax),%eax
  81d09d:	0f b7 f0             	movzwl %ax,%esi
  81d0a0:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d0a7:	00 00 00 
  81d0aa:	8b 00                	mov    (%rax),%eax
  81d0ac:	01 c6                	add    %eax,%esi
  81d0ae:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81d0b5:	00 00 00 
  81d0b8:	8b 00                	mov    (%rax),%eax
  81d0ba:	45 89 c1             	mov    %r8d,%r9d
  81d0bd:	41 89 f8             	mov    %edi,%r8d
  81d0c0:	89 c7                	mov    %eax,%edi
  81d0c2:	48 b8 48 45 81 00 00 	movabs $0x814548,%rax
  81d0c9:	00 00 00 
  81d0cc:	ff d0                	callq  *%rax
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    pbuf_free(p);
  81d0ce:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81d0d2:	48 89 c7             	mov    %rax,%rdi
  81d0d5:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  81d0dc:	00 00 00 
  81d0df:	ff d0                	callq  *%rax
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
}
  81d0e1:	48 83 c4 38          	add    $0x38,%rsp
  81d0e5:	5b                   	pop    %rbx
  81d0e6:	5d                   	pop    %rbp
  81d0e7:	c3                   	retq   

000000000081d0e8 <tcp_listen_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_listen_input(struct tcp_pcb_listen *pcb)
{
  81d0e8:	55                   	push   %rbp
  81d0e9:	48 89 e5             	mov    %rsp,%rbp
  81d0ec:	48 83 ec 20          	sub    $0x20,%rsp
  81d0f0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_pcb *npcb;
  u32_t optdata;

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
  81d0f4:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d0fb:	00 00 00 
  81d0fe:	0f b6 00             	movzbl (%rax),%eax
  81d101:	0f b6 c0             	movzbl %al,%eax
  81d104:	83 e0 10             	and    $0x10,%eax
  81d107:	85 c0                	test   %eax,%eax
  81d109:	0f 84 90 00 00 00    	je     81d19f <tcp_listen_input+0xb7>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  81d10f:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d116:	00 00 00 
  81d119:	48 8b 00             	mov    (%rax),%rax
  81d11c:	0f b7 00             	movzwl (%rax),%eax
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  81d11f:	44 0f b7 c0          	movzwl %ax,%r8d
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  81d123:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d12a:	00 00 00 
  81d12d:	48 8b 00             	mov    (%rax),%rax
  81d130:	0f b7 40 02          	movzwl 0x2(%rax),%eax
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  81d134:	0f b7 f8             	movzwl %ax,%edi
      &(iphdr->dest), &(iphdr->src),
  81d137:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d13e:	00 00 00 
  81d141:	48 8b 00             	mov    (%rax),%rax
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  81d144:	48 8d 48 0c          	lea    0xc(%rax),%rcx
      &(iphdr->dest), &(iphdr->src),
  81d148:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d14f:	00 00 00 
  81d152:	48 8b 00             	mov    (%rax),%rax
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  81d155:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81d159:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81d160:	00 00 00 
  81d163:	0f b7 00             	movzwl (%rax),%eax
  81d166:	0f b7 f0             	movzwl %ax,%esi
  81d169:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d170:	00 00 00 
  81d173:	8b 00                	mov    (%rax),%eax
  81d175:	01 c6                	add    %eax,%esi
  81d177:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81d17e:	00 00 00 
  81d181:	8b 00                	mov    (%rax),%eax
  81d183:	83 c0 01             	add    $0x1,%eax
  81d186:	45 89 c1             	mov    %r8d,%r9d
  81d189:	41 89 f8             	mov    %edi,%r8d
  81d18c:	89 c7                	mov    %eax,%edi
  81d18e:	48 b8 48 45 81 00 00 	movabs $0x814548,%rax
  81d195:	00 00 00 
  81d198:	ff d0                	callq  *%rax
  81d19a:	e9 41 02 00 00       	jmpq   81d3e0 <tcp_listen_input+0x2f8>
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
  81d19f:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d1a6:	00 00 00 
  81d1a9:	0f b6 00             	movzbl (%rax),%eax
  81d1ac:	0f b6 c0             	movzbl %al,%eax
  81d1af:	83 e0 02             	and    $0x2,%eax
  81d1b2:	85 c0                	test   %eax,%eax
  81d1b4:	0f 84 26 02 00 00    	je     81d3e0 <tcp_listen_input+0x2f8>
#if TCP_LISTEN_BACKLOG
    if (pcb->accepts_pending >= pcb->backlog) {
      return ERR_ABRT;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
  81d1ba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d1be:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  81d1c2:	0f b6 c0             	movzbl %al,%eax
  81d1c5:	89 c7                	mov    %eax,%edi
  81d1c7:	48 b8 14 07 81 00 00 	movabs $0x810714,%rax
  81d1ce:	00 00 00 
  81d1d1:	ff d0                	callq  *%rax
  81d1d3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
  81d1d7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81d1dc:	75 0a                	jne    81d1e8 <tcp_listen_input+0x100>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: could not allocate PCB\n"));
      TCP_STATS_INC(tcp.memerr);
      return ERR_MEM;
  81d1de:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81d1e3:	e9 fd 01 00 00       	jmpq   81d3e5 <tcp_listen_input+0x2fd>
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  81d1e8:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d1ef:	00 00 00 
  81d1f2:	48 8b 00             	mov    (%rax),%rax
  81d1f5:	48 83 c0 10          	add    $0x10,%rax
  81d1f9:	48 85 c0             	test   %rax,%rax
  81d1fc:	74 12                	je     81d210 <tcp_listen_input+0x128>
  81d1fe:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d205:	00 00 00 
  81d208:	48 8b 00             	mov    (%rax),%rax
  81d20b:	8b 40 10             	mov    0x10(%rax),%eax
  81d20e:	eb 05                	jmp    81d215 <tcp_listen_input+0x12d>
  81d210:	b8 00 00 00 00       	mov    $0x0,%eax
  81d215:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81d219:	89 02                	mov    %eax,(%rdx)
    npcb->local_port = pcb->local_port;
  81d21b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d21f:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  81d223:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d227:	66 89 50 28          	mov    %dx,0x28(%rax)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  81d22b:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d232:	00 00 00 
  81d235:	48 8b 00             	mov    (%rax),%rax
  81d238:	48 83 c0 0c          	add    $0xc,%rax
  81d23c:	48 85 c0             	test   %rax,%rax
  81d23f:	74 12                	je     81d253 <tcp_listen_input+0x16b>
  81d241:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d248:	00 00 00 
  81d24b:	48 8b 00             	mov    (%rax),%rax
  81d24e:	8b 40 0c             	mov    0xc(%rax),%eax
  81d251:	eb 05                	jmp    81d258 <tcp_listen_input+0x170>
  81d253:	b8 00 00 00 00       	mov    $0x0,%eax
  81d258:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81d25c:	89 42 04             	mov    %eax,0x4(%rdx)
    npcb->remote_port = tcphdr->src;
  81d25f:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d266:	00 00 00 
  81d269:	48 8b 00             	mov    (%rax),%rax
  81d26c:	0f b7 10             	movzwl (%rax),%edx
  81d26f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d273:	66 89 50 2a          	mov    %dx,0x2a(%rax)
    npcb->state = SYN_RCVD;
  81d277:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d27b:	c7 40 18 03 00 00 00 	movl   $0x3,0x18(%rax)
    npcb->rcv_nxt = seqno + 1;
  81d282:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d289:	00 00 00 
  81d28c:	8b 00                	mov    (%rax),%eax
  81d28e:	8d 50 01             	lea    0x1(%rax),%edx
  81d291:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d295:	89 50 30             	mov    %edx,0x30(%rax)
    npcb->snd_wnd = tcphdr->wnd;
  81d298:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d29f:	00 00 00 
  81d2a2:	48 8b 00             	mov    (%rax),%rax
  81d2a5:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
  81d2a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d2ad:	66 89 50 68          	mov    %dx,0x68(%rax)
    npcb->ssthresh = npcb->snd_wnd;
  81d2b1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d2b5:	0f b7 50 68          	movzwl 0x68(%rax),%edx
  81d2b9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d2bd:	66 89 50 5c          	mov    %dx,0x5c(%rax)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
  81d2c1:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d2c8:	00 00 00 
  81d2cb:	8b 00                	mov    (%rax),%eax
  81d2cd:	8d 50 ff             	lea    -0x1(%rax),%edx
  81d2d0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d2d4:	89 50 6c             	mov    %edx,0x6c(%rax)
    npcb->callback_arg = pcb->callback_arg;
  81d2d7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d2db:	48 8b 50 20          	mov    0x20(%rax),%rdx
  81d2df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d2e3:	48 89 50 20          	mov    %rdx,0x20(%rax)
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
  81d2e7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d2eb:	48 8b 50 30          	mov    0x30(%rax),%rdx
  81d2ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d2f3:	48 89 90 b8 00 00 00 	mov    %rdx,0xb8(%rax)
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
  81d2fa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d2fe:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  81d302:	66 25 99 01          	and    $0x199,%ax
  81d306:	89 c2                	mov    %eax,%edx
  81d308:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d30c:	66 89 50 08          	mov    %dx,0x8(%rax)
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG(&tcp_active_pcbs, npcb);
  81d310:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81d317:	00 00 00 
  81d31a:	48 8b 10             	mov    (%rax),%rdx
  81d31d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d321:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81d325:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81d32c:	00 00 00 
  81d32f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81d333:	48 89 10             	mov    %rdx,(%rax)
  81d336:	48 b8 f1 86 80 00 00 	movabs $0x8086f1,%rax
  81d33d:	00 00 00 
  81d340:	ff d0                	callq  *%rax

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
  81d342:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d346:	48 89 c7             	mov    %rax,%rdi
  81d349:	48 b8 c9 fb 81 00 00 	movabs $0x81fbc9,%rax
  81d350:	00 00 00 
  81d353:	ff d0                	callq  *%rax
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
  81d355:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d359:	48 8d 50 04          	lea    0x4(%rax),%rdx
  81d35d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d361:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81d365:	0f b7 c0             	movzwl %ax,%eax
  81d368:	48 89 d6             	mov    %rdx,%rsi
  81d36b:	89 c7                	mov    %eax,%edi
  81d36d:	48 b8 de 0c 81 00 00 	movabs $0x810cde,%rax
  81d374:	00 00 00 
  81d377:	ff d0                	callq  *%rax
  81d379:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81d37d:	66 89 42 40          	mov    %ax,0x40(%rdx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Build an MSS option. */
    optdata = TCP_BUILD_MSS_OPTION();
  81d381:	bf b4 05 04 02       	mov    $0x20405b4,%edi
  81d386:	48 b8 54 30 81 00 00 	movabs $0x813054,%rax
  81d38d:	00 00 00 
  81d390:	ff d0                	callq  *%rax
  81d392:	89 45 f4             	mov    %eax,-0xc(%rbp)
    /* Send a SYN|ACK together with the MSS option. */
    tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&optdata, 4);
  81d395:	48 8d 55 f4          	lea    -0xc(%rbp),%rdx
  81d399:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d39d:	c7 04 24 04 00 00 00 	movl   $0x4,(%rsp)
  81d3a4:	49 89 d1             	mov    %rdx,%r9
  81d3a7:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  81d3ad:	b9 12 00 00 00       	mov    $0x12,%ecx
  81d3b2:	ba 00 00 00 00       	mov    $0x0,%edx
  81d3b7:	be 00 00 00 00       	mov    $0x0,%esi
  81d3bc:	48 89 c7             	mov    %rax,%rdi
  81d3bf:	48 b8 87 31 81 00 00 	movabs $0x813187,%rax
  81d3c6:	00 00 00 
  81d3c9:	ff d0                	callq  *%rax
    return tcp_output(npcb);
  81d3cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d3cf:	48 89 c7             	mov    %rax,%rdi
  81d3d2:	48 b8 3d 3c 81 00 00 	movabs $0x813c3d,%rax
  81d3d9:	00 00 00 
  81d3dc:	ff d0                	callq  *%rax
  81d3de:	eb 05                	jmp    81d3e5 <tcp_listen_input+0x2fd>
  }
  return ERR_OK;
  81d3e0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81d3e5:	c9                   	leaveq 
  81d3e6:	c3                   	retq   

000000000081d3e7 <tcp_timewait_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
  81d3e7:	55                   	push   %rbp
  81d3e8:	48 89 e5             	mov    %rsp,%rbp
  81d3eb:	48 83 ec 10          	sub    $0x10,%rsp
  81d3ef:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
  81d3f3:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81d3fa:	00 00 00 
  81d3fd:	0f b7 00             	movzwl (%rax),%eax
  81d400:	0f b7 d0             	movzwl %ax,%edx
  81d403:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d40a:	00 00 00 
  81d40d:	8b 00                	mov    (%rax),%eax
  81d40f:	01 c2                	add    %eax,%edx
  81d411:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d415:	8b 40 30             	mov    0x30(%rax),%eax
  81d418:	29 c2                	sub    %eax,%edx
  81d41a:	89 d0                	mov    %edx,%eax
  81d41c:	85 c0                	test   %eax,%eax
  81d41e:	7e 25                	jle    81d445 <tcp_timewait_input+0x5e>
    pcb->rcv_nxt = seqno + tcplen;
  81d420:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81d427:	00 00 00 
  81d42a:	0f b7 00             	movzwl (%rax),%eax
  81d42d:	0f b7 d0             	movzwl %ax,%edx
  81d430:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d437:	00 00 00 
  81d43a:	8b 00                	mov    (%rax),%eax
  81d43c:	01 c2                	add    %eax,%edx
  81d43e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d442:	89 50 30             	mov    %edx,0x30(%rax)
  }
  if (tcplen > 0) {
  81d445:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81d44c:	00 00 00 
  81d44f:	0f b7 00             	movzwl (%rax),%eax
  81d452:	66 85 c0             	test   %ax,%ax
  81d455:	74 27                	je     81d47e <tcp_timewait_input+0x97>
    tcp_ack_now(pcb);
  81d457:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d45b:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81d45f:	83 c8 02             	or     $0x2,%eax
  81d462:	89 c2                	mov    %eax,%edx
  81d464:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d468:	88 50 2c             	mov    %dl,0x2c(%rax)
  81d46b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d46f:	48 89 c7             	mov    %rax,%rdi
  81d472:	48 b8 3d 3c 81 00 00 	movabs $0x813c3d,%rax
  81d479:	00 00 00 
  81d47c:	ff d0                	callq  *%rax
  }
  return tcp_output(pcb);
  81d47e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d482:	48 89 c7             	mov    %rax,%rdi
  81d485:	48 b8 3d 3c 81 00 00 	movabs $0x813c3d,%rax
  81d48c:	00 00 00 
  81d48f:	ff d0                	callq  *%rax
}
  81d491:	c9                   	leaveq 
  81d492:	c3                   	retq   

000000000081d493 <tcp_process>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_process(struct tcp_pcb *pcb)
{
  81d493:	55                   	push   %rbp
  81d494:	48 89 e5             	mov    %rsp,%rbp
  81d497:	48 83 ec 30          	sub    $0x30,%rsp
  81d49b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  struct tcp_seg *rseg;
  u8_t acceptable = 0;
  81d49f:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  err_t err;
  u8_t accepted_inseq;

  err = ERR_OK;
  81d4a3:	c6 45 fe 00          	movb   $0x0,-0x2(%rbp)

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
  81d4a7:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d4ae:	00 00 00 
  81d4b1:	0f b6 00             	movzbl (%rax),%eax
  81d4b4:	0f b6 c0             	movzbl %al,%eax
  81d4b7:	83 e0 04             	and    $0x4,%eax
  81d4ba:	85 c0                	test   %eax,%eax
  81d4bc:	0f 84 e0 00 00 00    	je     81d5a2 <tcp_process+0x10f>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
  81d4c2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d4c6:	8b 40 18             	mov    0x18(%rax),%eax
  81d4c9:	83 f8 02             	cmp    $0x2,%eax
  81d4cc:	75 1d                	jne    81d4eb <tcp_process+0x58>
      if (ackno == pcb->snd_nxt) {
  81d4ce:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d4d2:	8b 50 60             	mov    0x60(%rax),%edx
  81d4d5:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81d4dc:	00 00 00 
  81d4df:	8b 00                	mov    (%rax),%eax
  81d4e1:	39 c2                	cmp    %eax,%edx
  81d4e3:	75 4d                	jne    81d532 <tcp_process+0x9f>
        acceptable = 1;
  81d4e5:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
  81d4e9:	eb 47                	jmp    81d532 <tcp_process+0x9f>
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  81d4eb:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d4f2:	00 00 00 
  81d4f5:	8b 10                	mov    (%rax),%edx
  81d4f7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d4fb:	8b 40 30             	mov    0x30(%rax),%eax
  81d4fe:	29 c2                	sub    %eax,%edx
  81d500:	89 d0                	mov    %edx,%eax
  81d502:	85 c0                	test   %eax,%eax
  81d504:	78 2c                	js     81d532 <tcp_process+0x9f>
  81d506:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d50d:	00 00 00 
  81d510:	8b 10                	mov    (%rax),%edx
  81d512:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d516:	8b 48 30             	mov    0x30(%rax),%ecx
  81d519:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d51d:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  81d521:	0f b7 c0             	movzwl %ax,%eax
  81d524:	01 c8                	add    %ecx,%eax
  81d526:	29 c2                	sub    %eax,%edx
  81d528:	89 d0                	mov    %edx,%eax
  81d52a:	85 c0                	test   %eax,%eax
  81d52c:	7f 04                	jg     81d532 <tcp_process+0x9f>
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
  81d52e:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
      }
    }

    if (acceptable) {
  81d532:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  81d536:	74 60                	je     81d598 <tcp_process+0x105>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  81d538:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d53c:	8b 40 18             	mov    0x18(%rax),%eax
  81d53f:	85 c0                	test   %eax,%eax
  81d541:	75 2a                	jne    81d56d <tcp_process+0xda>
  81d543:	48 ba a8 3a 82 00 00 	movabs $0x823aa8,%rdx
  81d54a:	00 00 00 
  81d54d:	be 0a 02 00 00       	mov    $0x20a,%esi
  81d552:	48 bf a7 39 82 00 00 	movabs $0x8239a7,%rdi
  81d559:	00 00 00 
  81d55c:	b8 00 00 00 00       	mov    $0x0,%eax
  81d561:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81d568:	00 00 00 
  81d56b:	ff d1                	callq  *%rcx
      recv_flags = TF_RESET;
  81d56d:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81d574:	00 00 00 
  81d577:	c6 00 08             	movb   $0x8,(%rax)
      pcb->flags &= ~TF_ACK_DELAY;
  81d57a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d57e:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81d582:	83 e0 fe             	and    $0xfffffffe,%eax
  81d585:	89 c2                	mov    %eax,%edx
  81d587:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d58b:	88 50 2c             	mov    %dl,0x2c(%rax)
      return ERR_RST;
  81d58e:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  81d593:	e9 c7 0b 00 00       	jmpq   81e15f <tcp_process+0xccc>
    } else {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      return ERR_OK;
  81d598:	b8 00 00 00 00       	mov    $0x0,%eax
  81d59d:	e9 bd 0b 00 00       	jmpq   81e15f <tcp_process+0xccc>
    }
  }

  /* Update the PCB (in)activity timer. */
  pcb->tmr = tcp_ticks;
  81d5a2:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  81d5a9:	00 00 00 
  81d5ac:	8b 10                	mov    (%rax),%edx
  81d5ae:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d5b2:	89 50 38             	mov    %edx,0x38(%rax)
  pcb->keep_cnt_sent = 0;
  81d5b5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d5b9:	c6 80 d9 00 00 00 00 	movb   $0x0,0xd9(%rax)

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
  81d5c0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d5c4:	8b 40 18             	mov    0x18(%rax),%eax
  81d5c7:	83 f8 09             	cmp    $0x9,%eax
  81d5ca:	0f 87 89 0b 00 00    	ja     81e159 <tcp_process+0xcc6>
  81d5d0:	89 c0                	mov    %eax,%eax
  81d5d2:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  81d5d9:	00 
  81d5da:	48 b8 f8 3a 82 00 00 	movabs $0x823af8,%rax
  81d5e1:	00 00 00 
  81d5e4:	48 01 d0             	add    %rdx,%rax
  81d5e7:	48 8b 00             	mov    (%rax),%rax
  81d5ea:	ff e0                	jmpq   *%rax
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  81d5ec:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d5f3:	00 00 00 
  81d5f6:	0f b6 00             	movzbl (%rax),%eax
  81d5f9:	0f b6 c0             	movzbl %al,%eax
  81d5fc:	83 e0 10             	and    $0x10,%eax
  81d5ff:	85 c0                	test   %eax,%eax
  81d601:	0f 84 58 02 00 00    	je     81d85f <tcp_process+0x3cc>
  81d607:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d60e:	00 00 00 
  81d611:	0f b6 00             	movzbl (%rax),%eax
  81d614:	0f b6 c0             	movzbl %al,%eax
  81d617:	83 e0 02             	and    $0x2,%eax
  81d61a:	85 c0                	test   %eax,%eax
  81d61c:	0f 84 3d 02 00 00    	je     81d85f <tcp_process+0x3cc>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
  81d622:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d626:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81d62d:	48 8b 40 20          	mov    0x20(%rax),%rax
  81d631:	8b 40 04             	mov    0x4(%rax),%eax
  81d634:	89 c7                	mov    %eax,%edi
  81d636:	48 b8 8c 30 81 00 00 	movabs $0x81308c,%rax
  81d63d:	00 00 00 
  81d640:	ff d0                	callq  *%rax
  81d642:	8d 50 01             	lea    0x1(%rax),%edx
  81d645:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81d64c:	00 00 00 
  81d64f:	8b 00                	mov    (%rax),%eax
  81d651:	39 c2                	cmp    %eax,%edx
  81d653:	0f 85 06 02 00 00    	jne    81d85f <tcp_process+0x3cc>
      pcb->snd_buf++;
  81d659:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d65d:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  81d661:	8d 50 01             	lea    0x1(%rax),%edx
  81d664:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d668:	66 89 50 7a          	mov    %dx,0x7a(%rax)
      pcb->rcv_nxt = seqno + 1;
  81d66c:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d673:	00 00 00 
  81d676:	8b 00                	mov    (%rax),%eax
  81d678:	8d 50 01             	lea    0x1(%rax),%edx
  81d67b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d67f:	89 50 30             	mov    %edx,0x30(%rax)
      pcb->lastack = ackno;
  81d682:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81d689:	00 00 00 
  81d68c:	8b 10                	mov    (%rax),%edx
  81d68e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d692:	89 50 54             	mov    %edx,0x54(%rax)
      pcb->snd_wnd = tcphdr->wnd;
  81d695:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d69c:	00 00 00 
  81d69f:	48 8b 00             	mov    (%rax),%rax
  81d6a2:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
  81d6a6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d6aa:	66 89 50 68          	mov    %dx,0x68(%rax)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
  81d6ae:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d6b5:	00 00 00 
  81d6b8:	8b 00                	mov    (%rax),%eax
  81d6ba:	8d 50 ff             	lea    -0x1(%rax),%edx
  81d6bd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d6c1:	89 50 6c             	mov    %edx,0x6c(%rax)
      pcb->state = ESTABLISHED;
  81d6c4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d6c8:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%rax)

      /* Parse any options in the SYNACK before using pcb->mss since that
       * can be changed by the received options! */
      tcp_parseopt(pcb);
  81d6cf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d6d3:	48 89 c7             	mov    %rax,%rdi
  81d6d6:	48 b8 c9 fb 81 00 00 	movabs $0x81fbc9,%rax
  81d6dd:	00 00 00 
  81d6e0:	ff d0                	callq  *%rax
#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
  81d6e2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d6e6:	48 8d 50 04          	lea    0x4(%rax),%rdx
  81d6ea:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d6ee:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81d6f2:	0f b7 c0             	movzwl %ax,%eax
  81d6f5:	48 89 d6             	mov    %rdx,%rsi
  81d6f8:	89 c7                	mov    %eax,%edi
  81d6fa:	48 b8 de 0c 81 00 00 	movabs $0x810cde,%rax
  81d701:	00 00 00 
  81d704:	ff d0                	callq  *%rax
  81d706:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81d70a:	66 89 42 40          	mov    %ax,0x40(%rdx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
  81d70e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d712:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  81d716:	89 d0                	mov    %edx,%eax
  81d718:	c1 e0 02             	shl    $0x2,%eax
  81d71b:	01 d0                	add    %edx,%eax
  81d71d:	01 c0                	add    %eax,%eax
  81d71f:	89 c2                	mov    %eax,%edx
  81d721:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d725:	66 89 50 5c          	mov    %dx,0x5c(%rax)

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  81d729:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d72d:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81d731:	66 83 f8 01          	cmp    $0x1,%ax
  81d735:	75 0c                	jne    81d743 <tcp_process+0x2b0>
  81d737:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d73b:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81d73f:	01 c0                	add    %eax,%eax
  81d741:	eb 08                	jmp    81d74b <tcp_process+0x2b8>
  81d743:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d747:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81d74b:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81d74f:	66 89 42 5a          	mov    %ax,0x5a(%rdx)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  81d753:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d757:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  81d75b:	66 85 c0             	test   %ax,%ax
  81d75e:	75 2a                	jne    81d78a <tcp_process+0x2f7>
  81d760:	48 ba c8 3a 82 00 00 	movabs $0x823ac8,%rdx
  81d767:	00 00 00 
  81d76a:	be 36 02 00 00       	mov    $0x236,%esi
  81d76f:	48 bf a7 39 82 00 00 	movabs $0x8239a7,%rdi
  81d776:	00 00 00 
  81d779:	b8 00 00 00 00       	mov    $0x0,%eax
  81d77e:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81d785:	00 00 00 
  81d788:	ff d1                	callq  *%rcx
      --pcb->snd_queuelen;
  81d78a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d78e:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  81d792:	8d 50 ff             	lea    -0x1(%rax),%edx
  81d795:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d799:	66 89 50 7c          	mov    %dx,0x7c(%rax)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
  81d79d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d7a1:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81d7a8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      pcb->unacked = rseg->next;
  81d7ac:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81d7b0:	48 8b 10             	mov    (%rax),%rdx
  81d7b3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d7b7:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  81d7be:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d7c2:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81d7c9:	48 85 c0             	test   %rax,%rax
  81d7cc:	75 0c                	jne    81d7da <tcp_process+0x347>
        pcb->rtime = -1;
  81d7ce:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d7d2:	66 c7 40 3e ff ff    	movw   $0xffff,0x3e(%rax)
  81d7d8:	eb 12                	jmp    81d7ec <tcp_process+0x359>
      else {
        pcb->rtime = 0;
  81d7da:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d7de:	66 c7 40 3e 00 00    	movw   $0x0,0x3e(%rax)
        pcb->nrtx = 0;
  81d7e4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d7e8:	c6 40 52 00          	movb   $0x0,0x52(%rax)
      }

      tcp_seg_free(rseg);
  81d7ec:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81d7f0:	48 89 c7             	mov    %rax,%rdi
  81d7f3:	48 b8 7c 04 81 00 00 	movabs $0x81047c,%rax
  81d7fa:	00 00 00 
  81d7fd:	ff d0                	callq  *%rax

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
  81d7ff:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d803:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  81d80a:	48 85 c0             	test   %rax,%rax
  81d80d:	74 24                	je     81d833 <tcp_process+0x3a0>
  81d80f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d813:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  81d81a:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81d81e:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
  81d822:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  81d826:	ba 00 00 00 00       	mov    $0x0,%edx
  81d82b:	48 89 cf             	mov    %rcx,%rdi
  81d82e:	ff d0                	callq  *%rax
  81d830:	88 45 fe             	mov    %al,-0x2(%rbp)
      tcp_ack_now(pcb);
  81d833:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d837:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81d83b:	83 c8 02             	or     $0x2,%eax
  81d83e:	89 c2                	mov    %eax,%edx
  81d840:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d844:	88 50 2c             	mov    %dl,0x2c(%rax)
  81d847:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d84b:	48 89 c7             	mov    %rax,%rdi
  81d84e:	48 b8 3d 3c 81 00 00 	movabs $0x813c3d,%rax
  81d855:	00 00 00 
  81d858:	ff d0                	callq  *%rax
  81d85a:	e9 a8 00 00 00       	jmpq   81d907 <tcp_process+0x474>
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
  81d85f:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d866:	00 00 00 
  81d869:	0f b6 00             	movzbl (%rax),%eax
  81d86c:	0f b6 c0             	movzbl %al,%eax
  81d86f:	83 e0 10             	and    $0x10,%eax
  81d872:	85 c0                	test   %eax,%eax
  81d874:	0f 84 8d 00 00 00    	je     81d907 <tcp_process+0x474>
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  81d87a:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d881:	00 00 00 
  81d884:	48 8b 00             	mov    (%rax),%rax
  81d887:	0f b7 00             	movzwl (%rax),%eax
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  81d88a:	44 0f b7 c0          	movzwl %ax,%r8d
        tcphdr->dest, tcphdr->src);
  81d88e:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d895:	00 00 00 
  81d898:	48 8b 00             	mov    (%rax),%rax
  81d89b:	0f b7 40 02          	movzwl 0x2(%rax),%eax
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  81d89f:	0f b7 f8             	movzwl %ax,%edi
  81d8a2:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d8a9:	00 00 00 
  81d8ac:	48 8b 00             	mov    (%rax),%rax
  81d8af:	48 8d 48 0c          	lea    0xc(%rax),%rcx
  81d8b3:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d8ba:	00 00 00 
  81d8bd:	48 8b 00             	mov    (%rax),%rax
  81d8c0:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81d8c4:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81d8cb:	00 00 00 
  81d8ce:	0f b7 00             	movzwl (%rax),%eax
  81d8d1:	0f b7 f0             	movzwl %ax,%esi
  81d8d4:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d8db:	00 00 00 
  81d8de:	8b 00                	mov    (%rax),%eax
  81d8e0:	01 c6                	add    %eax,%esi
  81d8e2:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81d8e9:	00 00 00 
  81d8ec:	8b 00                	mov    (%rax),%eax
  81d8ee:	45 89 c1             	mov    %r8d,%r9d
  81d8f1:	41 89 f8             	mov    %edi,%r8d
  81d8f4:	89 c7                	mov    %eax,%edi
  81d8f6:	48 b8 48 45 81 00 00 	movabs $0x814548,%rax
  81d8fd:	00 00 00 
  81d900:	ff d0                	callq  *%rax
        tcphdr->dest, tcphdr->src);
    }
    break;
  81d902:	e9 53 08 00 00       	jmpq   81e15a <tcp_process+0xcc7>
  81d907:	e9 4e 08 00 00       	jmpq   81e15a <tcp_process+0xcc7>
  case SYN_RCVD:
    if (flags & TCP_ACK &&
  81d90c:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d913:	00 00 00 
  81d916:	0f b6 00             	movzbl (%rax),%eax
  81d919:	0f b6 c0             	movzbl %al,%eax
  81d91c:	83 e0 10             	and    $0x10,%eax
  81d91f:	85 c0                	test   %eax,%eax
  81d921:	0f 84 23 02 00 00    	je     81db4a <tcp_process+0x6b7>
       !(flags & TCP_RST)) {
  81d927:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d92e:	00 00 00 
  81d931:	0f b6 00             	movzbl (%rax),%eax
  81d934:	0f b6 c0             	movzbl %al,%eax
  81d937:	83 e0 04             	and    $0x4,%eax
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK &&
  81d93a:	85 c0                	test   %eax,%eax
  81d93c:	0f 85 08 02 00 00    	jne    81db4a <tcp_process+0x6b7>
       !(flags & TCP_RST)) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  81d942:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81d949:	00 00 00 
  81d94c:	8b 10                	mov    (%rax),%edx
  81d94e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d952:	8b 40 54             	mov    0x54(%rax),%eax
  81d955:	29 c2                	sub    %eax,%edx
  81d957:	89 d0                	mov    %edx,%eax
  81d959:	83 e8 01             	sub    $0x1,%eax
  81d95c:	85 c0                	test   %eax,%eax
  81d95e:	0f 88 59 01 00 00    	js     81dabd <tcp_process+0x62a>
  81d964:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81d96b:	00 00 00 
  81d96e:	8b 10                	mov    (%rax),%edx
  81d970:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d974:	8b 40 60             	mov    0x60(%rax),%eax
  81d977:	29 c2                	sub    %eax,%edx
  81d979:	89 d0                	mov    %edx,%eax
  81d97b:	85 c0                	test   %eax,%eax
  81d97d:	0f 8f 3a 01 00 00    	jg     81dabd <tcp_process+0x62a>
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
  81d983:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d987:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%rax)
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  81d98e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d992:	48 8b 80 b8 00 00 00 	mov    0xb8(%rax),%rax
  81d999:	48 85 c0             	test   %rax,%rax
  81d99c:	75 2a                	jne    81d9c8 <tcp_process+0x535>
  81d99e:	48 ba de 3a 82 00 00 	movabs $0x823ade,%rdx
  81d9a5:	00 00 00 
  81d9a8:	be 5c 02 00 00       	mov    $0x25c,%esi
  81d9ad:	48 bf a7 39 82 00 00 	movabs $0x8239a7,%rdi
  81d9b4:	00 00 00 
  81d9b7:	b8 00 00 00 00       	mov    $0x0,%eax
  81d9bc:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81d9c3:	00 00 00 
  81d9c6:	ff d1                	callq  *%rcx
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
  81d9c8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d9cc:	48 8b 80 b8 00 00 00 	mov    0xb8(%rax),%rax
  81d9d3:	48 85 c0             	test   %rax,%rax
  81d9d6:	74 24                	je     81d9fc <tcp_process+0x569>
  81d9d8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d9dc:	48 8b 80 b8 00 00 00 	mov    0xb8(%rax),%rax
  81d9e3:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81d9e7:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
  81d9eb:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  81d9ef:	ba 00 00 00 00       	mov    $0x0,%edx
  81d9f4:	48 89 cf             	mov    %rcx,%rdi
  81d9f7:	ff d0                	callq  *%rax
  81d9f9:	88 45 fe             	mov    %al,-0x2(%rbp)
        if (err != ERR_OK) {
  81d9fc:	80 7d fe 00          	cmpb   $0x0,-0x2(%rbp)
  81da00:	74 1d                	je     81da1f <tcp_process+0x58c>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
  81da02:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81da06:	48 89 c7             	mov    %rax,%rdi
  81da09:	48 b8 ff ee 80 00 00 	movabs $0x80eeff,%rax
  81da10:	00 00 00 
  81da13:	ff d0                	callq  *%rax
          return ERR_ABRT;
  81da15:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  81da1a:	e9 40 07 00 00       	jmpq   81e15f <tcp_process+0xccc>
        }
        old_cwnd = pcb->cwnd;
  81da1f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81da23:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81da27:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        accepted_inseq = tcp_receive(pcb);
  81da2b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81da2f:	48 89 c7             	mov    %rax,%rdi
  81da32:	48 b8 61 e1 81 00 00 	movabs $0x81e161,%rax
  81da39:	00 00 00 
  81da3c:	ff d0                	callq  *%rax
  81da3e:	88 45 ed             	mov    %al,-0x13(%rbp)

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  81da41:	66 83 7d ee 01       	cmpw   $0x1,-0x12(%rbp)
  81da46:	75 0c                	jne    81da54 <tcp_process+0x5c1>
  81da48:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81da4c:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81da50:	01 c0                	add    %eax,%eax
  81da52:	eb 08                	jmp    81da5c <tcp_process+0x5c9>
  81da54:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81da58:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81da5c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81da60:	66 89 42 5a          	mov    %ax,0x5a(%rdx)

        if ((flags & TCP_FIN) && accepted_inseq) {
  81da64:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81da6b:	00 00 00 
  81da6e:	0f b6 00             	movzbl (%rax),%eax
  81da71:	0f b6 c0             	movzbl %al,%eax
  81da74:	83 e0 01             	and    $0x1,%eax
  81da77:	85 c0                	test   %eax,%eax
  81da79:	74 3d                	je     81dab8 <tcp_process+0x625>
  81da7b:	80 7d ed 00          	cmpb   $0x0,-0x13(%rbp)
  81da7f:	74 37                	je     81dab8 <tcp_process+0x625>
          tcp_ack_now(pcb);
  81da81:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81da85:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81da89:	83 c8 02             	or     $0x2,%eax
  81da8c:	89 c2                	mov    %eax,%edx
  81da8e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81da92:	88 50 2c             	mov    %dl,0x2c(%rax)
  81da95:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81da99:	48 89 c7             	mov    %rax,%rdi
  81da9c:	48 b8 3d 3c 81 00 00 	movabs $0x813c3d,%rax
  81daa3:	00 00 00 
  81daa6:	ff d0                	callq  *%rax
          pcb->state = CLOSE_WAIT;
  81daa8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81daac:	c7 40 18 07 00 00 00 	movl   $0x7,0x18(%rax)
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK &&
       !(flags & TCP_RST)) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  81dab3:	e9 92 00 00 00       	jmpq   81db4a <tcp_process+0x6b7>
  81dab8:	e9 8d 00 00 00       	jmpq   81db4a <tcp_process+0x6b7>
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
                tcphdr->dest, tcphdr->src);
  81dabd:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81dac4:	00 00 00 
  81dac7:	48 8b 00             	mov    (%rax),%rax
  81daca:	0f b7 00             	movzwl (%rax),%eax
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  81dacd:	44 0f b7 c0          	movzwl %ax,%r8d
                tcphdr->dest, tcphdr->src);
  81dad1:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81dad8:	00 00 00 
  81dadb:	48 8b 00             	mov    (%rax),%rax
  81dade:	0f b7 40 02          	movzwl 0x2(%rax),%eax
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  81dae2:	0f b7 f8             	movzwl %ax,%edi
  81dae5:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81daec:	00 00 00 
  81daef:	48 8b 00             	mov    (%rax),%rax
  81daf2:	48 8d 48 0c          	lea    0xc(%rax),%rcx
  81daf6:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81dafd:	00 00 00 
  81db00:	48 8b 00             	mov    (%rax),%rax
  81db03:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81db07:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81db0e:	00 00 00 
  81db11:	0f b7 00             	movzwl (%rax),%eax
  81db14:	0f b7 f0             	movzwl %ax,%esi
  81db17:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81db1e:	00 00 00 
  81db21:	8b 00                	mov    (%rax),%eax
  81db23:	01 c6                	add    %eax,%esi
  81db25:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81db2c:	00 00 00 
  81db2f:	8b 00                	mov    (%rax),%eax
  81db31:	45 89 c1             	mov    %r8d,%r9d
  81db34:	41 89 f8             	mov    %edi,%r8d
  81db37:	89 c7                	mov    %eax,%edi
  81db39:	48 b8 48 45 81 00 00 	movabs $0x814548,%rax
  81db40:	00 00 00 
  81db43:	ff d0                	callq  *%rax
                tcphdr->dest, tcphdr->src);
      }
    }
    break;
  81db45:	e9 10 06 00 00       	jmpq   81e15a <tcp_process+0xcc7>
  81db4a:	e9 0b 06 00 00       	jmpq   81e15a <tcp_process+0xcc7>
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    accepted_inseq = tcp_receive(pcb);
  81db4f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81db53:	48 89 c7             	mov    %rax,%rdi
  81db56:	48 b8 61 e1 81 00 00 	movabs $0x81e161,%rax
  81db5d:	00 00 00 
  81db60:	ff d0                	callq  *%rax
  81db62:	88 45 ed             	mov    %al,-0x13(%rbp)
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
  81db65:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81db6c:	00 00 00 
  81db6f:	0f b6 00             	movzbl (%rax),%eax
  81db72:	0f b6 c0             	movzbl %al,%eax
  81db75:	83 e0 01             	and    $0x1,%eax
  81db78:	85 c0                	test   %eax,%eax
  81db7a:	74 3d                	je     81dbb9 <tcp_process+0x726>
  81db7c:	80 7d ed 00          	cmpb   $0x0,-0x13(%rbp)
  81db80:	74 37                	je     81dbb9 <tcp_process+0x726>
      tcp_ack_now(pcb);
  81db82:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81db86:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81db8a:	83 c8 02             	or     $0x2,%eax
  81db8d:	89 c2                	mov    %eax,%edx
  81db8f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81db93:	88 50 2c             	mov    %dl,0x2c(%rax)
  81db96:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81db9a:	48 89 c7             	mov    %rax,%rdi
  81db9d:	48 b8 3d 3c 81 00 00 	movabs $0x813c3d,%rax
  81dba4:	00 00 00 
  81dba7:	ff d0                	callq  *%rax
      pcb->state = CLOSE_WAIT;
  81dba9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dbad:	c7 40 18 07 00 00 00 	movl   $0x7,0x18(%rax)
    }
    break;
  81dbb4:	e9 a1 05 00 00       	jmpq   81e15a <tcp_process+0xcc7>
  81dbb9:	e9 9c 05 00 00       	jmpq   81e15a <tcp_process+0xcc7>
  case FIN_WAIT_1:
    tcp_receive(pcb);
  81dbbe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dbc2:	48 89 c7             	mov    %rax,%rdi
  81dbc5:	48 b8 61 e1 81 00 00 	movabs $0x81e161,%rax
  81dbcc:	00 00 00 
  81dbcf:	ff d0                	callq  *%rax
    if (flags & TCP_FIN) {
  81dbd1:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81dbd8:	00 00 00 
  81dbdb:	0f b6 00             	movzbl (%rax),%eax
  81dbde:	0f b6 c0             	movzbl %al,%eax
  81dbe1:	83 e0 01             	and    $0x1,%eax
  81dbe4:	85 c0                	test   %eax,%eax
  81dbe6:	0f 84 b9 01 00 00    	je     81dda5 <tcp_process+0x912>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  81dbec:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81dbf3:	00 00 00 
  81dbf6:	0f b6 00             	movzbl (%rax),%eax
  81dbf9:	0f b6 c0             	movzbl %al,%eax
  81dbfc:	83 e0 10             	and    $0x10,%eax
  81dbff:	85 c0                	test   %eax,%eax
  81dc01:	0f 84 6a 01 00 00    	je     81dd71 <tcp_process+0x8de>
  81dc07:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dc0b:	8b 50 60             	mov    0x60(%rax),%edx
  81dc0e:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81dc15:	00 00 00 
  81dc18:	8b 00                	mov    (%rax),%eax
  81dc1a:	39 c2                	cmp    %eax,%edx
  81dc1c:	0f 85 4f 01 00 00    	jne    81dd71 <tcp_process+0x8de>
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
  81dc22:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dc26:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81dc2a:	83 c8 02             	or     $0x2,%eax
  81dc2d:	89 c2                	mov    %eax,%edx
  81dc2f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dc33:	88 50 2c             	mov    %dl,0x2c(%rax)
  81dc36:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dc3a:	48 89 c7             	mov    %rax,%rdi
  81dc3d:	48 b8 3d 3c 81 00 00 	movabs $0x813c3d,%rax
  81dc44:	00 00 00 
  81dc47:	ff d0                	callq  *%rax
        tcp_pcb_purge(pcb);
  81dc49:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dc4d:	48 89 c7             	mov    %rax,%rdi
  81dc50:	48 b8 a7 09 81 00 00 	movabs $0x8109a7,%rax
  81dc57:	00 00 00 
  81dc5a:	ff d0                	callq  *%rax
        TCP_RMV(&tcp_active_pcbs, pcb);
  81dc5c:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81dc63:	00 00 00 
  81dc66:	48 8b 00             	mov    (%rax),%rax
  81dc69:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  81dc6d:	75 23                	jne    81dc92 <tcp_process+0x7ff>
  81dc6f:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81dc76:	00 00 00 
  81dc79:	48 8b 00             	mov    (%rax),%rax
  81dc7c:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81dc80:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81dc87:	00 00 00 
  81dc8a:	48 89 10             	mov    %rdx,(%rax)
  81dc8d:	e9 94 00 00 00       	jmpq   81dd26 <tcp_process+0x893>
  81dc92:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81dc99:	00 00 00 
  81dc9c:	48 8b 10             	mov    (%rax),%rdx
  81dc9f:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81dca6:	00 00 00 
  81dca9:	48 89 10             	mov    %rdx,(%rax)
  81dcac:	eb 66                	jmp    81dd14 <tcp_process+0x881>
  81dcae:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81dcb5:	00 00 00 
  81dcb8:	48 8b 00             	mov    (%rax),%rax
  81dcbb:	48 8b 40 10          	mov    0x10(%rax),%rax
  81dcbf:	48 85 c0             	test   %rax,%rax
  81dcc2:	74 32                	je     81dcf6 <tcp_process+0x863>
  81dcc4:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81dccb:	00 00 00 
  81dcce:	48 8b 00             	mov    (%rax),%rax
  81dcd1:	48 8b 40 10          	mov    0x10(%rax),%rax
  81dcd5:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  81dcd9:	75 1b                	jne    81dcf6 <tcp_process+0x863>
  81dcdb:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81dce2:	00 00 00 
  81dce5:	48 8b 00             	mov    (%rax),%rax
  81dce8:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81dcec:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  81dcf0:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81dcf4:	eb 30                	jmp    81dd26 <tcp_process+0x893>
  81dcf6:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81dcfd:	00 00 00 
  81dd00:	48 8b 00             	mov    (%rax),%rax
  81dd03:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81dd07:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81dd0e:	00 00 00 
  81dd11:	48 89 10             	mov    %rdx,(%rax)
  81dd14:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81dd1b:	00 00 00 
  81dd1e:	48 8b 00             	mov    (%rax),%rax
  81dd21:	48 85 c0             	test   %rax,%rax
  81dd24:	75 88                	jne    81dcae <tcp_process+0x81b>
  81dd26:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dd2a:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  81dd31:	00 
        pcb->state = TIME_WAIT;
  81dd32:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dd36:	c7 40 18 0a 00 00 00 	movl   $0xa,0x18(%rax)
        TCP_REG(&tcp_tw_pcbs, pcb);
  81dd3d:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81dd44:	00 00 00 
  81dd47:	48 8b 10             	mov    (%rax),%rdx
  81dd4a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dd4e:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81dd52:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81dd59:	00 00 00 
  81dd5c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81dd60:	48 89 10             	mov    %rdx,(%rax)
  81dd63:	48 b8 f1 86 80 00 00 	movabs $0x8086f1,%rax
  81dd6a:	00 00 00 
  81dd6d:	ff d0                	callq  *%rax
  81dd6f:	eb 72                	jmp    81dde3 <tcp_process+0x950>
      } else {
        tcp_ack_now(pcb);
  81dd71:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dd75:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81dd79:	83 c8 02             	or     $0x2,%eax
  81dd7c:	89 c2                	mov    %eax,%edx
  81dd7e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dd82:	88 50 2c             	mov    %dl,0x2c(%rax)
  81dd85:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dd89:	48 89 c7             	mov    %rax,%rdi
  81dd8c:	48 b8 3d 3c 81 00 00 	movabs $0x813c3d,%rax
  81dd93:	00 00 00 
  81dd96:	ff d0                	callq  *%rax
        pcb->state = CLOSING;
  81dd98:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dd9c:	c7 40 18 08 00 00 00 	movl   $0x8,0x18(%rax)
  81dda3:	eb 3e                	jmp    81dde3 <tcp_process+0x950>
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  81dda5:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81ddac:	00 00 00 
  81ddaf:	0f b6 00             	movzbl (%rax),%eax
  81ddb2:	0f b6 c0             	movzbl %al,%eax
  81ddb5:	83 e0 10             	and    $0x10,%eax
  81ddb8:	85 c0                	test   %eax,%eax
  81ddba:	74 27                	je     81dde3 <tcp_process+0x950>
  81ddbc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ddc0:	8b 50 60             	mov    0x60(%rax),%edx
  81ddc3:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81ddca:	00 00 00 
  81ddcd:	8b 00                	mov    (%rax),%eax
  81ddcf:	39 c2                	cmp    %eax,%edx
  81ddd1:	75 10                	jne    81dde3 <tcp_process+0x950>
      pcb->state = FIN_WAIT_2;
  81ddd3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ddd7:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%rax)
    }
    break;
  81ddde:	e9 77 03 00 00       	jmpq   81e15a <tcp_process+0xcc7>
  81dde3:	e9 72 03 00 00       	jmpq   81e15a <tcp_process+0xcc7>
  case FIN_WAIT_2:
    tcp_receive(pcb);
  81dde8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ddec:	48 89 c7             	mov    %rax,%rdi
  81ddef:	48 b8 61 e1 81 00 00 	movabs $0x81e161,%rax
  81ddf6:	00 00 00 
  81ddf9:	ff d0                	callq  *%rax
    if (flags & TCP_FIN) {
  81ddfb:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81de02:	00 00 00 
  81de05:	0f b6 00             	movzbl (%rax),%eax
  81de08:	0f b6 c0             	movzbl %al,%eax
  81de0b:	83 e0 01             	and    $0x1,%eax
  81de0e:	85 c0                	test   %eax,%eax
  81de10:	0f 84 52 01 00 00    	je     81df68 <tcp_process+0xad5>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  81de16:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81de1a:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81de1e:	83 c8 02             	or     $0x2,%eax
  81de21:	89 c2                	mov    %eax,%edx
  81de23:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81de27:	88 50 2c             	mov    %dl,0x2c(%rax)
  81de2a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81de2e:	48 89 c7             	mov    %rax,%rdi
  81de31:	48 b8 3d 3c 81 00 00 	movabs $0x813c3d,%rax
  81de38:	00 00 00 
  81de3b:	ff d0                	callq  *%rax
      tcp_pcb_purge(pcb);
  81de3d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81de41:	48 89 c7             	mov    %rax,%rdi
  81de44:	48 b8 a7 09 81 00 00 	movabs $0x8109a7,%rax
  81de4b:	00 00 00 
  81de4e:	ff d0                	callq  *%rax
      TCP_RMV(&tcp_active_pcbs, pcb);
  81de50:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81de57:	00 00 00 
  81de5a:	48 8b 00             	mov    (%rax),%rax
  81de5d:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  81de61:	75 23                	jne    81de86 <tcp_process+0x9f3>
  81de63:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81de6a:	00 00 00 
  81de6d:	48 8b 00             	mov    (%rax),%rax
  81de70:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81de74:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81de7b:	00 00 00 
  81de7e:	48 89 10             	mov    %rdx,(%rax)
  81de81:	e9 94 00 00 00       	jmpq   81df1a <tcp_process+0xa87>
  81de86:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81de8d:	00 00 00 
  81de90:	48 8b 10             	mov    (%rax),%rdx
  81de93:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81de9a:	00 00 00 
  81de9d:	48 89 10             	mov    %rdx,(%rax)
  81dea0:	eb 66                	jmp    81df08 <tcp_process+0xa75>
  81dea2:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81dea9:	00 00 00 
  81deac:	48 8b 00             	mov    (%rax),%rax
  81deaf:	48 8b 40 10          	mov    0x10(%rax),%rax
  81deb3:	48 85 c0             	test   %rax,%rax
  81deb6:	74 32                	je     81deea <tcp_process+0xa57>
  81deb8:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81debf:	00 00 00 
  81dec2:	48 8b 00             	mov    (%rax),%rax
  81dec5:	48 8b 40 10          	mov    0x10(%rax),%rax
  81dec9:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  81decd:	75 1b                	jne    81deea <tcp_process+0xa57>
  81decf:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81ded6:	00 00 00 
  81ded9:	48 8b 00             	mov    (%rax),%rax
  81dedc:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81dee0:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  81dee4:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81dee8:	eb 30                	jmp    81df1a <tcp_process+0xa87>
  81deea:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81def1:	00 00 00 
  81def4:	48 8b 00             	mov    (%rax),%rax
  81def7:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81defb:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81df02:	00 00 00 
  81df05:	48 89 10             	mov    %rdx,(%rax)
  81df08:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81df0f:	00 00 00 
  81df12:	48 8b 00             	mov    (%rax),%rax
  81df15:	48 85 c0             	test   %rax,%rax
  81df18:	75 88                	jne    81dea2 <tcp_process+0xa0f>
  81df1a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81df1e:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  81df25:	00 
      pcb->state = TIME_WAIT;
  81df26:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81df2a:	c7 40 18 0a 00 00 00 	movl   $0xa,0x18(%rax)
      TCP_REG(&tcp_tw_pcbs, pcb);
  81df31:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81df38:	00 00 00 
  81df3b:	48 8b 10             	mov    (%rax),%rdx
  81df3e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81df42:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81df46:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81df4d:	00 00 00 
  81df50:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81df54:	48 89 10             	mov    %rdx,(%rax)
  81df57:	48 b8 f1 86 80 00 00 	movabs $0x8086f1,%rax
  81df5e:	00 00 00 
  81df61:	ff d0                	callq  *%rax
    }
    break;
  81df63:	e9 f2 01 00 00       	jmpq   81e15a <tcp_process+0xcc7>
  81df68:	e9 ed 01 00 00       	jmpq   81e15a <tcp_process+0xcc7>
  case CLOSING:
    tcp_receive(pcb);
  81df6d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81df71:	48 89 c7             	mov    %rax,%rdi
  81df74:	48 b8 61 e1 81 00 00 	movabs $0x81e161,%rax
  81df7b:	00 00 00 
  81df7e:	ff d0                	callq  *%rax
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  81df80:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81df87:	00 00 00 
  81df8a:	0f b6 00             	movzbl (%rax),%eax
  81df8d:	0f b6 c0             	movzbl %al,%eax
  81df90:	83 e0 10             	and    $0x10,%eax
  81df93:	85 c0                	test   %eax,%eax
  81df95:	0f 84 6a 01 00 00    	je     81e105 <tcp_process+0xc72>
  81df9b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81df9f:	8b 50 60             	mov    0x60(%rax),%edx
  81dfa2:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81dfa9:	00 00 00 
  81dfac:	8b 00                	mov    (%rax),%eax
  81dfae:	39 c2                	cmp    %eax,%edx
  81dfb0:	0f 85 4f 01 00 00    	jne    81e105 <tcp_process+0xc72>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  81dfb6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dfba:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81dfbe:	83 c8 02             	or     $0x2,%eax
  81dfc1:	89 c2                	mov    %eax,%edx
  81dfc3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dfc7:	88 50 2c             	mov    %dl,0x2c(%rax)
  81dfca:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dfce:	48 89 c7             	mov    %rax,%rdi
  81dfd1:	48 b8 3d 3c 81 00 00 	movabs $0x813c3d,%rax
  81dfd8:	00 00 00 
  81dfdb:	ff d0                	callq  *%rax
      tcp_pcb_purge(pcb);
  81dfdd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dfe1:	48 89 c7             	mov    %rax,%rdi
  81dfe4:	48 b8 a7 09 81 00 00 	movabs $0x8109a7,%rax
  81dfeb:	00 00 00 
  81dfee:	ff d0                	callq  *%rax
      TCP_RMV(&tcp_active_pcbs, pcb);
  81dff0:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81dff7:	00 00 00 
  81dffa:	48 8b 00             	mov    (%rax),%rax
  81dffd:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  81e001:	75 23                	jne    81e026 <tcp_process+0xb93>
  81e003:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81e00a:	00 00 00 
  81e00d:	48 8b 00             	mov    (%rax),%rax
  81e010:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81e014:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81e01b:	00 00 00 
  81e01e:	48 89 10             	mov    %rdx,(%rax)
  81e021:	e9 94 00 00 00       	jmpq   81e0ba <tcp_process+0xc27>
  81e026:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81e02d:	00 00 00 
  81e030:	48 8b 10             	mov    (%rax),%rdx
  81e033:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81e03a:	00 00 00 
  81e03d:	48 89 10             	mov    %rdx,(%rax)
  81e040:	eb 66                	jmp    81e0a8 <tcp_process+0xc15>
  81e042:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81e049:	00 00 00 
  81e04c:	48 8b 00             	mov    (%rax),%rax
  81e04f:	48 8b 40 10          	mov    0x10(%rax),%rax
  81e053:	48 85 c0             	test   %rax,%rax
  81e056:	74 32                	je     81e08a <tcp_process+0xbf7>
  81e058:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81e05f:	00 00 00 
  81e062:	48 8b 00             	mov    (%rax),%rax
  81e065:	48 8b 40 10          	mov    0x10(%rax),%rax
  81e069:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  81e06d:	75 1b                	jne    81e08a <tcp_process+0xbf7>
  81e06f:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81e076:	00 00 00 
  81e079:	48 8b 00             	mov    (%rax),%rax
  81e07c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81e080:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  81e084:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81e088:	eb 30                	jmp    81e0ba <tcp_process+0xc27>
  81e08a:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81e091:	00 00 00 
  81e094:	48 8b 00             	mov    (%rax),%rax
  81e097:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81e09b:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81e0a2:	00 00 00 
  81e0a5:	48 89 10             	mov    %rdx,(%rax)
  81e0a8:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81e0af:	00 00 00 
  81e0b2:	48 8b 00             	mov    (%rax),%rax
  81e0b5:	48 85 c0             	test   %rax,%rax
  81e0b8:	75 88                	jne    81e042 <tcp_process+0xbaf>
  81e0ba:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e0be:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  81e0c5:	00 
      pcb->state = TIME_WAIT;
  81e0c6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e0ca:	c7 40 18 0a 00 00 00 	movl   $0xa,0x18(%rax)
      TCP_REG(&tcp_tw_pcbs, pcb);
  81e0d1:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81e0d8:	00 00 00 
  81e0db:	48 8b 10             	mov    (%rax),%rdx
  81e0de:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e0e2:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81e0e6:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81e0ed:	00 00 00 
  81e0f0:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81e0f4:	48 89 10             	mov    %rdx,(%rax)
  81e0f7:	48 b8 f1 86 80 00 00 	movabs $0x8086f1,%rax
  81e0fe:	00 00 00 
  81e101:	ff d0                	callq  *%rax
    }
    break;
  81e103:	eb 55                	jmp    81e15a <tcp_process+0xcc7>
  81e105:	eb 53                	jmp    81e15a <tcp_process+0xcc7>
  case LAST_ACK:
    tcp_receive(pcb);
  81e107:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e10b:	48 89 c7             	mov    %rax,%rdi
  81e10e:	48 b8 61 e1 81 00 00 	movabs $0x81e161,%rax
  81e115:	00 00 00 
  81e118:	ff d0                	callq  *%rax
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  81e11a:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81e121:	00 00 00 
  81e124:	0f b6 00             	movzbl (%rax),%eax
  81e127:	0f b6 c0             	movzbl %al,%eax
  81e12a:	83 e0 10             	and    $0x10,%eax
  81e12d:	85 c0                	test   %eax,%eax
  81e12f:	74 26                	je     81e157 <tcp_process+0xcc4>
  81e131:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e135:	8b 50 60             	mov    0x60(%rax),%edx
  81e138:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e13f:	00 00 00 
  81e142:	8b 00                	mov    (%rax),%eax
  81e144:	39 c2                	cmp    %eax,%edx
  81e146:	75 0f                	jne    81e157 <tcp_process+0xcc4>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags = TF_CLOSED;
  81e148:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81e14f:	00 00 00 
  81e152:	c6 00 10             	movb   $0x10,(%rax)
    }
    break;
  81e155:	eb 03                	jmp    81e15a <tcp_process+0xcc7>
  81e157:	eb 01                	jmp    81e15a <tcp_process+0xcc7>
  default:
    break;
  81e159:	90                   	nop
  }
  return ERR_OK;
  81e15a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81e15f:	c9                   	leaveq 
  81e160:	c3                   	retq   

000000000081e161 <tcp_receive>:
 *
 * @return 1 if the incoming segment is the next in sequence, 0 if not
 */
static u8_t
tcp_receive(struct tcp_pcb *pcb)
{
  81e161:	55                   	push   %rbp
  81e162:	48 89 e5             	mov    %rsp,%rbp
  81e165:	41 55                	push   %r13
  81e167:	41 54                	push   %r12
  81e169:	53                   	push   %rbx
  81e16a:	48 83 ec 58          	sub    $0x58,%rsp
  81e16e:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  81e172:	c6 45 c1 00          	movb   $0x0,-0x3f(%rbp)

  if (flags & TCP_ACK) {
  81e176:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81e17d:	00 00 00 
  81e180:	0f b6 00             	movzbl (%rax),%eax
  81e183:	0f b6 c0             	movzbl %al,%eax
  81e186:	83 e0 10             	and    $0x10,%eax
  81e189:	85 c0                	test   %eax,%eax
  81e18b:	0f 84 80 09 00 00    	je     81eb11 <tcp_receive+0x9b0>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  81e191:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e195:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81e199:	0f b7 d0             	movzwl %ax,%edx
  81e19c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e1a0:	8b 40 6c             	mov    0x6c(%rax),%eax
  81e1a3:	01 d0                	add    %edx,%eax
  81e1a5:	89 45 bc             	mov    %eax,-0x44(%rbp)

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  81e1a8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e1ac:	8b 50 6c             	mov    0x6c(%rax),%edx
  81e1af:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81e1b6:	00 00 00 
  81e1b9:	8b 00                	mov    (%rax),%eax
  81e1bb:	29 c2                	sub    %eax,%edx
  81e1bd:	89 d0                	mov    %edx,%eax
  81e1bf:	85 c0                	test   %eax,%eax
  81e1c1:	78 6b                	js     81e22e <tcp_receive+0xcd>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  81e1c3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e1c7:	8b 50 6c             	mov    0x6c(%rax),%edx
  81e1ca:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81e1d1:	00 00 00 
  81e1d4:	8b 00                	mov    (%rax),%eax

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  81e1d6:	39 c2                	cmp    %eax,%edx
  81e1d8:	75 1b                	jne    81e1f5 <tcp_receive+0x94>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  81e1da:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e1de:	8b 50 70             	mov    0x70(%rax),%edx
  81e1e1:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e1e8:	00 00 00 
  81e1eb:	8b 00                	mov    (%rax),%eax
  81e1ed:	29 c2                	sub    %eax,%edx
  81e1ef:	89 d0                	mov    %edx,%eax
  81e1f1:	85 c0                	test   %eax,%eax
  81e1f3:	78 39                	js     81e22e <tcp_receive+0xcd>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  81e1f5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e1f9:	8b 50 70             	mov    0x70(%rax),%edx
  81e1fc:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e203:	00 00 00 
  81e206:	8b 00                	mov    (%rax),%eax
  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  81e208:	39 c2                	cmp    %eax,%edx
  81e20a:	0f 85 84 00 00 00    	jne    81e294 <tcp_receive+0x133>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  81e210:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81e217:	00 00 00 
  81e21a:	48 8b 00             	mov    (%rax),%rax
  81e21d:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
  81e221:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e225:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81e229:	66 39 c2             	cmp    %ax,%dx
  81e22c:	76 66                	jbe    81e294 <tcp_receive+0x133>
      pcb->snd_wnd = tcphdr->wnd;
  81e22e:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81e235:	00 00 00 
  81e238:	48 8b 00             	mov    (%rax),%rax
  81e23b:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
  81e23f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e243:	66 89 50 68          	mov    %dx,0x68(%rax)
      pcb->snd_wl1 = seqno;
  81e247:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81e24e:	00 00 00 
  81e251:	8b 10                	mov    (%rax),%edx
  81e253:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e257:	89 50 6c             	mov    %edx,0x6c(%rax)
      pcb->snd_wl2 = ackno;
  81e25a:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e261:	00 00 00 
  81e264:	8b 10                	mov    (%rax),%edx
  81e266:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e26a:	89 50 70             	mov    %edx,0x70(%rax)
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
  81e26d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e271:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81e275:	66 85 c0             	test   %ax,%ax
  81e278:	74 1a                	je     81e294 <tcp_receive+0x133>
  81e27a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e27e:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  81e285:	84 c0                	test   %al,%al
  81e287:	74 0b                	je     81e294 <tcp_receive+0x133>
          pcb->persist_backoff = 0;
  81e289:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e28d:	c6 80 d8 00 00 00 00 	movb   $0x0,0xd8(%rax)
                               pcb->lastack, pcb->snd_max, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
      }
#endif /* TCP_WND_DEBUG */
    }

    if (pcb->lastack == ackno) {
  81e294:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e298:	8b 50 54             	mov    0x54(%rax),%edx
  81e29b:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e2a2:	00 00 00 
  81e2a5:	8b 00                	mov    (%rax),%eax
  81e2a7:	39 c2                	cmp    %eax,%edx
  81e2a9:	0f 85 72 01 00 00    	jne    81e421 <tcp_receive+0x2c0>
      pcb->acked = 0;
  81e2af:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e2b3:	66 c7 40 78 00 00    	movw   $0x0,0x78(%rax)

      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  81e2b9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e2bd:	8b 50 6c             	mov    0x6c(%rax),%edx
  81e2c0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e2c4:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81e2c8:	0f b7 c0             	movzwl %ax,%eax
  81e2cb:	01 d0                	add    %edx,%eax
  81e2cd:	3b 45 bc             	cmp    -0x44(%rbp),%eax
  81e2d0:	0f 85 15 05 00 00    	jne    81e7eb <tcp_receive+0x68a>
        ++pcb->dupacks;
  81e2d6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e2da:	0f b6 40 58          	movzbl 0x58(%rax),%eax
  81e2de:	8d 50 01             	lea    0x1(%rax),%edx
  81e2e1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e2e5:	88 50 58             	mov    %dl,0x58(%rax)
        if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
  81e2e8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e2ec:	0f b6 40 58          	movzbl 0x58(%rax),%eax
  81e2f0:	3c 02                	cmp    $0x2,%al
  81e2f2:	0f 86 f3 04 00 00    	jbe    81e7eb <tcp_receive+0x68a>
  81e2f8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e2fc:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e303:	48 85 c0             	test   %rax,%rax
  81e306:	0f 84 df 04 00 00    	je     81e7eb <tcp_receive+0x68a>
          if (!(pcb->flags & TF_INFR)) {
  81e30c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e310:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81e314:	0f b6 c0             	movzbl %al,%eax
  81e317:	83 e0 04             	and    $0x4,%eax
  81e31a:	85 c0                	test   %eax,%eax
  81e31c:	0f 85 bd 00 00 00    	jne    81e3df <tcp_receive+0x27e>
            /* This is fast retransmit. Retransmit the first unacked segment. */
            LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupacks %"U16_F" (%"U32_F"), fast retransmit %"U32_F"\n",
                                       (u16_t)pcb->dupacks, pcb->lastack,
                                       ntohl(pcb->unacked->tcphdr->seqno)));
            tcp_rexmit(pcb);
  81e322:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e326:	48 89 c7             	mov    %rax,%rdi
  81e329:	48 b8 2b 48 81 00 00 	movabs $0x81482b,%rax
  81e330:	00 00 00 
  81e333:	ff d0                	callq  *%rax
            /* Set ssthresh to max (FlightSize / 2, 2*SMSS) */
            /*pcb->ssthresh = LWIP_MAX((pcb->snd_max -
                                      pcb->lastack) / 2,
                                      2 * pcb->mss);*/
            /* Set ssthresh to half of the minimum of the current cwnd and the advertised window */
            if (pcb->cwnd > pcb->snd_wnd)
  81e335:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e339:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81e33d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e341:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81e345:	66 39 c2             	cmp    %ax,%dx
  81e348:	76 17                	jbe    81e361 <tcp_receive+0x200>
              pcb->ssthresh = pcb->snd_wnd / 2;
  81e34a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e34e:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81e352:	66 d1 e8             	shr    %ax
  81e355:	89 c2                	mov    %eax,%edx
  81e357:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e35b:	66 89 50 5c          	mov    %dx,0x5c(%rax)
  81e35f:	eb 15                	jmp    81e376 <tcp_receive+0x215>
            else
              pcb->ssthresh = pcb->cwnd / 2;
  81e361:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e365:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81e369:	66 d1 e8             	shr    %ax
  81e36c:	89 c2                	mov    %eax,%edx
  81e36e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e372:	66 89 50 5c          	mov    %dx,0x5c(%rax)

            /* The minimum value for ssthresh should be 2 MSS */
            if (pcb->ssthresh < 2*pcb->mss) {
  81e376:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e37a:	0f b7 40 5c          	movzwl 0x5c(%rax),%eax
  81e37e:	0f b7 d0             	movzwl %ax,%edx
  81e381:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e385:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e389:	0f b7 c0             	movzwl %ax,%eax
  81e38c:	01 c0                	add    %eax,%eax
  81e38e:	39 c2                	cmp    %eax,%edx
  81e390:	7d 13                	jge    81e3a5 <tcp_receive+0x244>
              LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: The minimum value for ssthresh %"U16_F" should be min 2 mss %"U16_F"...\n", pcb->ssthresh, 2*pcb->mss));
              pcb->ssthresh = 2*pcb->mss;
  81e392:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e396:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e39a:	8d 14 00             	lea    (%rax,%rax,1),%edx
  81e39d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e3a1:	66 89 50 5c          	mov    %dx,0x5c(%rax)
            }

            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  81e3a5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e3a9:	0f b7 48 5c          	movzwl 0x5c(%rax),%ecx
  81e3ad:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e3b1:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  81e3b5:	89 d0                	mov    %edx,%eax
  81e3b7:	01 c0                	add    %eax,%eax
  81e3b9:	01 d0                	add    %edx,%eax
  81e3bb:	8d 14 01             	lea    (%rcx,%rax,1),%edx
  81e3be:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e3c2:	66 89 50 5a          	mov    %dx,0x5a(%rax)
            pcb->flags |= TF_INFR;
  81e3c6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e3ca:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81e3ce:	83 c8 04             	or     $0x4,%eax
  81e3d1:	89 c2                	mov    %eax,%edx
  81e3d3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e3d7:	88 50 2c             	mov    %dl,0x2c(%rax)
  81e3da:	e9 0c 04 00 00       	jmpq   81e7eb <tcp_receive+0x68a>
          } else {
            /* Inflate the congestion window, but not if it means that
               the value overflows. */
            if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  81e3df:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e3e3:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81e3e7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e3eb:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e3ef:	01 c2                	add    %eax,%edx
  81e3f1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e3f5:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81e3f9:	66 39 c2             	cmp    %ax,%dx
  81e3fc:	0f 86 e9 03 00 00    	jbe    81e7eb <tcp_receive+0x68a>
              pcb->cwnd += pcb->mss;
  81e402:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e406:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81e40a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e40e:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e412:	01 c2                	add    %eax,%edx
  81e414:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e418:	66 89 50 5a          	mov    %dx,0x5a(%rax)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  81e41c:	e9 17 05 00 00       	jmpq   81e938 <tcp_receive+0x7d7>
        }
      } else {
        LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupack averted %"U32_F" %"U32_F"\n",
                                   pcb->snd_wl1 + pcb->snd_wnd, right_wnd_edge));
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  81e421:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e428:	00 00 00 
  81e42b:	8b 10                	mov    (%rax),%edx
  81e42d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e431:	8b 40 54             	mov    0x54(%rax),%eax
  81e434:	29 c2                	sub    %eax,%edx
  81e436:	89 d0                	mov    %edx,%eax
  81e438:	83 e8 01             	sub    $0x1,%eax
  81e43b:	85 c0                	test   %eax,%eax
  81e43d:	0f 88 99 03 00 00    	js     81e7dc <tcp_receive+0x67b>
  81e443:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e44a:	00 00 00 
  81e44d:	8b 10                	mov    (%rax),%edx
  81e44f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e453:	8b 40 64             	mov    0x64(%rax),%eax
  81e456:	29 c2                	sub    %eax,%edx
  81e458:	89 d0                	mov    %edx,%eax
  81e45a:	85 c0                	test   %eax,%eax
  81e45c:	0f 8f 7a 03 00 00    	jg     81e7dc <tcp_receive+0x67b>
      /* We come here when the ACK acknowledges new data. */
      
      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
  81e462:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e466:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81e46a:	0f b6 c0             	movzbl %al,%eax
  81e46d:	83 e0 04             	and    $0x4,%eax
  81e470:	85 c0                	test   %eax,%eax
  81e472:	74 24                	je     81e498 <tcp_receive+0x337>
        pcb->flags &= ~TF_INFR;
  81e474:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e478:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81e47c:	83 e0 fb             	and    $0xfffffffb,%eax
  81e47f:	89 c2                	mov    %eax,%edx
  81e481:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e485:	88 50 2c             	mov    %dl,0x2c(%rax)
        pcb->cwnd = pcb->ssthresh;
  81e488:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e48c:	0f b7 50 5c          	movzwl 0x5c(%rax),%edx
  81e490:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e494:	66 89 50 5a          	mov    %dx,0x5a(%rax)
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
  81e498:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e49c:	c6 40 52 00          	movb   $0x0,0x52(%rax)

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  81e4a0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e4a4:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  81e4a8:	66 c1 f8 03          	sar    $0x3,%ax
  81e4ac:	89 c2                	mov    %eax,%edx
  81e4ae:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e4b2:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  81e4b6:	01 d0                	add    %edx,%eax
  81e4b8:	89 c2                	mov    %eax,%edx
  81e4ba:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e4be:	66 89 50 50          	mov    %dx,0x50(%rax)

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
  81e4c2:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e4c9:	00 00 00 
  81e4cc:	8b 00                	mov    (%rax),%eax
  81e4ce:	89 c2                	mov    %eax,%edx
  81e4d0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e4d4:	8b 40 54             	mov    0x54(%rax),%eax
  81e4d7:	29 c2                	sub    %eax,%edx
  81e4d9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e4dd:	66 89 50 78          	mov    %dx,0x78(%rax)

      pcb->snd_buf += pcb->acked;
  81e4e1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e4e5:	0f b7 50 7a          	movzwl 0x7a(%rax),%edx
  81e4e9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e4ed:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  81e4f1:	01 c2                	add    %eax,%edx
  81e4f3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e4f7:	66 89 50 7a          	mov    %dx,0x7a(%rax)

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
  81e4fb:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e4ff:	c6 40 58 00          	movb   $0x0,0x58(%rax)
      pcb->lastack = ackno;
  81e503:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e50a:	00 00 00 
  81e50d:	8b 10                	mov    (%rax),%edx
  81e50f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e513:	89 50 54             	mov    %edx,0x54(%rax)

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
  81e516:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e51a:	8b 40 18             	mov    0x18(%rax),%eax
  81e51d:	83 f8 03             	cmp    $0x3,%eax
  81e520:	0f 86 a1 00 00 00    	jbe    81e5c7 <tcp_receive+0x466>
        if (pcb->cwnd < pcb->ssthresh) {
  81e526:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e52a:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81e52e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e532:	0f b7 40 5c          	movzwl 0x5c(%rax),%eax
  81e536:	66 39 c2             	cmp    %ax,%dx
  81e539:	73 3b                	jae    81e576 <tcp_receive+0x415>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  81e53b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e53f:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81e543:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e547:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e54b:	01 c2                	add    %eax,%edx
  81e54d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e551:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81e555:	66 39 c2             	cmp    %ax,%dx
  81e558:	76 6d                	jbe    81e5c7 <tcp_receive+0x466>
            pcb->cwnd += pcb->mss;
  81e55a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e55e:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81e562:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e566:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e56a:	01 c2                	add    %eax,%edx
  81e56c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e570:	66 89 50 5a          	mov    %dx,0x5a(%rax)
  81e574:	eb 51                	jmp    81e5c7 <tcp_receive+0x466>
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
  81e576:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e57a:	0f b7 48 5a          	movzwl 0x5a(%rax),%ecx
  81e57e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e582:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e586:	0f b7 d0             	movzwl %ax,%edx
  81e589:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e58d:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e591:	0f b7 c0             	movzwl %ax,%eax
  81e594:	0f af c2             	imul   %edx,%eax
  81e597:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  81e59b:	0f b7 52 5a          	movzwl 0x5a(%rdx),%edx
  81e59f:	0f b7 f2             	movzwl %dx,%esi
  81e5a2:	99                   	cltd   
  81e5a3:	f7 fe                	idiv   %esi
  81e5a5:	01 c8                	add    %ecx,%eax
  81e5a7:	66 89 45 ba          	mov    %ax,-0x46(%rbp)
          if (new_cwnd > pcb->cwnd) {
  81e5ab:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e5af:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81e5b3:	66 3b 45 ba          	cmp    -0x46(%rbp),%ax
  81e5b7:	73 0e                	jae    81e5c7 <tcp_receive+0x466>
            pcb->cwnd = new_cwnd;
  81e5b9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e5bd:	0f b7 55 ba          	movzwl -0x46(%rbp),%edx
  81e5c1:	66 89 50 5a          	mov    %dx,0x5a(%rax)
  81e5c5:	eb 00                	jmp    81e5c7 <tcp_receive+0x466>
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  81e5c7:	e9 11 01 00 00       	jmpq   81e6dd <tcp_receive+0x57c>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
  81e5cc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e5d0:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e5d7:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        pcb->unacked = pcb->unacked->next;
  81e5db:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e5df:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e5e6:	48 8b 10             	mov    (%rax),%rdx
  81e5e9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e5ed:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  81e5f4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e5f8:	0f b7 58 7c          	movzwl 0x7c(%rax),%ebx
  81e5fc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e600:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e604:	48 89 c7             	mov    %rax,%rdi
  81e607:	48 b8 f5 de 80 00 00 	movabs $0x80def5,%rax
  81e60e:	00 00 00 
  81e611:	ff d0                	callq  *%rax
  81e613:	0f b6 c0             	movzbl %al,%eax
  81e616:	66 39 c3             	cmp    %ax,%bx
  81e619:	73 2a                	jae    81e645 <tcp_receive+0x4e4>
  81e61b:	48 ba 48 3b 82 00 00 	movabs $0x823b48,%rdx
  81e622:	00 00 00 
  81e625:	be 56 03 00 00       	mov    $0x356,%esi
  81e62a:	48 bf a7 39 82 00 00 	movabs $0x8239a7,%rdi
  81e631:	00 00 00 
  81e634:	b8 00 00 00 00       	mov    $0x0,%eax
  81e639:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81e640:	00 00 00 
  81e643:	ff d1                	callq  *%rcx
        pcb->snd_queuelen -= pbuf_clen(next->p);
  81e645:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e649:	0f b7 58 7c          	movzwl 0x7c(%rax),%ebx
  81e64d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e651:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e655:	48 89 c7             	mov    %rax,%rdi
  81e658:	48 b8 f5 de 80 00 00 	movabs $0x80def5,%rax
  81e65f:	00 00 00 
  81e662:	ff d0                	callq  *%rax
  81e664:	0f b6 c0             	movzbl %al,%eax
  81e667:	29 c3                	sub    %eax,%ebx
  81e669:	89 da                	mov    %ebx,%edx
  81e66b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e66f:	66 89 50 7c          	mov    %dx,0x7c(%rax)
        tcp_seg_free(next);
  81e673:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e677:	48 89 c7             	mov    %rax,%rdi
  81e67a:	48 b8 7c 04 81 00 00 	movabs $0x81047c,%rax
  81e681:	00 00 00 
  81e684:	ff d0                	callq  *%rax

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
        if (pcb->snd_queuelen != 0) {
  81e686:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e68a:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  81e68e:	66 85 c0             	test   %ax,%ax
  81e691:	74 4a                	je     81e6dd <tcp_receive+0x57c>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
  81e693:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e697:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e69e:	48 85 c0             	test   %rax,%rax
  81e6a1:	75 3a                	jne    81e6dd <tcp_receive+0x57c>
  81e6a3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e6a7:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e6ae:	48 85 c0             	test   %rax,%rax
  81e6b1:	75 2a                	jne    81e6dd <tcp_receive+0x57c>
  81e6b3:	48 ba 70 3b 82 00 00 	movabs $0x823b70,%rdx
  81e6ba:	00 00 00 
  81e6bd:	be 5d 03 00 00       	mov    $0x35d,%esi
  81e6c2:	48 bf a7 39 82 00 00 	movabs $0x8239a7,%rdi
  81e6c9:	00 00 00 
  81e6cc:	b8 00 00 00 00       	mov    $0x0,%eax
  81e6d1:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81e6d8:	00 00 00 
  81e6db:	ff d1                	callq  *%rcx
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  81e6dd:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e6e1:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e6e8:	48 85 c0             	test   %rax,%rax
  81e6eb:	0f 84 bb 00 00 00    	je     81e7ac <tcp_receive+0x64b>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  81e6f1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e6f5:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e6fc:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e700:	8b 40 04             	mov    0x4(%rax),%eax
  81e703:	89 c7                	mov    %eax,%edi
  81e705:	48 b8 8c 30 81 00 00 	movabs $0x81308c,%rax
  81e70c:	00 00 00 
  81e70f:	ff d0                	callq  *%rax
  81e711:	89 c3                	mov    %eax,%ebx
  81e713:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e717:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e71e:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81e722:	44 0f b7 e0          	movzwl %ax,%r12d
  81e726:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e72a:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e731:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e735:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81e739:	0f b7 c0             	movzwl %ax,%eax
  81e73c:	89 c7                	mov    %eax,%edi
  81e73e:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  81e745:	00 00 00 
  81e748:	ff d0                	callq  *%rax
  81e74a:	0f b7 c0             	movzwl %ax,%eax
  81e74d:	83 e0 01             	and    $0x1,%eax
  81e750:	85 c0                	test   %eax,%eax
  81e752:	75 2e                	jne    81e782 <tcp_receive+0x621>
  81e754:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e758:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e75f:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e763:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81e767:	0f b7 c0             	movzwl %ax,%eax
  81e76a:	89 c7                	mov    %eax,%edi
  81e76c:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  81e773:	00 00 00 
  81e776:	ff d0                	callq  *%rax
  81e778:	0f b7 c0             	movzwl %ax,%eax
  81e77b:	83 e0 02             	and    $0x2,%eax
  81e77e:	85 c0                	test   %eax,%eax
  81e780:	74 07                	je     81e789 <tcp_receive+0x628>
  81e782:	b8 01 00 00 00       	mov    $0x1,%eax
  81e787:	eb 05                	jmp    81e78e <tcp_receive+0x62d>
  81e789:	b8 00 00 00 00       	mov    $0x0,%eax
  81e78e:	44 01 e0             	add    %r12d,%eax
  81e791:	8d 14 03             	lea    (%rbx,%rax,1),%edx
  81e794:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e79b:	00 00 00 
  81e79e:	8b 00                	mov    (%rax),%eax
  81e7a0:	29 c2                	sub    %eax,%edx
  81e7a2:	89 d0                	mov    %edx,%eax
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  81e7a4:	85 c0                	test   %eax,%eax
  81e7a6:	0f 8e 20 fe ff ff    	jle    81e5cc <tcp_receive+0x46b>
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  81e7ac:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e7b0:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e7b7:	48 85 c0             	test   %rax,%rax
  81e7ba:	75 0c                	jne    81e7c8 <tcp_receive+0x667>
        pcb->rtime = -1;
  81e7bc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e7c0:	66 c7 40 3e ff ff    	movw   $0xffff,0x3e(%rax)
  81e7c6:	eb 0a                	jmp    81e7d2 <tcp_receive+0x671>
      else
        pcb->rtime = 0;
  81e7c8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e7cc:	66 c7 40 3e 00 00    	movw   $0x0,0x3e(%rax)

      pcb->polltmr = 0;
  81e7d2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e7d6:	c6 40 3c 00          	movb   $0x0,0x3c(%rax)
  81e7da:	eb 0f                	jmp    81e7eb <tcp_receive+0x68a>
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
  81e7dc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e7e0:	66 c7 40 78 00 00    	movw   $0x0,0x78(%rax)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  81e7e6:	e9 4d 01 00 00       	jmpq   81e938 <tcp_receive+0x7d7>
  81e7eb:	e9 48 01 00 00       	jmpq   81e938 <tcp_receive+0x7d7>
           ) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
  81e7f0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e7f4:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e7fb:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
      pcb->unsent = pcb->unsent->next;
  81e7ff:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e803:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e80a:	48 8b 10             	mov    (%rax),%rdx
  81e80d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e811:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  81e818:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e81c:	0f b7 58 7c          	movzwl 0x7c(%rax),%ebx
  81e820:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e824:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e828:	48 89 c7             	mov    %rax,%rdi
  81e82b:	48 b8 f5 de 80 00 00 	movabs $0x80def5,%rax
  81e832:	00 00 00 
  81e835:	ff d0                	callq  *%rax
  81e837:	0f b6 c0             	movzbl %al,%eax
  81e83a:	66 39 c3             	cmp    %ax,%bx
  81e83d:	73 2a                	jae    81e869 <tcp_receive+0x708>
  81e83f:	48 ba 48 3b 82 00 00 	movabs $0x823b48,%rdx
  81e846:	00 00 00 
  81e849:	be 80 03 00 00       	mov    $0x380,%esi
  81e84e:	48 bf a7 39 82 00 00 	movabs $0x8239a7,%rdi
  81e855:	00 00 00 
  81e858:	b8 00 00 00 00       	mov    $0x0,%eax
  81e85d:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81e864:	00 00 00 
  81e867:	ff d1                	callq  *%rcx
      pcb->snd_queuelen -= pbuf_clen(next->p);
  81e869:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e86d:	0f b7 58 7c          	movzwl 0x7c(%rax),%ebx
  81e871:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e875:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e879:	48 89 c7             	mov    %rax,%rdi
  81e87c:	48 b8 f5 de 80 00 00 	movabs $0x80def5,%rax
  81e883:	00 00 00 
  81e886:	ff d0                	callq  *%rax
  81e888:	0f b6 c0             	movzbl %al,%eax
  81e88b:	29 c3                	sub    %eax,%ebx
  81e88d:	89 da                	mov    %ebx,%edx
  81e88f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e893:	66 89 50 7c          	mov    %dx,0x7c(%rax)
      tcp_seg_free(next);
  81e897:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e89b:	48 89 c7             	mov    %rax,%rdi
  81e89e:	48 b8 7c 04 81 00 00 	movabs $0x81047c,%rax
  81e8a5:	00 00 00 
  81e8a8:	ff d0                	callq  *%rax
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
      if (pcb->snd_queuelen != 0) {
  81e8aa:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e8ae:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  81e8b2:	66 85 c0             	test   %ax,%ax
  81e8b5:	74 4a                	je     81e901 <tcp_receive+0x7a0>
        LWIP_ASSERT("tcp_receive: valid queue length",
  81e8b7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e8bb:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e8c2:	48 85 c0             	test   %rax,%rax
  81e8c5:	75 3a                	jne    81e901 <tcp_receive+0x7a0>
  81e8c7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e8cb:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e8d2:	48 85 c0             	test   %rax,%rax
  81e8d5:	75 2a                	jne    81e901 <tcp_receive+0x7a0>
  81e8d7:	48 ba 70 3b 82 00 00 	movabs $0x823b70,%rdx
  81e8de:	00 00 00 
  81e8e1:	be 86 03 00 00       	mov    $0x386,%esi
  81e8e6:	48 bf a7 39 82 00 00 	movabs $0x8239a7,%rdi
  81e8ed:	00 00 00 
  81e8f0:	b8 00 00 00 00       	mov    $0x0,%eax
  81e8f5:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81e8fc:	00 00 00 
  81e8ff:	ff d1                	callq  *%rcx
          pcb->unacked != NULL || pcb->unsent != NULL);
      }

      if (pcb->unsent != NULL) {
  81e901:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e905:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e90c:	48 85 c0             	test   %rax,%rax
  81e90f:	74 27                	je     81e938 <tcp_receive+0x7d7>
        pcb->snd_nxt = htonl(pcb->unsent->tcphdr->seqno);
  81e911:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e915:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e91c:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e920:	8b 40 04             	mov    0x4(%rax),%eax
  81e923:	89 c7                	mov    %eax,%edi
  81e925:	48 b8 54 30 81 00 00 	movabs $0x813054,%rax
  81e92c:	00 00 00 
  81e92f:	ff d0                	callq  *%rax
  81e931:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  81e935:	89 42 60             	mov    %eax,0x60(%rdx)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  81e938:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e93c:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e943:	48 85 c0             	test   %rax,%rax
  81e946:	0f 84 d8 00 00 00    	je     81ea24 <tcp_receive+0x8c3>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  81e94c:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e953:	00 00 00 
  81e956:	44 8b 20             	mov    (%rax),%r12d
  81e959:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e95d:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e964:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e968:	8b 40 04             	mov    0x4(%rax),%eax
  81e96b:	89 c7                	mov    %eax,%edi
  81e96d:	48 b8 8c 30 81 00 00 	movabs $0x81308c,%rax
  81e974:	00 00 00 
  81e977:	ff d0                	callq  *%rax
  81e979:	89 c3                	mov    %eax,%ebx
  81e97b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e97f:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e986:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81e98a:	44 0f b7 e8          	movzwl %ax,%r13d
  81e98e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e992:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e999:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e99d:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81e9a1:	0f b7 c0             	movzwl %ax,%eax
  81e9a4:	89 c7                	mov    %eax,%edi
  81e9a6:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  81e9ad:	00 00 00 
  81e9b0:	ff d0                	callq  *%rax
  81e9b2:	0f b7 c0             	movzwl %ax,%eax
  81e9b5:	83 e0 01             	and    $0x1,%eax
  81e9b8:	85 c0                	test   %eax,%eax
  81e9ba:	75 2e                	jne    81e9ea <tcp_receive+0x889>
  81e9bc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e9c0:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e9c7:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e9cb:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81e9cf:	0f b7 c0             	movzwl %ax,%eax
  81e9d2:	89 c7                	mov    %eax,%edi
  81e9d4:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  81e9db:	00 00 00 
  81e9de:	ff d0                	callq  *%rax
  81e9e0:	0f b7 c0             	movzwl %ax,%eax
  81e9e3:	83 e0 02             	and    $0x2,%eax
  81e9e6:	85 c0                	test   %eax,%eax
  81e9e8:	74 07                	je     81e9f1 <tcp_receive+0x890>
  81e9ea:	b8 01 00 00 00       	mov    $0x1,%eax
  81e9ef:	eb 05                	jmp    81e9f6 <tcp_receive+0x895>
  81e9f1:	b8 00 00 00 00       	mov    $0x0,%eax
  81e9f6:	44 01 e8             	add    %r13d,%eax
  81e9f9:	01 d8                	add    %ebx,%eax
  81e9fb:	41 29 c4             	sub    %eax,%r12d
  81e9fe:	44 89 e0             	mov    %r12d,%eax
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  81ea01:	85 c0                	test   %eax,%eax
  81ea03:	78 1f                	js     81ea24 <tcp_receive+0x8c3>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  81ea05:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81ea0c:	00 00 00 
  81ea0f:	8b 10                	mov    (%rax),%edx
  81ea11:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ea15:	8b 40 64             	mov    0x64(%rax),%eax
  81ea18:	29 c2                	sub    %eax,%edx
  81ea1a:	89 d0                	mov    %edx,%eax
  81ea1c:	85 c0                	test   %eax,%eax
  81ea1e:	0f 8e cc fd ff ff    	jle    81e7f0 <tcp_receive+0x68f>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
  81ea24:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ea28:	8b 40 44             	mov    0x44(%rax),%eax
  81ea2b:	85 c0                	test   %eax,%eax
  81ea2d:	0f 84 de 00 00 00    	je     81eb11 <tcp_receive+0x9b0>
  81ea33:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ea37:	8b 50 48             	mov    0x48(%rax),%edx
  81ea3a:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81ea41:	00 00 00 
  81ea44:	8b 00                	mov    (%rax),%eax
  81ea46:	29 c2                	sub    %eax,%edx
  81ea48:	89 d0                	mov    %edx,%eax
  81ea4a:	85 c0                	test   %eax,%eax
  81ea4c:	0f 89 bf 00 00 00    	jns    81eb11 <tcp_receive+0x9b0>
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
  81ea52:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  81ea59:	00 00 00 
  81ea5c:	8b 00                	mov    (%rax),%eax
  81ea5e:	89 c2                	mov    %eax,%edx
  81ea60:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ea64:	8b 40 44             	mov    0x44(%rax),%eax
  81ea67:	29 c2                	sub    %eax,%edx
  81ea69:	89 d0                	mov    %edx,%eax
  81ea6b:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
  81ea6f:	0f b7 55 c2          	movzwl -0x3e(%rbp),%edx
  81ea73:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ea77:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  81ea7b:	66 c1 f8 03          	sar    $0x3,%ax
  81ea7f:	29 c2                	sub    %eax,%edx
  81ea81:	89 d0                	mov    %edx,%eax
  81ea83:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)
      pcb->sa += m;
  81ea87:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ea8b:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  81ea8f:	89 c2                	mov    %eax,%edx
  81ea91:	0f b7 45 c2          	movzwl -0x3e(%rbp),%eax
  81ea95:	01 d0                	add    %edx,%eax
  81ea97:	89 c2                	mov    %eax,%edx
  81ea99:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ea9d:	66 89 50 4c          	mov    %dx,0x4c(%rax)
      if (m < 0) {
  81eaa1:	66 83 7d c2 00       	cmpw   $0x0,-0x3e(%rbp)
  81eaa6:	79 0a                	jns    81eab2 <tcp_receive+0x951>
        m = -m;
  81eaa8:	0f b7 45 c2          	movzwl -0x3e(%rbp),%eax
  81eaac:	f7 d8                	neg    %eax
  81eaae:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)
      }
      m = m - (pcb->sv >> 2);
  81eab2:	0f b7 55 c2          	movzwl -0x3e(%rbp),%edx
  81eab6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eaba:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  81eabe:	66 c1 f8 02          	sar    $0x2,%ax
  81eac2:	29 c2                	sub    %eax,%edx
  81eac4:	89 d0                	mov    %edx,%eax
  81eac6:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)
      pcb->sv += m;
  81eaca:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eace:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  81ead2:	89 c2                	mov    %eax,%edx
  81ead4:	0f b7 45 c2          	movzwl -0x3e(%rbp),%eax
  81ead8:	01 d0                	add    %edx,%eax
  81eada:	89 c2                	mov    %eax,%edx
  81eadc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eae0:	66 89 50 4e          	mov    %dx,0x4e(%rax)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  81eae4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eae8:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  81eaec:	66 c1 f8 03          	sar    $0x3,%ax
  81eaf0:	89 c2                	mov    %eax,%edx
  81eaf2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eaf6:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  81eafa:	01 d0                	add    %edx,%eax
  81eafc:	89 c2                	mov    %eax,%edx
  81eafe:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eb02:	66 89 50 50          	mov    %dx,0x50(%rax)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
  81eb06:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eb0a:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%rax)
    }
  }

  /* If the incoming segment contains data, we must process it
     further. */
  if (tcplen > 0) {
  81eb11:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81eb18:	00 00 00 
  81eb1b:	0f b7 00             	movzwl (%rax),%eax
  81eb1e:	66 85 c0             	test   %ax,%ax
  81eb21:	0f 84 26 10 00 00    	je     81fb4d <tcp_receive+0x19ec>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  81eb27:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eb2b:	8b 50 30             	mov    0x30(%rax),%edx
  81eb2e:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81eb35:	00 00 00 
  81eb38:	8b 00                	mov    (%rax),%eax
  81eb3a:	29 c2                	sub    %eax,%edx
  81eb3c:	89 d0                	mov    %edx,%eax
  81eb3e:	83 e8 01             	sub    $0x1,%eax
  81eb41:	85 c0                	test   %eax,%eax
  81eb43:	0f 88 af 02 00 00    	js     81edf8 <tcp_receive+0xc97>
  81eb49:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eb4d:	8b 50 30             	mov    0x30(%rax),%edx
  81eb50:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81eb57:	00 00 00 
  81eb5a:	0f b7 00             	movzwl (%rax),%eax
  81eb5d:	0f b7 c8             	movzwl %ax,%ecx
  81eb60:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81eb67:	00 00 00 
  81eb6a:	8b 00                	mov    (%rax),%eax
  81eb6c:	01 c8                	add    %ecx,%eax
  81eb6e:	29 c2                	sub    %eax,%edx
  81eb70:	89 d0                	mov    %edx,%eax
  81eb72:	83 c0 01             	add    $0x1,%eax
  81eb75:	85 c0                	test   %eax,%eax
  81eb77:	0f 8f 7b 02 00 00    	jg     81edf8 <tcp_receive+0xc97>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
  81eb7d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eb81:	8b 50 30             	mov    0x30(%rax),%edx
  81eb84:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81eb8b:	00 00 00 
  81eb8e:	8b 00                	mov    (%rax),%eax
  81eb90:	29 c2                	sub    %eax,%edx
  81eb92:	89 d0                	mov    %edx,%eax
  81eb94:	89 45 c4             	mov    %eax,-0x3c(%rbp)
      p = inseg.p;
  81eb97:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81eb9e:	00 00 00 
  81eba1:	48 8b 40 08          	mov    0x8(%rax),%rax
  81eba5:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  81eba9:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ebb0:	00 00 00 
  81ebb3:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ebb7:	48 85 c0             	test   %rax,%rax
  81ebba:	75 2a                	jne    81ebe6 <tcp_receive+0xa85>
  81ebbc:	48 ba 90 3b 82 00 00 	movabs $0x823b90,%rdx
  81ebc3:	00 00 00 
  81ebc6:	be e6 03 00 00       	mov    $0x3e6,%esi
  81ebcb:	48 bf a7 39 82 00 00 	movabs $0x8239a7,%rdi
  81ebd2:	00 00 00 
  81ebd5:	b8 00 00 00 00       	mov    $0x0,%eax
  81ebda:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81ebe1:	00 00 00 
  81ebe4:	ff d1                	callq  *%rcx
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  81ebe6:	81 7d c4 fe 7f 00 00 	cmpl   $0x7ffe,-0x3c(%rbp)
  81ebed:	7e 2a                	jle    81ec19 <tcp_receive+0xab8>
  81ebef:	48 ba a0 3b 82 00 00 	movabs $0x823ba0,%rdx
  81ebf6:	00 00 00 
  81ebf9:	be e7 03 00 00       	mov    $0x3e7,%esi
  81ebfe:	48 bf a7 39 82 00 00 	movabs $0x8239a7,%rdi
  81ec05:	00 00 00 
  81ec08:	b8 00 00 00 00       	mov    $0x0,%eax
  81ec0d:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81ec14:	00 00 00 
  81ec17:	ff d1                	callq  *%rcx
      if (inseg.p->len < off) {
  81ec19:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ec20:	00 00 00 
  81ec23:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ec27:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81ec2b:	0f b7 c0             	movzwl %ax,%eax
  81ec2e:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  81ec31:	0f 8d ed 00 00 00    	jge    81ed24 <tcp_receive+0xbc3>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  81ec37:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ec3e:	00 00 00 
  81ec41:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ec45:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81ec49:	0f b7 c0             	movzwl %ax,%eax
  81ec4c:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  81ec4f:	7d 2a                	jge    81ec7b <tcp_receive+0xb1a>
  81ec51:	48 ba af 3b 82 00 00 	movabs $0x823baf,%rdx
  81ec58:	00 00 00 
  81ec5b:	be e9 03 00 00       	mov    $0x3e9,%esi
  81ec60:	48 bf a7 39 82 00 00 	movabs $0x8239a7,%rdi
  81ec67:	00 00 00 
  81ec6a:	b8 00 00 00 00       	mov    $0x0,%eax
  81ec6f:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81ec76:	00 00 00 
  81ec79:	ff d1                	callq  *%rcx
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
  81ec7b:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ec82:	00 00 00 
  81ec85:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ec89:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  81ec8d:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  81ec90:	29 c2                	sub    %eax,%edx
  81ec92:	89 d0                	mov    %edx,%eax
  81ec94:	66 89 45 b8          	mov    %ax,-0x48(%rbp)
        while (p->len < off) {
  81ec98:	eb 2f                	jmp    81ecc9 <tcp_receive+0xb68>
          off -= p->len;
  81ec9a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81ec9e:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81eca2:	0f b7 c0             	movzwl %ax,%eax
  81eca5:	29 45 c4             	sub    %eax,-0x3c(%rbp)
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
  81eca8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81ecac:	0f b7 55 b8          	movzwl -0x48(%rbp),%edx
  81ecb0:	66 89 50 10          	mov    %dx,0x10(%rax)
          p->len = 0;
  81ecb4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81ecb8:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
          p = p->next;
  81ecbe:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81ecc2:	48 8b 00             	mov    (%rax),%rax
  81ecc5:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
  81ecc9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81eccd:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81ecd1:	0f b7 c0             	movzwl %ax,%eax
  81ecd4:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  81ecd7:	7c c1                	jl     81ec9a <tcp_receive+0xb39>
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
  81ecd9:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  81ecdc:	f7 d8                	neg    %eax
  81ecde:	0f bf d0             	movswl %ax,%edx
  81ece1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81ece5:	89 d6                	mov    %edx,%esi
  81ece7:	48 89 c7             	mov    %rax,%rdi
  81ecea:	48 b8 7f db 80 00 00 	movabs $0x80db7f,%rax
  81ecf1:	00 00 00 
  81ecf4:	ff d0                	callq  *%rax
  81ecf6:	84 c0                	test   %al,%al
  81ecf8:	74 7f                	je     81ed79 <tcp_receive+0xc18>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  81ecfa:	48 ba bf 3b 82 00 00 	movabs $0x823bbf,%rdx
  81ed01:	00 00 00 
  81ed04:	be f6 03 00 00       	mov    $0x3f6,%esi
  81ed09:	48 bf a7 39 82 00 00 	movabs $0x8239a7,%rdi
  81ed10:	00 00 00 
  81ed13:	b8 00 00 00 00       	mov    $0x0,%eax
  81ed18:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81ed1f:	00 00 00 
  81ed22:	ff d1                	callq  *%rcx
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
  81ed24:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  81ed27:	f7 d8                	neg    %eax
  81ed29:	0f bf d0             	movswl %ax,%edx
  81ed2c:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ed33:	00 00 00 
  81ed36:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ed3a:	89 d6                	mov    %edx,%esi
  81ed3c:	48 89 c7             	mov    %rax,%rdi
  81ed3f:	48 b8 7f db 80 00 00 	movabs $0x80db7f,%rax
  81ed46:	00 00 00 
  81ed49:	ff d0                	callq  *%rax
  81ed4b:	84 c0                	test   %al,%al
  81ed4d:	74 2a                	je     81ed79 <tcp_receive+0xc18>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  81ed4f:	48 ba bf 3b 82 00 00 	movabs $0x823bbf,%rdx
  81ed56:	00 00 00 
  81ed59:	be fb 03 00 00       	mov    $0x3fb,%esi
  81ed5e:	48 bf a7 39 82 00 00 	movabs $0x8239a7,%rdi
  81ed65:	00 00 00 
  81ed68:	b8 00 00 00 00       	mov    $0x0,%eax
  81ed6d:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81ed74:	00 00 00 
  81ed77:	ff d1                	callq  *%rcx
        }
      }
      /* KJM following line changed to use p->payload rather than inseg->p->payload
         to fix bug #9076 */
      inseg.dataptr = p->payload;
  81ed79:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81ed7d:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81ed81:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ed88:	00 00 00 
  81ed8b:	48 89 50 10          	mov    %rdx,0x10(%rax)
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
  81ed8f:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ed96:	00 00 00 
  81ed99:	0f b7 50 18          	movzwl 0x18(%rax),%edx
  81ed9d:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81eda4:	00 00 00 
  81eda7:	8b 00                	mov    (%rax),%eax
  81eda9:	89 c1                	mov    %eax,%ecx
  81edab:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81edaf:	8b 40 30             	mov    0x30(%rax),%eax
  81edb2:	29 c1                	sub    %eax,%ecx
  81edb4:	89 c8                	mov    %ecx,%eax
  81edb6:	01 c2                	add    %eax,%edx
  81edb8:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81edbf:	00 00 00 
  81edc2:	66 89 50 18          	mov    %dx,0x18(%rax)
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
  81edc6:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81edcd:	00 00 00 
  81edd0:	48 8b 40 20          	mov    0x20(%rax),%rax
  81edd4:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  81edd8:	8b 4a 30             	mov    0x30(%rdx),%ecx
  81eddb:	48 ba d8 74 b5 00 00 	movabs $0xb574d8,%rdx
  81ede2:	00 00 00 
  81ede5:	89 0a                	mov    %ecx,(%rdx)
  81ede7:	48 ba d8 74 b5 00 00 	movabs $0xb574d8,%rdx
  81edee:	00 00 00 
  81edf1:	8b 12                	mov    (%rdx),%edx
  81edf3:	89 50 04             	mov    %edx,0x4(%rax)
  81edf6:	eb 42                	jmp    81ee3a <tcp_receive+0xcd9>
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
  81edf8:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81edff:	00 00 00 
  81ee02:	8b 10                	mov    (%rax),%edx
  81ee04:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ee08:	8b 40 30             	mov    0x30(%rax),%eax
  81ee0b:	29 c2                	sub    %eax,%edx
  81ee0d:	89 d0                	mov    %edx,%eax
  81ee0f:	85 c0                	test   %eax,%eax
  81ee11:	79 27                	jns    81ee3a <tcp_receive+0xcd9>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
  81ee13:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ee17:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81ee1b:	83 c8 02             	or     $0x2,%eax
  81ee1e:	89 c2                	mov    %eax,%edx
  81ee20:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ee24:	88 50 2c             	mov    %dl,0x2c(%rax)
  81ee27:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ee2b:	48 89 c7             	mov    %rax,%rdi
  81ee2e:	48 b8 3d 3c 81 00 00 	movabs $0x813c3d,%rax
  81ee35:	00 00 00 
  81ee38:	ff d0                	callq  *%rax
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  81ee3a:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81ee41:	00 00 00 
  81ee44:	8b 10                	mov    (%rax),%edx
  81ee46:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ee4a:	8b 40 30             	mov    0x30(%rax),%eax
  81ee4d:	29 c2                	sub    %eax,%edx
  81ee4f:	89 d0                	mov    %edx,%eax
  81ee51:	85 c0                	test   %eax,%eax
  81ee53:	0f 88 c9 0c 00 00    	js     81fb22 <tcp_receive+0x19c1>
  81ee59:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81ee60:	00 00 00 
  81ee63:	8b 10                	mov    (%rax),%edx
  81ee65:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ee69:	8b 48 30             	mov    0x30(%rax),%ecx
  81ee6c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ee70:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  81ee74:	0f b7 c0             	movzwl %ax,%eax
  81ee77:	01 c8                	add    %ecx,%eax
  81ee79:	29 c2                	sub    %eax,%edx
  81ee7b:	89 d0                	mov    %edx,%eax
  81ee7d:	83 c0 01             	add    $0x1,%eax
  81ee80:	85 c0                	test   %eax,%eax
  81ee82:	0f 8f 9a 0c 00 00    	jg     81fb22 <tcp_receive+0x19c1>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  81ee88:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ee8c:	8b 50 30             	mov    0x30(%rax),%edx
  81ee8f:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81ee96:	00 00 00 
  81ee99:	8b 00                	mov    (%rax),%eax
  81ee9b:	39 c2                	cmp    %eax,%edx
  81ee9d:	0f 85 42 07 00 00    	jne    81f5e5 <tcp_receive+0x1484>
        accepted_inseq = 1; 
  81eea3:	c6 45 c1 01          	movb   $0x1,-0x3f(%rbp)
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  81eea7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eeab:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81eeb2:	48 85 c0             	test   %rax,%rax
  81eeb5:	0f 84 4c 01 00 00    	je     81f007 <tcp_receive+0xea6>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
  81eebb:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eebf:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81eec6:	48 8b 40 20          	mov    0x20(%rax),%rax
  81eeca:	8b 50 04             	mov    0x4(%rax),%edx
  81eecd:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81eed4:	00 00 00 
  81eed7:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81eedb:	0f b7 c8             	movzwl %ax,%ecx
  81eede:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81eee5:	00 00 00 
  81eee8:	8b 00                	mov    (%rax),%eax
  81eeea:	01 c8                	add    %ecx,%eax
  81eeec:	29 c2                	sub    %eax,%edx
  81eeee:	89 d0                	mov    %edx,%eax
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  81eef0:	85 c0                	test   %eax,%eax
  81eef2:	0f 8f 0f 01 00 00    	jg     81f007 <tcp_receive+0xea6>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
          if (pcb->ooseq->len > 0) {
  81eef8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eefc:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81ef03:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81ef07:	66 85 c0             	test   %ax,%ax
  81ef0a:	74 65                	je     81ef71 <tcp_receive+0xe10>
            /* We have to trim the second edge of the incoming
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
  81ef0c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ef10:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81ef17:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ef1b:	8b 40 04             	mov    0x4(%rax),%eax
  81ef1e:	89 c2                	mov    %eax,%edx
  81ef20:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81ef27:	00 00 00 
  81ef2a:	8b 00                	mov    (%rax),%eax
  81ef2c:	29 c2                	sub    %eax,%edx
  81ef2e:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ef35:	00 00 00 
  81ef38:	66 89 50 18          	mov    %dx,0x18(%rax)
            pbuf_realloc(inseg.p, inseg.len);
  81ef3c:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ef43:	00 00 00 
  81ef46:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81ef4a:	0f b7 d0             	movzwl %ax,%edx
  81ef4d:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ef54:	00 00 00 
  81ef57:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ef5b:	89 d6                	mov    %edx,%esi
  81ef5d:	48 89 c7             	mov    %rax,%rdi
  81ef60:	48 b8 36 d9 80 00 00 	movabs $0x80d936,%rax
  81ef67:	00 00 00 
  81ef6a:	ff d0                	callq  *%rax
  81ef6c:	e9 96 00 00 00       	jmpq   81f007 <tcp_receive+0xea6>
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  81ef71:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ef78:	00 00 00 
  81ef7b:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ef7f:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81ef83:	0f b7 c0             	movzwl %ax,%eax
  81ef86:	89 c7                	mov    %eax,%edi
  81ef88:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  81ef8f:	00 00 00 
  81ef92:	ff d0                	callq  *%rax
  81ef94:	0f b7 d8             	movzwl %ax,%ebx
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
  81ef97:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ef9b:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81efa2:	48 8b 40 20          	mov    0x20(%rax),%rax
  81efa6:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81efaa:	0f b7 c0             	movzwl %ax,%eax
  81efad:	89 c7                	mov    %eax,%edi
  81efaf:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  81efb6:	00 00 00 
  81efb9:	ff d0                	callq  *%rax
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
            pbuf_realloc(inseg.p, inseg.len);
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  81efbb:	0f b7 c0             	movzwl %ax,%eax
  81efbe:	31 d8                	xor    %ebx,%eax
  81efc0:	83 e0 03             	and    $0x3,%eax
  81efc3:	85 c0                	test   %eax,%eax
  81efc5:	75 40                	jne    81f007 <tcp_receive+0xea6>
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
              struct tcp_seg *old_ooseq = pcb->ooseq;
  81efc7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81efcb:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81efd2:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
              pcb->ooseq = pcb->ooseq->next;
  81efd6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81efda:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81efe1:	48 8b 10             	mov    (%rax),%rdx
  81efe4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81efe8:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
              memp_free(MEMP_TCP_SEG, old_ooseq);
  81efef:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  81eff3:	48 89 c6             	mov    %rax,%rsi
  81eff6:	bf 04 00 00 00       	mov    $0x4,%edi
  81effb:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  81f002:	00 00 00 
  81f005:	ff d0                	callq  *%rax
            }
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        tcplen = TCP_TCPLEN(&inseg);
  81f007:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f00e:	00 00 00 
  81f011:	0f b7 58 18          	movzwl 0x18(%rax),%ebx
  81f015:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f01c:	00 00 00 
  81f01f:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f023:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f027:	0f b7 c0             	movzwl %ax,%eax
  81f02a:	89 c7                	mov    %eax,%edi
  81f02c:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  81f033:	00 00 00 
  81f036:	ff d0                	callq  *%rax
  81f038:	0f b7 c0             	movzwl %ax,%eax
  81f03b:	83 e0 01             	and    $0x1,%eax
  81f03e:	85 c0                	test   %eax,%eax
  81f040:	75 2d                	jne    81f06f <tcp_receive+0xf0e>
  81f042:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f049:	00 00 00 
  81f04c:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f050:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f054:	0f b7 c0             	movzwl %ax,%eax
  81f057:	89 c7                	mov    %eax,%edi
  81f059:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  81f060:	00 00 00 
  81f063:	ff d0                	callq  *%rax
  81f065:	0f b7 c0             	movzwl %ax,%eax
  81f068:	83 e0 02             	and    $0x2,%eax
  81f06b:	85 c0                	test   %eax,%eax
  81f06d:	74 07                	je     81f076 <tcp_receive+0xf15>
  81f06f:	b8 01 00 00 00       	mov    $0x1,%eax
  81f074:	eb 05                	jmp    81f07b <tcp_receive+0xf1a>
  81f076:	b8 00 00 00 00       	mov    $0x0,%eax
  81f07b:	8d 14 03             	lea    (%rbx,%rax,1),%edx
  81f07e:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81f085:	00 00 00 
  81f088:	66 89 10             	mov    %dx,(%rax)

        /* First received FIN will be ACKed +1, on any successive (duplicate)
         * FINs we are already in CLOSE_WAIT and have already done +1.
         */
        if (pcb->state != CLOSE_WAIT) {
  81f08b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f08f:	8b 40 18             	mov    0x18(%rax),%eax
  81f092:	83 f8 07             	cmp    $0x7,%eax
  81f095:	74 20                	je     81f0b7 <tcp_receive+0xf56>
          pcb->rcv_nxt += tcplen;
  81f097:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f09b:	8b 50 30             	mov    0x30(%rax),%edx
  81f09e:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81f0a5:	00 00 00 
  81f0a8:	0f b7 00             	movzwl (%rax),%eax
  81f0ab:	0f b7 c0             	movzwl %ax,%eax
  81f0ae:	01 c2                	add    %eax,%edx
  81f0b0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f0b4:	89 50 30             	mov    %edx,0x30(%rax)
        }

        /* Update the receiver's (our) window. */
        if (pcb->rcv_wnd < tcplen) {
  81f0b7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f0bb:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  81f0bf:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81f0c6:	00 00 00 
  81f0c9:	0f b7 00             	movzwl (%rax),%eax
  81f0cc:	66 39 c2             	cmp    %ax,%dx
  81f0cf:	73 0c                	jae    81f0dd <tcp_receive+0xf7c>
          pcb->rcv_wnd = 0;
  81f0d1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f0d5:	66 c7 40 34 00 00    	movw   $0x0,0x34(%rax)
  81f0db:	eb 1f                	jmp    81f0fc <tcp_receive+0xf9b>
        } else {
          pcb->rcv_wnd -= tcplen;
  81f0dd:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f0e1:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  81f0e5:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81f0ec:	00 00 00 
  81f0ef:	0f b7 00             	movzwl (%rax),%eax
  81f0f2:	29 c2                	sub    %eax,%edx
  81f0f4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f0f8:	66 89 50 34          	mov    %dx,0x34(%rax)
        }

        if (pcb->rcv_ann_wnd < tcplen) {
  81f0fc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f100:	0f b7 50 36          	movzwl 0x36(%rax),%edx
  81f104:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81f10b:	00 00 00 
  81f10e:	0f b7 00             	movzwl (%rax),%eax
  81f111:	66 39 c2             	cmp    %ax,%dx
  81f114:	73 0c                	jae    81f122 <tcp_receive+0xfc1>
          pcb->rcv_ann_wnd = 0;
  81f116:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f11a:	66 c7 40 36 00 00    	movw   $0x0,0x36(%rax)
  81f120:	eb 1f                	jmp    81f141 <tcp_receive+0xfe0>
        } else {
          pcb->rcv_ann_wnd -= tcplen;
  81f122:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f126:	0f b7 50 36          	movzwl 0x36(%rax),%edx
  81f12a:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81f131:	00 00 00 
  81f134:	0f b7 00             	movzwl (%rax),%eax
  81f137:	29 c2                	sub    %eax,%edx
  81f139:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f13d:	66 89 50 36          	mov    %dx,0x36(%rax)
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
  81f141:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f148:	00 00 00 
  81f14b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f14f:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81f153:	66 85 c0             	test   %ax,%ax
  81f156:	74 2d                	je     81f185 <tcp_receive+0x1024>
          recv_data = inseg.p;
  81f158:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f15f:	00 00 00 
  81f162:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81f166:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81f16d:	00 00 00 
  81f170:	48 89 10             	mov    %rdx,(%rax)
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
  81f173:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f17a:	00 00 00 
  81f17d:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81f184:	00 
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  81f185:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f18c:	00 00 00 
  81f18f:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f193:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f197:	0f b7 c0             	movzwl %ax,%eax
  81f19a:	89 c7                	mov    %eax,%edi
  81f19c:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  81f1a3:	00 00 00 
  81f1a6:	ff d0                	callq  *%rax
  81f1a8:	0f b7 c0             	movzwl %ax,%eax
  81f1ab:	83 e0 01             	and    $0x1,%eax
  81f1ae:	85 c0                	test   %eax,%eax
  81f1b0:	74 12                	je     81f1c4 <tcp_receive+0x1063>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags = TF_GOT_FIN;
  81f1b2:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81f1b9:	00 00 00 
  81f1bc:	c6 00 20             	movb   $0x20,(%rax)
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  81f1bf:	e9 85 03 00 00       	jmpq   81f549 <tcp_receive+0x13e8>
  81f1c4:	e9 80 03 00 00       	jmpq   81f549 <tcp_receive+0x13e8>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          cseg = pcb->ooseq;
  81f1c9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f1cd:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f1d4:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
          seqno = pcb->ooseq->tcphdr->seqno;
  81f1d8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f1dc:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f1e3:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f1e7:	8b 50 04             	mov    0x4(%rax),%edx
  81f1ea:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f1f1:	00 00 00 
  81f1f4:	89 10                	mov    %edx,(%rax)

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  81f1f6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f1fa:	8b 58 30             	mov    0x30(%rax),%ebx
  81f1fd:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f201:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f205:	44 0f b7 e0          	movzwl %ax,%r12d
  81f209:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f20d:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f211:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f215:	0f b7 c0             	movzwl %ax,%eax
  81f218:	89 c7                	mov    %eax,%edi
  81f21a:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  81f221:	00 00 00 
  81f224:	ff d0                	callq  *%rax
  81f226:	0f b7 c0             	movzwl %ax,%eax
  81f229:	83 e0 01             	and    $0x1,%eax
  81f22c:	85 c0                	test   %eax,%eax
  81f22e:	75 27                	jne    81f257 <tcp_receive+0x10f6>
  81f230:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f234:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f238:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f23c:	0f b7 c0             	movzwl %ax,%eax
  81f23f:	89 c7                	mov    %eax,%edi
  81f241:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  81f248:	00 00 00 
  81f24b:	ff d0                	callq  *%rax
  81f24d:	0f b7 c0             	movzwl %ax,%eax
  81f250:	83 e0 02             	and    $0x2,%eax
  81f253:	85 c0                	test   %eax,%eax
  81f255:	74 07                	je     81f25e <tcp_receive+0x10fd>
  81f257:	b8 01 00 00 00       	mov    $0x1,%eax
  81f25c:	eb 05                	jmp    81f263 <tcp_receive+0x1102>
  81f25e:	b8 00 00 00 00       	mov    $0x0,%eax
  81f263:	44 01 e0             	add    %r12d,%eax
  81f266:	8d 14 03             	lea    (%rbx,%rax,1),%edx
  81f269:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f26d:	89 50 30             	mov    %edx,0x30(%rax)
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  81f270:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f274:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  81f278:	0f b7 d8             	movzwl %ax,%ebx
  81f27b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f27f:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f283:	44 0f b7 e0          	movzwl %ax,%r12d
  81f287:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f28b:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f28f:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f293:	0f b7 c0             	movzwl %ax,%eax
  81f296:	89 c7                	mov    %eax,%edi
  81f298:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  81f29f:	00 00 00 
  81f2a2:	ff d0                	callq  *%rax
  81f2a4:	0f b7 c0             	movzwl %ax,%eax
  81f2a7:	83 e0 01             	and    $0x1,%eax
  81f2aa:	85 c0                	test   %eax,%eax
  81f2ac:	75 27                	jne    81f2d5 <tcp_receive+0x1174>
  81f2ae:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f2b2:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f2b6:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f2ba:	0f b7 c0             	movzwl %ax,%eax
  81f2bd:	89 c7                	mov    %eax,%edi
  81f2bf:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  81f2c6:	00 00 00 
  81f2c9:	ff d0                	callq  *%rax
  81f2cb:	0f b7 c0             	movzwl %ax,%eax
  81f2ce:	83 e0 02             	and    $0x2,%eax
  81f2d1:	85 c0                	test   %eax,%eax
  81f2d3:	74 07                	je     81f2dc <tcp_receive+0x117b>
  81f2d5:	b8 01 00 00 00       	mov    $0x1,%eax
  81f2da:	eb 05                	jmp    81f2e1 <tcp_receive+0x1180>
  81f2dc:	b8 00 00 00 00       	mov    $0x0,%eax
  81f2e1:	44 01 e0             	add    %r12d,%eax
  81f2e4:	39 c3                	cmp    %eax,%ebx
  81f2e6:	7d 0c                	jge    81f2f4 <tcp_receive+0x1193>
            pcb->rcv_wnd = 0;
  81f2e8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f2ec:	66 c7 40 34 00 00    	movw   $0x0,0x34(%rax)
  81f2f2:	eb 7a                	jmp    81f36e <tcp_receive+0x120d>
          } else {
            pcb->rcv_wnd -= TCP_TCPLEN(cseg);
  81f2f4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f2f8:	0f b7 58 34          	movzwl 0x34(%rax),%ebx
  81f2fc:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f300:	44 0f b7 60 18       	movzwl 0x18(%rax),%r12d
  81f305:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f309:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f30d:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f311:	0f b7 c0             	movzwl %ax,%eax
  81f314:	89 c7                	mov    %eax,%edi
  81f316:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  81f31d:	00 00 00 
  81f320:	ff d0                	callq  *%rax
  81f322:	0f b7 c0             	movzwl %ax,%eax
  81f325:	83 e0 01             	and    $0x1,%eax
  81f328:	85 c0                	test   %eax,%eax
  81f32a:	75 27                	jne    81f353 <tcp_receive+0x11f2>
  81f32c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f330:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f334:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f338:	0f b7 c0             	movzwl %ax,%eax
  81f33b:	89 c7                	mov    %eax,%edi
  81f33d:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  81f344:	00 00 00 
  81f347:	ff d0                	callq  *%rax
  81f349:	0f b7 c0             	movzwl %ax,%eax
  81f34c:	83 e0 02             	and    $0x2,%eax
  81f34f:	85 c0                	test   %eax,%eax
  81f351:	74 07                	je     81f35a <tcp_receive+0x11f9>
  81f353:	b8 01 00 00 00       	mov    $0x1,%eax
  81f358:	eb 05                	jmp    81f35f <tcp_receive+0x11fe>
  81f35a:	b8 00 00 00 00       	mov    $0x0,%eax
  81f35f:	44 01 e0             	add    %r12d,%eax
  81f362:	29 c3                	sub    %eax,%ebx
  81f364:	89 da                	mov    %ebx,%edx
  81f366:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f36a:	66 89 50 34          	mov    %dx,0x34(%rax)
          }
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  81f36e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f372:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  81f376:	0f b7 d8             	movzwl %ax,%ebx
  81f379:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f37d:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f381:	44 0f b7 e0          	movzwl %ax,%r12d
  81f385:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f389:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f38d:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f391:	0f b7 c0             	movzwl %ax,%eax
  81f394:	89 c7                	mov    %eax,%edi
  81f396:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  81f39d:	00 00 00 
  81f3a0:	ff d0                	callq  *%rax
  81f3a2:	0f b7 c0             	movzwl %ax,%eax
  81f3a5:	83 e0 01             	and    $0x1,%eax
  81f3a8:	85 c0                	test   %eax,%eax
  81f3aa:	75 27                	jne    81f3d3 <tcp_receive+0x1272>
  81f3ac:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f3b0:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f3b4:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f3b8:	0f b7 c0             	movzwl %ax,%eax
  81f3bb:	89 c7                	mov    %eax,%edi
  81f3bd:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  81f3c4:	00 00 00 
  81f3c7:	ff d0                	callq  *%rax
  81f3c9:	0f b7 c0             	movzwl %ax,%eax
  81f3cc:	83 e0 02             	and    $0x2,%eax
  81f3cf:	85 c0                	test   %eax,%eax
  81f3d1:	74 07                	je     81f3da <tcp_receive+0x1279>
  81f3d3:	b8 01 00 00 00       	mov    $0x1,%eax
  81f3d8:	eb 05                	jmp    81f3df <tcp_receive+0x127e>
  81f3da:	b8 00 00 00 00       	mov    $0x0,%eax
  81f3df:	44 01 e0             	add    %r12d,%eax
  81f3e2:	39 c3                	cmp    %eax,%ebx
  81f3e4:	7d 0c                	jge    81f3f2 <tcp_receive+0x1291>
            pcb->rcv_ann_wnd = 0;
  81f3e6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f3ea:	66 c7 40 36 00 00    	movw   $0x0,0x36(%rax)
  81f3f0:	eb 7a                	jmp    81f46c <tcp_receive+0x130b>
          } else {
            pcb->rcv_ann_wnd -= TCP_TCPLEN(cseg);
  81f3f2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f3f6:	0f b7 58 36          	movzwl 0x36(%rax),%ebx
  81f3fa:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f3fe:	44 0f b7 60 18       	movzwl 0x18(%rax),%r12d
  81f403:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f407:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f40b:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f40f:	0f b7 c0             	movzwl %ax,%eax
  81f412:	89 c7                	mov    %eax,%edi
  81f414:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  81f41b:	00 00 00 
  81f41e:	ff d0                	callq  *%rax
  81f420:	0f b7 c0             	movzwl %ax,%eax
  81f423:	83 e0 01             	and    $0x1,%eax
  81f426:	85 c0                	test   %eax,%eax
  81f428:	75 27                	jne    81f451 <tcp_receive+0x12f0>
  81f42a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f42e:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f432:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f436:	0f b7 c0             	movzwl %ax,%eax
  81f439:	89 c7                	mov    %eax,%edi
  81f43b:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  81f442:	00 00 00 
  81f445:	ff d0                	callq  *%rax
  81f447:	0f b7 c0             	movzwl %ax,%eax
  81f44a:	83 e0 02             	and    $0x2,%eax
  81f44d:	85 c0                	test   %eax,%eax
  81f44f:	74 07                	je     81f458 <tcp_receive+0x12f7>
  81f451:	b8 01 00 00 00       	mov    $0x1,%eax
  81f456:	eb 05                	jmp    81f45d <tcp_receive+0x12fc>
  81f458:	b8 00 00 00 00       	mov    $0x0,%eax
  81f45d:	44 01 e0             	add    %r12d,%eax
  81f460:	29 c3                	sub    %eax,%ebx
  81f462:	89 da                	mov    %ebx,%edx
  81f464:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f468:	66 89 50 36          	mov    %dx,0x36(%rax)
          }

          if (cseg->p->tot_len > 0) {
  81f46c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f470:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f474:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81f478:	66 85 c0             	test   %ax,%ax
  81f47b:	74 5c                	je     81f4d9 <tcp_receive+0x1378>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            if (recv_data) {
  81f47d:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81f484:	00 00 00 
  81f487:	48 8b 00             	mov    (%rax),%rax
  81f48a:	48 85 c0             	test   %rax,%rax
  81f48d:	74 29                	je     81f4b8 <tcp_receive+0x1357>
              pbuf_cat(recv_data, cseg->p);
  81f48f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f493:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81f497:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81f49e:	00 00 00 
  81f4a1:	48 8b 00             	mov    (%rax),%rax
  81f4a4:	48 89 d6             	mov    %rdx,%rsi
  81f4a7:	48 89 c7             	mov    %rax,%rdi
  81f4aa:	48 b8 4b df 80 00 00 	movabs $0x80df4b,%rax
  81f4b1:	00 00 00 
  81f4b4:	ff d0                	callq  *%rax
  81f4b6:	eb 15                	jmp    81f4cd <tcp_receive+0x136c>
            } else {
              recv_data = cseg->p;
  81f4b8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f4bc:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81f4c0:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81f4c7:	00 00 00 
  81f4ca:	48 89 10             	mov    %rdx,(%rax)
            }
            cseg->p = NULL;
  81f4cd:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f4d1:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81f4d8:	00 
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
  81f4d9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f4dd:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f4e1:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f4e5:	0f b7 c0             	movzwl %ax,%eax
  81f4e8:	89 c7                	mov    %eax,%edi
  81f4ea:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  81f4f1:	00 00 00 
  81f4f4:	ff d0                	callq  *%rax
  81f4f6:	0f b7 c0             	movzwl %ax,%eax
  81f4f9:	83 e0 01             	and    $0x1,%eax
  81f4fc:	85 c0                	test   %eax,%eax
  81f4fe:	74 24                	je     81f524 <tcp_receive+0x13c3>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags = TF_GOT_FIN;
  81f500:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81f507:	00 00 00 
  81f50a:	c6 00 20             	movb   $0x20,(%rax)
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
  81f50d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f511:	8b 40 18             	mov    0x18(%rax),%eax
  81f514:	83 f8 04             	cmp    $0x4,%eax
  81f517:	75 0b                	jne    81f524 <tcp_receive+0x13c3>
              pcb->state = CLOSE_WAIT;
  81f519:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f51d:	c7 40 18 07 00 00 00 	movl   $0x7,0x18(%rax)
            } 
          }


          pcb->ooseq = cseg->next;
  81f524:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f528:	48 8b 10             	mov    (%rax),%rdx
  81f52b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f52f:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
          tcp_seg_free(cseg);
  81f536:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f53a:	48 89 c7             	mov    %rax,%rdi
  81f53d:	48 b8 7c 04 81 00 00 	movabs $0x81047c,%rax
  81f544:	00 00 00 
  81f547:	ff d0                	callq  *%rax
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  81f549:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f54d:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f554:	48 85 c0             	test   %rax,%rax
  81f557:	74 21                	je     81f57a <tcp_receive+0x1419>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
  81f559:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f55d:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f564:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f568:	8b 50 04             	mov    0x4(%rax),%edx
  81f56b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f56f:	8b 40 30             	mov    0x30(%rax),%eax
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  81f572:	39 c2                	cmp    %eax,%edx
  81f574:	0f 84 4f fc ff ff    	je     81f1c9 <tcp_receive+0x1068>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  81f57a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f57e:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f582:	0f b6 c0             	movzbl %al,%eax
  81f585:	83 e0 01             	and    $0x1,%eax
  81f588:	85 c0                	test   %eax,%eax
  81f58a:	74 40                	je     81f5cc <tcp_receive+0x146b>
  81f58c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f590:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f594:	83 e0 fe             	and    $0xfffffffe,%eax
  81f597:	89 c2                	mov    %eax,%edx
  81f599:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f59d:	88 50 2c             	mov    %dl,0x2c(%rax)
  81f5a0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f5a4:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f5a8:	83 c8 02             	or     $0x2,%eax
  81f5ab:	89 c2                	mov    %eax,%edx
  81f5ad:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f5b1:	88 50 2c             	mov    %dl,0x2c(%rax)
  81f5b4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f5b8:	48 89 c7             	mov    %rax,%rdi
  81f5bb:	48 b8 3d 3c 81 00 00 	movabs $0x813c3d,%rax
  81f5c2:	00 00 00 
  81f5c5:	ff d0                	callq  *%rax
  81f5c7:	e9 54 05 00 00       	jmpq   81fb20 <tcp_receive+0x19bf>
  81f5cc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f5d0:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f5d4:	83 c8 01             	or     $0x1,%eax
  81f5d7:	89 c2                	mov    %eax,%edx
  81f5d9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f5dd:	88 50 2c             	mov    %dl,0x2c(%rax)
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  81f5e0:	e9 66 05 00 00       	jmpq   81fb4b <tcp_receive+0x19ea>
        /* Acknowledge the segment(s). */
        tcp_ack(pcb);

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_ack_now(pcb);
  81f5e5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f5e9:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f5ed:	83 c8 02             	or     $0x2,%eax
  81f5f0:	89 c2                	mov    %eax,%edx
  81f5f2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f5f6:	88 50 2c             	mov    %dl,0x2c(%rax)
  81f5f9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f5fd:	48 89 c7             	mov    %rax,%rdi
  81f600:	48 b8 3d 3c 81 00 00 	movabs $0x813c3d,%rax
  81f607:	00 00 00 
  81f60a:	ff d0                	callq  *%rax
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
  81f60c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f610:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f617:	48 85 c0             	test   %rax,%rax
  81f61a:	75 26                	jne    81f642 <tcp_receive+0x14e1>
          pcb->ooseq = tcp_seg_copy(&inseg);
  81f61c:	48 bf a0 74 b5 00 00 	movabs $0xb574a0,%rdi
  81f623:	00 00 00 
  81f626:	48 b8 f6 04 81 00 00 	movabs $0x8104f6,%rax
  81f62d:	00 00 00 
  81f630:	ff d0                	callq  *%rax
  81f632:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  81f636:	48 89 82 90 00 00 00 	mov    %rax,0x90(%rdx)
  81f63d:	e9 de 04 00 00       	jmpq   81fb20 <tcp_receive+0x19bf>

             If the incoming segment has the same sequence number as a
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
  81f642:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  81f649:	00 
          for(next = pcb->ooseq; next != NULL; next = next->next) {
  81f64a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f64e:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f655:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  81f659:	e9 b7 04 00 00       	jmpq   81fb15 <tcp_receive+0x19b4>
            if (seqno == next->tcphdr->seqno) {
  81f65e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f662:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f666:	8b 50 04             	mov    0x4(%rax),%edx
  81f669:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f670:	00 00 00 
  81f673:	8b 00                	mov    (%rax),%eax
  81f675:	39 c2                	cmp    %eax,%edx
  81f677:	0f 85 25 01 00 00    	jne    81f7a2 <tcp_receive+0x1641>
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
  81f67d:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f684:	00 00 00 
  81f687:	0f b7 50 18          	movzwl 0x18(%rax),%edx
  81f68b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f68f:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f693:	66 39 c2             	cmp    %ax,%dx
  81f696:	0f 86 01 01 00 00    	jbe    81f79d <tcp_receive+0x163c>
                /* The incoming segment is larger than the old
                   segment. We replace the old segment with the new
                   one. */
                cseg = tcp_seg_copy(&inseg);
  81f69c:	48 bf a0 74 b5 00 00 	movabs $0xb574a0,%rdi
  81f6a3:	00 00 00 
  81f6a6:	48 b8 f6 04 81 00 00 	movabs $0x8104f6,%rax
  81f6ad:	00 00 00 
  81f6b0:	ff d0                	callq  *%rax
  81f6b2:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
                if (cseg != NULL) {
  81f6b6:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  81f6bb:	0f 84 d7 00 00 00    	je     81f798 <tcp_receive+0x1637>
                  cseg->next = next->next;
  81f6c1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f6c5:	48 8b 10             	mov    (%rax),%rdx
  81f6c8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f6cc:	48 89 10             	mov    %rdx,(%rax)
                  if (prev != NULL) {
  81f6cf:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  81f6d4:	74 0d                	je     81f6e3 <tcp_receive+0x1582>
                    prev->next = cseg;
  81f6d6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f6da:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  81f6de:	48 89 10             	mov    %rdx,(%rax)
  81f6e1:	eb 0f                	jmp    81f6f2 <tcp_receive+0x1591>
                  } else {
                    pcb->ooseq = cseg;
  81f6e3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f6e7:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  81f6eb:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
                  }
                  tcp_seg_free(next);
  81f6f2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f6f6:	48 89 c7             	mov    %rax,%rdi
  81f6f9:	48 b8 7c 04 81 00 00 	movabs $0x81047c,%rax
  81f700:	00 00 00 
  81f703:	ff d0                	callq  *%rax
                  if (cseg->next != NULL) {
  81f705:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f709:	48 8b 00             	mov    (%rax),%rax
  81f70c:	48 85 c0             	test   %rax,%rax
  81f70f:	0f 84 83 00 00 00    	je     81f798 <tcp_receive+0x1637>
                    next = cseg->next;
  81f715:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f719:	48 8b 00             	mov    (%rax),%rax
  81f71c:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  81f720:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f724:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f728:	0f b7 d0             	movzwl %ax,%edx
  81f72b:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f732:	00 00 00 
  81f735:	8b 00                	mov    (%rax),%eax
  81f737:	01 c2                	add    %eax,%edx
  81f739:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f73d:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f741:	8b 40 04             	mov    0x4(%rax),%eax
  81f744:	29 c2                	sub    %eax,%edx
  81f746:	89 d0                	mov    %edx,%eax
  81f748:	85 c0                	test   %eax,%eax
  81f74a:	7e 4c                	jle    81f798 <tcp_receive+0x1637>
                      /* We need to trim the incoming segment. */
                      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
  81f74c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f750:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f754:	8b 40 04             	mov    0x4(%rax),%eax
  81f757:	89 c2                	mov    %eax,%edx
  81f759:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f760:	00 00 00 
  81f763:	8b 00                	mov    (%rax),%eax
  81f765:	29 c2                	sub    %eax,%edx
  81f767:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f76b:	66 89 50 18          	mov    %dx,0x18(%rax)
                      pbuf_realloc(cseg->p, cseg->len);
  81f76f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f773:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f777:	0f b7 d0             	movzwl %ax,%edx
  81f77a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f77e:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f782:	89 d6                	mov    %edx,%esi
  81f784:	48 89 c7             	mov    %rax,%rdi
  81f787:	48 b8 36 d9 80 00 00 	movabs $0x80d936,%rax
  81f78e:	00 00 00 
  81f791:	ff d0                	callq  *%rax
                    }
                  }
                }
                break;
  81f793:	e9 88 03 00 00       	jmpq   81fb20 <tcp_receive+0x19bf>
  81f798:	e9 83 03 00 00       	jmpq   81fb20 <tcp_receive+0x19bf>
              } else {
                /* Either the lenghts are the same or the incoming
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
  81f79d:	e9 7e 03 00 00       	jmpq   81fb20 <tcp_receive+0x19bf>
              }
            } else {
              if (prev == NULL) {
  81f7a2:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  81f7a7:	0f 85 f3 00 00 00    	jne    81f8a0 <tcp_receive+0x173f>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
  81f7ad:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f7b4:	00 00 00 
  81f7b7:	8b 10                	mov    (%rax),%edx
  81f7b9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f7bd:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f7c1:	8b 40 04             	mov    0x4(%rax),%eax
  81f7c4:	29 c2                	sub    %eax,%edx
  81f7c6:	89 d0                	mov    %edx,%eax
  81f7c8:	85 c0                	test   %eax,%eax
  81f7ca:	0f 89 5f 02 00 00    	jns    81fa2f <tcp_receive+0x18ce>
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */

                  if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  81f7d0:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f7d7:	00 00 00 
  81f7da:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f7de:	0f b7 d0             	movzwl %ax,%edx
  81f7e1:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f7e8:	00 00 00 
  81f7eb:	8b 00                	mov    (%rax),%eax
  81f7ed:	01 c2                	add    %eax,%edx
  81f7ef:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f7f3:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f7f7:	8b 40 04             	mov    0x4(%rax),%eax
  81f7fa:	29 c2                	sub    %eax,%edx
  81f7fc:	89 d0                	mov    %edx,%eax
  81f7fe:	85 c0                	test   %eax,%eax
  81f800:	7e 59                	jle    81f85b <tcp_receive+0x16fa>
                    /* We need to trim the incoming segment. */
                    inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  81f802:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f806:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f80a:	8b 40 04             	mov    0x4(%rax),%eax
  81f80d:	89 c2                	mov    %eax,%edx
  81f80f:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f816:	00 00 00 
  81f819:	8b 00                	mov    (%rax),%eax
  81f81b:	29 c2                	sub    %eax,%edx
  81f81d:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f824:	00 00 00 
  81f827:	66 89 50 18          	mov    %dx,0x18(%rax)
                    pbuf_realloc(inseg.p, inseg.len);
  81f82b:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f832:	00 00 00 
  81f835:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f839:	0f b7 d0             	movzwl %ax,%edx
  81f83c:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f843:	00 00 00 
  81f846:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f84a:	89 d6                	mov    %edx,%esi
  81f84c:	48 89 c7             	mov    %rax,%rdi
  81f84f:	48 b8 36 d9 80 00 00 	movabs $0x80d936,%rax
  81f856:	00 00 00 
  81f859:	ff d0                	callq  *%rax
                  }
                  cseg = tcp_seg_copy(&inseg);
  81f85b:	48 bf a0 74 b5 00 00 	movabs $0xb574a0,%rdi
  81f862:	00 00 00 
  81f865:	48 b8 f6 04 81 00 00 	movabs $0x8104f6,%rax
  81f86c:	00 00 00 
  81f86f:	ff d0                	callq  *%rax
  81f871:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
                  if (cseg != NULL) {
  81f875:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  81f87a:	74 1f                	je     81f89b <tcp_receive+0x173a>
                    cseg->next = next;
  81f87c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f880:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81f884:	48 89 10             	mov    %rdx,(%rax)
                    pcb->ooseq = cseg;
  81f887:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f88b:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  81f88f:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
                  }
                  break;
  81f896:	e9 85 02 00 00       	jmpq   81fb20 <tcp_receive+0x19bf>
  81f89b:	e9 80 02 00 00       	jmpq   81fb20 <tcp_receive+0x19bf>
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  81f8a0:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f8a7:	00 00 00 
  81f8aa:	8b 10                	mov    (%rax),%edx
  81f8ac:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f8b0:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f8b4:	8b 40 04             	mov    0x4(%rax),%eax
  81f8b7:	29 c2                	sub    %eax,%edx
  81f8b9:	89 d0                	mov    %edx,%eax
  81f8bb:	83 e8 01             	sub    $0x1,%eax
  81f8be:	85 c0                	test   %eax,%eax
  81f8c0:	0f 88 69 01 00 00    	js     81fa2f <tcp_receive+0x18ce>
  81f8c6:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f8cd:	00 00 00 
  81f8d0:	8b 10                	mov    (%rax),%edx
  81f8d2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f8d6:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f8da:	8b 40 04             	mov    0x4(%rax),%eax
  81f8dd:	29 c2                	sub    %eax,%edx
  81f8df:	89 d0                	mov    %edx,%eax
  81f8e1:	83 c0 01             	add    $0x1,%eax
  81f8e4:	85 c0                	test   %eax,%eax
  81f8e6:	0f 8f 43 01 00 00    	jg     81fa2f <tcp_receive+0x18ce>
                /* The sequence number of the incoming segment is in
                   between the sequence numbers of the previous and
                   the next segment on ->ooseq. We trim and insert the
                   incoming segment and trim the previous segment, if
                   needed. */
                if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  81f8ec:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f8f3:	00 00 00 
  81f8f6:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f8fa:	0f b7 d0             	movzwl %ax,%edx
  81f8fd:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f904:	00 00 00 
  81f907:	8b 00                	mov    (%rax),%eax
  81f909:	01 c2                	add    %eax,%edx
  81f90b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f90f:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f913:	8b 40 04             	mov    0x4(%rax),%eax
  81f916:	29 c2                	sub    %eax,%edx
  81f918:	89 d0                	mov    %edx,%eax
  81f91a:	85 c0                	test   %eax,%eax
  81f91c:	7e 59                	jle    81f977 <tcp_receive+0x1816>
                  /* We need to trim the incoming segment. */
                  inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  81f91e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f922:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f926:	8b 40 04             	mov    0x4(%rax),%eax
  81f929:	89 c2                	mov    %eax,%edx
  81f92b:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f932:	00 00 00 
  81f935:	8b 00                	mov    (%rax),%eax
  81f937:	29 c2                	sub    %eax,%edx
  81f939:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f940:	00 00 00 
  81f943:	66 89 50 18          	mov    %dx,0x18(%rax)
                  pbuf_realloc(inseg.p, inseg.len);
  81f947:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f94e:	00 00 00 
  81f951:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f955:	0f b7 d0             	movzwl %ax,%edx
  81f958:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f95f:	00 00 00 
  81f962:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f966:	89 d6                	mov    %edx,%esi
  81f968:	48 89 c7             	mov    %rax,%rdi
  81f96b:	48 b8 36 d9 80 00 00 	movabs $0x80d936,%rax
  81f972:	00 00 00 
  81f975:	ff d0                	callq  *%rax
                }

                cseg = tcp_seg_copy(&inseg);
  81f977:	48 bf a0 74 b5 00 00 	movabs $0xb574a0,%rdi
  81f97e:	00 00 00 
  81f981:	48 b8 f6 04 81 00 00 	movabs $0x8104f6,%rax
  81f988:	00 00 00 
  81f98b:	ff d0                	callq  *%rax
  81f98d:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
                if (cseg != NULL) {
  81f991:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  81f996:	0f 84 8e 00 00 00    	je     81fa2a <tcp_receive+0x18c9>
                  cseg->next = next;
  81f99c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f9a0:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81f9a4:	48 89 10             	mov    %rdx,(%rax)
                  prev->next = cseg;
  81f9a7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f9ab:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  81f9af:	48 89 10             	mov    %rdx,(%rax)
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  81f9b2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f9b6:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f9ba:	8b 50 04             	mov    0x4(%rax),%edx
  81f9bd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f9c1:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f9c5:	0f b7 c0             	movzwl %ax,%eax
  81f9c8:	01 c2                	add    %eax,%edx
  81f9ca:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f9d1:	00 00 00 
  81f9d4:	8b 00                	mov    (%rax),%eax
  81f9d6:	29 c2                	sub    %eax,%edx
  81f9d8:	89 d0                	mov    %edx,%eax
  81f9da:	85 c0                	test   %eax,%eax
  81f9dc:	7e 4c                	jle    81fa2a <tcp_receive+0x18c9>
                    /* We need to trim the prev segment. */
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
  81f9de:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f9e5:	00 00 00 
  81f9e8:	8b 00                	mov    (%rax),%eax
  81f9ea:	89 c2                	mov    %eax,%edx
  81f9ec:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f9f0:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f9f4:	8b 40 04             	mov    0x4(%rax),%eax
  81f9f7:	29 c2                	sub    %eax,%edx
  81f9f9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f9fd:	66 89 50 18          	mov    %dx,0x18(%rax)
                    pbuf_realloc(prev->p, prev->len);
  81fa01:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81fa05:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81fa09:	0f b7 d0             	movzwl %ax,%edx
  81fa0c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81fa10:	48 8b 40 08          	mov    0x8(%rax),%rax
  81fa14:	89 d6                	mov    %edx,%esi
  81fa16:	48 89 c7             	mov    %rax,%rdi
  81fa19:	48 b8 36 d9 80 00 00 	movabs $0x80d936,%rax
  81fa20:	00 00 00 
  81fa23:	ff d0                	callq  *%rax
                  }
                }
                break;
  81fa25:	e9 f6 00 00 00       	jmpq   81fb20 <tcp_receive+0x19bf>
  81fa2a:	e9 f1 00 00 00       	jmpq   81fb20 <tcp_receive+0x19bf>
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  81fa2f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fa33:	48 8b 00             	mov    (%rax),%rax
  81fa36:	48 85 c0             	test   %rax,%rax
  81fa39:	0f 85 c3 00 00 00    	jne    81fb02 <tcp_receive+0x19a1>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
  81fa3f:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81fa46:	00 00 00 
  81fa49:	8b 10                	mov    (%rax),%edx
  81fa4b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fa4f:	48 8b 40 20          	mov    0x20(%rax),%rax
  81fa53:	8b 40 04             	mov    0x4(%rax),%eax
  81fa56:	29 c2                	sub    %eax,%edx
  81fa58:	89 d0                	mov    %edx,%eax
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  81fa5a:	85 c0                	test   %eax,%eax
  81fa5c:	0f 8e a0 00 00 00    	jle    81fb02 <tcp_receive+0x19a1>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                next->next = tcp_seg_copy(&inseg);
  81fa62:	48 bf a0 74 b5 00 00 	movabs $0xb574a0,%rdi
  81fa69:	00 00 00 
  81fa6c:	48 b8 f6 04 81 00 00 	movabs $0x8104f6,%rax
  81fa73:	00 00 00 
  81fa76:	ff d0                	callq  *%rax
  81fa78:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81fa7c:	48 89 02             	mov    %rax,(%rdx)
                if (next->next != NULL) {
  81fa7f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fa83:	48 8b 00             	mov    (%rax),%rax
  81fa86:	48 85 c0             	test   %rax,%rax
  81fa89:	74 75                	je     81fb00 <tcp_receive+0x199f>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  81fa8b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fa8f:	48 8b 40 20          	mov    0x20(%rax),%rax
  81fa93:	8b 50 04             	mov    0x4(%rax),%edx
  81fa96:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fa9a:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81fa9e:	0f b7 c0             	movzwl %ax,%eax
  81faa1:	01 c2                	add    %eax,%edx
  81faa3:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81faaa:	00 00 00 
  81faad:	8b 00                	mov    (%rax),%eax
  81faaf:	29 c2                	sub    %eax,%edx
  81fab1:	89 d0                	mov    %edx,%eax
  81fab3:	85 c0                	test   %eax,%eax
  81fab5:	7e 49                	jle    81fb00 <tcp_receive+0x199f>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
  81fab7:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81fabe:	00 00 00 
  81fac1:	8b 00                	mov    (%rax),%eax
  81fac3:	89 c2                	mov    %eax,%edx
  81fac5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fac9:	48 8b 40 20          	mov    0x20(%rax),%rax
  81facd:	8b 40 04             	mov    0x4(%rax),%eax
  81fad0:	29 c2                	sub    %eax,%edx
  81fad2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fad6:	66 89 50 18          	mov    %dx,0x18(%rax)
                    pbuf_realloc(next->p, next->len);
  81fada:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fade:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81fae2:	0f b7 d0             	movzwl %ax,%edx
  81fae5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fae9:	48 8b 40 08          	mov    0x8(%rax),%rax
  81faed:	89 d6                	mov    %edx,%esi
  81faef:	48 89 c7             	mov    %rax,%rdi
  81faf2:	48 b8 36 d9 80 00 00 	movabs $0x80d936,%rax
  81faf9:	00 00 00 
  81fafc:	ff d0                	callq  *%rax
                  }
                }
                break;
  81fafe:	eb 20                	jmp    81fb20 <tcp_receive+0x19bf>
  81fb00:	eb 1e                	jmp    81fb20 <tcp_receive+0x19bf>
              }
            }
            prev = next;
  81fb02:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fb06:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
             If the incoming segment has the same sequence number as a
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
  81fb0a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fb0e:	48 8b 00             	mov    (%rax),%rax
  81fb11:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  81fb15:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  81fb1a:	0f 85 3e fb ff ff    	jne    81f65e <tcp_receive+0x14fd>
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  81fb20:	eb 29                	jmp    81fb4b <tcp_receive+0x19ea>
        }
#endif /* TCP_QUEUE_OOSEQ */

      }
    } else {
      tcp_ack_now(pcb);
  81fb22:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81fb26:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81fb2a:	83 c8 02             	or     $0x2,%eax
  81fb2d:	89 c2                	mov    %eax,%edx
  81fb2f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81fb33:	88 50 2c             	mov    %dl,0x2c(%rax)
  81fb36:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81fb3a:	48 89 c7             	mov    %rax,%rdi
  81fb3d:	48 b8 3d 3c 81 00 00 	movabs $0x813c3d,%rax
  81fb44:	00 00 00 
  81fb47:	ff d0                	callq  *%rax
  81fb49:	eb 6f                	jmp    81fbba <tcp_receive+0x1a59>
  81fb4b:	eb 6d                	jmp    81fbba <tcp_receive+0x1a59>
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  81fb4d:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81fb54:	00 00 00 
  81fb57:	8b 10                	mov    (%rax),%edx
  81fb59:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81fb5d:	8b 40 30             	mov    0x30(%rax),%eax
  81fb60:	29 c2                	sub    %eax,%edx
  81fb62:	89 d0                	mov    %edx,%eax
  81fb64:	85 c0                	test   %eax,%eax
  81fb66:	78 2b                	js     81fb93 <tcp_receive+0x1a32>
  81fb68:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81fb6f:	00 00 00 
  81fb72:	8b 10                	mov    (%rax),%edx
  81fb74:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81fb78:	8b 48 30             	mov    0x30(%rax),%ecx
  81fb7b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81fb7f:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  81fb83:	0f b7 c0             	movzwl %ax,%eax
  81fb86:	01 c8                	add    %ecx,%eax
  81fb88:	29 c2                	sub    %eax,%edx
  81fb8a:	89 d0                	mov    %edx,%eax
  81fb8c:	83 c0 01             	add    $0x1,%eax
  81fb8f:	85 c0                	test   %eax,%eax
  81fb91:	7e 27                	jle    81fbba <tcp_receive+0x1a59>
      tcp_ack_now(pcb);
  81fb93:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81fb97:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81fb9b:	83 c8 02             	or     $0x2,%eax
  81fb9e:	89 c2                	mov    %eax,%edx
  81fba0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81fba4:	88 50 2c             	mov    %dl,0x2c(%rax)
  81fba7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81fbab:	48 89 c7             	mov    %rax,%rdi
  81fbae:	48 b8 3d 3c 81 00 00 	movabs $0x813c3d,%rax
  81fbb5:	00 00 00 
  81fbb8:	ff d0                	callq  *%rax
    }
  }
  return accepted_inseq;
  81fbba:	0f b6 45 c1          	movzbl -0x3f(%rbp),%eax
}
  81fbbe:	48 83 c4 58          	add    $0x58,%rsp
  81fbc2:	5b                   	pop    %rbx
  81fbc3:	41 5c                	pop    %r12
  81fbc5:	41 5d                	pop    %r13
  81fbc7:	5d                   	pop    %rbp
  81fbc8:	c3                   	retq   

000000000081fbc9 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
  81fbc9:	55                   	push   %rbp
  81fbca:	48 89 e5             	mov    %rsp,%rbp
  81fbcd:	53                   	push   %rbx
  81fbce:	48 83 ec 38          	sub    $0x38,%rsp
  81fbd2:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  81fbd6:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81fbdd:	00 00 00 
  81fbe0:	48 8b 00             	mov    (%rax),%rax
  81fbe3:	48 83 c0 14          	add    $0x14,%rax
  81fbe7:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  81fbeb:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81fbf2:	00 00 00 
  81fbf5:	48 8b 00             	mov    (%rax),%rax
  81fbf8:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81fbfc:	0f b7 c0             	movzwl %ax,%eax
  81fbff:	89 c7                	mov    %eax,%edi
  81fc01:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  81fc08:	00 00 00 
  81fc0b:	ff d0                	callq  *%rax
  81fc0d:	66 c1 e8 0c          	shr    $0xc,%ax
  81fc11:	66 83 f8 05          	cmp    $0x5,%ax
  81fc15:	0f 86 11 01 00 00    	jbe    81fd2c <tcp_parseopt+0x163>
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  81fc1b:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  81fc1f:	e9 cd 00 00 00       	jmpq   81fcf1 <tcp_parseopt+0x128>
      opt = opts[c];
  81fc24:	0f b6 55 ef          	movzbl -0x11(%rbp),%edx
  81fc28:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81fc2c:	48 01 d0             	add    %rdx,%rax
  81fc2f:	0f b6 00             	movzbl (%rax),%eax
  81fc32:	88 45 df             	mov    %al,-0x21(%rbp)
      if (opt == 0x00) {
  81fc35:	80 7d df 00          	cmpb   $0x0,-0x21(%rbp)
  81fc39:	75 05                	jne    81fc40 <tcp_parseopt+0x77>
        /* End of options. */
        break;
  81fc3b:	e9 ec 00 00 00       	jmpq   81fd2c <tcp_parseopt+0x163>
      } else if (opt == 0x01) {
  81fc40:	80 7d df 01          	cmpb   $0x1,-0x21(%rbp)
  81fc44:	75 09                	jne    81fc4f <tcp_parseopt+0x86>
        ++c;
  81fc46:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
  81fc4a:	e9 a2 00 00 00       	jmpq   81fcf1 <tcp_parseopt+0x128>
        /* NOP option. */
      } else if (opt == 0x02 &&
  81fc4f:	80 7d df 02          	cmpb   $0x2,-0x21(%rbp)
  81fc53:	75 6f                	jne    81fcc4 <tcp_parseopt+0xfb>
        opts[c + 1] == 0x04) {
  81fc55:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81fc59:	48 8d 50 01          	lea    0x1(%rax),%rdx
  81fc5d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81fc61:	48 01 d0             	add    %rdx,%rax
  81fc64:	0f b6 00             	movzbl (%rax),%eax
        /* End of options. */
        break;
      } else if (opt == 0x01) {
        ++c;
        /* NOP option. */
      } else if (opt == 0x02 &&
  81fc67:	3c 04                	cmp    $0x4,%al
  81fc69:	75 59                	jne    81fcc4 <tcp_parseopt+0xfb>
        opts[c + 1] == 0x04) {
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
  81fc6b:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81fc6f:	48 8d 50 02          	lea    0x2(%rax),%rdx
  81fc73:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81fc77:	48 01 d0             	add    %rdx,%rax
  81fc7a:	0f b6 00             	movzbl (%rax),%eax
  81fc7d:	0f b6 c0             	movzbl %al,%eax
  81fc80:	c1 e0 08             	shl    $0x8,%eax
  81fc83:	89 c2                	mov    %eax,%edx
  81fc85:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81fc89:	48 8d 48 03          	lea    0x3(%rax),%rcx
  81fc8d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81fc91:	48 01 c8             	add    %rcx,%rax
  81fc94:	0f b6 00             	movzbl (%rax),%eax
  81fc97:	0f b6 c0             	movzbl %al,%eax
  81fc9a:	09 d0                	or     %edx,%eax
  81fc9c:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
  81fca0:	66 81 7d dc b4 05    	cmpw   $0x5b4,-0x24(%rbp)
  81fca6:	77 0d                	ja     81fcb5 <tcp_parseopt+0xec>
  81fca8:	66 83 7d dc 00       	cmpw   $0x0,-0x24(%rbp)
  81fcad:	74 06                	je     81fcb5 <tcp_parseopt+0xec>
  81fcaf:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  81fcb3:	eb 05                	jmp    81fcba <tcp_parseopt+0xf1>
  81fcb5:	b8 b4 05 00 00       	mov    $0x5b4,%eax
  81fcba:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81fcbe:	66 89 42 40          	mov    %ax,0x40(%rdx)

        /* And we are done processing options. */
        break;
  81fcc2:	eb 68                	jmp    81fd2c <tcp_parseopt+0x163>
      } else {
        if (opts[c + 1] == 0) {
  81fcc4:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81fcc8:	48 8d 50 01          	lea    0x1(%rax),%rdx
  81fccc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81fcd0:	48 01 d0             	add    %rdx,%rax
  81fcd3:	0f b6 00             	movzbl (%rax),%eax
  81fcd6:	84 c0                	test   %al,%al
  81fcd8:	75 02                	jne    81fcdc <tcp_parseopt+0x113>
          /* If the length field is zero, the options are malformed
             and we don't process them further. */
          break;
  81fcda:	eb 50                	jmp    81fd2c <tcp_parseopt+0x163>
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
  81fcdc:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81fce0:	48 8d 50 01          	lea    0x1(%rax),%rdx
  81fce4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81fce8:	48 01 d0             	add    %rdx,%rax
  81fceb:	0f b6 00             	movzbl (%rax),%eax
  81fcee:	00 45 ef             	add    %al,-0x11(%rbp)

  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  81fcf1:	0f b6 5d ef          	movzbl -0x11(%rbp),%ebx
  81fcf5:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81fcfc:	00 00 00 
  81fcff:	48 8b 00             	mov    (%rax),%rax
  81fd02:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81fd06:	0f b7 c0             	movzwl %ax,%eax
  81fd09:	89 c7                	mov    %eax,%edi
  81fd0b:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  81fd12:	00 00 00 
  81fd15:	ff d0                	callq  *%rax
  81fd17:	66 c1 e8 0c          	shr    $0xc,%ax
  81fd1b:	0f b7 c0             	movzwl %ax,%eax
  81fd1e:	83 e8 05             	sub    $0x5,%eax
  81fd21:	c1 e0 02             	shl    $0x2,%eax
  81fd24:	39 c3                	cmp    %eax,%ebx
  81fd26:	0f 8c f8 fe ff ff    	jl     81fc24 <tcp_parseopt+0x5b>
           can skip past them. */
        c += opts[c + 1];
      }
    }
  }
}
  81fd2c:	48 83 c4 38          	add    $0x38,%rsp
  81fd30:	5b                   	pop    %rbx
  81fd31:	5d                   	pop    %rbp
  81fd32:	c3                   	retq   

000000000081fd33 <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
  81fd33:	55                   	push   %rbp
  81fd34:	48 89 e5             	mov    %rsp,%rbp
  81fd37:	48 83 ec 40          	sub    $0x40,%rsp
  81fd3b:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  81fd3f:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  struct raw_pcb *pcb, *prev;
  struct ip_hdr *iphdr;
  s16_t proto;
  u8_t eaten = 0;
  81fd43:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  81fd47:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81fd4b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81fd4f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  proto = IPH_PROTO(iphdr);
  81fd53:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81fd57:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  81fd5b:	0f b7 c0             	movzwl %ax,%eax
  81fd5e:	89 c7                	mov    %eax,%edi
  81fd60:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  81fd67:	00 00 00 
  81fd6a:	ff d0                	callq  *%rax
  81fd6c:	66 25 ff 00          	and    $0xff,%ax
  81fd70:	66 89 45 de          	mov    %ax,-0x22(%rbp)

  prev = NULL;
  81fd74:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  81fd7b:	00 
  pcb = raw_pcbs;
  81fd7c:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  81fd83:	00 00 00 
  81fd86:	48 8b 00             	mov    (%rax),%rax
  81fd89:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  81fd8d:	e9 a3 00 00 00       	jmpq   81fe35 <raw_input+0x102>
    if (pcb->protocol == proto) {
  81fd92:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fd96:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81fd9a:	0f b6 d0             	movzbl %al,%edx
  81fd9d:	0f bf 45 de          	movswl -0x22(%rbp),%eax
  81fda1:	39 c2                	cmp    %eax,%edx
  81fda3:	75 7c                	jne    81fe21 <raw_input+0xee>
      /* receive callback function available? */
      if (pcb->recv != NULL) {
  81fda5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fda9:	48 8b 40 20          	mov    0x20(%rax),%rax
  81fdad:	48 85 c0             	test   %rax,%rax
  81fdb0:	74 6f                	je     81fe21 <raw_input+0xee>
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  81fdb2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fdb6:	48 8b 40 20          	mov    0x20(%rax),%rax
  81fdba:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81fdbe:	48 8d 4a 0c          	lea    0xc(%rdx),%rcx
  81fdc2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81fdc6:	48 8b 7a 28          	mov    0x28(%rdx),%rdi
  81fdca:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81fdce:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  81fdd2:	ff d0                	callq  *%rax
  81fdd4:	84 c0                	test   %al,%al
  81fdd6:	74 49                	je     81fe21 <raw_input+0xee>
        {
          /* receive function ate the packet */
          p = NULL;
  81fdd8:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  81fddf:	00 
          eaten = 1;
  81fde0:	c6 45 ef 01          	movb   $0x1,-0x11(%rbp)
          if (prev != NULL) {
  81fde4:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81fde9:	74 36                	je     81fe21 <raw_input+0xee>
          /* move the pcb to the front of raw_pcbs so that is
             found faster next time */
            prev->next = pcb->next;
  81fdeb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fdef:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81fdf3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81fdf7:	48 89 50 10          	mov    %rdx,0x10(%rax)
            pcb->next = raw_pcbs;
  81fdfb:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  81fe02:	00 00 00 
  81fe05:	48 8b 10             	mov    (%rax),%rdx
  81fe08:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fe0c:	48 89 50 10          	mov    %rdx,0x10(%rax)
            raw_pcbs = pcb;
  81fe10:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  81fe17:	00 00 00 
  81fe1a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81fe1e:	48 89 10             	mov    %rdx,(%rax)
        }
      }
      /* no receive callback function was set for this raw PCB */
      /* drop the packet */
    }
    prev = pcb;
  81fe21:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fe25:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    pcb = pcb->next;
  81fe29:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fe2d:	48 8b 40 10          	mov    0x10(%rax),%rax
  81fe31:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  81fe35:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  81fe39:	75 0b                	jne    81fe46 <raw_input+0x113>
  81fe3b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81fe40:	0f 85 4c ff ff ff    	jne    81fd92 <raw_input+0x5f>
      /* drop the packet */
    }
    prev = pcb;
    pcb = pcb->next;
  }
  return eaten;
  81fe46:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
}
  81fe4a:	c9                   	leaveq 
  81fe4b:	c3                   	retq   

000000000081fe4c <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  81fe4c:	55                   	push   %rbp
  81fe4d:	48 89 e5             	mov    %rsp,%rbp
  81fe50:	48 83 ec 10          	sub    $0x10,%rsp
  81fe54:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81fe58:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  ip_addr_set(&pcb->local_ip, ipaddr);
  81fe5c:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81fe61:	74 08                	je     81fe6b <raw_bind+0x1f>
  81fe63:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81fe67:	8b 00                	mov    (%rax),%eax
  81fe69:	eb 05                	jmp    81fe70 <raw_bind+0x24>
  81fe6b:	b8 00 00 00 00       	mov    $0x0,%eax
  81fe70:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81fe74:	89 02                	mov    %eax,(%rdx)
  return ERR_OK;
  81fe76:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81fe7b:	c9                   	leaveq 
  81fe7c:	c3                   	retq   

000000000081fe7d <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  81fe7d:	55                   	push   %rbp
  81fe7e:	48 89 e5             	mov    %rsp,%rbp
  81fe81:	48 83 ec 10          	sub    $0x10,%rsp
  81fe85:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81fe89:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  ip_addr_set(&pcb->remote_ip, ipaddr);
  81fe8d:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81fe92:	74 08                	je     81fe9c <raw_connect+0x1f>
  81fe94:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81fe98:	8b 00                	mov    (%rax),%eax
  81fe9a:	eb 05                	jmp    81fea1 <raw_connect+0x24>
  81fe9c:	b8 00 00 00 00       	mov    $0x0,%eax
  81fea1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81fea5:	89 42 04             	mov    %eax,0x4(%rdx)
  return ERR_OK;
  81fea8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81fead:	c9                   	leaveq 
  81feae:	c3                   	retq   

000000000081feaf <raw_recv>:
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
  81feaf:	55                   	push   %rbp
  81feb0:	48 89 e5             	mov    %rsp,%rbp
  81feb3:	48 83 ec 18          	sub    $0x18,%rsp
  81feb7:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81febb:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  81febf:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  /* remember recv() callback and user data */
  pcb->recv = recv;
  81fec3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fec7:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81fecb:	48 89 50 20          	mov    %rdx,0x20(%rax)
  pcb->recv_arg = recv_arg;
  81fecf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fed3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81fed7:	48 89 50 28          	mov    %rdx,0x28(%rax)
}
  81fedb:	c9                   	leaveq 
  81fedc:	c3                   	retq   

000000000081fedd <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
  81fedd:	55                   	push   %rbp
  81fede:	48 89 e5             	mov    %rsp,%rbp
  81fee1:	48 83 ec 40          	sub    $0x40,%rsp
  81fee5:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  81fee9:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  81feed:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
  81fef1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81fef5:	be 14 00 00 00       	mov    $0x14,%esi
  81fefa:	48 89 c7             	mov    %rax,%rdi
  81fefd:	48 b8 7f db 80 00 00 	movabs $0x80db7f,%rax
  81ff04:	00 00 00 
  81ff07:	ff d0                	callq  *%rax
  81ff09:	84 c0                	test   %al,%al
  81ff0b:	74 4c                	je     81ff59 <raw_sendto+0x7c>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
  81ff0d:	ba 00 00 00 00       	mov    $0x0,%edx
  81ff12:	be 00 00 00 00       	mov    $0x0,%esi
  81ff17:	bf 01 00 00 00       	mov    $0x1,%edi
  81ff1c:	48 b8 61 d4 80 00 00 	movabs $0x80d461,%rax
  81ff23:	00 00 00 
  81ff26:	ff d0                	callq  *%rax
  81ff28:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  81ff2c:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81ff31:	75 0a                	jne    81ff3d <raw_sendto+0x60>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
  81ff33:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81ff38:	e9 42 01 00 00       	jmpq   82007f <raw_sendto+0x1a2>
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  81ff3d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  81ff41:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81ff45:	48 89 d6             	mov    %rdx,%rsi
  81ff48:	48 89 c7             	mov    %rax,%rdi
  81ff4b:	48 b8 6a e0 80 00 00 	movabs $0x80e06a,%rax
  81ff52:	00 00 00 
  81ff55:	ff d0                	callq  *%rax
  81ff57:	eb 4e                	jmp    81ffa7 <raw_sendto+0xca>
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
  81ff59:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81ff5d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    if(pbuf_header(q, -IP_HLEN)) {
  81ff61:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81ff65:	be ec ff ff ff       	mov    $0xffffffec,%esi
  81ff6a:	48 89 c7             	mov    %rax,%rdi
  81ff6d:	48 b8 7f db 80 00 00 	movabs $0x80db7f,%rax
  81ff74:	00 00 00 
  81ff77:	ff d0                	callq  *%rax
  81ff79:	84 c0                	test   %al,%al
  81ff7b:	74 2a                	je     81ffa7 <raw_sendto+0xca>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
  81ff7d:	48 ba d8 3b 82 00 00 	movabs $0x823bd8,%rdx
  81ff84:	00 00 00 
  81ff87:	be e4 00 00 00       	mov    $0xe4,%esi
  81ff8c:	48 bf fe 3b 82 00 00 	movabs $0x823bfe,%rdi
  81ff93:	00 00 00 
  81ff96:	b8 00 00 00 00       	mov    $0x0,%eax
  81ff9b:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  81ffa2:	00 00 00 
  81ffa5:	ff d1                	callq  *%rcx
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  81ffa7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81ffab:	48 89 c7             	mov    %rax,%rdi
  81ffae:	48 b8 de 0d 81 00 00 	movabs $0x810dde,%rax
  81ffb5:	00 00 00 
  81ffb8:	ff d0                	callq  *%rax
  81ffba:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81ffbe:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81ffc3:	75 27                	jne    81ffec <raw_sendto+0x10f>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
  81ffc5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81ffc9:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  81ffcd:	74 13                	je     81ffe2 <raw_sendto+0x105>
      pbuf_free(q);
  81ffcf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81ffd3:	48 89 c7             	mov    %rax,%rdi
  81ffd6:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  81ffdd:	00 00 00 
  81ffe0:	ff d0                	callq  *%rax
    }
    return ERR_RTE;
  81ffe2:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  81ffe7:	e9 93 00 00 00       	jmpq   82007f <raw_sendto+0x1a2>
  }

  if (ip_addr_isany(&pcb->local_ip)) {
  81ffec:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fff0:	48 85 c0             	test   %rax,%rax
  81fff3:	74 0a                	je     81ffff <raw_sendto+0x122>
  81fff5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fff9:	8b 00                	mov    (%rax),%eax
  81fffb:	85 c0                	test   %eax,%eax
  81fffd:	75 0e                	jne    82000d <raw_sendto+0x130>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  81ffff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820003:	48 83 c0 08          	add    $0x8,%rax
  820007:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  82000b:	eb 08                	jmp    820015 <raw_sendto+0x138>
  } else {
    /* use RAW PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
  82000d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  820011:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  820015:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  820019:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  82001d:	44 0f b6 c8          	movzbl %al,%r9d
  820021:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  820025:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  820029:	44 0f b6 c0          	movzbl %al,%r8d
  82002d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  820031:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  820035:	0f b6 c8             	movzbl %al,%ecx
  820038:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  82003c:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  820040:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  820044:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  820048:	48 89 3c 24          	mov    %rdi,(%rsp)
  82004c:	48 89 c7             	mov    %rax,%rdi
  82004f:	48 b8 13 13 81 00 00 	movabs $0x811313,%rax
  820056:	00 00 00 
  820059:	ff d0                	callq  *%rax
  82005b:	88 45 e7             	mov    %al,-0x19(%rbp)
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
  82005e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  820062:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  820066:	74 13                	je     82007b <raw_sendto+0x19e>
    /* free the header */
    pbuf_free(q);
  820068:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  82006c:	48 89 c7             	mov    %rax,%rdi
  82006f:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  820076:	00 00 00 
  820079:	ff d0                	callq  *%rax
  }
  return err;
  82007b:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
}
  82007f:	c9                   	leaveq 
  820080:	c3                   	retq   

0000000000820081 <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  820081:	55                   	push   %rbp
  820082:	48 89 e5             	mov    %rsp,%rbp
  820085:	48 83 ec 10          	sub    $0x10,%rsp
  820089:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  82008d:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  return raw_sendto(pcb, p, &pcb->remote_ip);
  820091:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820095:	48 8d 50 04          	lea    0x4(%rax),%rdx
  820099:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  82009d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8200a1:	48 89 ce             	mov    %rcx,%rsi
  8200a4:	48 89 c7             	mov    %rax,%rdi
  8200a7:	48 b8 dd fe 81 00 00 	movabs $0x81fedd,%rax
  8200ae:	00 00 00 
  8200b1:	ff d0                	callq  *%rax
}
  8200b3:	c9                   	leaveq 
  8200b4:	c3                   	retq   

00000000008200b5 <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
  8200b5:	55                   	push   %rbp
  8200b6:	48 89 e5             	mov    %rsp,%rbp
  8200b9:	48 83 ec 20          	sub    $0x20,%rsp
  8200bd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
  8200c1:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  8200c8:	00 00 00 
  8200cb:	48 8b 00             	mov    (%rax),%rax
  8200ce:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8200d2:	75 20                	jne    8200f4 <raw_remove+0x3f>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
  8200d4:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  8200db:	00 00 00 
  8200de:	48 8b 00             	mov    (%rax),%rax
  8200e1:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8200e5:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  8200ec:	00 00 00 
  8200ef:	48 89 10             	mov    %rdx,(%rax)
  8200f2:	eb 51                	jmp    820145 <raw_remove+0x90>
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  8200f4:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  8200fb:	00 00 00 
  8200fe:	48 8b 00             	mov    (%rax),%rax
  820101:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  820105:	eb 37                	jmp    82013e <raw_remove+0x89>
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  820107:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  82010b:	48 8b 40 10          	mov    0x10(%rax),%rax
  82010f:	48 85 c0             	test   %rax,%rax
  820112:	74 1e                	je     820132 <raw_remove+0x7d>
  820114:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820118:	48 8b 40 10          	mov    0x10(%rax),%rax
  82011c:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  820120:	75 10                	jne    820132 <raw_remove+0x7d>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  820122:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820126:	48 8b 50 10          	mov    0x10(%rax),%rdx
  82012a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  82012e:	48 89 50 10          	mov    %rdx,0x10(%rax)
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  820132:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820136:	48 8b 40 10          	mov    0x10(%rax),%rax
  82013a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  82013e:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  820143:	75 c2                	jne    820107 <raw_remove+0x52>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
  820145:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820149:	48 89 c6             	mov    %rax,%rsi
  82014c:	bf 00 00 00 00       	mov    $0x0,%edi
  820151:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  820158:	00 00 00 
  82015b:	ff d0                	callq  *%rax
}
  82015d:	c9                   	leaveq 
  82015e:	c3                   	retq   

000000000082015f <raw_new>:
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
  82015f:	55                   	push   %rbp
  820160:	48 89 e5             	mov    %rsp,%rbp
  820163:	48 83 ec 20          	sub    $0x20,%rsp
  820167:	89 f8                	mov    %edi,%eax
  820169:	88 45 ec             	mov    %al,-0x14(%rbp)
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
  82016c:	bf 00 00 00 00       	mov    $0x0,%edi
  820171:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  820178:	00 00 00 
  82017b:	ff d0                	callq  *%rax
  82017d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
  820181:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  820186:	74 56                	je     8201de <raw_new+0x7f>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
  820188:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  82018c:	ba 30 00 00 00       	mov    $0x30,%edx
  820191:	be 00 00 00 00       	mov    $0x0,%esi
  820196:	48 89 c7             	mov    %rax,%rdi
  820199:	48 b8 70 21 80 00 00 	movabs $0x802170,%rax
  8201a0:	00 00 00 
  8201a3:	ff d0                	callq  *%rax
    pcb->protocol = proto;
  8201a5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8201a9:	0f b6 55 ec          	movzbl -0x14(%rbp),%edx
  8201ad:	88 50 18             	mov    %dl,0x18(%rax)
    pcb->ttl = RAW_TTL;
  8201b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8201b4:	c6 40 0b ff          	movb   $0xff,0xb(%rax)
    pcb->next = raw_pcbs;
  8201b8:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  8201bf:	00 00 00 
  8201c2:	48 8b 10             	mov    (%rax),%rdx
  8201c5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8201c9:	48 89 50 10          	mov    %rdx,0x10(%rax)
    raw_pcbs = pcb;
  8201cd:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  8201d4:	00 00 00 
  8201d7:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8201db:	48 89 10             	mov    %rdx,(%rax)
  }
  return pcb;
  8201de:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8201e2:	c9                   	leaveq 
  8201e3:	c3                   	retq   

00000000008201e4 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
  8201e4:	55                   	push   %rbp
  8201e5:	48 89 e5             	mov    %rsp,%rbp
  8201e8:	53                   	push   %rbx
  8201e9:	48 83 ec 58          	sub    $0x58,%rsp
  8201ed:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8201f1:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
  8201f5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8201f9:	48 8b 40 08          	mov    0x8(%rax),%rax
  8201fd:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  hlen = IPH_HL(iphdr) * 4;
  820201:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820205:	0f b7 00             	movzwl (%rax),%eax
  820208:	0f b7 c0             	movzwl %ax,%eax
  82020b:	89 c7                	mov    %eax,%edi
  82020d:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  820214:	00 00 00 
  820217:	ff d0                	callq  *%rax
  820219:	66 c1 e8 08          	shr    $0x8,%ax
  82021d:	83 e0 0f             	and    $0xf,%eax
  820220:	c1 e0 02             	shl    $0x2,%eax
  820223:	66 89 45 e6          	mov    %ax,-0x1a(%rbp)
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
  820227:	0f b7 45 e6          	movzwl -0x1a(%rbp),%eax
  82022b:	f7 d8                	neg    %eax
  82022d:	0f bf d0             	movswl %ax,%edx
  820230:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  820234:	89 d6                	mov    %edx,%esi
  820236:	48 89 c7             	mov    %rax,%rdi
  820239:	48 b8 7f db 80 00 00 	movabs $0x80db7f,%rax
  820240:	00 00 00 
  820243:	ff d0                	callq  *%rax
  820245:	84 c0                	test   %al,%al
  820247:	75 0e                	jne    820257 <icmp_input+0x73>
  820249:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  82024d:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  820251:	66 83 f8 03          	cmp    $0x3,%ax
  820255:	77 05                	ja     82025c <icmp_input+0x78>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  820257:	e9 90 04 00 00       	jmpq   8206ec <icmp_input+0x508>
  }

  type = *((u8_t *)p->payload);
  82025c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  820260:	48 8b 40 08          	mov    0x8(%rax),%rax
  820264:	0f b6 00             	movzbl (%rax),%eax
  820267:	88 45 e5             	mov    %al,-0x1b(%rbp)
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
  82026a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  82026e:	48 8b 40 08          	mov    0x8(%rax),%rax
  820272:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  820276:	88 45 e4             	mov    %al,-0x1c(%rbp)
#endif /* LWIP_DEBUG */
  switch (type) {
  820279:	0f b6 45 e5          	movzbl -0x1b(%rbp),%eax
  82027d:	83 f8 08             	cmp    $0x8,%eax
  820280:	74 05                	je     820287 <icmp_input+0xa3>
  820282:	e9 50 04 00 00       	jmpq   8206d7 <icmp_input+0x4f3>
  case ICMP_ECHO:
    /* broadcast or multicast destination address? */
    if (ip_addr_isbroadcast(&iphdr->dest, inp) || ip_addr_ismulticast(&iphdr->dest)) {
  820287:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  82028b:	48 8d 50 10          	lea    0x10(%rax),%rdx
  82028f:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  820293:	48 89 c6             	mov    %rax,%rsi
  820296:	48 89 d7             	mov    %rdx,%rdi
  820299:	48 b8 41 0d 81 00 00 	movabs $0x810d41,%rax
  8202a0:	00 00 00 
  8202a3:	ff d0                	callq  *%rax
  8202a5:	84 c0                	test   %al,%al
  8202a7:	75 2f                	jne    8202d8 <icmp_input+0xf4>
  8202a9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8202ad:	8b 58 10             	mov    0x10(%rax),%ebx
  8202b0:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  8202b5:	48 b8 8c 30 81 00 00 	movabs $0x81308c,%rax
  8202bc:	00 00 00 
  8202bf:	ff d0                	callq  *%rax
  8202c1:	21 c3                	and    %eax,%ebx
  8202c3:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  8202c8:	48 b8 8c 30 81 00 00 	movabs $0x81308c,%rax
  8202cf:	00 00 00 
  8202d2:	ff d0                	callq  *%rax
  8202d4:	39 c3                	cmp    %eax,%ebx
  8202d6:	75 18                	jne    8202f0 <icmp_input+0x10c>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
      ICMP_STATS_INC(icmp.err);
      pbuf_free(p);
  8202d8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8202dc:	48 89 c7             	mov    %rax,%rdi
  8202df:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  8202e6:	00 00 00 
  8202e9:	ff d0                	callq  *%rax
      return;
  8202eb:	e9 10 04 00 00       	jmpq   820700 <icmp_input+0x51c>
    }
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  8202f0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8202f4:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  8202f8:	66 83 f8 07          	cmp    $0x7,%ax
  8202fc:	77 05                	ja     820303 <icmp_input+0x11f>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
  8202fe:	e9 e9 03 00 00       	jmpq   8206ec <icmp_input+0x508>
    }
    if (inet_chksum_pbuf(p) != 0) {
  820303:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  820307:	48 89 c7             	mov    %rax,%rdi
  82030a:	48 b8 30 2b 81 00 00 	movabs $0x812b30,%rax
  820311:	00 00 00 
  820314:	ff d0                	callq  *%rax
  820316:	66 85 c0             	test   %ax,%ax
  820319:	74 18                	je     820333 <icmp_input+0x14f>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
  82031b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  82031f:	48 89 c7             	mov    %rax,%rdi
  820322:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  820329:	00 00 00 
  82032c:	ff d0                	callq  *%rax
      ICMP_STATS_INC(icmp.chkerr);
      snmp_inc_icmpinerrors();
      return;
  82032e:	e9 cd 03 00 00       	jmpq   820700 <icmp_input+0x51c>
    }
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  820333:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  820337:	be 22 00 00 00       	mov    $0x22,%esi
  82033c:	48 89 c7             	mov    %rax,%rdi
  82033f:	48 b8 7f db 80 00 00 	movabs $0x80db7f,%rax
  820346:	00 00 00 
  820349:	ff d0                	callq  *%rax
  82034b:	84 c0                	test   %al,%al
  82034d:	0f 84 8f 01 00 00    	je     8204e2 <icmp_input+0x2fe>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
  820353:	0f bf 55 e6          	movswl -0x1a(%rbp),%edx
  820357:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  82035b:	89 d6                	mov    %edx,%esi
  82035d:	48 89 c7             	mov    %rax,%rdi
  820360:	48 b8 7f db 80 00 00 	movabs $0x80db7f,%rax
  820367:	00 00 00 
  82036a:	ff d0                	callq  *%rax
  82036c:	84 c0                	test   %al,%al
  82036e:	74 2a                	je     82039a <icmp_input+0x1b6>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
  820370:	48 ba 18 3c 82 00 00 	movabs $0x823c18,%rdx
  820377:	00 00 00 
  82037a:	be 7c 00 00 00       	mov    $0x7c,%esi
  82037f:	48 bf 4b 3c 82 00 00 	movabs $0x823c4b,%rdi
  820386:	00 00 00 
  820389:	b8 00 00 00 00       	mov    $0x0,%eax
  82038e:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  820395:	00 00 00 
  820398:	ff d1                	callq  *%rcx
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
  82039a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  82039e:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  8203a2:	0f b7 c0             	movzwl %ax,%eax
  8203a5:	ba 00 00 00 00       	mov    $0x0,%edx
  8203aa:	89 c6                	mov    %eax,%esi
  8203ac:	bf 02 00 00 00       	mov    $0x2,%edi
  8203b1:	48 b8 61 d4 80 00 00 	movabs $0x80d461,%rax
  8203b8:	00 00 00 
  8203bb:	ff d0                	callq  *%rax
  8203bd:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
      if (r == NULL) {
  8203c1:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8203c6:	75 1a                	jne    8203e2 <icmp_input+0x1fe>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
  8203c8:	90                   	nop
  pbuf_free(p);
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
memerr:
  pbuf_free(p);
  8203c9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8203cd:	48 89 c7             	mov    %rax,%rdi
  8203d0:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  8203d7:	00 00 00 
  8203da:	ff d0                	callq  *%rax
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
  8203dc:	90                   	nop
  8203dd:	e9 1e 03 00 00       	jmpq   820700 <icmp_input+0x51c>
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
      if (r == NULL) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  8203e2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8203e6:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8203ea:	0f b7 c0             	movzwl %ax,%eax
  8203ed:	48 0f bf 55 e6       	movswq -0x1a(%rbp),%rdx
  8203f2:	48 83 c2 08          	add    $0x8,%rdx
  8203f6:	48 39 d0             	cmp    %rdx,%rax
  8203f9:	73 2a                	jae    820425 <icmp_input+0x241>
  8203fb:	48 ba 68 3c 82 00 00 	movabs $0x823c68,%rdx
  820402:	00 00 00 
  820405:	be 86 00 00 00       	mov    $0x86,%esi
  82040a:	48 bf 4b 3c 82 00 00 	movabs $0x823c4b,%rdi
  820411:	00 00 00 
  820414:	b8 00 00 00 00       	mov    $0x0,%eax
  820419:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  820420:	00 00 00 
  820423:	ff d1                	callq  *%rcx
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
  820425:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  820429:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  82042d:	48 89 d6             	mov    %rdx,%rsi
  820430:	48 89 c7             	mov    %rax,%rdi
  820433:	48 b8 bf e1 80 00 00 	movabs $0x80e1bf,%rax
  82043a:	00 00 00 
  82043d:	ff d0                	callq  *%rax
  82043f:	84 c0                	test   %al,%al
  820441:	74 2a                	je     82046d <icmp_input+0x289>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
  820443:	48 ba a0 3c 82 00 00 	movabs $0x823ca0,%rdx
  82044a:	00 00 00 
  82044d:	be 89 00 00 00       	mov    $0x89,%esi
  820452:	48 bf 4b 3c 82 00 00 	movabs $0x823c4b,%rdi
  820459:	00 00 00 
  82045c:	b8 00 00 00 00       	mov    $0x0,%eax
  820461:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  820468:	00 00 00 
  82046b:	ff d1                	callq  *%rcx
        goto memerr;
      }
      iphdr = r->payload;
  82046d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  820471:	48 8b 40 08          	mov    0x8(%rax),%rax
  820475:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
  820479:	0f b7 45 e6          	movzwl -0x1a(%rbp),%eax
  82047d:	f7 d8                	neg    %eax
  82047f:	0f bf d0             	movswl %ax,%edx
  820482:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  820486:	89 d6                	mov    %edx,%esi
  820488:	48 89 c7             	mov    %rax,%rdi
  82048b:	48 b8 7f db 80 00 00 	movabs $0x80db7f,%rax
  820492:	00 00 00 
  820495:	ff d0                	callq  *%rax
  820497:	84 c0                	test   %al,%al
  820499:	74 2a                	je     8204c5 <icmp_input+0x2e1>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  82049b:	48 ba c8 3c 82 00 00 	movabs $0x823cc8,%rdx
  8204a2:	00 00 00 
  8204a5:	be 8f 00 00 00       	mov    $0x8f,%esi
  8204aa:	48 bf 4b 3c 82 00 00 	movabs $0x823c4b,%rdi
  8204b1:	00 00 00 
  8204b4:	b8 00 00 00 00       	mov    $0x0,%eax
  8204b9:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  8204c0:	00 00 00 
  8204c3:	ff d1                	callq  *%rcx
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
  8204c5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8204c9:	48 89 c7             	mov    %rax,%rdi
  8204cc:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  8204d3:	00 00 00 
  8204d6:	ff d0                	callq  *%rax
      /* we now have an identical copy of p that has room for link headers */
      p = r;
  8204d8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8204dc:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  8204e0:	eb 46                	jmp    820528 <icmp_input+0x344>
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  8204e2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8204e6:	be de ff ff ff       	mov    $0xffffffde,%esi
  8204eb:	48 89 c7             	mov    %rax,%rdi
  8204ee:	48 b8 7f db 80 00 00 	movabs $0x80db7f,%rax
  8204f5:	00 00 00 
  8204f8:	ff d0                	callq  *%rax
  8204fa:	84 c0                	test   %al,%al
  8204fc:	74 2a                	je     820528 <icmp_input+0x344>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  8204fe:	48 ba c8 3c 82 00 00 	movabs $0x823cc8,%rdx
  820505:	00 00 00 
  820508:	be 99 00 00 00       	mov    $0x99,%esi
  82050d:	48 bf 4b 3c 82 00 00 	movabs $0x823c4b,%rdi
  820514:	00 00 00 
  820517:	b8 00 00 00 00       	mov    $0x0,%eax
  82051c:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  820523:	00 00 00 
  820526:	ff d1                	callq  *%rcx
      }
    }
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = p->payload;
  820528:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  82052c:	48 8b 40 08          	mov    0x8(%rax),%rax
  820530:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    tmpaddr.addr = iphdr->src.addr;
  820534:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820538:	8b 40 0c             	mov    0xc(%rax),%eax
  82053b:	89 45 c0             	mov    %eax,-0x40(%rbp)
    iphdr->src.addr = iphdr->dest.addr;
  82053e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820542:	8b 50 10             	mov    0x10(%rax),%edx
  820545:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820549:	89 50 0c             	mov    %edx,0xc(%rax)
    iphdr->dest.addr = tmpaddr.addr;
  82054c:	8b 55 c0             	mov    -0x40(%rbp),%edx
  82054f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820553:	89 50 10             	mov    %edx,0x10(%rax)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
  820556:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  82055a:	0f b7 00             	movzwl (%rax),%eax
  82055d:	0f b7 c0             	movzwl %ax,%eax
  820560:	89 c7                	mov    %eax,%edi
  820562:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  820569:	00 00 00 
  82056c:	ff d0                	callq  *%rax
  82056e:	0f b7 c0             	movzwl %ax,%eax
  820571:	0f b6 c0             	movzbl %al,%eax
  820574:	89 c7                	mov    %eax,%edi
  820576:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  82057d:	00 00 00 
  820580:	ff d0                	callq  *%rax
  820582:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  820586:	66 89 02             	mov    %ax,(%rdx)
    /* adjust the checksum */
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
  820589:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  82058d:	0f b7 58 02          	movzwl 0x2(%rax),%ebx
  820591:	bf ff f7 00 00       	mov    $0xf7ff,%edi
  820596:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  82059d:	00 00 00 
  8205a0:	ff d0                	callq  *%rax
  8205a2:	66 39 c3             	cmp    %ax,%bx
  8205a5:	72 28                	jb     8205cf <icmp_input+0x3eb>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
  8205a7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8205ab:	0f b7 58 02          	movzwl 0x2(%rax),%ebx
  8205af:	bf 00 08 00 00       	mov    $0x800,%edi
  8205b4:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  8205bb:	00 00 00 
  8205be:	ff d0                	callq  *%rax
  8205c0:	01 d8                	add    %ebx,%eax
  8205c2:	8d 50 01             	lea    0x1(%rax),%edx
  8205c5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8205c9:	66 89 50 02          	mov    %dx,0x2(%rax)
  8205cd:	eb 24                	jmp    8205f3 <icmp_input+0x40f>
    } else {
      iecho->chksum += htons(ICMP_ECHO << 8);
  8205cf:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8205d3:	0f b7 58 02          	movzwl 0x2(%rax),%ebx
  8205d7:	bf 00 08 00 00       	mov    $0x800,%edi
  8205dc:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  8205e3:	00 00 00 
  8205e6:	ff d0                	callq  *%rax
  8205e8:	8d 14 03             	lea    (%rbx,%rax,1),%edx
  8205eb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8205ef:	66 89 50 02          	mov    %dx,0x2(%rax)
    }

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
  8205f3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8205f7:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8205fb:	0f b7 c0             	movzwl %ax,%eax
  8205fe:	89 c7                	mov    %eax,%edi
  820600:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  820607:	00 00 00 
  82060a:	ff d0                	callq  *%rax
  82060c:	66 0d 00 ff          	or     $0xff00,%ax
  820610:	0f b7 c0             	movzwl %ax,%eax
  820613:	89 c7                	mov    %eax,%edi
  820615:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  82061c:	00 00 00 
  82061f:	ff d0                	callq  *%rax
  820621:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  820625:	66 89 42 08          	mov    %ax,0x8(%rdx)
    IPH_CHKSUM_SET(iphdr, 0);
  820629:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  82062d:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  820633:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820637:	be 14 00 00 00       	mov    $0x14,%esi
  82063c:	48 89 c7             	mov    %rax,%rdi
  82063f:	48 b8 01 2b 81 00 00 	movabs $0x812b01,%rax
  820646:	00 00 00 
  820649:	ff d0                	callq  *%rax
  82064b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  82064f:	66 89 42 0a          	mov    %ax,0xa(%rdx)
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
  820653:	0f bf 55 e6          	movswl -0x1a(%rbp),%edx
  820657:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  82065b:	89 d6                	mov    %edx,%esi
  82065d:	48 89 c7             	mov    %rax,%rdi
  820660:	48 b8 7f db 80 00 00 	movabs $0x80db7f,%rax
  820667:	00 00 00 
  82066a:	ff d0                	callq  *%rax
  82066c:	84 c0                	test   %al,%al
  82066e:	74 2a                	je     82069a <icmp_input+0x4b6>
      LWIP_ASSERT("Can't move over header in packet", 0);
  820670:	48 ba 00 3d 82 00 00 	movabs $0x823d00,%rdx
  820677:	00 00 00 
  82067a:	be ba 00 00 00       	mov    $0xba,%esi
  82067f:	48 bf 4b 3c 82 00 00 	movabs $0x823c4b,%rdi
  820686:	00 00 00 
  820689:	b8 00 00 00 00       	mov    $0x0,%eax
  82068e:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  820695:	00 00 00 
  820698:	ff d1                	callq  *%rcx
    } else {
      err_t ret;
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
  82069a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  82069e:	48 8d 70 0c          	lea    0xc(%rax),%rsi
  8206a2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8206a6:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8206aa:	48 89 14 24          	mov    %rdx,(%rsp)
  8206ae:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  8206b4:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8206ba:	b9 ff 00 00 00       	mov    $0xff,%ecx
  8206bf:	ba 00 00 00 00       	mov    $0x0,%edx
  8206c4:	48 89 c7             	mov    %rax,%rdi
  8206c7:	48 b8 13 13 81 00 00 	movabs $0x811313,%rax
  8206ce:	00 00 00 
  8206d1:	ff d0                	callq  *%rax
  8206d3:	88 45 cf             	mov    %al,-0x31(%rbp)
                   ICMP_TTL, 0, IP_PROTO_ICMP, inp);
      if (ret != ERR_OK) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
      }
    }
    break;
  8206d6:	90                   	nop
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  8206d7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8206db:	48 89 c7             	mov    %rax,%rdi
  8206de:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  8206e5:	00 00 00 
  8206e8:	ff d0                	callq  *%rax
  return;
  8206ea:	eb 14                	jmp    820700 <icmp_input+0x51c>
lenerr:
  pbuf_free(p);
  8206ec:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8206f0:	48 89 c7             	mov    %rax,%rdi
  8206f3:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  8206fa:	00 00 00 
  8206fd:	ff d0                	callq  *%rax
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
  8206ff:	90                   	nop
memerr:
  pbuf_free(p);
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
}
  820700:	48 83 c4 58          	add    $0x58,%rsp
  820704:	5b                   	pop    %rbx
  820705:	5d                   	pop    %rbp
  820706:	c3                   	retq   

0000000000820707 <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  820707:	55                   	push   %rbp
  820708:	48 89 e5             	mov    %rsp,%rbp
  82070b:	48 83 ec 30          	sub    $0x30,%rsp
  82070f:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  820713:	89 75 d4             	mov    %esi,-0x2c(%rbp)
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_dur_hdr *idur;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  820716:	ba 00 00 00 00       	mov    $0x0,%edx
  82071b:	be 24 00 00 00       	mov    $0x24,%esi
  820720:	bf 01 00 00 00       	mov    $0x1,%edi
  820725:	48 b8 61 d4 80 00 00 	movabs $0x80d461,%rax
  82072c:	00 00 00 
  82072f:	ff d0                	callq  *%rax
  820731:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
                 PBUF_RAM);
  if (q == NULL) {
  820735:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  82073a:	75 05                	jne    820741 <icmp_dest_unreach+0x3a>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
  82073c:	e9 60 01 00 00       	jmpq   8208a1 <icmp_dest_unreach+0x19a>
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  820741:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820745:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  820749:	66 83 f8 23          	cmp    $0x23,%ax
  82074d:	77 2a                	ja     820779 <icmp_dest_unreach+0x72>
  82074f:	48 ba 28 3d 82 00 00 	movabs $0x823d28,%rdx
  820756:	00 00 00 
  820759:	be f0 00 00 00       	mov    $0xf0,%esi
  82075e:	48 bf 4b 3c 82 00 00 	movabs $0x823c4b,%rdi
  820765:	00 00 00 
  820768:	b8 00 00 00 00       	mov    $0x0,%eax
  82076d:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  820774:	00 00 00 
  820777:	ff d1                	callq  *%rcx
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  820779:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  82077d:	48 8b 40 08          	mov    0x8(%rax),%rax
  820781:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

  idur = q->payload;
  820785:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820789:	48 8b 40 08          	mov    0x8(%rax),%rax
  82078d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  ICMPH_TYPE_SET(idur, ICMP_DUR);
  820791:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820795:	0f b7 00             	movzwl (%rax),%eax
  820798:	0f b7 c0             	movzwl %ax,%eax
  82079b:	89 c7                	mov    %eax,%edi
  82079d:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  8207a4:	00 00 00 
  8207a7:	ff d0                	callq  *%rax
  8207a9:	0f b6 c0             	movzbl %al,%eax
  8207ac:	80 cc 03             	or     $0x3,%ah
  8207af:	0f b7 c0             	movzwl %ax,%eax
  8207b2:	89 c7                	mov    %eax,%edi
  8207b4:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  8207bb:	00 00 00 
  8207be:	ff d0                	callq  *%rax
  8207c0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8207c4:	66 89 02             	mov    %ax,(%rdx)
  ICMPH_CODE_SET(idur, t);
  8207c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8207cb:	0f b7 00             	movzwl (%rax),%eax
  8207ce:	0f b7 c0             	movzwl %ax,%eax
  8207d1:	89 c7                	mov    %eax,%edi
  8207d3:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  8207da:	00 00 00 
  8207dd:	ff d0                	callq  *%rax
  8207df:	b0 00                	mov    $0x0,%al
  8207e1:	89 c2                	mov    %eax,%edx
  8207e3:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8207e6:	09 d0                	or     %edx,%eax
  8207e8:	0f b7 c0             	movzwl %ax,%eax
  8207eb:	89 c7                	mov    %eax,%edi
  8207ed:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  8207f4:	00 00 00 
  8207f7:	ff d0                	callq  *%rax
  8207f9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8207fd:	66 89 02             	mov    %ax,(%rdx)

  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), p->payload,
  820800:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  820804:	48 8b 40 08          	mov    0x8(%rax),%rax
  820808:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  82080c:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  820810:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  820814:	ba 1c 00 00 00       	mov    $0x1c,%edx
  820819:	48 89 c6             	mov    %rax,%rsi
  82081c:	48 89 cf             	mov    %rcx,%rdi
  82081f:	48 b8 12 23 80 00 00 	movabs $0x802312,%rax
  820826:	00 00 00 
  820829:	ff d0                	callq  *%rax
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  idur->chksum = 0;
  82082b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  82082f:	66 c7 40 02 00 00    	movw   $0x0,0x2(%rax)
  idur->chksum = inet_chksum(idur, q->len);
  820835:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820839:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  82083d:	0f b7 d0             	movzwl %ax,%edx
  820840:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820844:	89 d6                	mov    %edx,%esi
  820846:	48 89 c7             	mov    %rax,%rdi
  820849:	48 b8 01 2b 81 00 00 	movabs $0x812b01,%rax
  820850:	00 00 00 
  820853:	ff d0                	callq  *%rax
  820855:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  820859:	66 89 42 02          	mov    %ax,0x2(%rdx)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  82085d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  820861:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  820865:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820869:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  82086f:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  820875:	b9 ff 00 00 00       	mov    $0xff,%ecx
  82087a:	be 00 00 00 00       	mov    $0x0,%esi
  82087f:	48 89 c7             	mov    %rax,%rdi
  820882:	48 b8 c9 15 81 00 00 	movabs $0x8115c9,%rax
  820889:	00 00 00 
  82088c:	ff d0                	callq  *%rax
  pbuf_free(q);
  82088e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820892:	48 89 c7             	mov    %rax,%rdi
  820895:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  82089c:	00 00 00 
  82089f:	ff d0                	callq  *%rax
}
  8208a1:	c9                   	leaveq 
  8208a2:	c3                   	retq   

00000000008208a3 <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
  8208a3:	55                   	push   %rbp
  8208a4:	48 89 e5             	mov    %rsp,%rbp
  8208a7:	48 83 ec 30          	sub    $0x30,%rsp
  8208ab:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8208af:	89 75 d4             	mov    %esi,-0x2c(%rbp)
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_te_hdr *tehdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  8208b2:	ba 00 00 00 00       	mov    $0x0,%edx
  8208b7:	be 24 00 00 00       	mov    $0x24,%esi
  8208bc:	bf 01 00 00 00       	mov    $0x1,%edi
  8208c1:	48 b8 61 d4 80 00 00 	movabs $0x80d461,%rax
  8208c8:	00 00 00 
  8208cb:	ff d0                	callq  *%rax
  8208cd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
                 PBUF_RAM);
  if (q == NULL) {
  8208d1:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8208d6:	75 05                	jne    8208dd <icmp_time_exceeded+0x3a>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  8208d8:	e9 60 01 00 00       	jmpq   820a3d <icmp_time_exceeded+0x19a>
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  8208dd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8208e1:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8208e5:	66 83 f8 23          	cmp    $0x23,%ax
  8208e9:	77 2a                	ja     820915 <icmp_time_exceeded+0x72>
  8208eb:	48 ba 28 3d 82 00 00 	movabs $0x823d28,%rdx
  8208f2:	00 00 00 
  8208f5:	be 1f 01 00 00       	mov    $0x11f,%esi
  8208fa:	48 bf 4b 3c 82 00 00 	movabs $0x823c4b,%rdi
  820901:	00 00 00 
  820904:	b8 00 00 00 00       	mov    $0x0,%eax
  820909:	48 b9 e9 10 80 00 00 	movabs $0x8010e9,%rcx
  820910:	00 00 00 
  820913:	ff d1                	callq  *%rcx
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  820915:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  820919:	48 8b 40 08          	mov    0x8(%rax),%rax
  82091d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  tehdr = q->payload;
  820921:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820925:	48 8b 40 08          	mov    0x8(%rax),%rax
  820929:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  ICMPH_TYPE_SET(tehdr, ICMP_TE);
  82092d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820931:	0f b7 00             	movzwl (%rax),%eax
  820934:	0f b7 c0             	movzwl %ax,%eax
  820937:	89 c7                	mov    %eax,%edi
  820939:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  820940:	00 00 00 
  820943:	ff d0                	callq  *%rax
  820945:	0f b6 c0             	movzbl %al,%eax
  820948:	80 cc 0b             	or     $0xb,%ah
  82094b:	0f b7 c0             	movzwl %ax,%eax
  82094e:	89 c7                	mov    %eax,%edi
  820950:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  820957:	00 00 00 
  82095a:	ff d0                	callq  *%rax
  82095c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  820960:	66 89 02             	mov    %ax,(%rdx)
  ICMPH_CODE_SET(tehdr, t);
  820963:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820967:	0f b7 00             	movzwl (%rax),%eax
  82096a:	0f b7 c0             	movzwl %ax,%eax
  82096d:	89 c7                	mov    %eax,%edi
  82096f:	48 b8 32 30 81 00 00 	movabs $0x813032,%rax
  820976:	00 00 00 
  820979:	ff d0                	callq  *%rax
  82097b:	b0 00                	mov    $0x0,%al
  82097d:	89 c2                	mov    %eax,%edx
  82097f:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  820982:	09 d0                	or     %edx,%eax
  820984:	0f b7 c0             	movzwl %ax,%eax
  820987:	89 c7                	mov    %eax,%edi
  820989:	48 b8 0f 30 81 00 00 	movabs $0x81300f,%rax
  820990:	00 00 00 
  820993:	ff d0                	callq  *%rax
  820995:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  820999:	66 89 02             	mov    %ax,(%rdx)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), (u8_t *)p->payload,
  82099c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8209a0:	48 8b 40 08          	mov    0x8(%rax),%rax
  8209a4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8209a8:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8209ac:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  8209b0:	ba 1c 00 00 00       	mov    $0x1c,%edx
  8209b5:	48 89 c6             	mov    %rax,%rsi
  8209b8:	48 89 cf             	mov    %rcx,%rdi
  8209bb:	48 b8 12 23 80 00 00 	movabs $0x802312,%rax
  8209c2:	00 00 00 
  8209c5:	ff d0                	callq  *%rax
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  tehdr->chksum = 0;
  8209c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8209cb:	66 c7 40 02 00 00    	movw   $0x0,0x2(%rax)
  tehdr->chksum = inet_chksum(tehdr, q->len);
  8209d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8209d5:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8209d9:	0f b7 d0             	movzwl %ax,%edx
  8209dc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8209e0:	89 d6                	mov    %edx,%esi
  8209e2:	48 89 c7             	mov    %rax,%rdi
  8209e5:	48 b8 01 2b 81 00 00 	movabs $0x812b01,%rax
  8209ec:	00 00 00 
  8209ef:	ff d0                	callq  *%rax
  8209f1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8209f5:	66 89 42 02          	mov    %ax,0x2(%rdx)
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  8209f9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8209fd:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  820a01:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820a05:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  820a0b:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  820a11:	b9 ff 00 00 00       	mov    $0xff,%ecx
  820a16:	be 00 00 00 00       	mov    $0x0,%esi
  820a1b:	48 89 c7             	mov    %rax,%rdi
  820a1e:	48 b8 c9 15 81 00 00 	movabs $0x8115c9,%rax
  820a25:	00 00 00 
  820a28:	ff d0                	callq  *%rax
  pbuf_free(q);
  820a2a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820a2e:	48 89 c7             	mov    %rax,%rdi
  820a31:	48 b8 40 dd 80 00 00 	movabs $0x80dd40,%rax
  820a38:	00 00 00 
  820a3b:	ff d0                	callq  *%rax
}
  820a3d:	c9                   	leaveq 
  820a3e:	c3                   	retq   
